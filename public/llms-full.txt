# 部署

Source: https://docs.streamlit.io/deploy


获取部署应用和与用户共享所需的所有信息。

<InlineCalloutContainer>
<InlineCallout bold="概念。" color="lightBlue-70" href="/deploy/concepts" icon="book">了解应用部署的基础知识。</InlineCallout>
<InlineCallout bold="Streamlit Community Cloud。" color="lightBlue-70" href="/deploy/streamlit-community-cloud" icon="cloud">在我们的免费平台上部署你的应用，加入全球开发者社区分享他们的应用。这是你的非商业、个人和教育应用的理想场所。</InlineCallout>
<InlineCallout bold="Snowflake。" color="lightBlue-70" href="/deploy/snowflake" icon="ac_unit">在 Snowflake 中部署应用，享受安全的企业级环境。这是你的商业应用的理想场所。</InlineCallout>
<InlineCallout bold="其他平台。" color="lightBlue-70" href="/deploy/tutorials" icon="bolt">学习如何通过我们方便的教程集合在各种平台上部署应用。</InlineCallout>
</InlineCalloutContainer>

---

# 部署概念

Source: https://docs.streamlit.io/deploy/concepts


了解应用部署的基本概念。部署应用涉及三个主要过程。

- 在部署环境中安装 Python、Streamlit 和其他依赖项。
- 安全处理你的密钥和私密信息。
- 远程启动应用（`streamlit run`）。

如果你使用 Streamlit Community Cloud，我们会为你处理大部分工作！

<InlineCalloutContainer>
<InlineCallout bold="依赖项。" color="lightBlue-70" href="/deploy/concepts/dependencies" icon="build_circle">了解配置部署环境的基础知识。</InlineCallout>
<InlineCallout bold="密钥。" color="lightBlue-70" href="/deploy/concepts/secrets" icon="password">了解密钥管理的基础知识。</InlineCallout>
</InlineCalloutContainer>

---

# 部署应用时管理依赖项

Source: https://docs.streamlit.io/deploy/concepts/dependencies


开始开发您的应用前，你通过安装 Python 和 Streamlit 来设置和配置开发环境。部署应用时，你需要以相同的方式设置和配置部署环境。部署应用到云服务时，你的应用的 [Python 服务器](/develop/concepts/architecture/architecture#python-backend-server) 将在远程计算机上运行。此远程计算机无法访问你个人计算机上的所有文件和程序。

所有 Streamlit 应用至少有两个依赖项：Python 和 Streamlit。您的应用可能有以 Python 包或一定被安装的软件形式的其他依赖项。如果你使用的是第三方平台 Streamlit Community Cloud，其非正是型 Streamlit 应用，我们会为你处理 Python 和 Streamlit！

## 安装 Python 和其他软件

如果你使用 Streamlit Community Cloud，Python 已经安装。你可以简单地在部署对话中选择版本。如果你需要自己安装 Python 或有其他非 Python 软件要安装，按照你的平台的请求程序来安装附加软件。我们通常会使用包管理工具来执行此操作。例如，Streamlit Community Cloud 对于基于 Debian 的 Linux 系统使用高级包管理器（`apt`）。有关在 Streamlit Community Cloud 上安装非 Python 依赖项的更多信息，请参阅 [`apt-get` 依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#apt-get-dependencies)。

## 安装 Python 包

在您的部署环境中安装 Python 后，您需要安装所有必要的 Python 包，包括 Streamlit！每次你对一个已安装的包的 `import` ，你正在为您的脚本添加一个 Python 依赖项。你需要通过 Python 包管理器在部署环境中安装这些依赖项。

如果您使用 Streamlit Community Cloud，您默认会安装最新版本的 Streamlit 和它的所有依赖项。所以，如果您会做一个简单的应用或不需要额外依赖项，您不需要做任何事情！

### `pip` 和 `requirements.txt`

由于 `pip` 废默认宏了 Python，最常见的配置 Python 环境的方法是使用 `requirements.txt` 文件。`requirements.txt` 文件的每一行都是要 `pip install` 的一个包。你应该不_不_在您的 `requirements.txt` 文件中包括 <a href="https://docs.python.org/3/py-modindex.html" target="_blank">内置 Python 库</a>、比如 `math`、`random` 或 `distutils` 等。这些是 Python 的一部分，不是单独安装的。

<Tip>

由于依赖项可能依赖于 Python 的特定版本，始终了正您的开发环境中使用的 Python 版本，并为您的部署环境选择相同的版本。

</Tip>

如果你有一个像下面这样的脚本，你只需要安装 Streamlit。不需要额外的依赖项，因为 `pandas` 和 `numpy` 是作为 `streamlit` 的直接依赖项安装的。同样，`math` 和 `random` 是内置到 Python 中的。

```python
import streamlit as st
import pandas as pd
import numpy as np
import math
import random

st.write('Hi!')
```

但是，最佳实践是血辿记录你使用的包，因此推荐的 `requirements.txt` 文件是：

```none
streamlit
pandas
numpy
```

如果你需要指定特定的版本，另一个有效的例子是：

```none
streamlit==1.24.1
pandas&gt;2.0
numpy

---

# 部署应用时管理密钥

Source: https://docs.streamlit.io/deploy/concepts/secrets


如果您连接到数据源或外部服务，您可能正在处理机密信息，如凭证或密钥。机密信息应以安全的方式存储和传输。部署应用时，请确保您了解您的平台的功能和处理密钥的机制，以便您可以遵循最佳实践。

避免直接在代码中保存密钥，并保持 `.gitignore` 最新以防止意外将本地密钥提交到存储库。有用的提醒，请参阅 [安全提醒](/develop/concepts/connections/security-reminders)。

如果您使用 Streamlit Community Cloud，[密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management) 允许您保存环境变量并将密钥存储在代码之外。如果您使用为 Streamlit 设计的另一个平台，请检查他们是否有内置的机制来处理密钥。在某些情况下，他们甚至可能支持 `st.secrets` 或安全地上传您的 `secrets.toml` 文件。

有关使用带有环境变量的 `st.connection` 的信息，请参阅 [全局密钥、管理多个应用和多个数据存储](/develop/concepts/connections/connecting-to-data#global-secrets-managing-multiple-apps-and-multiple-data-stores)。

---

# 在 Snowflake 中部署 Streamlit 应用

Source: https://docs.streamlit.io/deploy/snowflake


在单个全球平台中与您的数据一起托管您的应用。Snowflake 提供行业领先的功能，为您的账户、用户、数据和应用提供最高级别的安全性。如果您正在寻找企业托管解决方案，请尝试 Snowflake！

<TileContainer>
<Tile background="lightBlue-70" icon="rocket_launch" link="/get-started/installation/streamlit-in-snowflake" text="创建免费试用账户并使用 Snowflake 中的 Streamlit 部署应用。" title="Snowflake 中的 Streamlit 快速入门"/>
<Tile background="lightBlue-70" icon="code" link="https://github.com/Snowflake-Labs/snowflake-demo-streamlit" text="在 Snowflake Labs 的 snowflake-demo-streamlit 存储库中探索各种示例应用。" title="示例"/>
<Tile background="lightBlue-70" icon="book" link="https://docs.snowflake.com/user-guide-getting-started" text="了解更多 Snowflake 的文档。" title="Snowflake 入门"/>
</TileContainer>

在 Snowflake 中有三种方式来托管 Streamlit 应用：

<InlineCalloutContainer>
<InlineCallout bold="Snowflake 中的 Streamlit。" color="lightBlue-70" href="https://docs.snowflake.com/developer-guide/streamlit/about-streamlit" icon="bolt">以 Snowflake 中的原生对象运行您的 Streamlit 应用。享受浏览器内编辑器和最少的环境配置工作。通过基于角色的访问控制 (RBAC) 与 Snowflake 账户中的其他用户共享您的应用。这是为您的业务内部部署应用的好方式。查看 Snowflake 文档！</InlineCallout>
<InlineCallout bold="Snowflake 原生应用。" color="lightBlue-70" href="https://docs.snowflake.com/en/developer-guide/native-apps/adding-streamlit" icon="ac_unit">将您的应用与数据打包并与其他 Snowflake 账户共享。这是与使用 Snowflake 的其他组织共享应用及其底层数据的好方式。查看 Snowflake 文档！</InlineCallout>
<InlineCallout bold="Snowpark 容器服务。" color="lightBlue-70" href="https://docs.snowflake.com/en/developer-guide/snowpark-container-services/overview" icon="web_asset">在针对 Snowflake 运行进行了优化的容器中部署您的应用。这是最灵活的选项，您可以使用任何库并为应用分配公共 URL。通过您的 Snowflake 账户管理您的允许查看者。查看 Snowflake 文档！</InlineCallout>
</InlineCalloutContainer>
<Note>

    使用 Snowpark 容器服务部署 Streamlit 应用需要计算池，目前在试用账户中不可用。

</Note>

---

# 欢迎使用 Streamlit Community Cloud

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud


通过 Streamlit Community Cloud，你可以创建、部署和管理 Streamlit 应用——完全免费。与世界分享你的应用，并构建一个自定义配置文件页面来展示你的工作。你的 Community Cloud 账户直接连接到 GitHub 仓库（公开或私有）。大多数应用只需几分钟就能启动。Community Cloud 处理所有容器化工作，因此部署很容易。带上你自己的代码，或从我们的流行模板中选择一个。通过简单地更改 GitHub 中的代码来快速原型、探索和更新应用。大多数更改会立即显示！

想避免设置本地开发环境的工作？Community Cloud 可以帮助你快速配置代码空间在云中开发。只需点击几下就可以开始编码或编辑 Streamlit 应用。参见[编辑你的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app)。

访问我们的[Community Cloud 快速入门](/deploy/streamlit-community-cloud/get-started/quickstart)快速运行创建账户、部署示例应用以及使用 GitHub Codespaces 编辑它的过程。如果你还没有构建你的第一个 Streamlit 应用，请参见[Streamlit 快速开始](/get-started)。

<InlineCalloutContainer>
<InlineCallout bold="快速开始。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started" icon="arrow_forward">了解 Streamlit Community Cloud 账户及如何创建一个。</InlineCallout>
<InlineCallout bold="部署应用。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/deploy-your-app" icon="flight_takeoff">关于如何部署应用的分步指南。</InlineCallout>
<InlineCallout bold="管理应用。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/manage-your-app" icon="settings">访问日志、重启应用、设置收藏等。进入 GitHub 代码空间在云中编辑应用。</InlineCallout>
<InlineCallout bold="共享应用。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/share-your-app" icon="share">共享或嵌入你的应用。</InlineCallout>
<InlineCallout bold="管理账户。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/manage-your-account" icon="manage_accounts">更新邮箱、管理连接或删除账户。</InlineCallout>
</InlineCalloutContainer>

---

# 在 Community Cloud 上准备和部署应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/deploy-your-app


Streamlit Community Cloud 支持一键部署，大多数应用可在数分钟内完成部署。若无现成应用，可从 <a href="https://streamlit.io/gallery" target="_blank">应用库</a>中 fork 或克隆示例项目——涵盖机器学习、数据可视化、数据分析、A/B 测试等多种场景。你也可以[使用模板快速部署](/deploy/streamlit-community-cloud/get-started/deploy-from-a-template)。应用部署后，可[通过 GitHub Codespaces 进行在线编辑](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app#edit-your-app-with-github-codespaces)。

<Note>

如需在其他云平台部署应用，请参阅[部署指南](/deploy/tutorials)。

</Note>

## 概述

以下内容说明如何组织项目结构，为 Community Cloud 提供必要配置以确保应用正常运行。

准备就绪后，部署流程十分简洁。进入工作区，点击右上角的"**新建应用**"。按照向导完成应用信息配置，最后点击"**部署**"。

![从工作区部署新应用](/images/streamlit-community-cloud/deploy-empty-new-app.png)

## 核心步骤

<InlineCalloutContainer>
<InlineCallout bold="项目结构" color="lightBlue-70" href="/deploy/streamlit-community-cloud/deploy-your-app/file-organization" icon="description">了解 Community Cloud 应用初始化机制及路径解析规则。掌握配置文件的放置位置。</InlineCallout>
<InlineCallout bold="依赖管理" color="lightBlue-70" href="/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies" icon="build_circle">学习如何声明依赖项，将 Python 库及其他依赖安装到运行时环境。</InlineCallout>
<InlineCallout bold="密钥管理" color="lightBlue-70" href="/deploy/streamlit-community-cloud/deploy-your-app/secrets-management" icon="password">掌握 Community Cloud 提供的密钥管理接口，安全上传 <code>secrets.toml</code> 配置。</InlineCallout>
<InlineCallout bold="部署应用" color="lightBlue-70" href="/deploy/streamlit-community-cloud/deploy-your-app/deploy" icon="flight_takeoff">整合所有配置，将应用发布到生产环境。</InlineCallout>
</InlineCalloutContainer>

---

# Community Cloud应用的应用依赖

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies


应用无法正确构建的主要原因是Streamlit Community Cloud找不到你的依赖！你的应用可能有两种依赖：Python依赖和外部依赖。Python依赖是你`import`到脚本中的其他Python包（就像Streamlit一样！）。外部依赖不太常见，但它们包括脚本正常运行所需的任何其他软件。由于Community Cloud在Linux上运行，这些将是在Python环境外使用`apt-get`安装的Linux依赖。

为了确保你的依赖被正确安装，请确保你：

1. 为Python依赖添加[需求文件](#add-python-dependencies)。
2. 可选：要管理任何外部依赖，请添加`packages.txt`文件。

<Note>

Python需求文件应放在你的仓库根目录或与你应用的入口文件相同的目录中。

</Note>

## 添加Python依赖

每当你在脚本中使用`import`语句时，你就引入了一个Python依赖。你需要告诉Community Cloud如何通过Python包管理器安装这些依赖。我们推荐使用`requirements.txt`文件，它基于`pip`。

你_不应该_在`requirements.txt`文件中包含<a href="https://docs.python.org/3/py-modindex.html" target="_blank">内置Python库</a>如`math`、`random`或`distutils`。这些是Python的一部分，不需要单独安装。另外，Community Cloud默认已安装了`streamlit`。除非你想固定或限制版本，否则不必严格包含`streamlit`。如果你部署的应用没有`requirements.txt`文件，你的应用将在只安装了`streamlit`（及其依赖）的环境中运行。

<Important>

Python的版本很重要！内置库在不同的Python版本之间会发生变化，其他库也可能有特定的版本要求。每当Streamlit支持新的Python版本时，Community Cloud会快速跟进并默认该新的Python版本。始终在与部署应用相同的Python版本中开发应用。有关部署应用时设置Python版本的更多信息，请参阅[可选：配置秘密和Python版本](/deploy/streamlit-community-cloud/deploy-your-app/deploy#optional-configure-secrets-and-python-version)。

</Important>

如果你有如下脚本，则不需要额外的依赖，因为`pandas`和`numpy`已安装为`streamlit`的直接依赖。同样，`math`和`random`是Python的内置库。

```python
import streamlit as st
import pandas as pd
import numpy as np
import math
import random

st.write("Hi!")
```

但是，一个有效的`requirements.txt`文件将是：

```none
streamlit
pandas
numpy
```

或者，如果你需要指定某些版本，另一个有效的例子将是：

```none
streamlit==1.24.1
pandas&gt;2.0
numpy

---

# 在Community Cloud上部署你的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/deploy-your-app/deploy


在你[整理了你的文件](/deploy/streamlit-community-cloud/deploy-your-app/file-organization)和[添加了你的依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies)如前面页面所述后，你已准备好将你的应用部署到Community Cloud！

## 选择你的仓库和入口文件

1. 从你在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作空间，在右上角点击"**创建应用**"。

   ![从你的工作空间部署新应用](/images/streamlit-community-cloud/deploy-empty-new-app.png)

1. 当被问及"你已经有应用吗？"时，点击"**是的，我有应用**"。
1. 填入你的仓库、分支和文件路径。或者，要直接粘贴GitHub上的`your_app.py`链接，点击"**粘贴GitHub URL**"。
1. 可选：在"应用URL"字段中，为你的新应用选择一个子域。

   每个Community Cloud应用都部署到`streamlit.app`上的子域，但你可以随时更改应用的子域。有关更多信息，请参阅[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)。在下面的示例中，Community Cloud将应用部署到`https://red-balloon.streamlit.app/`。

   ![填入你的应用信息以部署你的应用](/images/streamlit-community-cloud/deploy-an-app.png)

   尽管Community Cloud尝试建议可用的仓库和文件，这些建议并不总是完整的。如果任何字段中找不到所需的信息，请手动输入。

## 可选：配置秘密和Python版本

<Note>

Streamlit Community Cloud支持所有仍在接收安全更新的发布的 [Python版本](https://devguide.python.org/versions/)。Streamlit Community Cloud默认为版本3.12。你可以从"高级设置"模态框中的"Python版本"下拉菜单中选择你选择的版本。如果应用运行的Python版本变得不支持，它将被强制升级到最旧的受支持的Python版本，可能会出现问题。

</Note>

1. 点击"**高级设置**"。
1. 选择你想要的Python版本。
1. 要定义环境变量和秘密，在"秘密"字段中粘贴你的`secrets.toml`文件的内容。

   有关更多信息，请参阅[Community Cloud秘密管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

1. 点击"**保存**"。

<div>{{ maxWidth: '70%', margin: 'auto' }}&gt;
<Image alt="部署你的应用的高级设置" src="/images/streamlit-community-cloud/deploy-an-app-advanced.png"/>
</div>

## 观看你的应用启动

你的应用现在正在被部署，你可以在它启动时观看。大多数应用在几分钟内部署，但如果你的应用有很多依赖，可能需要更长时间。初始部署后，对代码的更改应该立即反映在你的应用中。对依赖的更改将立即处理，但可能需要几分钟时间来安装。

![观看你的应用启动](/images/streamlit-community-cloud/deploy-an-app-provisioning.png)

<Note>

Streamlit Community Cloud日志在你的应用右侧只对具有仓库写入权限的用户可见。这些日志帮助你调试应用的任何问题。了解更多关于[Streamlit Community Cloud日志](/deploy/streamlit-community-cloud/manage-your-app#cloud-logs)。

</Note>
<a name="your-app-url"/>

## 查看你的应用

就这样你完成了！你的应用现在有一个你可以与他人共享的唯一URL。阅读更多关于如何与查看者[共享你的应用](/deploy/streamlit-community-cloud/share-your-app)。

### 唯一的子域

如果在部署应用时"**自定义子域（可选）**"字段为空，将根据你的GitHub仓库结构分配一个URL。URL的子域是以下内容的破折号分隔列表：

- 仓库所有者（GitHub用户或组织）
- 仓库名称
- 入口文件路径
- 分支名称（如果不是`main`或`master`）
- 随机哈希

```bash
https://[GitHub username or organization]-[repo name]-[app path]-[branch name]-[short hash].streamlit.app
```

例如，以下应用从`streamlit`组织部署。仓库是`demo-self-driving`，应用名称是根目录中的`streamlit_app.py`。分支名称是`master`，因此不包括在内。

```bash
https://streamlit-demo-self-driving-streamlit-app-8jya0g.streamlit.app
```

### 自定义子域

设置自定义子域使共享你的应用变得容易得多，因为你可以选择容易记住的名称。要了解如何更改已部署应用的子域，请参阅[查看或更改你的应用URL](/deploy/streamlit-community-cloud/manage-your-app/app-settings#view-or-change-your-apps-url)。

---

# Community Cloud应用的文件组织

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/deploy-your-app/file-organization


Streamlit Community Cloud复制仓库中的所有文件并从其根目录执行`streamlit run`。因为Community Cloud正在创建一个新的Python环境来运行你的应用，你需要包括对任何[应用依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies)的声明，以及任何[配置](/develop/concepts/configuration)选项。

你可以在你的仓库中有多个应用，其入口文件可以在仓库的任何位置。但是，你只能有一个配置文件。本页解释如何正确组织你的应用、配置和依赖文件。以下示例假设你使用`requirements.txt`来声明依赖，因为这是最常见的方式。如前一页所述，Community Cloud支持其他格式来配置你的Python环境。

## 基础示例

在以下示例中，入口文件（`your_app.py`）位于项目目录的根目录，与`requirements.txt`文件并排，以声明应用的依赖。

```
your_repository/
├── requirements.txt
└── your_app.py
```

如果你包括自定义配置，你的配置文件必须位于仓库内的`.streamlit/config.toml`。

```
your_repository/
├── .streamlit/
│   └── config.toml
├── requirements.txt
└── your_app.py
```

此外，应用需要本地可用的任何文件都应包括在仓库中。

<Tip>

如果你有非常大或二进制的数据，你经常更改，git运行缓慢，你可能想看看[Git Large File Store (LFS)](https://git-lfs.github.com/)作为在GitHub中存储大文件的更好方式。你不需要对应用做任何更改来开始使用它。如果你的GitHub仓库使用LFS，它将_正常工作_与Streamlit Community Cloud。

</Tip>

## 在子目录中使用入口文件

当入口文件在子目录中时，配置文件必须保留在根目录。但是，依赖文件可以在根目录或入口文件旁边。

你的依赖文件可以在仓库根目录，而入口文件在子目录中。

```
your_repository/
├── .streamlit/
│   └── config.toml
├── requirements.txt
└── subdirectory
    └── your_app.py
```

或者，你的依赖文件可以在与入口文件相同的子目录中。

```
your_repository/
├── .streamlit/
│   └── config.toml
└── subdirectory
    ├── requirements.txt
    └── your_app.py
```

虽然大多数Streamlit命令相对于入口文件解释路径，但某些命令相对于工作目录解释路径。在Community Cloud上，工作目录始终是仓库的根目录。因此，在本地开发和测试应用时，从仓库根目录执行`streamlit run`。这确保路径在本地环境和Community Cloud之间的解释一致。

在前面的示例中，这将看起来像这样：

```bash
cd your_repository
streamlit run subdirectory/your_app.py
```

<Tip>
    记住总是在你的路径中使用正斜杠路径分隔符。Community Cloud无法使用反斜杠分隔的路径。
</Tip>

## 仓库中的多个应用

当你在一个仓库中有多个应用时，它们共享仓库根目录的同一个配置文件（`.streamlit/config.toml`）。依赖文件可能为这些多个应用共享或单独配置。要为应用定义单独的依赖文件，将每个入口文件放在其自己的子目录中，以及其自己的依赖文件。要了解更多关于Community Cloud如何优先级和解析依赖文件，请参阅[应用依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies)。

---

# Community Cloud应用的秘密管理

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/deploy-your-app/secrets-management


## 介绍

如果你正在[连接到数据源](/develop/tutorials/databases)，你可能需要处理凭证或秘密。在git仓库中存储未加密的秘密是不好的做法。如果你的应用需要访问敏感的凭证，推荐的解决方案是将这些凭证存储在不提交到仓库的文件中，并将其作为环境变量传递。

## 如何使用秘密管理

Community Cloud允许你在应用的设置中保存秘密。在本地开发时，你可以在代码中使用`st.secrets`从`.streamlit/secrets.toml`文件读取秘密。但是，此`secrets.toml`文件永远不应该提交到仓库。相反，当你部署应用时，你可以将`secrets.toml`文件的内容粘贴到"**高级设置**"对话框中。你可以通过工作空间中应用的设置随时更新秘密。

### 先决条件

- 你应该了解如何使用`st.secrets`和`secrets.toml`。请参阅[秘密管理](/develop/concepts/connections/secrets-management)。

### 高级设置

在部署应用时，你可以访问"**高级设置**"来设置你的秘密。部署应用后，你可以通过应用的设置查看或更新秘密。完整的部署工作流程在下一页中描述，但"**高级设置**"对话框看起来像这样：

<div>{{ maxWidth: '70%', margin: 'auto' }}&gt;
<Image alt="部署你的应用的高级设置" src="/images/streamlit-community-cloud/deploy-an-app-advanced.png"/>
</div>

只需将本地`secrets.toml`文件的内容复制并粘贴到对话框内的"秘密"字段中。在你点击"**保存**"以提交更改后，就完成了！

### 编辑你的应用秘密

如果你需要为已经部署的应用添加或编辑秘密，你可以通过[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)访问秘密。请参阅[查看或更新你的秘密](/deploy/streamlit-community-cloud/manage-your-app/app-settings#view-or-update-your-secrets)。

---

# Streamlit Community Cloud 快速开始

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started


欢迎来到 Streamlit Community Cloud，在这里你可以与世界分享你的 Streamlit 应用！无论你是已经创建了第一个 Streamlit 应用，还是刚刚开始，你来对地方了。

首先，你需要创建 Streamlit Community Cloud 账户来开始部署应用。

<TileContainer>
<Tile background="lightBlue-70" icon="rocket_launch" link="/deploy/streamlit-community-cloud/get-started/quickstart" text="创建账户并尽快部署示例应用。使用 GitHub Codespaces 直接跳入编码。" title="快速入门"/>
<Tile background="lightBlue-70" icon="security" link="/deploy/streamlit-community-cloud/get-started/trust-and-security" text="安全第一！如果你想在开始前了解我们如何处理你的数据，我们已经为你准备好了。" title="信任和安全"/>
</TileContainer>

如果你需要帮助构建第一个 Streamlit 应用，请阅读 Streamlit 库的[快速开始](/get-started)文档。如果你想 fork 一个应用并从示例开始，请查看我们的<a href="https://streamlit.io/gallery" target="_blank">应用库</a>。无论哪种方式，只需几分钟就可以创建你的第一个应用。

如果你需要比快速入门更详细的说明，请尝试以下方式：

<InlineCalloutContainer>
<InlineCallout bold="创建账户。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started/create-your-account" icon="person">查看所有选项，并在创建 Streamlit Community Cloud 账户时获得完整说明。</InlineCallout>
<InlineCallout bold="连接 GitHub 账户。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started/connect-your-github-account" icon="code">创建 Community Cloud 账户后，连接 GitHub 以进行源代码控制。</InlineCallout>
<InlineCallout bold="探索工作区。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started/explore-your-workspace" icon="computer">快速浏览你的 Community Cloud 工作区。看看所有魔法发生的地方。</InlineCallout>
<InlineCallout bold="从模板部署应用。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started/deploy-from-a-template" icon="auto_fix_high">使用模板在几分钟内启动和运行你自己的应用。</InlineCallout>
<InlineCallout bold="Fork 和编辑公开应用。" color="lightBlue-70" href="/deploy/streamlit-community-cloud/get-started/fork-and-edit-a-public-app" icon="fork_right">从一个精彩的开始！Fork 公开应用并直接跳入代码。</InlineCallout>
</InlineCalloutContainer>

---

# 连接你的GitHub账户

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/connect-your-github-account


将GitHub连接到你的Streamlit Community Cloud账户允许你直接从存储在仓库中的文件部署应用。它还使系统能够检查这些文件的更新并自动更新你的应用。首次将GitHub账户连接到Community Cloud账户时，你将能够将应用从公共仓库部署到Community Cloud。如果你想从私有仓库部署，你可以给予Community Cloud额外权限来这样做。有关这些权限的更多信息，请参阅[GitHub OAuth范围](/deploy/streamlit-community-cloud/status#github-oauth-scope)。

<Important>
    为了部署应用，你必须对其仓库有**管理员**权限。如果你没有管理员访问权限，请联系仓库的所有者或fork仓库来创建你自己的副本。如需更多帮助，请参阅我们的<a href="https://discuss.streamlit.io/" target="_blank">社区论坛</a>。
</Important>

如果你是GitHub组织的成员，该组织将显示在每个GitHub OAuth提示的底部。在这种情况下，我们建议在执行连接GitHub账户的步骤之前阅读本页末尾的[组织访问](#organization-access)。你必须是GitHub中的组织所有者才能向该组织授予访问权限。

## 先决条件

- 你必须拥有Community Cloud账户。请参阅[创建你的账户](/deploy/streamlit-community-cloud/get-started/create-your-account)。
- 你必须拥有GitHub账户。

## 添加对公共仓库的访问权限

1. 在左上角，点击"**工作空间 <i>{{ verticalAlign: "-.25em", color: "#ff8700" }} className={{ class: "material-icons-sharp" }}&gt;warning</i>**"。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="将GitHub账户连接到新的Community Cloud账户" src="/images/streamlit-community-cloud/workspace-unconnected-setup.png"/>
</div>

1. 从下拉菜单中，点击"**连接GitHub账户**"。
1. 输入你的GitHub凭据并遵循GitHub的认证提示。
1. 点击"**授权streamlit**"。

   <div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
   <Image alt="授权Community Cloud连接到你的GitHub账户" src="/images/streamlit-community-cloud/GitHub-auth1-none.png"/>
</div>

   这将"Streamlit" OAuth应用程序添加到你的GitHub账户。这允许Community Cloud与你的公共仓库配合使用并为你创建codespaces。在下一部分中，你也可以允许Community Cloud访问你的私有仓库。有关在你账户上使用和审查OAuth应用程序的更多信息，请参阅GitHub文档中的[使用OAuth应用](https://docs.github.com/en/apps/oauth-apps/using-oauth-apps)。

## 可选：添加对私有仓库的访问权限

在你的Community Cloud账户有权从公共仓库部署后，你可以遵循这些额外步骤来授予对私有仓库的访问权限。

1. 在左上角，点击你的GitHub用户名。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="访问你的工作空间设置" src="/images/streamlit-community-cloud/workspace-empty-menu.png"/>
</div>

1. 从下拉菜单中，点击"**设置**"。
1. 在对话框的左侧，选择"**链接账户**"。
1. 在"源代码控制"下，点击"**在此连接 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_forward</i>**"。
1. 点击"**授权streamlit**"。

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="授权Community Cloud连接到你的私有GitHub仓库" src="/images/streamlit-community-cloud/GitHub-auth2-none.png"/>
</div>

## 组织访问

要从GitHub组织拥有的仓库部署应用，Community Cloud必须有权访问组织的仓库。如果在连接GitHub账户时你是GitHub组织的成员，你的OAuth提示将包括标记为"组织访问"的部分。

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="包含组织访问的GitHub Oauth提示" src="/images/streamlit-community-cloud/GitHub-auth1-organizations.png"/>
</div>

如果你已经连接了GitHub账户并需要添加组织的访问权限，请遵循[管理你的GitHub连接](/deploy/streamlit-community-cloud/manage-your-account/manage-your-github-connection)中的步骤来断开你的GitHub账户并重新开始。或者，如果你不是组织的所有者，你可以请求所有者为自己创建Community Cloud账户并直接添加权限。

### 你拥有的组织

对于你拥有的任何组织，如果之前未授予或拒绝授权，你可以在点击"**授权streamlit**"之前点击"**授予**"。

<div>{{ maxWidth: '80%', margin: 'auto' }}&gt;
<Image alt="在你拥有的GitHub组织上授权你的Streamlit" src="/images/streamlit-community-cloud/GitHub-auth-grant-XL.png"/>
</div>

### 由他人拥有的组织

对于你不拥有的组织，如果之前未授予或拒绝授权，你可以在点击"**授权streamlit**"之前点击"**请求**"。

<div>{{ maxWidth: '80%', margin: 'auto' }}&gt;
<Image alt="在他人拥有的GitHub组织上授权你的Streamlit" src="/images/streamlit-community-cloud/GitHub-auth-request-XL.png"/>
</div>

### 先前或待处理的授权

如果有人已经启动了为你的组织授权Streamlit的过程，OAuth提示将显示当前状态。

#### 已批准访问

如果组织已经授予Streamlit访问权限，OAuth提示显示绿色勾号（<i>{{ verticalAlign: "-.25em", color: "#1a7f37" }} className={{ class: "material-icons-sharp" }}&gt;check</i>）。

<div>{{ maxWidth: '60%', margin: 'auto' }}&gt;
<Image alt="组织对Streamlit的已批准授权" src="/images/streamlit-community-cloud/GitHub-auth-granted-XL.png"/>
</div>

#### 待处理访问

如果之前发送了请求但尚未批准，OAuth提示显示"访问请求待处理"。与组织的所有者跟进以在GitHub中接受请求。

<div>{{ maxWidth: '60%', margin: 'auto' }}&gt;
<Image alt="组织对Streamlit的待处理授权" src="/images/streamlit-community-cloud/GitHub-auth-pending-XL.png"/>
</div>

#### 拒绝访问

如果之前发送了请求并被拒绝，OAuth提示显示红色X（<i>{{ verticalAlign: "-.25em", color: "#d1242f" }} className={{ class: "material-icons-sharp" }}&gt;close</i>）。在这种情况下，组织所有者将需要从GitHub授权Streamlit。请参阅GitHub关于<a href="https://docs.github.com/en/apps/oauth-apps/using-oauth-apps/authorizing-oauth-apps#oauth-apps-and-organizations" target="_blank">OAuth应用和组织</a>的文档。

<div>{{ maxWidth: '60%', margin: 'auto' }}&gt;
<Image alt="组织对Streamlit的拒绝授权" src="/images/streamlit-community-cloud/GitHub-auth-denied-XL.png"/>
</div>

## 接下来呢？

现在你有了账户，你可以[探索你的工作空间](/deploy/streamlit-community-cloud/get-started/explore-your-workspace)。或者如果你已准备好，直接跳进去并[部署你的应用](/deploy/streamlit-community-cloud/deploy-your-app)。

---

# 创建您的账户

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/create-your-account


在您开始部署应用程序供全世界查看之前，您需要注册您的 Streamlit 社区云账户。

每个社区云账户都与一个电子邮件关联。两个账户不能使用相同的电子邮件。当分享私有应用程序时，您将通过电子邮件分配查看权限。此外，两个账户不能具有相同源码控制系统（GitHub 账户）。如果您尝试使用相同源码控制系统创建第二个社区云账户，社区云将会合并这些账户。

## 注册

社区云允许您使用以下三种方法之一登录：

- 通过电子邮件发送的单次使用验证码
- Google
- GitHub

<Important>
    即使您通过 GitHub 登录，认证流程也会将您的电子邮件地址返回给社区云。如果您通过 GitHub 登录，更改 GitHub 账户上的电子邮件可能会影响您的社区云账户。
</Important>

1. 前往 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>.
1. 点击"**继续登录**".
1. 使用下面列出的三个选项之一继续操作。

   ### 选项 1: 使用邮件验证码登录
   1. 在"电子邮件"字段中，输入您的电子邮件地址。
   1. 点击"**继续**"。(如果提示，请验证您是人类。)
   1. 前往您的电子邮件收件箱，复制您的一次性六位数字验证码。验证码有效期为十分钟。
   1. 返回到认证页面，输入您的验证码。(如果提示，请验证您是人类。)

   ### 选项 2: 使用 Google 登录
   1. 点击"**使用 Google 继续**"。
   1. 输入您的 Google 凭据，并按照 Google 的身份验证提示操作。

   ### 选项 3: 使用 GitHub 登录
   1. 点击"**使用 GitHub 继续**"。
   1. 输入您的 GitHub 凭据，并按照 GitHub 的身份验证提示操作。

      这会将"Streamlit 社区云"OAuth 应用程序添加到您的 GitHub 账户。此应用程序仅用于在您登录社区云时传递您的电子邮件。在下一页，您将执行额外步骤以允许社区云访问您的存储库。有关使用和审查您账户上的 OAuth 应用程序的更多信息，请参阅 GitHub 文档中的 [使用 OAuth 应用](https://docs.github.com/en/apps/oauth-apps/using-oauth-apps)。

1. 填写您的信息，然后点击底部的"**继续**"。

   "主要电子邮件"字段预先填入了您用来登录的电子邮件。如果您在账户设置表单中更改此电子邮件，它只会影响营销电子邮件；它不会反映在您的新账户上。要在创建账户后更改与账户关联的电子邮件，请参阅 [更新您的电子邮件地址](/deploy/streamlit-community-cloud/manage-your-account/update-your-email)。

## 完成

恭喜您创建了 Streamlit 社区云账户！左上角 "**工作空间**" 旁边的警告图标 (<i>{{ verticalAlign: "-.25em", color: "#ff8700" }} className={{ class: "material-icons-sharp" }}&gt;warning</i>) 是正常的；这表示您的账户尚未连接到 GitHub。即使您通过 GitHub 创建了账户，您的账户尚无权访问您的存储库。请继续下一页连接您的 GitHub 账户。

---

# 从模板部署应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/deploy-from-a-template


Streamlit Community Cloud让你用几个便捷的模板轻松入门。只需选择一个模板，Community Cloud就会将其fork到你的账户并部署它。你推送到新fork的任何编辑都会立即显示在部署的应用中。此外，如果你不想使用本地开发环境，Community Cloud让你轻松创建一个为Streamlit应用开发完全配置的GitHub codespace。

## 访问模板选择器

开始部署模板有两种方式："**创建应用**"按钮和工作空间底部的模板库。

- 如果你点击"**创建应用**"按钮，Community Cloud会问你"你已经有应用吗？"选择"**否，从模板创建一个**"。
- 如果你滚动到工作空间底部的"**我的应用**"部分，你可以看到最受欢迎的模板。直接点击一个，或选择"**查看所有模板**"。

模板选择器在左侧显示可用模板列表。当前选定模板的预览显示在右侧。

![Community Cloud上的"从模板部署"页面](/images/streamlit-community-cloud/deploy-template-picker.png)

## 选择模板

1. 从左侧的模板列表中，选择"**GDP仪表板**"。
1. 可选：对于"新GitHub仓库的名称"，输入新fork仓库的名称。

   当你从模板部署时，Community Cloud会将模板仓库fork到你的GitHub账户。Community Cloud根据选定的模板为此仓库选择默认名称。如果你之前使用默认名称部署了相同的模板，Community Cloud会将自动递增的数字附加到名称。

   <Note>
       即使你有另一个用户或组织的工作空间已选中，Community Cloud也始终会从你的个人工作空间部署模板应用。也就是说，Community Cloud始终会将模板fork到你的GitHub用户账户。如果你想从组织部署模板应用，在GitHub中手动fork模板，并在关联的工作空间中从你的fork部署它。
   </Note>

1. 可选：在"应用URL"字段中，为新应用选择子域。

   每个Community Cloud应用都部署到`streamlit.app`上的子域，但你可以随时更改应用的子域。有关更多信息，请参阅[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)。

1. 可选：要立即在GitHub codespace中编辑模板，选择"**打开GitHub Codespaces...**"的选项。

   你可以在任何时候为应用创建codespace。要了解如何在部署应用后创建codespace，请参阅[编辑你的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app)。

1. 可选：要更改Python版本，在屏幕底部点击"**高级设置**"，选择Python版本，然后点击"**保存**"。

   <Important>
       部署应用后，在不删除和重新部署应用的情况下，你无法更改Python版本。
   </Important>

1. 在底部点击"**部署**"。

## 查看你的应用

- 如果你没有选择打开GitHub Codespaces的选项，你会被重定向到你的新应用。

  ![GDP仪表板模板应用](/images/streamlit-community-cloud/deploy-template-GDP.png)

- 如果你选择了打开GitHub Codespaces的选项，你会被重定向到新的codespace，完全初始化可能需要几分钟。在Visual Studio Code编辑器出现在你的codespace中后，安装Python并启动Streamlit服务器可能需要几分钟。完成后，分割屏幕视图在左侧显示代码编辑器，在右侧显示运行应用。代码编辑器默认打开两个选项卡：仓库的readme文件和应用的入口文件。

  ![codespace中的GDP仪表板模板应用](/images/streamlit-community-cloud/deploy-template-GDP-codespace.png)

<Important>
    你的codespace中显示的应用不是你在Community Cloud上部署的同一个实例。你的codespace是一个独立的开发环境。当你在codespace内进行编辑时，这些编辑在你提交到仓库之前不会离开codespace。当你提交更改到仓库时，Community Cloud检测更改并更新你部署的应用。要了解更多，请参阅[编辑你的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app)。
</Important>

---

# 探索你的工作空间

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/explore-your-workspace


如果你刚刚[创建了你的账户](/deploy/streamlit-community-cloud/get-started/create-your-account)并[连接了GitHub账户](/deploy/streamlit-community-cloud/get-started/connect-your-github-account)，恭喜！你现在已登录并准备好出发。如果你加入别人的工作空间，你可能已经看到了一些应用。

## 工作空间

GitHub账户和组织中的每一个都在Community Cloud中关联一个工作空间。当你第一次登录Community Cloud时，你将进入与GitHub用户账户关联的个人工作空间。Community Cloud的左上角显示你当前的工作空间。

![Streamlit Community Cloud中的新的空工作空间。工作空间所有者显示在左上角。](/images/streamlit-community-cloud/workspace-empty-SM.png)

### 切换工作空间

要在工作空间之间切换，点击左上角的工作空间名称并选择新的工作空间。

其他工作空间对你可用如下：

- 当你对仓库有写入权限且仓库所有者已加入Community Cloud时，你可以选择关联的工作空间。所有者可以是GitHub用户或组织。
- 如果有人通过Community Cloud与你分享了应用，你将看到应用的关联工作空间。这是仅查看访问。

![此工作空间用于用户`sammy-streamlit`，他有权访问其个人工作空间和组织`we-love-streamlit`的另一个工作空间。](/images/streamlit-community-cloud/workspace-empty-switch.png)

### 邀请其他开发者到你的工作空间

邀请其他开发者很简单：只需给他们对GitHub仓库的写入权限，这样你们就可以一起编码。当他们登录<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>时，他们将有权访问你的工作空间。

Streamlit Community Cloud从GitHub继承开发者权限。当其他人登录Community Cloud时，他们将自动看到与你共享的工作空间。从那里，你们都可以一起部署、管理和分享应用。

<Note>

当用户被添加到GitHub上的仓库时，最多需要15分钟才能在Community Cloud上部署或管理应用。如果用户从GitHub上的仓库中被移除，最多需要15分钟才能撤销他们从该仓库管理应用的权限。

</Note>

记住，每当团队中的任何人在GitHub上更新代码时，应用都会自动为你更新！

## 我的应用

工作空间的"**我的应用**"部分是你部署和管理应用的基地。当你部署应用时，它会被添加到工作空间的这一部分。

### 部署应用

如果你已经将应用保存到GitHub仓库，你可以直接部署它。否则，Community Cloud提供你可以使用的模板。当你从模板部署时，Community Cloud将fork一个项目到你的GitHub账户并从新的fork部署。如果你还没有创建Streamlit应用，这是一个便捷的开始方式。

要开始，只需在右上角点击"**创建应用**"。要了解更多，请参阅[部署你的应用](/deploy/streamlit-community-cloud/deploy-your-app)和[从模板部署](/deploy/streamlit-community-cloud/get-started/deploy-from-a-template)。

## 我的配置文件

工作空间的"**我的配置文件**"部分让你自定义Streamlit应用的个人组合与世界分享。策展和展示你的Streamlit应用来展示你的工作。

## 探索

如需灵感，请查看"**探索**"部分。这是Streamlit社区创建的Streamlit应用的画廊。查看热门和趋势应用，或搜索你感兴趣的领域中的应用。

---

# Fork和编辑公共应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/fork-and-edit-a-public-app


Community Cloud就是关于学习、分享和探索Streamlit世界。对于具有公共仓库的应用，你可以快速fork副本到你的GitHub账户、部署你自己的版本并跳入GitHub上的codespace以开始编辑和探索Streamlit代码。

1. 从可fork的应用，在右上角点击"**Fork**"。

   ![在公共应用的右上角点击Fork](/images/streamlit-community-cloud/fork-public-hello.png)

1. 可选：在"应用URL"字段中，为你的应用选择自定义子域。

   每个Community Cloud应用都部署到`streamlit.app`上的子域，但你可以随时更改应用的子域。有关更多信息，请参阅[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)。

1. 点击"**Fork!**"

   仓库将被fork到你的GitHub账户。如果你已经fork了仓库，Community Cloud将使用现有的fork。如果你现有的fork已经有关联的codespace，codespace将被重用。

   <Warning>
      在以下情况下不要使用此方法：
      - 你有与fork名称匹配的现有仓库（但不是此应用的fork）。
      - 你有此应用的现有fork，但你已更改仓库的名称。

   如果你有此应用的现有fork并保持了原始仓库名称，Community Cloud将使用你现有的fork。如果你之前部署了应用并打开了codespace，Community Cloud将打开你现有的codespace。
   </Warning>

   ![点击Fork以确认和部署你的应用](/images/streamlit-community-cloud/fork-public-hello-deploy.png)

1. 等待GitHub设置你的codespace。

   完全初始化你的codespace可能需要几分钟。在Visual Studio Code编辑器出现在你的codespace中后，安装Python并启动Streamlit服务器可能需要几分钟。完成后，分割屏幕视图在左侧显示代码编辑器，在右侧显示运行应用。代码编辑器默认打开两个选项卡：仓库的readme文件和应用的入口文件。

   ![点击Fork以确认和部署你的应用](/images/streamlit-community-cloud/fork-public-hello-codespace.png)

   <Important>
      你的codespace中显示的应用不是你在Community Cloud上部署的同一个实例。你的codespace是一个独立的开发环境。当你在codespace内进行编辑时，这些编辑在你提交到仓库之前不会离开codespace。当你提交更改到仓库时，Community Cloud检测更改并更新你部署的应用。要了解更多，请参阅[编辑你的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app)。
   </Important>

1. 根据需要编辑你新fork的应用。有关使用GitHub Codespaces的更多说明，请参阅[编辑你的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app)。

---

# 快速入门

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/quickstart


这是一套简洁的步骤，用于创建您的 Streamlit 社区云账户、部署示例应用程序，并使用 GitHub Codespaces 开始编辑。对于其他选项和完整说明，请从 [创建您的账户](/deploy/streamlit-community-cloud/get-started/create-your-account) 开始。

在此过程中，您将登录到您的 GitHub 账户。社区云将使用您 GitHub 账户中的电子邮件来创建您的社区云账户。对于其他登录选项，请参见 [创建您的账户](/deploy/streamlit-community-cloud/get-started/create-your-account)。

## 先决条件

- 您必须拥有一个 GitHub 账户。

## 注册 Streamlit 社区云

1. 前往 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>。
1. 点击"**继续登录**"。
1. 点击"**使用 GitHub 继续**"。
1. 输入您的 GitHub 凭据并按照 GitHub 的身份验证提示操作。
1. 填写您的账户信息，然后点击底部的"**我接受**"。

## 添加对公共仓库的访问权限

1. 在左上角，点击"**工作空间 <i>{{ verticalAlign: "-.25em", color: "#ff8700" }} className={{ class: "material-icons-sharp" }}&gt;warning</i>**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="将您的 GitHub 账户连接到新的社区云账户" src="/images/streamlit-community-cloud/workspace-unconnected-setup.png"/>
</div>

1. 从下拉菜单中，点击"**连接 GitHub 账户**。"
1. 输入您的 GitHub 凭据并按照 GitHub 的身份验证提示操作。
1. 点击"**授权 streamlit**。"

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="授权社区云连接到您的 GitHub 账户" src="/images/streamlit-community-cloud/GitHub-auth1-none.png"/>
</div>

## 可选：添加对私有仓库的访问权限

1. 在左上角，点击您的 GitHub 用户名。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="访问您的工作区设置" src="/images/streamlit-community-cloud/workspace-empty-menu.png"/>
</div>

1. 从下拉菜单中，点击"**设置**。"
1. 在对话框左侧，选择"**已连接的账户**。"
1. 在"源码控制"下，点击"**在此连接 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_forward</i>**。"
1. 点击"**授权 streamlit**。"

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="授权社区云连接到您的私有 GitHub 仓库" src="/images/streamlit-community-cloud/GitHub-auth2-none.png"/>
</div>

## 从模板创建新应用程序

1. 在右上角，点击"**创建应用程序**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="在 Streamlit 社区云中从工作区创建新应用程序" src="/images/streamlit-community-cloud/deploy-empty-new-app.png"/>
</div>

1. 当被问到"您已经有应用程序了吗？"时，点击"**没有，从模板创建一个**。"
1. 从左侧的模板列表中，选择"**空白应用程序**。"
1. 在底部，选择"**打开 GitHub Codespaces...**"选项
1. 在底部，点击"**部署**。"

## 在 GitHub Codespaces 中编辑您的应用程序

1. 等待 GitHub 设置您的代码空间。

   完全初始化您的代码空间可能需要几分钟时间。在 Visual Studio Code 编辑器出现在您的代码空间中后，安装 Python 并启动 Streamlit 服务器可能还需要几分钟时间。完成后，分屏视图显示左侧的代码编辑器和右侧正在运行的应用程序。代码编辑器默认打开两个标签：仓库的 readme 文件和应用程序的入口文件。

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="您的新 GitHub 代码空间" src="/images/streamlit-community-cloud/deploy-template-blank-codespace.png"/>
</div>

1. 在左窗格中转到应用程序的入口文件（`streamlit_app.py`），并在第3行中在 `st.title` 内添加"Streamlit"。

   ```diff
   -st.title("🎈 My new app")
   +st.title("🎈 My new Streamlit app")
   ```

   在您的代码空间中，每次编辑时文件都会自动保存。

1. 输入更改后片刻，您右侧的应用程序将显示重新运行提示。点击"**始终重新运行**。"

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="编辑示例 Streamlit 应用程序的标题" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit.png"/>
</div>

   如果您点击之前重新运行提示消失，可以悬停在溢出菜单图标上（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>）将其恢复。

1. 可选：继续进行编辑并在几秒钟内观察更改。

## 发布您的更改

1. 在左侧导航栏中，点击源码控制图标。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="查看您已部署的 Streamlit 应用程序" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-source-control.png"/>
</div>

1. 在左侧的源码控制侧边栏中，为您的提交输入一个名称。
1. 点击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;check</i> 提交**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="查看您已部署的 Streamlit 应用程序" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-commit.png"/>
</div>

1. 要暂存并提交所有更改，在确认对话框中点击"**是**。"您的更改在代码空间中本地提交。
1. 要将您的提交推送到 GitHub，在左侧的源码控制侧边栏中点击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;cached</i> 1 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_upward</i>**。"
1. 要将提交推送到"origin/main"，在确认对话框中点击"**确定**。"

   您的更改现在已保存到您的 GitHub 仓库。社区云将立即在您已部署的应用程序中反映更改。

1. 可选：要查看您更新后的已发布应用程序，请返回到 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 工作区的"**我的应用程序**"部分，然后点击您的应用程序。

## 停止或删除您的代码空间

当您停止与代码空间交互时，GitHub 通常会为您停止代码空间。然而，避免不必要使用容量的最可靠方法是在完成后停止或删除代码空间。

1. 前往 <a href="https://github.com/codespaces" target="_blank">github.com/codespaces</a>。在页面底部，列出您的所有代码空间。点击您代码空间的溢出菜单图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_horiz</i>）。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="停止或删除您的 GitHub 代码空间" src="/images/streamlit-community-cloud/deploy-hello-codespace-manage.png"/>
</div>

2. 如果您想稍后返回您的工作，请点击"**停止代码空间**。否则，请点击"**删除**。"

   <div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
   <Image alt="停止您的 GitHub 代码空间" src="/images/streamlit-community-cloud/codespace-menu.png"/>
</div>

3. 恭喜！您刚刚将应用程序部署到 Streamlit 社区云。🎉 返回到 <a href="https://share.streamlit.io/" target="_blank">share.streamlit.io/</a> 的工作区并 [部署另一个 Streamlit 应用程序](/deploy/streamlit-community-cloud/deploy-your-app)。

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="查看您已部署的 Streamlit 应用程序" src="/images/streamlit-community-cloud/deploy-template-blank-edited.png"/>
</div>

---

# Streamlit信任和安全

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started/trust-and-security


Streamlit是一个将Python脚本转化为交互式应用的框架，给数据科学家快速为整个公司创建基于数据和模型的应用的能力。

一个简单的Streamlit应用是：

```python
import streamlit as st
number = st.slider("Pick a number: ", min_value=1, max_value=10)
st.text("Your number is " + str(number))
```

当你执行`streamlit run my_app.py`时，你启动一个在本地计算机上以`http://localhost:8501`运行交互式应用的web服务器。这对本地开发很好。当你想与同事分享时，Streamlit Community Cloud让你在云中部署和运行这些应用。Streamlit Community Cloud处理容器化的细节，并为你提供一个用于轻松管理部署应用的界面。

本文档提供了我们实施的安全保障措施的概述，以保护你和你的数据。但是，安全是共同责任，你最终负责适当使用Streamlit和Streamlit Community Cloud，包括实施适当的用户可配置的安全保障措施和最佳做法。

## 产品安全

### 认证

你必须通过GitHub进行认证以部署或管理应用。当你在关联的GitHub仓库上没有推送或管理员权限时，通过Google或单次使用电子邮件链接的认证是查看私有应用所必需的。单次使用电子邮件链接在请求后有效期为15分钟。

### 权限

Streamlit Community Cloud继承你在GitHub中分配的权限。对给定应用的GitHub仓库有写入权限的用户将能够在Streamlit管理控制台中进行更改。但是，只有拥有仓库**管理员访问权限**的用户能够**部署和删除应用**。

## 网络和应用安全

### 数据托管

我们的物理基础设施托管和管理在由基础设施即服务云提供商维护的安全数据中心内。Streamlit利用这些平台的许多内置安全、隐私和冗余功能。我们的云提供商持续监控其数据中心以寻求风险，并进行评估以确保符合行业标准。

### 数据删除

Community Cloud用户可以选择删除他们部署的任何应用以及整个账户。

当用户从管理控制台删除应用时，我们删除其源代码，包括从其GitHub仓库复制的任何文件或从运行应用在我们系统中创建的文件。但是，我们在数据库中保留表示应用的记录。此记录包含应用的坐标：GitHub组织或用户、GitHub仓库、分支和主模块文件的路径。

当用户删除其账户时，我们对其数据进行硬删除，并对与其账户相关联的GitHub身份所属的所有应用进行硬删除。在这种情况下，我们不保留上述应用坐标的记录。删除账户时，我们也删除与Community Cloud账户相关联的任何HubSpot联系人。

### 虚拟专用云

我们的所有服务器都在虚拟专用云（VPC）内，带有防火墙和网络访问控制列表（ACL），允许外部访问选定的少数API端点；所有其他内部服务仅在VPC内可访问。

### 加密

Streamlit应用完全通过HTTPS提供。我们只使用强密码套件和HTTP严格传输安全（HSTS）来确保浏览器与Streamlit应用通过HTTPS交互。

所有通过公网发送到或来自Streamlit的数据都使用256位加密进行传输加密。我们的API和应用端点使用传输层安全（TLS）1.2（或更好）。我们也使用AES-256对磁盘上的静止数据进行加密。

### 权限和认证

对Community Cloud用户账户数据的访问仅限于授权人员。我们运行零信任企业网络，利用单点登录和多因素认证（MFA），并强制执行强密码策略以确保对云相关服务的访问受到保护。

### 事件响应

我们处理安全事件的内部协议包括检测、分析、响应、升级和缓解。安全公告可在[https://streamlit.io/advisories](https://streamlit.io/advisories)获得。

### 渗透测试

Streamlit使用第三方安全工具定期扫描漏洞。我们的安全团队对Streamlit平台进行定期、密集的渗透测试。我们的产品开发团队对任何已识别的问题或潜在漏洞进行响应，以确保Streamlit应用的质量、安全和可用性。

### 漏洞管理

我们使我们的系统保持最新的最新安全补丁，并持续监控新漏洞。这包括对我们代码仓库的自动扫描，以寻找易受攻击的依赖。

如果你在我们的一个产品或网站中发现漏洞，请向[HackerOne](https://hackerone.com/snowflake?type=team)报告问题。

---

# 管理您的账户

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account


您可以通过 [工作区设置](/deploy/streamlit-community-cloud/manage-your-account/workspace-settings) [更新您的电子邮件](/deploy/streamlit-community-cloud/manage-your-account/update-your-email) 或完全 [删除您的账户](/deploy/streamlit-community-cloud/manage-your-account/delete-your-account)。

您的 Streamlit Community Cloud 账户由您的电子邮件标识。当您登录 Community Cloud 时，无论您使用哪种方法，您都在向 Community Cloud 提供您的电子邮件地址。特别是，当您使用 GitHub 登录 Community Cloud 时，您使用的是 GitHub 账户上的主电子邮件。您可以从工作区设置中的"[**关联账户**](/deploy/streamlit-community-cloud/manage-your-account/workspace-settings#linked-accounts)"中查看您的电子邮件身份和源代码控制身份。

## 访问您的工作区设置

1. 登录到 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>。
1. 在左上角，单击您的工作区名称。
1. 在下拉菜单中，单击"**设置**"。

<div>{{ maxWidth: '75%', marginLeft: '3em' }}&gt;
    <Image alt="从您的工作区访问您的工作区设置" src="/images/streamlit-community-cloud/account-settings-header.png"/>
</div>

---

# 删除你的账户

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account/delete-your-account


删除你的Streamlit Community Cloud账户就像创建它一样简单。当你删除账户时，你的信息、账户和所有托管的应用也会被删除。在[Streamlit信任和安全](/deploy/streamlit-community-cloud/get-started/trust-and-security#data-deletion)中了解更多关于数据删除。

<Warning>

删除你的账户是永久性的，无法撤销。在继续之前，请确保你确实想删除你的账户和所有托管的应用。你部署的任何应用都将被删除，无论它从哪个工作空间部署。

</Warning>

## 如何删除你的账户

按照以下步骤删除你的账户：

1. 在<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>登录Streamlit Community Cloud并访问你的[工作空间设置](/deploy/streamlit-community-cloud/manage-your-account/workspace-settings)。

   ![从工作空间设置删除你的Streamlit Community Cloud账户](/images/streamlit-community-cloud/workspace-settings-linked-accounts.png)

1. 从"**链接账户**"部分，点击"**删除账户**"。
1. 在确认对话框中，遵循提示并点击"**永久删除账户**"。

   你的所有信息和应用将被永久删除。

   ![你的Streamlit Community Cloud账户已被删除。](/images/streamlit-community-cloud/account-deleted.png)

就这么简单！如果你有任何问题或在删除账户时遇到问题，请在<a href="https://discuss.streamlit.io/c/community-cloud/13" target="_blank">我们的论坛</a>上与我们联系。我们很乐意帮助！🎈

---

# 管理你的GitHub连接

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account/manage-your-github-connection


如果你已创建账户但尚未连接GitHub，请参阅[连接你的GitHub账户](/deploy/streamlit-community-cloud/get-started/connect-your-github-account)。

如果你已连接GitHub账户但仍需允许Streamlit Community Cloud访问私有仓库，请参阅[可选：添加对私有仓库的访问权限](/deploy/streamlit-community-cloud/get-started/connect-your-github-account#optional-add-access-to-private-repositories)。

## 添加组织访问权限

如果你在组织中，你可以在连接GitHub账户时授予或请求对该组织的访问权限。有关更多信息，请参阅[组织访问](/deploy/streamlit-community-cloud/get-started/connect-your-github-account#organization-access)。

如果你的GitHub账户已连接，你可以在GitHub设置中移除权限，并在下次登录Community Cloud时强制Streamlit重新提示GitHub授权。

### 撤销和重新授权

1. 从你的工作空间，点击右上角的工作空间名称。要退出Community Cloud，点击"**退出**"。

   ![从Streamlit Community Cloud退出](/images/streamlit-community-cloud/account-sign-out.png)

1. 转到<a href="https://github.com/settings/applications" target="_blank">github.com/settings/applications</a>的GitHub应用设置。
1. 找到"Streamlit"应用，并点击三个点(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_horiz</i>)以打开溢出菜单。

   如果你曾使用GitHub登录Community Cloud，你也会在GitHub账户中看到"Streamlit Community Cloud"应用。"Streamlit"应用管理仓库访问。"Streamlit Community Cloud"应用仅用于管理你在Community Cloud上的身份（电子邮件）。你只需撤销对"Streamlit"应用的访问权限。

1. 点击"**撤销**"。

   <div>{{ maxWidth: '75%', margin: 'auto' }}&gt;
   <Image alt="撤销Streamlit访问你的GitHub账户的权限" src="/images/streamlit-community-cloud/GitHub-revoke.png"/>
</div>

1. 点击"**我了解，撤销访问**"。

  <div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
  <Image alt="确认撤销Streamlit对你的GitHub账户的访问权限" src="/images/streamlit-community-cloud/GitHub-revoke-confirm.png"/>
</div>

1. 返回<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>并登录。你将被提示授权GitHub，如[连接GitHub](/deploy/streamlit-community-cloud/get-started/connect-your-github-account#organization-access)中所述。

### 授予先前被拒绝的访问权限

如果组织所有者限制了Streamlit的访问或限制了所有OAuth应用，他们可能需要直接在GitHub中修改他们的权限。如果组织限制了Streamlit的访问，当你被提示使用GitHub账户授权时，组织旁边会出现红色X(<i>{{ verticalAlign: "-.25em", color: "#d1242f" }} className={{ class: "material-icons-sharp" }}&gt;close</i>)。

<div>{{ maxWidth: '60%', margin: 'auto' }}&gt;
<Image alt="Streamlit访问你的GitHub账户的拒绝授权" src="/images/streamlit-community-cloud/GitHub-auth-denied-XL.png"/>
</div>

请参阅GitHub关于<a href="https://docs.github.com/en/apps/oauth-apps/using-oauth-apps/authorizing-oauth-apps#oauth-apps-and-organizations" target="_blank">OAuth应用和组织</a>的文档。

## 重命名你的GitHub账户或仓库

Community Cloud通过GitHub坐标（所有者、仓库、分支、入口文件路径）识别应用。如果你重命名已从其部署应用的账户或仓库，你将失去管理应用的访问权限。要了解更多，请参阅[在GitHub中重命名你的应用](/deploy/streamlit-community-cloud/manage-your-app/rename-your-app)。

---

# 登录和退出

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account/sign-in-sign-out


在你创建了账户后，你可以按照以下选项登录到<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>。

![登录到Streamlit Community Cloud](/images/streamlit-community-cloud/account-sign-in.png)

## 使用Google登录

1. 点击"**继续登录**"。
1. 点击"**使用Google继续**"。
1. 输入你的Google账户凭据并遵循提示。

如果你的账户已与GitHub关联，你可能会立即被提示使用GitHub登录。

## 使用GitHub登录

1. 点击"**继续登录**"。
1. 点击"**使用GitHub继续**"。
1. 输入你的GitHub凭据并遵循提示。

<Important>
    当你使用GitHub登录时，Community Cloud会查找使用你GitHub账户上相同电子邮件的账户。如果该账户不存在，Community Cloud会查找使用你的GitHub账户进行源代码控制的账户。在后一种情况下，Community Cloud会更新Community Cloud账户上的电子邮件，以匹配GitHub账户上的电子邮件。
</Important>

## 使用电子邮件登录

1. 点击"**继续登录**"。
1. 在"电子邮件"字段中，输入你的电子邮件地址。
1. 点击"**继续**"。（如果提示，验证你是人类。）
1. 转到你的电子邮件收件箱，复制你的一次性六位数代码。代码有效期为十分钟。
1. 返回认证页面，输入你的代码。（如果提示，验证你是人类。）

如果你的账户已与GitHub关联，你可能会立即被提示使用GitHub登录。

## 从你的账户退出

从你的工作空间，点击左上角的工作空间名称。点击"**退出**"。

<div>{{ maxWidth: '80%', margin: 'auto' }}&gt;
<Image alt="从Streamlit Community Cloud退出" src="/images/streamlit-community-cloud/account-sign-out.png"/>
</div>

---

# 更新你的电子邮件

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account/update-your-email


要更新Streamlit Community Cloud上的电子邮件，你有两个选项：你可以创建新账户并将现有账户合并到其中，或者你可以使用GitHub账户更新你的电子邮件。

## 选项1：创建新账户并合并它

两个Community Cloud账户不能对源代码控制有相同的GitHub账户。当你将GitHub账户连接到新Community Cloud账户以进行源代码控制时，Community Cloud会自动合并任何具有相同源代码控制的现有账户。

因此，你可以使用所需的电子邮件创建新账户，并连接相同的GitHub账户以将它们合并在一起。

1. 使用你的新电子邮件创建新账户。
1. 连接你的GitHub账户。

你的旧账户和新账户现在已合并，你已有效更改了电子邮件地址。

## 选项2：使用你的GitHub账户

或者，你可以更改GitHub账户上的电子邮件，然后使用GitHub登录Community Cloud。

1. 转到GitHub，将你的主要电子邮件地址设置为新电子邮件。
1. 如果你当前登录到Community Cloud，请退出。
1. 使用GitHub登录Community Cloud。

   如果你被重定向到工作空间，你看到现有应用，你已完成！你的电子邮件已更改。要确认当前电子邮件和GitHub账户，点击左上角的工作空间名称，并查看下拉菜单底部。

   如果你被重定向到空工作空间，你看到左上角的"**工作空间 <i>{{ verticalAlign: "-.25em", color: "#ff8700" }} className={{ class: "material-icons-sharp" }}&gt;warning</i>**"，请继续[连接你的GitHub账户](/deploy/streamlit-community-cloud/get-started/connect-your-github-account)。如果你之前使用新电子邮件创建了账户但没有将GitHub账户连接到它，就可能发生这种情况。

<Important>
   如果你有多个GitHub账户，请小心。为避免意外行为，要么在每个GitHub账户上使用唯一的电子邮件，要么避免使用GitHub登录Community Cloud。
</Important>

---

# 工作空间设置

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-account/workspace-settings


从工作空间设置，你可以[管理你的账户](/deploy/streamlit-community-cloud/manage-your-account)、查看[应用资源和限制](/deploy/streamlit-community-cloud/manage-your-app#app-resources-and-limits)并访问支持资源。

## 访问工作空间设置

1. 登录到<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>。
1. 在左上角，点击工作空间名称。
1. 在下拉菜单中，点击"**设置**"。

   ![从工作空间访问工作空间设置](/images/streamlit-community-cloud/account-settings-header.png)

## 链接账户

"**链接账户**"部分显示当前电子邮件身份和源代码控制账户。要了解更多，请参阅[管理你的账户](/deploy/streamlit-community-cloud/manage-your-account)。

![在工作空间设置中管理链接账户](/images/streamlit-community-cloud/workspace-settings-linked-accounts.png)

## 限制

"**限制**"部分显示当前资源和限制。要了解更多，请参阅[应用资源和限制](/deploy/streamlit-community-cloud/manage-your-app#app-resources-and-limits)。

![工作空间设置中显示的资源限制](/images/streamlit-community-cloud/workspace-settings-limits.png)

## 支持

"**支持**"部分提供了一个有用资源的便捷列表，以便你知道在需要帮助时去哪里。

![通过工作空间设置提供的支持选项](/images/streamlit-community-cloud/workspace-settings-support.png)

---

# Manage your app

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app


You can manage your deployed app from your workspace at <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> or directly from `<your-custom-subdomain>.streamlit.app`. You can view, deploy, delete, reboot, or favorite an app.

## Manage your app from your workspace

Streamlit Community Cloud is organized into workspaces, which automatically group your apps according to their repository's owner in GitHub. Your workspace is indicated in the upper-left corner. For more information, see [Switching workspaces](/deploy/streamlit-community-cloud/get-started/explore-your-workspace#switching-workspaces).

To deploy or manage any app, always switch to the workspace matching the repository's owner first.

### 排序您的应用

如果您的工作区中有许多应用，可以通过将应用标记为收藏 (<i>{{ verticalAlign: "-.25em", color: "#faca2b" }} className={{ class: "material-icons-sharp" }}&gt;star</i>) 来将应用固定到顶部。有关更多信息，请参阅[收藏您的应用](/deploy/streamlit-community-cloud/manage-your-app/favorite-your-app)。

### 应用溢出菜单

每个应用都有一个菜单，可从右侧的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>) 访问。

- **使用 Codespaces 编辑**  请参阅[使用 GitHub Codespaces 编辑您的应用](/deploy/streamlit-community-cloud/manage-your-app/edit-your-app#edit-your-app-with-github-codespaces)
- **重启**  请参阅[重启您的应用](/deploy/streamlit-community-cloud/manage-your-app/reboot-your-app)
- **删除**  请参阅[删除您的应用](/deploy/streamlit-community-cloud/manage-your-app/delete-your-app)
- **分析**  请参阅[应用分析](/deploy/streamlit-community-cloud/manage-your-app/app-analytics)
- **设置**  请参阅[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)

![您的工作区中的应用溢出菜单](/images/streamlit-community-cloud/workspace-app-overflow.png)

如果您对某个应用具有仅查看权限，则应用菜单中的所有选项都将被禁用，除了分析。

![您的工作区中的仅查看应用溢出菜单](/images/streamlit-community-cloud/workspace-view-only.png)

## 直接从应用管理您的应用

您可以直接从应用本身管理已部署的应用！只需确保您已登录到 Community Cloud，然后访问您的应用。

### 云日志

1. 从您的应用 `<your-custom-subdomain>.streamlit.app`，单击右下角的"**管理应用**"。

   ![从应用右下角的"管理应用"访问云日志](/images/streamlit-community-cloud/cloud-logs-open.png)

2. 单击"**管理应用**"后，您将能够查看应用的日志。这是您排查应用问题的主要位置。

   ![Streamlit Community Cloud 日志](/images/streamlit-community-cloud/cloud-logs.png)

3. 您可以通过单击云日志底部的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>) 来访问更多开发者选项。要方便地下载日志，请单击"**下载日志**"。

   ![下载您的 Streamlit Community Cloud 日志](/images/streamlit-community-cloud/cloud-logs-menu-download.png)

<Flex>
<div>

从云日志访问的其他选项包括：

- **分析**  请参阅 [应用分析](/deploy/streamlit-community-cloud/manage-your-app/app-analytics)。
- **重启应用**  请参阅 [重启您的应用](/deploy/streamlit-community-cloud/manage-your-app/reboot-your-app)。
- **删除应用**  请参阅 [删除您的应用](/deploy/streamlit-community-cloud/manage-your-app/delete-your-app)。
- **设置**  请参阅 [应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)。
- **您的应用**  带您前往您的 [应用工作区](#manage-your-app-from-your-workspace)。
- **文档**  带您前往我们的文档。
- **支持**  带您前往 <a href="https://discuss.streamlit.io/" target="_blank">我们的论坛</a>！

</div>
<div>{{ maxWidth: '30%', margin: "auto" }}&gt;
    <Image src="/images/streamlit-community-cloud/cloud-logs-menu-XL.png"/>
</div>
</Flex>

### 应用界面

从 `<your-custom-subdomain>.streamlit.app` 的应用，您始终可以访问 [应用界面](/develop/concepts/architecture/app-chrome)，就像在本地开发时一样。部署应用的选项已被删除，但您仍然可以从这里清除缓存。

![Streamlit Community Cloud 中的应用菜单](/images/streamlit-community-cloud/app-menu.png)

## 在 GitHub 中管理您的应用

### 更新您的应用

您的 GitHub 存储库是应用的源，这意味着每当您将更新推送到存储库时，您将看到应用中的更改几乎实时反映。试试看！

Streamlit 还会聪明地检测您是否修改了依赖项，在这种情况下，它将自动为您进行完整重新部署，这将花费更多时间。但由于大多数更新不涉及依赖项更改，您通常应该看到应用实时更新。

### 添加或删除依赖项

要随时添加或删除依赖项，只需更新 `requirements.txt`（Python 依赖项）或 `packages.txt`（Linux 依赖项），然后将更改提交到 GitHub 上的存储库。Community Cloud 检测到您的依赖项中的更改，并自动触发（重新）安装。

最好的做法是在 `requirements.txt` 中固定您的 Streamlit 版本。否则，版本可能在您不知情的情况下随时自动升级，这可能导致不期望的结果（例如，当我们在 Streamlit 中弃用功能时）。

## 应用资源和限制

### 资源限制

所有 Community Cloud 用户都可以访问相同的资源，并受相同限制的约束。这些限制可能随时更改，恕不另行通知。如果您的应用达到或超过其限制，它可能会因限流而变慢或无法正常运行。截至 2024 年 2 月，限制大约如下：

- CPU：最小 0.078 核，最大 2 核
- 内存：最小 690MB，最大 2.7GB
- 存储：无最小值，最大 50GB

应用资源不足的症状包括以下几项：

- 您的应用运行缓慢。
- 您的应用显示"🤯 此应用已超过其资源限制"。
- 您的应用显示"😦 哎呀"。

### 对世界有益

Streamlit 为具有对世界有益的用例的应用提供增加的资源。通常，这些应用由教育机构或非营利组织使用、属于开源项目的一部分，或以某种方式造福世界。如果您的应用 **不是** 主要由营利公司使用，您可以 [申请增加资源](https://info.snowflake.com/streamlit-resource-increase-request.html)。

### 优化您的应用

如果您的应用运行缓慢或显示上述错误页面，我们首先强烈建议您通读以下博客文章中的建议并加以实施，以防止您的应用达到资源限制，并检测您的 Streamlit 应用是否存在内存泄漏：

- <a href="https://blog.streamlit.io/common-app-problems-resource-limits/" target="_blank">常见应用问题：资源限制</a>
- <a href="https://blog.streamlit.io/3-steps-to-fix-app-memory-leaks/" target="_blank">修复应用内存泄漏的 3 个步骤</a>

如果您的应用超过其资源限制，开发人员和查看者都会看到"😦 哎呀"。

<div>{{ maxWidth: '70%', margin: 'auto' }}&gt;
<Image alt="应用状态：哎呀。运行应用时出错。" src="/images/streamlit-community-cloud/app-state-oh-no.png"/>
</div>

如果查看应用时看到"😦 哎呀"，首先检查云日志以查找任何特定错误。如果云日志中没有错误，您可能正在处理资源问题。

#### 开发者视图

如果您以超过限制的应用的开发者账户身份登录，您可以从应用右下角访问"**管理应用**"以重新启动应用并清除其内存。"**管理应用**"将显示为红色并带有警告图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;error</i>)。

![开发者视图：哎呀。运行应用时出错。](/images/streamlit-community-cloud/app-state-oh-no-developer.png)

### 应用休眠

12 小时无流量的所有应用都会进入休眠。Community Cloud 将应用置于休眠状态以节省资源并允许平台的最佳共享使用。要保持应用保持活跃，只需访问您的应用。

当有人访问处于睡眠状态的应用时，他们将看到睡眠页面：

<div>{{ maxWidth: '80%', margin: 'auto' }}&gt;
<Image alt="应用状态：Zzzz。此应用由于不活动而进入睡眠。" src="/images/streamlit-community-cloud/app-state-zzzz.png"/>
</div>

要唤醒应用，请单击"**是的，让此应用重新启动！**"这可以由 *任何* 可以查看应用的人完成，而不仅仅是应用开发者！

您可以从工作区查看哪些应用处于睡眠状态。睡眠应用右侧有一个月亮图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;bedtime</i>)。

![应用状态：Zzzz。此应用由于不活动而进入睡眠](/images/streamlit-community-cloud/workspace-sleeping-app.png)</your-custom-subdomain></your-custom-subdomain></your-custom-subdomain>

---

# 应用分析

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/app-analytics


Streamlit Community Cloud允许你看到每个应用的观众数。具体来说，你可以看到：

- 应用的总观众数（从2022年4月计算）。
- 最近的唯一观众（限制为最后20个观众）。
- 每个唯一观众最后访问的相对时间戳。

![Streamlit Community Cloud上的应用分析](/images/streamlit-community-cloud/workspace-app-analytics-viewers.png)

## 访问应用分析

你可以通过以下方式访问应用的分析：

- [从工作空间](#access-app-analytics-from-your-workspace)。
- [从Cloud日志](#access-app-analytics-from-your-cloud-logs)。

### 从工作空间访问应用分析

从<a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>的工作空间，点击应用旁边的溢出图标(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)。点击"**分析**"。

![通过应用溢出菜单从工作空间访问应用分析](/images/streamlit-community-cloud/workspace-app-analytics.png)

### 从Cloud日志访问应用分析

从`<your-custom-subdomain>.streamlit.app`的应用，在右下角点击"**管理应用**"。

![从应用访问Streamlit Community Cloud日志](/images/streamlit-community-cloud/cloud-logs-open.png)

点击溢出菜单图标(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)并点击"**分析**"。

![从Cloud日志访问应用分析](/images/streamlit-community-cloud/cloud-logs-menu-analytics.png)

## 应用观众

对于公开应用，我们匿名化工作空间外的所有观众以保护其隐私，并将匿名观众显示为随机假名。你仍然能够看到工作空间中的同事的身份，包括你邀请的任何观众（一旦他们接受）。

<Important>

当你邀请观众到应用时，他们也获得分析访问权限。此外，如果有人被邀请作为工作空间中_任何_应用的观众，他们可以看到工作空间中所有公开应用的分析，并可以邀请额外的观众。工作空间中的观众可能通过分析看到工作空间中开发者和其他观众的电子邮件。

</Important>

同时，对于私有应用，你控制谁有访问权限，你将能够看到最近查看应用的特定用户。

此外，你偶尔可能在私有应用中看到匿名用户。放心，这些匿名用户_确实_有你或工作空间成员授予的授权查看访问权限。

用户显示为匿名的常见原因是：

- 应用之前是公开的。
- 给定的观众在2022年4月查看了应用，当时Streamlit团队正在为此功能改进用户识别。

请参阅Streamlit的通用<a href="https://streamlit.io/privacy-policy" target="_blank">隐私通知</a>。</your-custom-subdomain>

---

# 应用设置

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/app-settings


此页面关于 Streamlit Community Cloud 上的应用设置。从您的应用设置中，您可以[查看或更改您的应用的 URL](/deploy/streamlit-community-cloud/manage-your-app/app-settings#view-or-change-your-apps-url)，管理[对您的应用的公共或私有访问](/deploy/streamlit-community-cloud/share-your-app)，并更新您的应用的已保存[秘密](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

如果您从运行应用的右上角的[应用 chrome](/develop/concepts/architecture/app-chrome) 访问"**设置**"，您可以访问控制应用运行时外观的功能。

## 访问您的应用设置

您可以通过以下方式访问您的应用设置：

- [从您的工作区](#access-app-settings-from-your-workspace)。
- [从您的 Cloud 日志](#access-app-settings-from-your-cloud-logs)。

### 从您的工作区访问应用设置

从您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区，单击您的应用旁边的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)。单击"**设置**"。

![从您的工作区访问应用设置](/images/streamlit-community-cloud/workspace-app-settings.png)

### 从您的 Cloud 日志访问应用设置

从您的应用 `<your-custom-subdomain>.streamlit.app`，单击右下角的"**管理应用**"。

![从您的应用访问 Streamlit Community Cloud 日志](/images/streamlit-community-cloud/cloud-logs-open.png)

单击溢出菜单图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>) 并单击"**设置**"。

![从您的 Cloud 日志访问应用设置](/images/streamlit-community-cloud/cloud-logs-menu-settings.png)

## 更改您的应用设置

### 查看或更改您的应用的 URL

要从仪表板查看或自定义您的应用子域：

1. 如上所述访问您的应用设置。
1. 在"应用设置"对话框的"**常规**"选项卡中，在"应用 URL"字段中查看您的应用的唯一子域。

   ![Streamlit Community Cloud 上的常规应用设置：自定义子域](/images/streamlit-community-cloud/workspace-app-settings-general.png)

1. 可选：输入一个新的自定义子域，长度在 6 到 63 个字符之间，然后单击"**保存**"。

   ![您的应用的新自定义子域](/images/streamlit-community-cloud/workspace-app-settings-general-valid-domain.png)

   如果自定义子域不可用（例如，因为它已被占用或包含受限词），您将看到错误消息。按照指示更改您的子域。

   ![您的应用的无效自定义子域](/images/streamlit-community-cloud/workspace-app-settings-general-invalid-domain.png)

### 更新您的应用的共享设置

了解如何[共享您的应用](/deploy/streamlit-community-cloud/share-your-app)。

![Streamlit Community Cloud 上的共享设置](/images/streamlit-community-cloud/workspace-app-settings-sharing.png)

### 查看或更新您的秘密

1. 如上所述访问您的应用设置。
1. 在"应用设置"对话框的"**秘密**"选项卡中，在"秘密"字段中查看您的应用的秘密。

   ![Streamlit Community Cloud 上的秘密应用设置](/images/streamlit-community-cloud/workspace-app-settings-secrets.png)

1. 可选：添加、编辑或删除您的秘密，然后单击"**保存**"。

了解更多关于[您的 Community Cloud 应用的秘密管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。</your-custom-subdomain>

---

# 删除您的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/delete-your-app


如果您需要删除您的应用，它很简单且容易。有几种情况您可能需要删除您的应用：

- 您已经完成了示例应用的试用。
- 您想从私有仓库部署，但已经有一个私有应用。
- 您想为您的应用[更改 Python 版本](/deploy/streamlit-community-cloud/manage-your-app/upgrade-python)。
- 您想[重命名您的仓库](/deploy/streamlit-community-cloud/manage-your-app/rename-your-app)或移动您的入口点文件。

如果您删除您的应用并打算立即重新部署，您的自定义子域应该立即可供重用。阅读更多关于[Streamlit 信任和安全](/deploy/streamlit-community-cloud/get-started/trust-and-security#data-deletion)中的数据删除。

您可以删除您的应用：

- [从您的工作区](#delete-your-app-from-your-workspace)。
- [从您的 Cloud 日志](#delete-your-app-from-your-cloud-logs)。

### 从您的工作区删除您的应用

1. 从您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区，单击您的应用旁边的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)。单击"**删除**"。

   ![从您的工作区删除您的应用](/images/streamlit-community-cloud/workspace-app-delete.png)

2. 将显示确认。输入所需的确认字符串并单击"**删除**"。

   <div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
   <Image alt="确认从 Streamlit Community Cloud 删除您的应用" src="/images/streamlit-community-cloud/workspace-app-delete-confirm.png"/>
</div>

### 从您的 Cloud 日志删除您的应用

1. 从您的应用 `<your-custom-subdomain>.streamlit.app`，单击右下角的"**管理应用**"。

   ![从您的应用访问 Streamlit Community Cloud 日志](/images/streamlit-community-cloud/cloud-logs-open.png)

2. 单击溢出菜单图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>) 并单击"**删除应用**"。

   ![从您的 Cloud 日志删除您的应用](/images/streamlit-community-cloud/cloud-logs-menu-delete.png)

3. 将显示确认。输入所需的确认字符串并单击"**删除**"。

<div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
<Image alt="确认从 Streamlit Community Cloud 删除您的应用" src="/images/streamlit-community-cloud/workspace-app-delete-confirm.png"/>
</div></your-custom-subdomain>

---

# 编辑您的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/edit-your-app


您可以使用您选择的任何开发环境编辑您的应用。Streamlit Community Cloud 将监控您的仓库并自动复制您提交的任何文件更改。对于大多数更改（例如对您的应用 Python 文件的编辑），您将立即在已部署的应用中看到提交的反映。

Community Cloud 还使跳过设置开发环境的工作变得容易。只需几次点击，您就可以使用 GitHub Codespaces 配置开发环境。

## 使用 GitHub Codespaces 编辑您的应用

在几分钟内为您的已部署应用启动基于云的开发环境。您可以在您的 codespace 中运行您的应用，以享受在安全、沙盒环境中实验。当您完成代码编辑后，您可以将更改提交到您的仓库，或者只是将它们留在您的 codespace 中稍后返回。

### 为您的已部署应用创建 codespace

1. 从您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区，单击您的应用旁边的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)。单击"**使用 Codespaces 编辑**"。

   ![使用 GitHub Codespaces 编辑您的应用](/images/streamlit-community-cloud/workspace-app-edit.png)

   Community Cloud 将向您的仓库添加一个 `.devcontainer/devcontainer.json` 文件。如果您的仓库中已经有一个同名文件，它不会被更改。如果您希望您的仓库接收 Community Cloud 创建的实例，请删除或重命名您现有的 devcontainer 配置。

1. 等待 GitHub 设置您的 codespace。

   完全初始化您的 codespace 可能需要几分钟时间。在您的 codespace 中出现 Visual Studio Code 编辑器后，可能需要几分钟来安装 Python 并启动 Streamlit 服务器。完成后，分屏视图将在左侧显示代码编辑器，在右侧显示运行的应用。代码编辑器默认打开两个选项卡：仓库的自述文件和应用的入口点文件。

   ![您的新 GitHub Codespace](/images/streamlit-community-cloud/deploy-template-blank-codespace.png)

1. 可选：为了有更多工作空间，在另一个选项卡中打开应用预览。

   如果您有多个显示器并想要更多工作空间，请将应用预览在另一个选项卡中打开，而不是使用 Visual Studio Code 中的简单浏览器。只需从简单浏览器复制 URL 到另一个选项卡，然后关闭简单浏览器。现在您有更多空间编辑您的代码。本页面的其余步骤将继续显示 Visual Studio Code 中的分屏视图。

1. 对您的应用进行更改。

   当您对您的应用进行更改时，文件会在您的 codespace 中自动保存。您的编辑不会影响您的仓库或已部署的应用，直到您提交这些更改，这将在后面的步骤中解释。右侧显示的应用预览是您的 codespace 本地的。

1. 为了在右侧自动看到更新，在您的第一次编辑后提示时单击"**始终重新运行**"。

   ![选择"始终重新运行"以在运行的应用中自动看到编辑](/images/streamlit-community-cloud/deploy-template-blank-codespace-edit.png)

   或者，您可以单击"**重新运行**"以避免在编写代码时不必要的重新运行。因为您的代码会持续保存，自动重新运行应用会在您在代码行中途暂停时引发错误。无论您选择哪个，您都可以通过应用 chrome 更改设置。只需单击预览应用右上角的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)，单击"**设置**"，然后切换"**保存时运行**"。

1. 继续编辑您的应用。您的 codespace 将继续在您处理文件时自动保存它们，并且预览将继续在应用重新运行时更新。

### 可选：发布您的更改

在对您的应用进行编辑后，您可以选择将您的编辑提交到您的仓库以立即更新您的已部署应用。如果您只想将您的编辑保留在您的 codespace 中稍后返回，请跳到[停止或删除您的 codespace](#stop-or-delete-your-codespace)。

1. 在左侧导航栏中，单击源代码控制图标。

   ![单击源代码控制图标](/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-source-control.png)

1. 在左侧的源代码控制侧边栏中，为您的提交输入名称。
1. 单击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;check</i> 提交**"。

   ![查看您的已部署 Streamlit 应用](/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-commit.png)

1. 要暂存和提交您的所有更改，在确认对话框中单击"**是**"。您的更改在您的 codespace 中本地提交。
1. 要将您的提交推送到 GitHub，在左侧的源代码控制侧边栏中，单击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;cached</i> 1 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_upward</i>**"。
1. 要将提交推送到"origin/main"，在确认对话框中单击"**确定**"。

   您的更改现在保存到您的 GitHub 仓库。Community Cloud 将立即在您的已部署应用中反映更改。

1. 可选：要查看您的更新、已发布的应用，返回到您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区的"**我的应用**"部分，并单击您的应用。

### 停止或删除您的 codespace

当您停止与您的 codespace 交互时，GitHub 通常会为您停止 codespace。但是，避免不 desired 使用容量的最可靠方法是在完成后停止或删除您的 codespace。

1. 转到 <a href="https://github.com/codespaces" target="_blank">github.com/codespaces</a>。在页面底部，列出了您的所有 codespace。单击您的 codespace 的溢出菜单图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_horiz</i>)。

   ![停止或删除您的 GitHub Codespace](/images/streamlit-community-cloud/deploy-hello-codespace-manage.png)

2. 如果您想稍后返回工作，单击"**停止 codespace**"。否则，单击"**删除**"。

   <div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
   <Image alt="停止您的 GitHub codespace" src="/images/streamlit-community-cloud/codespace-menu.png"/>
</div>

3. 恭喜！您刚刚将应用部署到 Community Cloud。🎉 返回到您在 <a href="https://share.streamlit.io/" target="_blank">share.streamlit.io/</a> 的工作区并[部署另一个 Streamlit 应用](/deploy/streamlit-community-cloud/deploy-your-app)。

   ![查看您的已部署 Streamlit 应用](/images/streamlit-community-cloud/deploy-template-blank-edited.png)

---

# 收藏您的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/favorite-your-app


Streamlit Community Cloud 支持"收藏"功能，让您可以从您的工作区快速访问您的应用。收藏的应用在其工作区顶部显示，旁边有一个黄色星星 (<i>{{ verticalAlign: "-.25em", color: "#faca2b" }} className={{ class: "material-icons-sharp" }}&gt;star</i>)。您可以在您作为开发者或受邀查看者有访问权限的任何工作区中收藏和取消收藏应用。

![收藏的应用在 Streamlit Community Cloud 中显示在顶部](/images/streamlit-community-cloud/workspace-two-apps.png)

<Note>

收藏是特定于您的账户的。您工作区的其他成员看不到您收藏了哪些应用。

</Note>

## 收藏和取消收藏您的应用

您可以收藏您的应用：

- [从您的工作区](#favorite-your-app-from-your-workspace)。
- [从您的应用](#favorite-your-app-from-your-app-toolbar)！

### 从您的工作区收藏您的应用

1. 从您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区，将鼠标悬停在您的应用上。

   如果您的应用尚未收藏，悬停时会出现星星轮廓 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;star_border</i>)。

1. 单击您的应用名称旁边的星星 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;star_border</i>/<i>{{ verticalAlign: "-.25em", color: "#faca2b" }} className={{ class: "material-icons-sharp" }}&gt;star</i>) 以切换其收藏状态。

### 从您的应用工具栏收藏您的应用

从您的应用 `<your-custom-subdomain>.streamlit.app`，单击右上角的星星 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;star_border</i>/<i>{{ verticalAlign: "-.25em", color: "#faca2b" }} className={{ class: "material-icons-sharp" }}&gt;star</i>) 以切换您的应用的收藏状态。

![直接从您的实时应用收藏您的应用](/images/streamlit-community-cloud/favorite-select.png)</your-custom-subdomain>

---

# 重启您的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/reboot-your-app


如果您需要清除您的应用的内存或在修改 Streamlit Community Cloud 不监控的文件后强制全新构建，您可能需要重启您的应用。这将中断任何当前可能正在使用您的应用的用户，并且您的应用重新部署可能需要几分钟时间。在重启期间，访问您的应用的任何人都会看到"您的应用正在烘焙中"。

在 Community Cloud 上重启您的应用很容易！您可以重启您的应用：

- [从您的工作区](#reboot-your-app-from-your-workspace)。
- [从您的 Cloud 日志](#reboot-your-app-from-your-cloud-logs)。

### 从您的工作区重启您的应用

1. 从您在 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 的工作区，单击您的应用旁边的溢出图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)。单击"**重启**"。

   ![从您的工作区重启您的应用](/images/streamlit-community-cloud/workspace-app-reboot.png)

2. 将显示确认。单击"**重启**"。

<div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
<Image alt="确认在 Streamlit Community Cloud 中重启您的应用" src="/images/streamlit-community-cloud/workspace-app-reboot-confirm.png"/>
</div>

### 从您的 Cloud 日志重启您的应用

1. 从您的应用 `<your-custom-subdomain>.streamlit.app`，单击右下角的"**管理应用**"。

   ![从您的应用访问 Streamlit Community Cloud 日志](/images/streamlit-community-cloud/cloud-logs-open.png)

2. 单击溢出菜单图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>) 并单击"**重启应用**"。

   ![从您的 Cloud 日志重启您的应用](/images/streamlit-community-cloud/cloud-logs-menu-reboot.png)

3. 将显示确认。单击"**重启**"。

<div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
<Image alt="确认在 Streamlit Community Cloud 中重启您的应用" src="/images/streamlit-community-cloud/workspace-app-reboot-confirm.png"/>
</div></your-custom-subdomain>

---

# 重命名或更改您的应用的 GitHub 坐标

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/rename-your-app


Streamlit Community Cloud 通过 GitHub 坐标（所有者、仓库、分支、入口点文件路径）识别应用。如果您在没有准备的情况下移动或重命名这些坐标之一，您将失去管理任何关联应用的访问权限。

## 删除、重命名、重新部署

如果您需要重命名您的仓库、移动您的入口点文件，或以其他方式更改已部署应用的 GitHub 坐标，请执行以下操作：

1. 删除您的应用。
1. 在 GitHub 中进行您想要的更改。
1. 重新部署您的应用。

## 当您已经更改了应用的 GitHub 坐标时重新获得访问权限

如果您更改了仓库，使得 Community Cloud 无法再在 GitHub 上找到您的应用，您的应用将丢失或显示为仅查看。仅查看意味着您无法编辑、重启、删除或查看应用的设置。您只能访问分析。

您可以通过以下方式重新获得控制权：

1. 恢复您对应用的更改，以便 Community Cloud 可以看到它期望的所有者、仓库、分支和入口点文件。
1. 退出 Community Cloud 和 GitHub。
1. 重新登录 Community Cloud 和 GitHub。
1. 如果您已重新获得访问权限，请删除您的应用。继续进行您的原始更改，并重新部署您的应用。

   如果这不能恢复对您的应用的访问权限，请[联系 Snowflake 支持](/knowledge-base/deploy/how-to-submit-a-support-case-for-streamlit-community-cloud)寻求帮助。他们可以删除您的断开连接的应用，以便您重新部署它们。为了获得最快的帮助，请按 URL 提供您的受影响应用的完整列表。

---

# 在 Community Cloud 上升级您的应用的 Python 版本

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/upgrade-python


Python 中的依赖项可以通过简单地更改您的环境配置文件（通常是 `requirements.txt`）来就地升级。但是，Python 本身在部署后无法更改。

当您部署应用时，您可以通过"**高级设置**"对话框选择 Python 的版本。在您部署应用后，您必须删除它并重新部署它来更改它使用的 Python 版本。

1. 记下您的应用设置：
   - 当前的自定义子域。
   - GitHub 坐标（仓库、分支和入口点文件路径）。
   - 秘密。

   当您删除应用时，其自定义子域立即可供重用。

1. [删除您的应用](/deploy/streamlit-community-cloud/manage-your-app/delete-your-app)。
1. [部署您的应用](/deploy/streamlit-community-cloud/deploy-your-app)。
   1. 在部署页面上，选择您的应用的 GitHub 坐标。
   1. 将您的自定义域设置为与您的已删除实例匹配。
   1. 单击"**高级设置**"。
   1. 选择您想要的 Python 版本。
   1. 可选：如果您的应用有秘密，请重新输入它们。
   1. 单击"**保存**"。
   1. 单击"**部署**"。

在几分钟内，Community Cloud 将重定向您到您的重新部署的应用。

---

# 在 Streamlit Community Cloud 上升级您的应用的 Streamlit 版本

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/manage-your-app/upgrade-streamlit


想要使用一个很酷的新 Streamlit 功能，但您的应用在 Streamlit Community Cloud 上运行的是旧版本的 Streamlit 库？如果是这样，别担心！以下是如何升级您的应用的 Streamlit 版本，基于您如何管理您的[应用依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies)：

## 没有依赖文件

当您的仓库中没有依赖文件时，您的应用将使用上次重启时存在的最新 Streamlit 版本。在这种情况下，只需[重启您的应用](/deploy/streamlit-community-cloud/manage-your-app/reboot-your-app)，Community Cloud 将安装最新版本。

如果您的应用依赖于特定版本的 Streamlit，您可能想要避免陷入这种情况。这就是为什么我们鼓励您使用依赖文件并固定您想要的 Streamlit 版本。

## 使用依赖文件

当您的应用包含依赖文件时，重启您的应用或按如下方式更改您的依赖文件：

- 如果 Streamlit 未包含在您的依赖文件中，如上所述重启应用。

  请注意，我们不推荐有不完整的依赖文件，因为 `pip` 在解析您的依赖项的兼容版本时无法包含 `streamlit`。

- 如果 Streamlit 包含在您的依赖文件中，但版本未固定或未限制，如上所述重启应用。

  当 Community Cloud 重启您的应用时，它将重新解析您的依赖文件。您的应用随后将拥有与您的依赖文件一致的所有依赖项的最新版本。

- 如果 Streamlit 包含在您的依赖文件中，并且版本已固定（例如，`streamlit==1.37.0`），更新您的依赖文件。

  当您在您的仓库中提交对依赖文件的更改时，Community Cloud 将检测更改并自动解析新依赖项。这就是您添加、删除或更改所有 Python 依赖项的一般方式。您不需要手动重启您的应用，但如果您想，可以这样做。

---

# 分享你的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/share-your-app


现在你的应用已经部署，你可以轻松地分享并进行协作。首先，让我们停下来庆祝一下你成功部署了应用！👩💃

你的应用现在可以在一个固定的URL上访问。根据你的需求与任何你想分享的人分享吧。你的应用将从GitHub仓库继承权限，这意味着如果你的仓库是私有的，你的应用将是私有的；如果你的仓库是公开的，你的应用将是公开的。如果你想改变这一点，你可以简单地从应用设置菜单中改变。

一次只允许一个私有应用。如果你从私有仓库部署，你将需要将该应用设为公开或删除它，才能从私有仓库部署另一个应用。只有开发者可以改变你的应用的公开和私有状态。

- [使你的应用公开或私有](#make-your-app-public-or-private)
- [分享你的公开应用](#share-your-public-app)
- [分享你的私有应用](#share-your-private-app)

## 使你的应用公开或私有

如果你从公开仓库部署你的应用，你的应用默认情况下将是公开的。如果你从私有仓库部署你的应用，你将需要将该应用设为公开，或者如果你想仅与特定人分享。

### 从应用设置中设置为公开或私有

1. 访问你的[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)并转到"分享"部分。

   ![Streamlit Community Cloud中的分享设置](/images/streamlit-community-cloud/workspace-app-settings-sharing.png)

2. 在"谁能查看此应用"下设置你的应用为公开或私有。选择"此应用是公开的且可发现的"使你的应用公开。选择"只有特定人士可以查看此应用"使你的应用私有。

## 分享你的公开应用

有很多方式可以与他人分享你的公开应用：

- **直接共享链接**——将你的应用URL复制粘贴到任何地方——电子邮件、Slack、Twitter等。
- **社交媒体**——当你在社交媒体上分享你的公开应用链接时，会自动生成一个含有你的应用标题、描述和预览图像的卡片。更多关于[共享预览](/deploy/streamlit-community-cloud/share-your-app/share-previews)的信息。
- **GitHub徽章**——将一个漂亮的Streamlit徽章添加到你的仓库README中，指向你的应用。更多关于[GitHub徽章](#add-a-github-badge)的信息。

### 添加GitHub徽章

为了让更多人能够发现你的应用，你可以在GitHub仓库的README中添加一个GitHub徽章。这是一个简单的链接，当点击时会带你到你的应用。

1. 将以下代码行复制到你的README文件中：

   ```markdown
   [![Streamlit App](https://static.streamlit.io/badges/streamlit_badge_black_white.svg)](https://YOUR-STREAMLIT-CLOUD-URL)
   ```

2. 将`YOUR-STREAMLIT-CLOUD-URL`替换为你的应用实际的URL。

   例如，如果你的应用URL是`https://share.streamlit.io/username/repo/app.py`，你的徽章代码应该看起来像这样：

   ```markdown
   [![Streamlit App](https://static.streamlit.io/badges/streamlit_badge_black_white.svg)](https://share.streamlit.io/username/repo/app.py)
   ```

有几个Streamlit徽章变体可用。你可以在以下链接找到它们：

- 黑色和白色（推荐）：`https://static.streamlit.io/badges/streamlit_badge_black_white.svg`
- 黑色背景：`https://static.streamlit.io/badges/streamlit_badge_black.svg`
- 红色背景：`https://static.streamlit.io/badges/streamlit_badge_red.svg`

## 分享你的私有应用

对于私有应用，你可以邀请特定的人查看你的应用。

### 邀请查看者

1. 访问你的[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)并转到"分享"部分。
2. 在"邀请查看者"下，输入你想邀请的人的电子邮件地址。
3. 点击"邀请"。你邀请的人将收到一封邮件邀请他们查看你的应用。

### 管理查看者访问

1. 访问你的[应用设置](/deploy/streamlit-community-cloud/manage-your-app/app-settings)并转到"分享"部分。
2. 在"查看者访问"下，你会看到所有受邀查看你应用的人员的列表。
3. 要删除某人的访问权限，请点击他们旁边的"删除"按钮。

<Note>

当你删除某人的访问权限时，他们将无法再查看你的应用。

</Note>

---

# 嵌入你的应用

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/share-your-app/embed-your-app


在网站、博客和平台中嵌入Streamlit Community Cloud应用可以通过将交互式、数据驱动的应用直接集成到页面中来丰富你的内容。无论你是在写博客文章、技术文档，还是在Medium、Notion甚至StackOverflow等平台上共享资源，嵌入Streamlit应用都会为你的内容添加动态组件。这允许你的观众与你的想法互动，而不仅仅是阅读或查看截图。

Streamlit Community Cloud支持使用[iframe](#embedding-with-iframes)和[oEmbed](#embedding-with-oembed)两种方法来嵌入**公开**应用。这种灵活性使你能够在各种平台上分享你的应用，扩大应用的可见性和影响力。在本指南中，我们将介绍如何有效地使用两种方法与世界分享Streamlit应用。

## 使用iframe嵌入

Streamlit Community Cloud支持使用子域方案嵌入**公开**应用。要嵌入公开应用，将查询参数`/?embed=true`添加到`*.streamlit.app` URL的末尾。

例如，假设你想嵌入[30DaysOfStreamlit应用](https://30days.streamlit.app/)。要在iframe中包含的URL是：`https://30days.streamlit.app/?embed=true`：

```javascript
<iframe src="https://30days.streamlit.app?embed=true" style="height: 450px; width: 100%;"/>
```

<Important>

对于嵌入私有应用，将没有正式支持。

</Important>

除了允许你通过iframe嵌入应用，`?embed=true`查询参数还执行以下操作：

- 移除带有应用菜单图标的工具栏。
- 移除应用顶部和底部的填充。
- 移除页脚。
- 移除应用顶部的彩色线。

为了对嵌入行为进行细粒度控制，Streamlit允许你指定一个或多个`?embed_options`查询参数实例（例如显示工具栏、以深色主题打开应用等）。[点击此处查看完整的嵌入选项列表。](#embed-options)

## 使用oEmbed嵌入

Streamlit的oEmbed支持提供了更简单的嵌入体验。你可以直接将Streamlit应用的URL放入Medium、Ghost或Notion页面（或任何支持oEmbed或embed.ly的700多个内容提供商）。嵌入的应用将自动出现！这有助于Streamlit Community Cloud应用无缝集成到这些平台中，提高应用的可见性和可访问性。

### 示例

在Notion页面、Medium文章或Ghost博客中创建内容时，你只需粘贴应用的URL并按"Enter"。然后应用将在内容中的该位置自动呈现。你可以使用不带`?embed=true`查询参数的应用URL。

```
https://30days.streamlit.app/
```

oEmbed应该可以在几个平台上开箱即用，包括但不限于：

- Medium
- Notion
- Looker
- Tableau
- Ghost
- Discourse
- StackOverflow
- W3
- Reddit

请查看具体平台的文档以验证对oEmbed的支持。

### iframe与oEmbed的比较

这两种方法之间唯一值得注意的区别是iframe允许你使用下一部分中描述的各种`?embed_options`来自定义应用的嵌入行为（例如显示工具栏、以深色主题打开应用等）。

## 嵌入选项

当使用iframe嵌入时，Streamlit允许你指定一个或多个`?embed_options`查询参数实例来对嵌入行为进行细粒度控制。

`?embed`和`?embed_options`对`st.query_params`及其前身`st.experimental_get_query_params`和`st.experimental_set_query_params`都是不可见的。你无法获取或设置它们的值。

`?embed_options`的支持值如下所列：

1. 显示应用右上角的工具栏，包括应用菜单、运行按钮和GitHub链接。

   ```javascript
   /?embed=true=show_toolbar
   ```

2. 显示应用顶部和底部的填充。

   ```javascript
   /?embed=true=show_padding
   ```

3. 显示读取"Made with Streamlit."的页脚。（这不适用于Streamlit 1.29.0及更高版本，因为页脚已从库中移除。）

   ```javascript
   /?embed=true=show_footer
   ```

4. 显示应用顶部的彩色线。

   ```javascript
   /?embed=true=show_colored_line
   ```

5. 隐藏应用加载时出现的"骨架"。

   ```javascript
   /?embed=true=hide_loading_screen
   ```

6. 禁用应用主体的滚动。（侧栏仍可滚动。）

   ```javascript
   /?embed=true=disable_scrolling
   ```

7. 使用浅色主题打开应用。

   ```javascript
   /?embed=true=light_theme
   ```

8. 使用深色主题打开应用。

   ```javascript
   /?embed=true=dark_theme
   ```

你也可以组合这些参数：

```javascript
/?embed=true=show_toolbar=show_padding=show_footer=show_colored_line=disable_scrolling
```

### 构建嵌入链接

你可以方便地直接从应用构建嵌入链接！

1. 从`<your-custom-subdomain>.streamlit.app`的应用，点击右上角的"共享"。
2. 点击"嵌入"以访问可选择的嵌入选项列表。
3. 选择嵌入选项并点击"获取嵌入链接"以将嵌入链接复制到剪贴板。</your-custom-subdomain>

---

# SEO和搜索可索引性

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/share-your-app/indexability


当你将公开应用部署到Streamlit Community Cloud时，它会每周自动被Google和Bing等搜索引擎索引。这意味着任何人都可以通过搜索其自定义子域（例如"traingenerator.streamlit.app"）或搜索应用标题来找到你的应用。

## 充分利用应用可索引性

这里有一些提示可以帮助你充分利用应用可索引性：

1. 确保你的应用是公开的
2. 尽早选择自定义子域
3. 选择描述性应用标题
4. 自定义应用的元描述

### 确保你的应用是公开的

Community Cloud上托管的所有公开应用都被搜索引擎索引。如果你的应用是私有的，它将不被搜索引擎索引。要使私有应用公开，请阅读"共享你的应用"。

### 尽早选择自定义子域

如果你不选择子域，Community Cloud会自动为应用生成子域。但是，你可以随时更改子域！自定义子域会修改应用URL以反映应用内容、个人品牌或任何你想要的内容。要了解如何更改应用子域，请参阅"查看或更改应用URL"。

通过选择自定义子域，你可以使用它来帮助人们找到你的应用。例如，如果你部署生成训练数据的应用，你可能会选择像`traingenerator.streamlit.app`这样的子域。这使人们可以通过搜索"training generator"或"train generator streamlit app"来轻松找到你的应用。

我们建议在部署应用时选择自定义子域。这确保应用使用自定义子域而不是自动生成的子域被搜索引擎索引。如果稍后选择自定义子域，应用可能会被索引多次——一次使用默认子域，一次使用自定义子域。在这种情况下，旧URL将导致404错误，这可能会困惑正在搜索应用的用户。

### 选择描述性应用标题

应用的元标题是显示在搜索引擎结果中的文本。它也是应用打开时显示在浏览器选项卡中的文本。默认情况下，应用的元标题与应用标题相同。但是，你可以通过将`st.set_page_config`参数`page_title`设置为自定义字符串来自定义应用的元标题。例如：

```python
st.set_page_config(page_title="Traingenerator")
```

这会将应用的元标题更改为"Traingenerator"。这使人们可以通过搜索"Traingenerator"或"train generator streamlit app"更轻松地找到你的应用。

### 自定义应用的元描述

元描述是显示在搜索引擎结果中的短描述。搜索引擎使用元描述来帮助用户理解应用的内容。

从我们的观察来看，搜索引擎似乎比`st.title`更喜欢`st.header`和`st.text`中的内容。如果你在应用顶部在`st.header`或`st.text`下放置描述，搜索引擎很可能会将其用于元描述。

## 我的索引应用看起来怎样？

如果你对应用在搜索引擎结果中的样子感到好奇，你可以在Google搜索中输入以下内容：

```
site:<your-custom-subdomain>.streamlit.app
```

示例：`site:traingenerator.streamlit.app`

## 如果我不想要索引应用怎么办？

如果你不想让应用被搜索引擎索引，你可以将其设为私有。阅读"共享你的应用"以了解更多关于使应用私有的信息。注意：每个工作空间只能有一个私有应用。如果你想使应用私有，你必须首先删除工作空间中的任何其他私有应用或使其成为公开。

也就是说，Community Cloud是一个开放且免费的平台，供社区部署、发现和彼此分享Streamlit应用和代码。因此，我们鼓励你使应用成为公开，以便可以被搜索引擎索引并被其他Streamlit用户和社区成员发现。</your-custom-subdomain>

---

# 共享预览

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/share-your-app/share-previews


当你分享链接时，社交媒体网站会生成一张带有标题、预览图像和描述的卡片。此功能称为"共享预览"。同样，当你在社交媒体上分享公开Streamlit应用的链接时，也会生成共享预览。以下是在Twitter上发布的公开Streamlit应用的共享预览示例：

<Note>

共享预览仅为部署在Streamlit Community Cloud上的公开应用生成。

</Note>

## 标题

标题是显示在共享预览顶部的文本。访问应用时，文本也出现在浏览器选项卡中。你应该将标题设置为对应用受众有意义并描述应用功能的内容。最佳做法是保持标题简洁，理想情况下少于60个字符。

有两种方法可以设置共享预览的标题：

1. 将[`st.set_page_config()`](/develop/api-reference/configuration/st.set_page_config)中的`page_title`参数设置为你想要的标题。例如：

   ```python
   import streamlit as st

   st.set_page_config(page_title="My App")

   # ... rest of your app
   ```

2. 如果不设置`page_title`参数，共享预览的标题将是应用GitHub仓库的名称。例如，对于托管在GitHub上的应用的默认标题为"traingenerator"。

## 描述

描述是显示在共享预览标题下方的文本。描述应该总结应用功能，理想情况下应少于100个字符。

Streamlit从应用的GitHub仓库的README中提取描述。如果没有README，描述将默认为：

"此应用在Streamlit中构建！查看它并访问https://streamlit.io以获取更多精彩社区应用。🎈"

如果你想让共享预览看起来很好，并希望用户分享你的应用并点击你的链接，你应该在应用的GitHub仓库的README中写一个很好的描述。

## 预览图像

Streamlit Community Cloud每天对应用进行一次屏幕截图，并将其用作预览图像，不像从应用代码或GitHub仓库直接提取的标题和描述。此屏幕截图可能需要长达24小时才能更新。

### 将应用从公开转换为私有

如果你最初将应用设为公开，后来决定将其设为私有，我们将停止为应用生成共享预览。但是，共享预览可能需要长达24小时才能停止出现。

---

# Community Cloud 的状态和限制

Source: https://docs.streamlit.io/deploy/streamlit-community-cloud/status


## Community Cloud 状态

您可以在 [streamlitstatus.com](https://www.streamlitstatus.com/) 查看 Community Cloud 的当前状态。

## GitHub OAuth 范围

要部署您的应用，Streamlit 需要访问 GitHub 中的应用源代码以及管理与存储库关联的公钥的能力。默认的 GitHub OAuth 范围足以处理公开 GitHub 存储库中的应用。但是，要访问您的专有存储库，我们创建一个只读 [GitHub 部署密钥](https://docs.github.com/en/free-pro-team@latest/developers/overview/managing-deploy-keys#deploy-keys)，然后使用 SSH 密钥访问您的存储库。当我们创建此密钥时，GitHub 会以安全措施的形式通知存储库管理员创建。

Streamlit 需要来自 GitHub 的额外 `repo` OAuth 范围才能使用您的专有存储库并管理部署密钥。我们意识到 `repo` 范围为 Streamlit 提供了我们不真正需要的额外权限，作为重视安全的人，我们宁愿根本不被授予。这是创建 Community Cloud 时 GitHub 提供的权限模型。但是，我们正在采用新的 GitHub 权限模型来减少不必要的权限。

### 开发者权限

由于上述 OAuth 限制，开发者必须具有存储库的管理权限才能从中部署应用。

## 存储库文件结构

您可以从存储库部署多个应用，您的入口文件可能在目录结构的任何位置。但是，Community Cloud 从存储库的根目录初始化所有应用，即使入口文件在子目录中也是如此。这具有以下后果：

- Community Cloud 仅在存储库的根目录（每个分支）识别一个 `.streamlit/configuration.toml` 文件。
- 您必须声明 Streamlit 命令的图像、视频和音频文件路径相对于存储库的根目录。例如，`st.image`、`st.logo` 和 `st.set_page_config` 中的 `page_icon` 参数期望文件位置相对于您的工作目录（即执行 `streamlit run` 的位置）。

## Linux 环境

Community Cloud 建立在 Debian Linux 上。

- Community Cloud 使用 Debian 11（"bullseye"）。要浏览可安装的可用包，请参阅 [包列表](https://packages.debian.org/bullseye/)。
- 所有文件路径必须使用正斜杠路径分隔符。

## Python 环境

- 您不能为单个应用混合和匹配 Python 包管理器。Community Cloud 根据它找到的第一个环境配置文件配置应用的 Python 环境。有关更多信息，请参阅 [其他 Python 包管理器](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#other-python-package-managers)。
- 我们建议您使用最新版本的 Streamlit 以确保完整的 Community Cloud 功能。规划您的环境时，请务必注意 Streamlit 对包兼容性的 [当前要求](https://github.com/streamlit/streamlit/blob/develop/lib/setup.py)，特别是 `protobuf&gt;=3.20,

---

# 部署教程

Source: https://docs.streamlit.io/deploy/tutorials


本部分包含关于如何将 Streamlit 应用部署到各种云平台和服务的逐步指南。我们有以下的部署指南：

<DataSourcesContainer>
<DataSourcesCard href="/deploy/streamlit-community-cloud/get-started">
<Image>alt="screenshot" src="/images/deploy/streamlit-cloud.png" /&gt;

<h5 align="center">Streamlit Community Cloud</h5>
</Image>
<DataSourcesCard href="/deploy/tutorials/docker">
<Image>alt="screenshot" src="/images/deploy/docker.png" /&gt;

<h5 align="center">Docker</h5>
</Image>
<DataSourcesCard href="/deploy/tutorials/kubernetes">
<Image>alt="screenshot" src="/images/deploy/kubernetes.png" /&gt;

<h5 align="center">Kubernetes</h5>
</Image>
</DataSourcesCard>

当我们为其他托管提供商编写官方 Streamlit 部署指南时，这里是用户提交的针对不同云服务的一些教程：

- [如何将 Streamlit 应用部署到 **Google App Engine**](https://dev.to/whitphx/how-to-deploy-streamlit-apps-to-google-app-engine-407o)，由 [Yuichiro Tachibana (Tsuchiya)](https://discuss.streamlit.io/u/whitphx/summary) 提供。
- [在 **Heroku** 上托管 Streamlit](https://towardsdatascience.com/quickly-build-and-deploy-an-application-with-streamlit-988ca08c7e83)，由 Maarten Grootendorst 提供。
- [在 **Ploomber Cloud** 上部署 Streamlit](https://docs.cloud.ploomber.io/en/latest/apps/streamlit.html)，由 Ido Michael 提供。
- [在 **21YunBox** 上托管 Streamlit](https://www.21yunbox.com/docs/#/deploy-streamlit)，由 Toby Lei 提供。
- [在 **Koyeb** 上部署 Streamlit 应用](https://www.koyeb.com/docs/deploy/streamlit)，由 Justin Ellingwood 提供。
- [社区支持的部署 wiki](https://discuss.streamlit.io/t/streamlit-deployment-guide-wiki/5099)。</DataSourcesCard></DataSourcesCard></DataSourcesContainer>

---

# 使用 Docker 部署 Streamlit

Source: https://docs.streamlit.io/deploy/tutorials/docker


## 介绍

你有一个了不起的应用，想开始与他人分享，你应该怎么做？你有几个选择。首先，你想在哪里运行你的 Streamlit 应用，你想如何访问它？

- **在你的公司网络上** - 大多数公司网络与外部世界隔离。你通常使用 VPN 登录到公司网络并访问那里的资源。出于安全原因，你可以在公司网络的服务器上运行 Streamlit 应用，以确保只有公司内部的人才能访问它。
- **在云上** - 如果你想从公司网络外部访问 Streamlit 应用，或与不在你的家庭网络或笔记本电脑上的人分享应用，你可能会选择此选项。在这种情况下，这取决于你的托管提供商。我们有来自 Heroku、AWS 和其他提供商的[社区提交的指南](/knowledge-base/deploy/deploy-streamlit-heroku-aws-google-cloud)。

无论你决定在哪里部署应用，你首先需要将其容器化。本指南将指导你使用 Docker 部署应用。如果你更喜欢 Kubernetes，请参阅[使用 Kubernetes 部署 Streamlit](/deploy/tutorials/kubernetes)。

## 前置条件

1. [安装 Docker Engine](#install-docker-engine)
2. [检查网络端口可访问性](#check-network-port-accessibility)

### 安装 Docker Engine

如果你还没有安装，请在服务器上安装 [Docker](https://docs.docker.com/engine/install/#server)。Docker 提供来自许多 Linux 发行版的 `.deb` 和 `.rpm` 包，包括：

- [Debian](https://docs.docker.com/engine/install/debian/)
- [Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

通过运行 `hello-world` Docker 镜像验证 Docker Engine 已正确安装：

```bash
sudo docker run hello-world
```

<Tip>

遵循 Docker 的官方[Linux 后安装步骤](https://docs.docker.com/engine/install/linux-postinstall/)，以便以非 root 用户身份运行 Docker，这样你就不必在 `docker` 命令前加上 `sudo`。

</Tip>

### 检查网络端口可访问性

当你和你的用户在公司 VPN 后面时，你需要确保你们都可以访问特定的网络端口。假设端口 `8501`，因为它是 Streamlit 使用的默认端口。联系你的 IT 团队并请求为你和你的用户开放端口 `8501` 的访问权限。

## 创建 Dockerfile

Docker 通过读取 `Dockerfile` 中的指令来构建镜像。`Dockerfile` 是一个文本文档，包含用户可在命令行上调用以组建镜像的所有命令。在 [Dockerfile 参考](https://docs.docker.com/engine/reference/builder/)中了解更多信息。[docker build](https://docs.docker.com/engine/reference/commandline/build/) 命令从 `Dockerfile` 构建镜像。[docker run](https://docs.docker.com/engine/reference/commandline/run/) 命令首先在指定的镜像上创建一个容器，然后使用指定的命令启动它。

下面是一个 `Dockerfile` 示例，你可以将其添加到目录的根目录，即 `/app/`

```docker
# app/Dockerfile

FROM python:3.9-slim

WORKDIR /app

RUN apt-get update  apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
     rm -rf /var/lib/apt/lists/*

RUN git clone https://github.com/streamlit/streamlit-example.git .

RUN pip3 install -r requirements.txt

EXPOSE 8501

HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

ENTRYPOINT ["streamlit", "run", "streamlit_app.py", "--server.port=8501", "--server.address=0.0.0.0"]
```

### Dockerfile 演练

让我们逐行演练 Dockerfile：

1. `Dockerfile` 必须以 [`FROM`](https://docs.docker.com/engine/reference/builder/#from) 指令开始。它为容器设置[基础镜像](https://docs.docker.com/glossary/#base-image)（想象成操作系统）：

   ```docker
   FROM python:3.9-slim
   ```

   Docker 有许多基于各种 Linux 发行版的官方 Docker 基础镜像。它们还有随附语言特定模块的基础镜像，例如 [Python](https://hub.docker.com/_/python)。`python` 镜像有许多变种，每一个都为特定用途而设计。在这里，我们使用 `python:3.9-slim` 镜像，这是一个轻量级镜像，附带最新版本的 Python 3.9。

   <Tip>

   你也可以使用自己的基础镜像，前提是你使用的镜像包含 [Streamlit 支持的 Python 版本](/knowledge-base/using-streamlit/sanity-checks#check-0-are-you-using-a-streamlit-supported-version-of-python)。使用任何特定基础镜像没有一刀切的方法，也没有官方的 Streamlit 特定基础镜像。

   </Tip>

2. `WORKDIR` 指令为 `Dockerfile` 中后续的任何 `RUN`、`CMD`、`ENTRYPOINT`、`COPY` 和 `ADD` 指令设置工作目录。让我们将其设置为 `app/`：

   ```docker
   WORKDIR /app
   ```

   <Important>

   如[开发流程](/get-started/fundamentals/main-concepts#development-flow)中所述，对于 Streamlit 版本 1.10.0 及更高版本，Streamlit 应用无法从 Linux 发行版的根目录运行。你的主脚本应该位于除根目录之外的目录中。如果你尝试从根目录运行 Streamlit 应用，Streamlit 将抛出 `FileNotFoundError: [Errno 2] No such file or directory` 错误。有关更多信息，请参阅 GitHub 问题 [#5239](https://github.com/streamlit/streamlit/issues/5239)。

   如果你使用的是 Streamlit 版本 1.10.0 或更高版本，你必须将 `WORKDIR` 设置为除根目录以外的目录。例如，你可以将 `WORKDIR` 设置为 `/app`，如上面的示例 `Dockerfile` 中所示。
   </Important>

3. 安装 `git` 以便我们可以从远程仓库克隆应用代码：

   ```docker
   RUN apt-get update  apt-get install -y \
       build-essential \
       curl \
       software-properties-common \
       git \
        rm -rf /var/lib/apt/lists/*
   ```

4. 将你驻留在远程仓库中的代码克隆到 `WORKDIR`：

   a. 如果你的代码在公开仓库中：

   ```docker
   RUN git clone https://github.com/streamlit/streamlit-example.git .
   ```

   克隆后，`WORKDIR` 的目录将如下所示：

   ```bash
   app/
   - requirements.txt
   - streamlit_app.py
   ```

   其中 `requirements.txt` 文件包含所有 [Python 依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)。例如

   ```
   altair
   pandas
   streamlit
   ```

   `streamlit_app.py` 是你的主脚本。例如

   ```python
   from collections import namedtuple
   import altair as alt
   import math
   import pandas as pd
   import streamlit as st

   """
   # Welcome to Streamlit!

   Edit `/streamlit_app.py` to customize this app to your heart's desire :heart:

   If you have any questions, checkout our [documentation](https://docs.streamlit.io) and [community
   forums](https://discuss.streamlit.io).

   In the meantime, below is an example of what you can do with just a few lines of code:
   """

   with st.echo(code_location='below'):
      total_points = st.slider("Number of points in spiral", 1, 5000, 2000)
      num_turns = st.slider("Number of turns in spiral", 1, 100, 9)

      Point = namedtuple('Point', 'x y')
      data = []

      points_per_turn = total_points / num_turns

      for curr_point_num in range(total_points):
         curr_turn, i = divmod(curr_point_num, points_per_turn)
         angle = (curr_turn + 1) * 2 * math.pi * i / points_per_turn
         radius = curr_point_num / total_points
         x = radius * math.cos(angle)
         y = radius * math.sin(angle)
         data.append(Point(x, y))

      st.altair_chart(alt.Chart(pd.DataFrame(data), height=500, width=500)
         .mark_circle(color='#0068c9', opacity=0.5)
         .encode(x='x:Q', y='y:Q'))
   ```

   b. 如果你的代码在私有仓库中，请阅读[在构建中使用 SSH 访问私有数据](https://docs.docker.com/develop/develop-images/build_enhancements/#using-ssh-to-access-private-data-in-builds)并相应地修改 Dockerfile - 安装 SSH 客户端，下载 [github.com](https://github.com) 的公钥，并克隆你的私有仓库。如果你使用 GitLab 或 Bitbucket 等替代 VCS，请查阅该 VCS 的文档，了解如何将你的代码复制到 Dockerfile 的 `WORKDIR`。

   c. 如果你的代码与 Dockerfile 位于同一目录中，通过用以下内容替换 `git clone` 行，将所有应用文件（包括 `streamlit_app.py`、`requirements.txt` 等）从你的服务器复制到容器中：

   ```docker
   COPY . .
   ```

   更一般地说，目的是将你的应用代码从它驻留在服务器上的任何地方复制到容器中。如果代码不在与 Dockerfile 相同的目录中，请修改上述命令以包含代码的路径。

5. 从克隆的容器中的 `requirements.txt` 安装应用的 [Python 依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)：

   ```docker
   RUN pip3 install -r requirements.txt
   ```

6. [`EXPOSE`](https://docs.docker.com/engine/reference/builder/#expose) 指令告知 Docker 容器在运行时监听指定的网络端口。你的容器需要监听 Streamlit 的（默认）端口 8501：

   ```docker
   EXPOSE 8501
   ```

7. [`HEALTHCHECK`](https://docs.docker.com/engine/reference/builder/#expose) 指令告诉 Docker 如何测试容器以检查它是否仍在工作。你的容器需要监听 Streamlit 的（默认）端口 8501：

   ```docker
   HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health
   ```

8. [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#entrypoint) 允许你配置一个作为可执行文件运行的容器。在这里，它还包含应用的整个 `streamlit run` 命令，因此你不必从命令行调用它：

   ```docker
   ENTRYPOINT ["streamlit", "run", "streamlit_app.py", "--server.port=8501", "--server.address=0.0.0.0"]
   ```

## 构建 Docker 镜像

[`docker build`](https://docs.docker.com/engine/reference/commandline/build/) 命令从 `Dockerfile` 构建镜像。从服务器上的 `app/` 目录运行以下命令来构建镜像：

```docker
docker build -t streamlit .
```

`-t` 标志用于标记镜像。在这里，我们标记了镜像 `streamlit`。如果你运行：

```docker
docker images
```

你应该在 REPOSITORY 列下看到 `streamlit` 镜像。例如：

```
REPOSITORY   TAG       IMAGE ID       CREATED              SIZE
streamlit    latest    70b0759a094d   About a minute ago   1.02GB
```

## 运行 Docker 容器

现在你已构建了镜像，你可以通过执行以下命令来运行容器：

```docker
docker run -p 8501:8501 streamlit
```

`-p` 标志将容器的端口 8501 发布到服务器的 8501 端口。

如果一切顺利，你应该看到类似于以下的输出：

```
docker run -p 8501:8501 streamlit

  You can now view your Streamlit app in your browser.

  URL: http://0.0.0.0:8501
```

要查看你的应用，用户可以浏览到 `http://0.0.0.0:8501` 或 `http://localhost:8501`

<Note>

根据你的服务器的网络配置，你可以映射到端口 80/443，以便用户可以使用服务器 IP 或主机名查看你的应用。例如：`http://your-server-ip:80` 或 `http://your-hostname:443`。

</Note>

---

# 使用 Kubernetes 部署 Streamlit

Source: https://docs.streamlit.io/deploy/tutorials/kubernetes


## 介绍

你有一个了不起的应用，想开始与他人分享，你应该怎么做？你有几个选择。首先，你想在哪里运行你的 Streamlit 应用，你想如何访问它？

- **在你的公司网络上** - 大多数公司网络与外部世界隔离。你通常使用 VPN 登录到公司网络并访问那里的资源。出于安全原因，你可以在公司网络的服务器上运行 Streamlit 应用，以确保只有公司内部的人才能访问它。
- **在云上** - 如果你想从公司网络外部访问 Streamlit 应用，或与不在你的家庭网络或笔记本电脑上的人分享应用，你可能会选择此选项。在这种情况下，这取决于你的托管提供商。我们有来自 Heroku、AWS 和其他提供商的[社区提交的指南](/knowledge-base/deploy/deploy-streamlit-heroku-aws-google-cloud)。

无论你决定在哪里部署应用，你首先需要将其容器化。本指南将指导你使用 Kubernetes 部署应用。如果你更喜欢 Docker，请参阅[使用 Docker 部署 Streamlit](/deploy/tutorials/docker)。

## 前置条件

1. [安装 Docker Engine](#install-docker-engine)
2. [安装 gcloud CLI](#install-the-gcloud-cli)

### 安装 Docker Engine

如果你还没有安装，请在服务器上安装 [Docker](https://docs.docker.com/engine/install/#server)。Docker 提供来自许多 Linux 发行版的 `.deb` 和 `.rpm` 包，包括：

- [Debian](https://docs.docker.com/engine/install/debian/)
- [Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

通过运行 `hello-world` Docker 镜像验证 Docker Engine 已正确安装：

```bash
sudo docker run hello-world
```

<Tip>

遵循 Docker 的官方[Linux 后安装步骤](https://docs.docker.com/engine/install/linux-postinstall/)，以便以非 root 用户身份运行 Docker，这样你就不必在 `docker` 命令前加上 `sudo`。

</Tip>

### 安装 gcloud CLI

在本指南中，我们将使用 Kubernetes 编排 Docker 容器，并在 Google Container Registry (GCR) 上托管 docker 镜像。由于 GCR 是 Google 支持的 Docker 注册表，我们需要将 [`gcloud`](https://cloud.google.com/sdk/gcloud/reference) 注册为 Docker 凭证帮助程序。

按照官方文档[安装 gcloud CLI](https://cloud.google.com/sdk/docs/install) 并初始化它。

## 创建 Docker 容器

我们需要创建一个包含所有依赖和应用代码的 docker 容器。下面你可以看到入口点，即容器启动时运行的命令，以及 Dockerfile 定义。

### 创建入口点脚本

创建一个包含以下内容的 `run.sh` 脚本：

```bash
#!/bin/bash

APP_PID=
stopRunningProcess() {
    # Based on https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script
    if test ! "${APP_PID}" = ''  ps -p ${APP_PID} &gt; /dev/null ; then
       &gt; /proc/1/fd/1 echo "Stopping ${COMMAND_PATH} which is running with process ID ${APP_PID}"

       kill -TERM ${APP_PID}
       &gt; /proc/1/fd/1 echo "Waiting for ${COMMAND_PATH} to process SIGTERM signal"

        wait ${APP_PID}
        &gt; /proc/1/fd/1 echo "All processes have stopped running"
    else
        &gt; /proc/1/fd/1 echo "${COMMAND_PATH} was not started when the signal was sent or it has already been stopped"
    fi
}

trap stopRunningProcess EXIT TERM

source ${VIRTUAL_ENV}/bin/activate

streamlit run ${HOME}/app/streamlit_app.py 
APP_ID=${!}

wait ${APP_ID}
```

### 创建 Dockerfile

Docker 通过读取 `Dockerfile` 中的指令来构建镜像。`Dockerfile` 是一个文本文档，包含用户可在命令行上调用以组建镜像的所有命令。在 [Dockerfile 参考](https://docs.docker.com/engine/reference/builder/)中了解更多信息。[docker build](https://docs.docker.com/engine/reference/commandline/build/) 命令从 `Dockerfile` 构建镜像。[docker run](https://docs.docker.com/engine/reference/commandline/run/) 命令首先在指定的镜像上创建一个容器，然后使用指定的命令启动它。

下面是一个可以添加到目录根目录的示例 `Dockerfile`。

```docker
FROM python:3.9-slim

RUN groupadd --gid 1000 appuser \
     useradd --uid 1000 --gid 1000 -ms /bin/bash appuser

RUN pip3 install --no-cache-dir --upgrade \
    pip \
    virtualenv

RUN apt-get update  apt-get install -y \
    build-essential \
    software-properties-common \
    git

USER appuser
WORKDIR /home/appuser

RUN git clone https://github.com/streamlit/streamlit-example.git app

ENV VIRTUAL_ENV=/home/appuser/venv
RUN virtualenv ${VIRTUAL_ENV}
RUN . ${VIRTUAL_ENV}/bin/activate  pip install -r app/requirements.txt

EXPOSE 8501

COPY run.sh /home/appuser
ENTRYPOINT ["./run.sh"]
```

<Important>

如[开发流程](/get-started/fundamentals/main-concepts#development-flow)中所述，对于 Streamlit 版本 1.10.0 及更高版本，Streamlit 应用无法从 Linux 发行版的根目录运行。你的主脚本应该位于除根目录之外的目录中。如果你尝试从根目录运行 Streamlit 应用，Streamlit 将抛出 `FileNotFoundError: [Errno 2] No such file or directory` 错误。有关更多信息，请参阅 GitHub 问题 [#5239](https://github.com/streamlit/streamlit/issues/5239)。

如果你使用的是 Streamlit 版本 1.10.0 或更高版本，你必须将 `WORKDIR` 设置为除根目录以外的目录。例如，你可以将 `WORKDIR` 设置为 `/home/appuser`，如上面的示例 `Dockerfile` 中所示。
</Important>

### 构建 Docker 镜像

将上述文件（`run.sh` 和 `Dockerfile`）放在同一文件夹中并构建 docker 镜像：

```docker
docker build --platform linux/amd64 -t gcr.io/<GCP_PROJECT_ID>/k8s-streamlit:test .
```

<Important>

将上述命令中的 `<GCP_PROJECT_ID>` 替换为你的 Google Cloud 项目的名称。

</GCP_PROJECT_ID>

### 将 Docker 镜像上传到容器注册表

下一步是将 Docker 镜像上传到容器注册表。在本示例中，我们将使用 [Google Container Registry (GCR)](https://cloud.google.com/container-registry)。首先启用 Container Registry API。登录 Google Cloud 并导航到你的项目的 **Container Registry**，然后单击 **Enable**。

我们现在可以从上一步构建 Docker 镜像并将其推送到我们的项目的 GCR。确保将 docker push 命令中的 `<GCP_PROJECT_ID>` 替换为你的项目名称：

```bash
gcloud auth configure-docker
docker push gcr.io/<GCP_PROJECT_ID>/k8s-streamlit:test
```

## 创建 Kubernetes 部署

对于此步骤，你需要：

- 正在运行的 Kubernetes 服务
- 可以为其生成 TLS 证书的自定义域
- DNS 服务，你可以在其中配置你的自定义域以指向应用程序 IP

由于镜像在上一步中已上传到容器注册表，我们可以使用以下配置在 Kubernetes 中运行它。

### 安装和运行 Kubernetes

确保你的 [Kubernetes 客户端](https://kubernetes.io/docs/tasks/tools/#kubectl) `kubectl` 已安装并在你的机器上运行。

### 配置 Google OAuth 客户端和 OAuth2-Proxy

有关配置 Google OAuth 客户端，请参阅 [Google Auth Provider](https://oauth2-proxy.github.io/oauth2-proxy/docs/configuration/oauth_provider#google-auth-provider)。将 OAuth2-Proxy 配置为使用所需的 [OAuth 提供商配置](https://oauth2-proxy.github.io/oauth2-proxy/docs/configuration/oauth_provider)，并更新配置映射中的 OAuth2-Proxy 配置。

以下配置包含一个处理 Google 认证的 OAuth2-Proxy sidecar 容器。你可以从 [`oauth2-proxy` 仓库](https://github.com/oauth2-proxy/oauth2-proxy)了解更多信息。

### 创建 Kubernetes 配置文件

创建一个名为 `k8s-streamlit.yaml` 的 [YAML](https://yaml.org/) [配置文件](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#organizing-resource-configurations)：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: streamlit-configmap
data:
  oauth2-proxy.cfg: |-
    http_address = "0.0.0.0:4180"
    upstreams = ["http://127.0.0.1:8501/"]
    email_domains = ["*"]
    client_id = "<GOOGLE_CLIENT_ID>"
    client_secret = "<GOOGLE_CLIENT_SECRET>"
    cookie_secret = "</GOOGLE_CLIENT_SECRET></GOOGLE_CLIENT_ID></GCP_PROJECT_ID></GCP_PROJECT_ID></Important></GCP_PROJECT_ID>

---

# 开发

Source: https://docs.streamlit.io/develop


获取所有信息，您需要使用 Streamlit 构建美观、高性能的网络应用！

<InlineCalloutContainer>
<InlineCallout bold="概念。" color="indigo-70" href="/develop/concepts" icon="book">通过关于我们的执行模型和功能的深入指南，了解 Streamlit 的工作原理。</InlineCallout>
<InlineCallout bold="API 参考。" color="indigo-70" href="/develop/api-reference" icon="list">通过函数定义和示例了解我们的 API。</InlineCallout>
<InlineCallout bold="教程。" color="indigo-70" href="/develop/tutorials" icon="auto_awesome">按照分步说明构建示例应用和有用的代码片段。</InlineCallout>
<InlineCallout bold="快速参考。" color="indigo-70" href="/develop/quick-reference" icon="bolt">查看我们的快速参考，以便轻松访问方便的信息，如我们的变更日志、速查表、预发布功能和路线图。</InlineCallout>
</InlineCalloutContainer>

---

# API 参考

Source: https://docs.streamlit.io/develop/api-reference


Streamlit 使您可以轻松地可视化、改变和分享数据。API 参考按活动类型进行组织，例如显示数据或优化性能。每个部分包括与活动类型关联的方法，包括示例。

浏览下面的 API 并点击以了解更多关于我们任何可用命令的信息！🎈

## 几乎显示任何内容

### 写入和魔法

<br/>
<TileContainer>
<RefCard href="/develop/api-reference/write-magic/st.write">
<h4>st.write</h4>

将参数写入应用。

```python
st.write("Hello **world**!")
st.write(my_data_frame)
st.write(my_mpl_figure)
```

</RefCard>
<RefCard href="/develop/api-reference/write-magic/st.write_stream">
<h4>st.write_stream</h4>

使用打字机效果将生成器或流写入应用。

```python
st.write_stream(my_generator)
st.write_stream(my_llm_stream)
```

</RefCard>
<RefCard href="/develop/api-reference/write-magic/magic">
<h4>魔法</h4>

每当 Streamlit 在其自己的一行上看到变量或文字值时，它会自动使用 `st.write` 将其写入您的应用

```python
"Hello **world**!"
my_data_frame
my_mpl_figure
```

</RefCard>
</TileContainer>

### 文本元素

<br/>
<TileContainer>
<RefCard href="/develop/api-reference/text/st.markdown">
<Image>alt="screenshot" src="/images/api/markdown.jpg" /&gt;

<h4>Markdown</h4>

显示格式化为 Markdown 的字符串。

```python
st.markdown("Hello **world**!")
```

</Image>
<RefCard href="/develop/api-reference/text/st.title">
<Image>alt="screenshot" src="/images/api/title.jpg" /&gt;

<h4>标题</h4>

以标题格式显示文本。

```python
st.title("The app title")
```

</Image>
<RefCard href="/develop/api-reference/text/st.header">
<Image>alt="screenshot" src="/images/api/header.jpg" /&gt;

<h4>标题</h4>

以标题格式显示文本。

```python
st.header("This is a header")
```

</Image>
<RefCard href="/develop/api-reference/text/st.subheader">
<Image>alt="screenshot" src="/images/api/subheader.jpg" /&gt;

<h4>副标题</h4>

以副标题格式显示文本。

```python
st.subheader("This is a subheader")
```

</Image>
<RefCard href="/develop/api-reference/text/st.badge">
<Image>alt="screenshot" src="/images/api/badge.jpg" /&gt;

<h4>徽章</h4>

显示一个小的着色徽章。

```python
st.badge("New")
```

</Image>
<RefCard href="/develop/api-reference/text/st.caption">
<Image>alt="screenshot" src="/images/api/caption.jpg" /&gt;

<h4>标题</h4>

用小字体显示文本。

```python
st.caption("This is written small caption text")
```

</Image>
<RefCard href="/develop/api-reference/text/st.code">
<Image>alt="screenshot" src="/images/api/code.jpg" /&gt;

<h4>代码块</h4>

显示一个代码块，可选语法高亮。

```python
st.code("a = 1234")
```

</Image>
<RefCard href="/develop/api-reference/text/st.echo">
<Image>alt="screenshot" src="/images/api/code.jpg" /&gt;

<h4>回显</h4>

在应用中显示一些代码，然后执行它。对教程很有用。

```python
with st.echo():
  st.write('This code will be printed')
```

</Image>
<RefCard href="/develop/api-reference/text/st.latex">
<Image>alt="screenshot" src="/images/api/latex.jpg" /&gt;

<h4>LaTeX</h4>

显示格式化为 LaTeX 的数学表达式。

```python
st.latex("\int a x^2 \,dx")
```

</Image>
<RefCard href="/develop/api-reference/text/st.text">
<Image>alt="screenshot" src="/images/api/text.jpg" /&gt;

<h4>预格式化文本</h4>

写入固定宽度和预格式化的文本。

```python
st.text("Hello world")
```

</Image>
<RefCard href="/develop/api-reference/text/st.divider">
<Image>alt="screenshot" src="/images/api/divider.jpg" /&gt;

<h4>分隔线</h4>

显示水平线。

```python
st.divider()
```

</Image>
<RefCard href="/develop/api-reference/text/st.help">
<h4>获得帮助</h4>

Display object’s doc string, nicely formatted.

```python
st.help(st.write)
st.help(pd.DataFrame)
```

</RefCard>
<RefCard href="/develop/api-reference/text/st.html">
<h4>渲染 HTML</h4>

将 HTML 字符串渲染到您的应用。

```python
st.html("<p>Foo bar.</p>")
```

</RefCard>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/tvst/st-annotated-text">
<Image>alt="screenshot" src="/images/api/components/annotated-text.jpg" /&gt;

<h4>注释文本</h4>

在 Streamlit 应用中显示注释文本。由 [@tvst](https://github.com/tvst) 创建。

```python
annotated_text("This ", ("is", "verb"), " some ", ("annotated", "adj"), ("text", "noun"), " for those of ", ("you", "pronoun"), " who ", ("like", "verb"), " this sort of ", ("thing", "noun"), ".")
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-drawable-canvas">
<Image>alt="screenshot" src="/images/api/components/drawable-canvas.jpg" /&gt;

<h4>可绘制画布</h4>

使用 [Fabric.js](http://fabricjs.com/) 提供绘图画布。由 [@andfanilo](https://github.com/andfanilo) 创建。

```python
st_canvas(fill_color="rgba(255, 165, 0, 0.3)", stroke_width=stroke_width, stroke_color=stroke_color, background_color=bg_color, background_image=Image.open(bg_image) if bg_image else None, update_streamlit=realtime_update, height=150, drawing_mode=drawing_mode, point_display_radius=point_display_radius if drawing_mode == 'point' else 0, key="canvas",)
```

</Image>
<ComponentCard href="https://github.com/gagan3012/streamlit-tags">
<Image>alt="screenshot" src="/images/api/components/tags.jpg" /&gt;

<h4>标签</h4>

向您的 Streamlit 应用添加标签。由 [@gagan3012](https://github.com/gagan3012) 创建。

```python
st_tags(label='# Enter Keywords:', text='Press enter to add more', value=['Zero', 'One', 'Two'], suggestions=['five', 'six', 'seven', 'eight', 'nine', 'three', 'eleven', 'ten', 'four'], maxtags = 4, key='1')
```

</Image>
<ComponentCard href="https://github.com/JohnSnowLabs/nlu">
<Image>alt="screenshot" src="/images/api/components/nlu.jpg" /&gt;

<h4>NLU</h4>

对数据框应用文本挖掘。由 [@JohnSnowLabs](https://github.com/JohnSnowLabs/) 创建。

```python
nlu.load("sentiment").predict("I love NLU! </Image></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

# App testing

Source: https://docs.streamlit.io/develop/api-reference/app-testing


Streamlit app testing framework enables developers to build and run headless tests that execute their app code directly, simulate user input, and inspect rendered outputs for correctness.

The provided class, AppTest, simulates a running app and provides methods to set up, manipulate, and inspect the app contents via API instead of a browser UI. It can be used to write automated tests of an app in various scenarios. These can then be run using a tool like pytest. A typical pattern is to build a suite of tests for an app that ensure consistent functionality as the app evolves, and run the tests locally and/or in a CI environment like Github Actions.

## The AppTest class

<TileContainer>
<RefCard href="/develop/api-reference/app-testing/st.testing.v1.apptest" size="full">
<h3>st.testing.v1.AppTest</h3>

`st.testing.v1.AppTest` simulates a running Streamlit app for testing.

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("streamlit_app.py")
at.secrets["WORD"] = "Foobar"
at.run()
assert not at.exception

at.text_input("word").input("Bazbat").run()
assert at.warning[0].value == "Try again."
```

</RefCard>
<RefCard href="">

{/** TODO: Bug fix. The second RefCard does not render. Empty card is a workaround. **/}

</RefCard>
<RefCard href="/develop/api-reference/app-testing/st.testing.v1.apptest#apptestfrom_file" size="full">
<h3>AppTest.from_file</h3>

`st.testing.v1.AppTest.from_file` initializes a simulated app from a file.

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("streamlit_app.py")
at.secrets["WORD"] = "Foobar"
at.run()
assert not at.exception
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/st.testing.v1.apptest#apptestfrom_string" size="full">
<h3>AppTest.from_string</h3>

`st.testing.v1.AppTest.from_string` initializes a simulated app from a string.

```python
from streamlit.testing.v1 import AppTest

app_script = """
import streamlit as st

word_of_the_day = st.text_input("What's the word of the day?", key="word")
if word_of_the_day == st.secrets["WORD"]:
    st.success("That's right!")
elif word_of_the_day and word_of_the_day != st.secrets["WORD"]:
    st.warn("Try again.")
"""

at = AppTest.from_string(app_script)
at.secrets["WORD"] = "Foobar"
at.run()
assert not at.exception
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/st.testing.v1.apptest#apptestfrom_function" size="full">
<h3>AppTest.from_function</h3>

`st.testing.v1.AppTest.from_function` initializes a simulated app from a function.

```python
from streamlit.testing.v1 import AppTest

def app_script ():
    import streamlit as st

    word_of_the_day = st.text_input("What's the word of the day?", key="word")
    if word_of_the_day == st.secrets["WORD"]:
        st.success("That's right!")
    elif word_of_the_day and word_of_the_day != st.secrets["WORD"]:
        st.warn("Try again.")

at = AppTest.from_function(app_script)
at.secrets["WORD"] = "Foobar"
at.run()
assert not at.exception
```

</RefCard>
</TileContainer>

## Testing-element classes

<TileContainer>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeblock" size="half">
<h4>Block</h4>

A representation of container elements, including:

- `st.chat_message`
- `st.columns`
- `st.sidebar`
- `st.tabs`
- The main body of the app.

```python
# at.sidebar returns a Block
at.sidebar.button[0].click().run()
assert not at.exception
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeelement" size="half">
<h4>Element</h4>

The base class for representation of all elements, including:

- `st.title`
- `st.header`
- `st.markdown`
- `st.dataframe`

```python
# at.title returns a sequence of Title
# Title inherits from Element
assert at.title[0].value == "My awesome app"
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treebutton" size="third">
<h4>Button</h4>

A representation of `st.button` and `st.form_submit_button`.

```python
at.button[0].click().run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treechatinput" size="third">
<h4>ChatInput</h4>

A representation of `st.chat_input`.

```python
at.chat_input[0].set_value("What is Streamlit?").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treecheckbox" size="third">
<h4>Checkbox</h4>

A representation of `st.checkbox`.

```python
at.checkbox[0].check().run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treecolorpicker" size="third">
<h4>ColorPicker</h4>

A representation of `st.color_picker`.

```python
at.color_picker[0].pick("#FF4B4B").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treedateinput" size="third">
<h4>DateInput</h4>

A representation of `st.date_input`.

```python
release_date = datetime.date(2023, 10, 26)
at.date_input[0].set_value(release_date).run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treemultiselect" size="third">
<h4>Multiselect</h4>

A representation of `st.multiselect`.

```python
at.multiselect[0].select("New York").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treenumberinput" size="third">
<h4>NumberInput</h4>

A representation of `st.number_input`.

```python
at.number_input[0].increment().run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeradio" size="third">
<h4>Radio</h4>

A representation of `st.radio`.

```python
at.radio[0].set_value("New York").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeselectslider" size="third">
<h4>SelectSlider</h4>

A representation of `st.select_slider`.

```python
at.select_slider[0].set_range("A","C").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeselectbox" size="third">
<h4>Selectbox</h4>

A representation of `st.selectbox`.

```python
at.selectbox[0].select("New York").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treeslider" size="third">
<h4>Slider</h4>

A representation of `st.slider`.

```python
at.slider[0].set_range(2,5).run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treetextarea" size="third">
<h4>TextArea</h4>

A representation of `st.text_area`.

```python
at.text_area[0].input("Streamlit is awesome!").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treetextinput" size="third">
<h4>TextInput</h4>

A representation of `st.text_input`.

```python
at.text_input[0].input("Streamlit").run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treetimeinput" size="third">
<h4>TimeInput</h4>

A representation of `st.time_input`.

```python
at.time_input[0].increment().run()
```

</RefCard>
<RefCard href="/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treetoggle" size="third">
<h4>Toggle</h4>

A representation of `st.toggle`.

```python
at.toggle[0].set_value("True").run()
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/app-testing/st.testing.v1.apptest

<h1>{{display: "none"}}&gt;</h1>

# The AppTest class


* Function signature:

   st.testing.v1.AppTest(script_path, *, default_timeout, args=None, kwargs=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | secrets | dict[str, Any] |  | Dictionary of secrets to be used the simulated app. Use dict-like syntax to set secret values for the simulated app. |
   | session_state | SafeSessionState |  | Session State for the simulated app. SafeSessionState object supports read and write operations as usual for Streamlit apps. |
   | query_params | dict[str, Any] |  | Dictionary of query parameters to be used by the simluated app. Use dict-like syntax to set query_params values for the simulated app. |



# Initialize a simulated app using AppTest


* Function signature:

   AppTest.from_file(cls, script_path, *, default_timeout=3)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | script_path | str | Path |  | Path to a script file. The path should be absolute or relative to the file calling .from_file. |
   | default_timeout | float | time | Default time in seconds before a script run is timed out. Can be overridden for individual .run() calls. |

* Returns: AppTest

    A simulated Streamlit app for testing. The simulated app can be
executed via .run().



* Function signature:

   AppTest.from_string(cls, script, *, default_timeout=3)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | script | str |  | The string contents of the script to be run. |
   | default_timeout | float | time | Default time in seconds before a script run is timed out. Can be overridden for individual .run() calls. |

* Returns: AppTest

    A simulated Streamlit app for testing. The simulated app can be
executed via .run().



* Function signature:

   AppTest.from_function(cls, script, *, default_timeout=3, args=None, kwargs=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | script | Callable |  | A function whose body will be used as a script. Must be runnable in isolation, so it must include any necessary imports. |
   | default_timeout | float | time | Default time in seconds before a script run is timed out. Can be overridden for individual .run() calls. |
   | args | tuple |  | An optional tuple of args to pass to the script function. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the script function. |

* Returns: AppTest

    A simulated Streamlit app for testing. The simulated app can be
executed via .run().



# Run an AppTest script


* Function signature:

   AppTest.run(*, timeout=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | timeout | float or None | timeout | The maximum number of seconds to run the script. If timeout is None (default), Streamlit uses the default timeout set for the instance of AppTest. |

* Returns: AppTest

    self



* Function signature:

   AppTest.switch_page(page_path)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | page_path | str |  | Path of the page to switch to. The path must be relative to the main script's location (e.g. "pages/my_page.py"). |

* Returns: AppTest

    self



# Get AppTest script elements

The main value of `AppTest` is providing an API to programmatically inspect and interact with the elements and widgets produced by a running Streamlit app. Using the `AppTest.<element>` properties or `AppTest.get()` method returns a collection of all the elements or widgets of the specified type that would have been displayed by running the app.

Note that you can also retrieve elements within a specific container in the same way - first retrieve the container, then retrieve the elements just in that container.


* Function signature:

   AppTest.get(element_type)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | element_type | str |  | An element attribute of AppTest. For example, "button", "caption", or "chat_input". |

* Returns: Sequence of Elements

    Sequence of elements of the given type. Individual elements can
be accessed from a Sequence by index (order on the page). When
getting and element_type that is a widget, individual widgets
can be accessed by key. For example, at.get("text")[0] for the
first st.text element or at.get("slider")(key="my_key") for
the st.slider widget with a given key.



* Function signature:

   AppTest.button

* Returns: WidgetList of Button

    Sequence of all st.button and st.form_submit_button
widgets. Individual widgets can be accessed from a WidgetList by
index (order on the page) or key. For example, at.button[0] for
the first widget or at.button(key="my_key") for a widget with a
given key.



* Function signature:

   AppTest.caption

* Returns: ElementList of Caption

    Sequence of all st.caption elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.caption[0] for the first element. Caption is an
extension of the Element class.



* Function signature:

   AppTest.chat_input

* Returns: WidgetList of ChatInput

    Sequence of all st.chat_input widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.chat_input[0] for the first widget or
at.chat_input(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.chat_message

* Returns: Sequence of ChatMessage

    Sequence of all st.chat_message elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.chat_message[0] for the first element.  ChatMessage
is an extension of the Block class.



* Function signature:

   AppTest.checkbox

* Returns: WidgetList of Checkbox

    Sequence of all st.checkbox widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.checkbox[0] for the first widget or
at.checkbox(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.code

* Returns: ElementList of Code

    Sequence of all st.code elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.code[0] for the first element. Code is an
extension of the Element class.



* Function signature:

   AppTest.color_picker

* Returns: WidgetList of ColorPicker

    Sequence of all st.color_picker widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.color_picker[0] for the first widget or
at.color_picker(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.columns

* Returns: Sequence of Column

    Sequence of all columns within st.columns elements. Individual
columns can be accessed from an ElementList by index (order on the
page). For example, at.columns[0] for the first column. Column
is an extension of the Block class.



* Function signature:

   AppTest.dataframe

* Returns: ElementList of Dataframe

    Sequence of all st.dataframe elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.dataframe[0] for the first element. Dataframe is an
extension of the Element class.



* Function signature:

   AppTest.date_input

* Returns: WidgetList of DateInput

    Sequence of all st.date_input widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.date_input[0] for the first widget or
at.date_input(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.divider

* Returns: ElementList of Divider

    Sequence of all st.divider elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.divider[0] for the first element. Divider is an
extension of the Element class.



* Function signature:

   AppTest.error

* Returns: ElementList of Error

    Sequence of all st.error elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.error[0] for the first element. Error is an
extension of the Element class.



* Function signature:

   AppTest.exception

* Returns: ElementList of Exception

    Sequence of all st.exception elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.exception[0] for the first element. Exception is an
extension of the Element class.



* Function signature:

   AppTest.expander

* Returns: Sequence of Expandable

    Sequence of all st.expander elements. Individual elements can be
accessed from a Sequence by index (order on the page). For
example, at.expander[0] for the first element. Expandable is an
extension of the Block class.



* Function signature:

   AppTest.header

* Returns: ElementList of Header

    Sequence of all st.header elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.header[0] for the first element. Header is an
extension of the Element class.



* Function signature:

   AppTest.info

* Returns: ElementList of Info

    Sequence of all st.info elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.info[0] for the first element. Info is an
extension of the Element class.



* Function signature:

   AppTest.json

* Returns: ElementList of Json

    Sequence of all st.json elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.json[0] for the first element. Json is an
extension of the Element class.



* Function signature:

   AppTest.latex

* Returns: ElementList of Latex

    Sequence of all st.latex elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.latex[0] for the first element. Latex is an
extension of the Element class.



* Function signature:

   AppTest.main

* Returns: Block

    A container of elements. Block can be queried for elements in the
same manner as AppTest. For example, Block.checkbox will
return all st.checkbox within the associated container.



* Function signature:

   AppTest.markdown

* Returns: ElementList of Markdown

    Sequence of all st.markdown elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.markdown[0] for the first element. Markdown is an
extension of the Element class.



* Function signature:

   AppTest.metric

* Returns: ElementList of Metric

    Sequence of all st.metric elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.metric[0] for the first element. Metric is an
extension of the Element class.



* Function signature:

   AppTest.multiselect

* Returns: WidgetList of Multiselect

    Sequence of all st.multiselect widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.multiselect[0] for the first widget or
at.multiselect(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.number_input

* Returns: WidgetList of NumberInput

    Sequence of all st.number_input widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.number_input[0] for the first widget or
at.number_input(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.radio

* Returns: WidgetList of Radio

    Sequence of all st.radio widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.radio[0] for the first widget or
at.radio(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.select_slider

* Returns: WidgetList of SelectSlider

    Sequence of all st.select_slider widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.select_slider[0] for the first widget or
at.select_slider(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.selectbox

* Returns: WidgetList of Selectbox

    Sequence of all st.selectbox widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.selectbox[0] for the first widget or
at.selectbox(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.sidebar

* Returns: Block

    A container of elements. Block can be queried for elements in the
same manner as AppTest. For example, Block.checkbox will
return all st.checkbox within the associated container.



* Function signature:

   AppTest.slider

* Returns: WidgetList of Slider

    Sequence of all st.slider widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.slider[0] for the first widget or
at.slider(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.subheader

* Returns: ElementList of Subheader

    Sequence of all st.subheader elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.subheader[0] for the first element. Subheader is an
extension of the Element class.



* Function signature:

   AppTest.success

* Returns: ElementList of Success

    Sequence of all st.success elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.success[0] for the first element. Success is an
extension of the Element class.



* Function signature:

   AppTest.status

* Returns: Sequence of Status

    Sequence of all st.status elements. Individual elements can be
accessed from a Sequence by index (order on the page). For
example, at.status[0] for the first element. Status is an
extension of the Block class.



* Function signature:

   AppTest.table

* Returns: ElementList of Table

    Sequence of all st.table elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.table[0] for the first element. Table is an
extension of the Element class.



* Function signature:

   AppTest.tabs

* Returns: Sequence of Tab

    Sequence of all tabs within st.tabs elements. Individual
tabs can be accessed from an ElementList by index (order on the
page). For example, at.tabs[0] for the first tab. Tab is an
extension of the Block class.



* Function signature:

   AppTest.text

* Returns: ElementList of Text

    Sequence of all st.text elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.text[0] for the first element. Text is an
extension of the Element class.



* Function signature:

   AppTest.text_area

* Returns: WidgetList of TextArea

    Sequence of all st.text_area widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.text_area[0] for the first widget or
at.text_area(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.text_input

* Returns: WidgetList of TextInput

    Sequence of all st.text_input widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.text_input[0] for the first widget or
at.text_input(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.time_input

* Returns: WidgetList of TimeInput

    Sequence of all st.time_input widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.time_input[0] for the first widget or
at.time_input(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.title

* Returns: ElementList of Title

    Sequence of all st.title elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.title[0] for the first element. Title is an
extension of the Element class.



* Function signature:

   AppTest.toast

* Returns: ElementList of Toast

    Sequence of all st.toast elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.toast[0] for the first element. Toast is an
extension of the Element class.



* Function signature:

   AppTest.toggle

* Returns: WidgetList of Toggle

    Sequence of all st.toggle widgets. Individual widgets can
be accessed from a WidgetList by index (order on the page) or key.
For example, at.toggle[0] for the first widget or
at.toggle(key="my_key") for a widget with a given key.



* Function signature:

   AppTest.warning

* Returns: ElementList of Warning

    Sequence of all st.warning elements. Individual elements can be
accessed from an ElementList by index (order on the page). For
example, at.warning[0] for the first element. Warning is an
extension of the Element class.

</element>

---

# Testing element classes

Source: https://docs.streamlit.io/develop/api-reference/app-testing/testing-element-classes


## st.testing.v1.element_tree.Block

The `Block` class has the same methods and attributes as `AppTest`. A `Block` instance represents a container of elements just as `AppTest` represents the entire app. For example, `Block.button` will produce a `WidgetList` of `Button` in the same manner as [`AppTest.button`](/develop/api-reference/testing/st.testing.v1.apptest#apptestbutton).

`ChatMessage`, `Column`, and `Tab` all inherit from `Block`. For all container classes, parameters of the original element can be obtained as properties. For example, `ChatMessage.avatar` and `Tab.label`.


* Function signature:

   st.testing.v1.element_tree.Element(proto, root)



* Function signature:

   st.testing.v1.element_tree.Button(proto, root)



* Function signature:

   st.testing.v1.element_tree.ChatInput(proto, root)



* Function signature:

   st.testing.v1.element_tree.Checkbox(proto, root)



* Function signature:

   st.testing.v1.element_tree.ColorPicker(proto, root)



* Function signature:

   st.testing.v1.element_tree.DateInput(proto, root)



* Function signature:

   st.testing.v1.element_tree.Multiselect(proto, root)



* Function signature:

   st.testing.v1.element_tree.NumberInput(proto, root)



* Function signature:

   st.testing.v1.element_tree.Radio(proto, root)



* Function signature:

   st.testing.v1.element_tree.SelectSlider(proto, root)



* Function signature:

   st.testing.v1.element_tree.Selectbox(proto, root)



* Function signature:

   st.testing.v1.element_tree.Slider(proto, root)



* Function signature:

   st.testing.v1.element_tree.TextArea(proto, root)



* Function signature:

   st.testing.v1.element_tree.TextInput(proto, root)



* Function signature:

   st.testing.v1.element_tree.TimeInput(proto, root)



* Function signature:

   st.testing.v1.element_tree.Toggle(proto, root)



---

# 缓存和状态

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state


优化性能并为您的应用添加状态性！

## 缓存

Streamlit 为数据和全局资源提供强大的[缓存原语](/develop/concepts/architecture/caching)。它们允许您的应用即使在从网络加载数据、操作大型数据集或执行昂贵计算时也能保持性能。

<TileContainer>
<RefCard href="/develop/api-reference/caching-and-state/st.cache_data" size="half">
<h4>缓存数据</h4>

函数装饰器，用于缓存返回数据（例如数据框转换、数据库查询、ML 推理）的函数。

```python
@st.cache_data
def long_function(param1, param2):
  # 在这里执行昂贵计算或
  # 从网络获取数据
  return data
```

</RefCard>
<RefCard href="/develop/api-reference/caching-and-state/st.cache_resource" size="half">
<h4>缓存资源</h4>

函数装饰器，用于缓存返回全局资源（例如数据库连接、ML 模型）的函数。

```python
@st.cache_resource
def init_model():
  # 在这里返回全局资源
  return pipeline(
    "sentiment-analysis",
    model="distilbert-base-uncased-finetuned-sst-2-english"
  )
```

</RefCard>
</TileContainer>

## 浏览器和服务器状态

Streamlit 在每次用户交互时重新执行您的脚本。窗口小部件在重运行之间具有内置的状态性，但会话状态让您可以做更多！

<TileContainer>
<RefCard href="/develop/api-reference/caching-and-state/st.context">
<h4>上下文</h4>

`st.context` 提供只读接口来访问 cookies、headers、locale 和其他浏览器会话信息。

```python
st.context.cookies
st.context.headers
```

</RefCard>
<RefCard href="/develop/api-reference/caching-and-state/st.session_state">
<h4>会话状态</h4>

在重运行和页面之间保存数据。

```python
st.session_state["foo"] = "bar"
```

</RefCard>
<RefCard href="/develop/api-reference/caching-and-state/st.query_params">
<h4>查询参数</h4>

获取、设置或清除显示在浏览器 URL 栏中的查询参数。

```python
st.query_params[key] = value
st.query_params.clear()
```

</RefCard>
</TileContainer>

## 已弃用的命令

<TileContainer>
<RefCard href="/develop/api-reference/caching-and-state/st.experimental_get_query_params" size="half">{true}&gt;

<h4>获取查询参数</h4>

获取显示在浏览器 URL 栏中的查询参数。

```python
param_dict = st.experimental_get_query_params()
```

</RefCard>
<RefCard href="/develop/api-reference/caching-and-state/st.experimental_set_query_params" size="half">{true}&gt;

<h4>设置查询参数</h4>

设置显示在浏览器 URL 栏中的查询参数。

```python
st.experimental_set_query_params(
  {"show_all"=True, "selected"=["asia", "america"]}
)
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.cache_data

<Tip>

此页面仅包含有关 `st.cache_data` API 的信息。有关缓存的深入探讨以及如何使用它，请查看[缓存](/develop/concepts/architecture/caching)。

</Tip>

* Function signature:

   st.cache_data(func=None, *, ttl, max_entries, show_spinner, show_time=False, persist, hash_funcs=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | func | callable |  | The function to cache. Streamlit hashes the function's source code. |
   | ttl | float, timedelta, str, or None |  | The maximum time to keep an entry in the cache. Can be one of:  None if cache entries should never expire (default). A number specifying the time in seconds. A string specifying the time in a format supported by Pandas's Timedelta constructor, e.g. "1d", "1.5 days", or "1h23s". A timedelta object from Python's built-in datetime library, e.g. timedelta(days=1).  Note that ttl will be ignored if persist="disk" or persist=True. |
   | max_entries | int or None | None | The maximum number of entries to keep in the cache, or None for an unbounded cache. When a new entry is added to a full cache, the oldest cached entry will be removed. Defaults to None. |
   | show_spinner | bool or str | True | Enable the spinner. Default is True to show a spinner when there is a "cache miss" and the cached data is being created. If string, value of show_spinner param will be used for spinner text. |
   | show_time | bool |  | Whether to show the elapsed time next to the spinner text. If this is False (default), no time is displayed. If this is True, elapsed time is displayed with a precision of 0.1 seconds. The time format is not configurable. |
   | persist | "disk", bool, or None | None | Optional location to persist cached data to. Passing "disk" (or True) will persist the cached data to the local disk. None (or False) will disable persistence. The default is None. |
   | hash_funcs | dict or None |  | Mapping of types or fully qualified names to hash functions. This is used to override the behavior of the hasher inside Streamlit's caching mechanism: when the hasher encounters an object, it will first check to see if its type matches a key in this dict and, if so, will use the provided function to generate a hash for it. See below for an example of how this can be used. |


<Warning>

`st.cache_data` 隐式使用 `pickle` 模块，这已知是不安全的。您的缓存函数返回的任何内容都会被 pickle 并存储，然后在检索时 unpickle。确保您的缓存函数返回可信值，因为可以构造恶意 pickle 数据，在 unpickling 期间执行任意代码。永远不要以不安全模式加载可能来自不可信来源的数据或可能已被篡改的数据。**仅加载您信任的数据**。

</Warning>

* Function signature:

   st.cache_data.clear()



#### 示例

在下面的示例中，按下"Clear All"按钮将清除所有用 `@st.cache_data` 装饰的函数的记忆值。

```python
import streamlit as st

@st.cache_data
def square(x):
    return x**2

@st.cache_data
def cube(x):
    return x**3

if st.button("Clear All"):
    # 清除 *所有* 内存中和磁盘上的数据缓存的值：
    # 即清除 square 和 cube 的值
    st.cache_data.clear()
```


* Function signature:

   CachedFunc.clear(*args, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | *args | Any |  | Arguments of the cached functions. |
   | **kwargs | Any |  | Keyword arguments of the cached function. |



## 在缓存函数中使用 Streamlit 命令

### 静态元素

从版本 1.16.0 开始，缓存函数可以包含 Streamlit 命令！例如，您可以这样做：

```python
@st.cache_data
def get_api_data():
    data = api.get(...)
    st.success("Fetched data from API!")  # 👈 显示成功消息
    return data
```

我们知道，Streamlit 仅在之前未缓存时运行此函数。在第一次运行时，`st.success` 消息将出现在应用中。但在后续运行中会发生什么？它仍然会出现！Streamlit 意识到缓存函数内部有 `st.` 命令，在第一次运行期间保存它，并在后续运行中重放它。重放静态元素适用于两个缓存装饰器。

您还可以使用此功能来缓存您的 UI 的整个部分：

```python
@st.cache_data
def show_data():
    st.header("Data analysis")
    data = api.get(...)
    st.success("Fetched data from API!")
    st.write("Here is a plot of the data:")
    st.line_chart(data)
    st.write("And here is the raw data:")
    st.dataframe(data)
```

### 输入窗口小部件

您还可以在缓存函数中使用[交互式输入窗口小部件](/develop/api-reference/widgets)，如 `st.slider` 或 `st.text_input`。窗口小部件重放目前是一个实验性功能。要启用它，您需要设置 `experimental_allow_widgets` 参数：

```python
@st.cache_data(experimental_allow_widgets=True)  # 👈 设置参数
def get_data():
    num_rows = st.slider("Number of rows to get")  # 👈 添加滑块
    data = api.get(..., num_rows)
    return data
```

Streamlit 将滑块视为缓存函数的附加输入参数。如果您更改滑块位置，Streamlit 将查看是否已经为此滑块值缓存了函数。如果是，它将返回缓存值。如果不是，它将使用新的滑块值重新运行函数。

在缓存函数中使用窗口小部件非常强大，因为它让您可以缓存应用的整个部分。但它可能很危险！由于 Streamlit 将窗口小部件值视为附加输入参数，它很容易导致过多的内存使用。想象您的缓存函数有五个滑块并返回一个 100 MB 的 DataFrame。然后我们将为这些五个滑块值的 _每个排列_ 添加 100 MB 到缓存中 - 即使滑块不影响返回的数据！这些添加可以使您的缓存非常快速地爆炸。如果您在缓存函数中使用窗口小部件，请注意此限制。我们建议仅在 UI 的隔离部分使用此功能，其中窗口小部件直接影响缓存的返回值。

<Warning>

对缓存函数中窗口小部件的支持目前是实验性的。我们可能随时更改或删除它而不会发出警告。请谨慎使用！
</Warning>
<Note>

两个窗口小部件目前在缓存函数中不受支持：`st.file_uploader` 和 `st.camera_input`。我们将来可能会支持它们。如果您需要它们，请随时[打开 GitHub 问题](https://github.com/streamlit/streamlit/issues)！
</Note>

---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.cache_resource

<Tip>

此页面仅包含有关 `st.cache_resource` API 的信息。有关缓存的深入探讨以及如何使用它，请查看[缓存](/develop/concepts/architecture/caching)。

</Tip>

* Function signature:

   st.cache_resource(func, *, ttl, max_entries, show_spinner, show_time=False, validate, hash_funcs=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | func | callable |  | The function that creates the cached resource. Streamlit hashes the function's source code. |
   | ttl | float, timedelta, str, or None |  | The maximum time to keep an entry in the cache. Can be one of:  None if cache entries should never expire (default). A number specifying the time in seconds. A string specifying the time in a format supported by Pandas's Timedelta constructor, e.g. "1d", "1.5 days", or "1h23s". A timedelta object from Python's built-in datetime library, e.g. timedelta(days=1). |
   | max_entries | int or None | None | The maximum number of entries to keep in the cache, or None for an unbounded cache. When a new entry is added to a full cache, the oldest cached entry will be removed. Defaults to None. |
   | show_spinner | bool or str | True | Enable the spinner. Default is True to show a spinner when there is a "cache miss" and the cached resource is being created. If string, value of show_spinner param will be used for spinner text. |
   | show_time | bool |  | Whether to show the elapsed time next to the spinner text. If this is False (default), no time is displayed. If this is True, elapsed time is displayed with a precision of 0.1 seconds. The time format is not configurable. |
   | validate | callable or None |  | An optional validation function for cached data. validate is called each time the cached value is accessed. It receives the cached value as its only parameter and it must return a boolean. If validate returns False, the current cached value is discarded, and the decorated function is called to compute a new value. This is useful e.g. to check the health of database connections. |
   | hash_funcs | dict or None |  | Mapping of types or fully qualified names to hash functions. This is used to override the behavior of the hasher inside Streamlit's caching mechanism: when the hasher encounters an object, it will first check to see if its type matches a key in this dict and, if so, will use the provided function to generate a hash for it. See below for an example of how this can be used. |



* Function signature:

   st.cache_resource.clear()



#### 示例

在下面的示例中，按下"Clear All"按钮将清除 _所有_ cache_resource 缓存。即清除所有用 `@st.cache_resource` 装饰的函数的缓存全局资源。

```python
import streamlit as st
from transformers import BertModel

@st.cache_resource
 def get_database_session(url):
     # 创建指向 URL 的数据库会话对象。
     return session

@st.cache_resource
def get_model(model_type):
    # 创建指定类型的模型。
    return BertModel.from_pretrained(model_type)

if st.button("Clear All"):
    # 清除所有 st.cache_resource 缓存：
    st.cache_resource.clear()
```


* Function signature:

   CachedFunc.clear(*args, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | *args | Any |  | Arguments of the cached functions. |
   | **kwargs | Any |  | Keyword arguments of the cached function. |



## 在缓存函数中使用 Streamlit 命令

### 静态元素

从版本 1.16.0 开始，缓存函数可以包含 Streamlit 命令！例如，您可以这样做：

```python
from transformers import pipeline

@st.cache_resource
def load_model():
    model = pipeline("sentiment-analysis")
    st.success("Loaded NLP model from Hugging Face!")  # 👈 显示成功消息
    return model
```

我们知道，Streamlit 仅在之前未缓存时运行此函数。在第一次运行时，`st.success` 消息将出现在应用中。但在后续运行中会发生什么？它仍然会出现！Streamlit 意识到缓存函数内部有 `st.` 命令，在第一次运行期间保存它，并在后续运行中重放它。重放静态元素适用于两个缓存装饰器。

您还可以使用此功能来缓存您的 UI 的整个部分：

```python
@st.cache_resource
def load_model():
    st.header("Data analysis")
    model = torchvision.models.resnet50(weights=ResNet50_Weights.DEFAULT)
    st.success("Loaded model!")
    st.write("Turning on evaluation mode...")
    model.eval()
    st.write("Here's the model:")
    return model
```

### 输入窗口小部件

您还可以在缓存函数中使用[交互式输入窗口小部件](/develop/api-reference/widgets)，如 `st.slider` 或 `st.text_input`。窗口小部件重放目前是一个实验性功能。要启用它，您需要设置 `experimental_allow_widgets` 参数：

```python
@st.cache_resource(experimental_allow_widgets=True)  # 👈 设置参数
def load_model():
    pretrained = st.checkbox("Use pre-trained model:")  # 👈 添加复选框
    model = torchvision.models.resnet50(weights=ResNet50_Weights.DEFAULT, pretrained=pretrained)
    return model
```

Streamlit 将复选框视为缓存函数的附加输入参数。如果您取消选中它，Streamlit 将查看是否已经为此复选框状态缓存了函数。如果是，它将返回缓存值。如果不是，它将使用新的滑块值重新运行函数。

在缓存函数中使用窗口小部件非常强大，因为它让您可以缓存应用的整个部分。但它可能很危险！由于 Streamlit 将窗口小部件值视为附加输入参数，它很容易导致过多的内存使用。想象您的缓存函数有五个滑块并返回一个 100 MB 的 DataFrame。然后我们将为这些五个滑块值的 _每个排列_ 添加 100 MB 到缓存中 - 即使滑块不影响返回的数据！这些添加可以使您的缓存非常快速地爆炸。如果您在缓存函数中使用窗口小部件，请注意此限制。我们建议仅在 UI 的隔离部分使用此功能，其中窗口小部件直接影响缓存的返回值。

<Warning>

对缓存函数中窗口小部件的支持目前是实验性的。我们可能随时更改或删除它而不会发出警告。请谨慎使用！
</Warning>
<Note>

两个窗口小部件目前在缓存函数中不受支持：`st.file_uploader` 和 `st.camera_input`。我们将来可能会支持它们。如果您需要它们，请随时[打开 GitHub 问题](https://github.com/streamlit/streamlit/issues)！
</Note>

---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.context


* Function signature:

   st.context()



* Function signature:

   context.cookies



* Function signature:

   context.headers



* Function signature:

   context.ip_address



* Function signature:

   context.is_embedded



* Function signature:

   context.locale



* Function signature:

   context.theme

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | type | "light", "dark" |  | The theme type inferred from the background color of the app. |



* Function signature:

   context.timezone



* Function signature:

   context.timezone_offset



* Function signature:

   context.url



---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.experimental_get_query_params


* Function signature:

   st.experimental_get_query_params()

* Returns: dict

    The current query parameters as a dict. "Query parameters" are the part of the URL that comes
after the first "?".



---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.experimental_set_query_params


* Function signature:

   st.experimental_set_query_params(**query_params)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | **query_params | dict |  | The query parameters to set, as key-value pairs. |



---

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.query_params

## st.query_params

`st.query_params` 从 Streamlit 1.30.0 开始提供字典式接口来访问应用 URL 中的查询参数。它与 `st.session_state` 的行为类似，但值得注意的是，应用的 URL 中可能重复键。重复键的处理需要特别考虑，如下所述。

`st.query_params` 可以使用键和属性表示法。例如，`st.query_params.my_key` 和 `st.query_params["my_key"]`。所有键和值都将设置为字符串并返回。当您写入 `st.query_params` 时，以 `?` 为前缀的键值对会添加到应用的 URL 末尾。每个额外的对以 `` 而不是 `?` 为前缀。在多页应用中导航时，查询参数会被清除。

例如，考虑以下 URL：

```javascript
https://your_app.streamlit.app/?first_key=1=two=true
```

上述 URL 中的参数将在 `st.query_params` 中可访问为：

```python
{
    "first_key" : "1",
    "second_key" : "two",
    "third_key" : "true"
}
```

这意味着您可以在应用中使用这些参数，如下所示：

```python
# 您可以使用键表示法读取查询参数
if st.query_params["first_key"] == "1":
    do_something()

# ...或使用属性表示法
if st.query_params.second_key == "two":
    do_something_else()

# 您可以通过写入来更改参数
st.query_params.first_key = 2  # 这会自动转换为字符串
```

### 重复键

当应用的 URL 中重复键（`?a=1=2=3`）时，字典式方法将仅返回最后一个值。在此示例中，`st.query_params["a"]` 返回 `"3"`。要获取所有键作为列表，请使用下面显示的 [`.get_all()`](/develop/api-reference/caching-and-state/st.query_params#stquery_paramsget_all) 方法。要设置重复键的值，请将值分配为列表。例如，`st.query_params.a = ["1", "2", "3"]` 会产生本段开头给出的重复键。

### 限制

`st.query_params` 无法获取或设置[嵌入您的应用](/deploy/streamlit-community-cloud/share-your-app/embed-your-app#embed-options)中描述的嵌入设置。`st.query_params.embed` 和 `st.query_params.embed_options` 在尝试获取或设置其值时会引发 `AttributeError` 或 `StreamlitAPIException`。


* Function signature:

   st.query_params.clear()

* Returns: None



* Function signature:

   st.query_params.from_dict(params)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | params | dict |  | A dictionary used to replace the current query parameters. |



* Function signature:

   st.query_params.get_all(key)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | key | str |  | The label of the query parameter in the URL. |

* Returns: List[str]

    A list of values associated to the given key. May return zero, one,
or multiple values.



* Function signature:

   st.query_params.to_dict()

* Returns: Dict[str,str]

    A dictionary of the current query parameters in the app's URL.



---

# 会话状态

Source: https://docs.streamlit.io/develop/api-reference/caching-and-state/st.session_state


会话状态是一种在每次用户会话的重运行之间共享变量的方式。除了存储和持久化状态的能力外，Streamlit 还公开了使用回调操作状态的能力。会话状态还跨[多页应用](/develop/concepts/multipage-apps)中的应用持久化。

观看 Streamlit 开发者倡导者 Marisa Smith 博士的这个会话状态基础教程视频开始：

<YouTube videoId="92jUAXBmZyU"/>

### 在会话状态中初始化值

会话状态 API 遵循基于字段的 API，与 Python 字典非常相似：

```python
# 初始化
if 'key' not in st.session_state:
    st.session_state['key'] = 'value'

# 会话状态还支持基于属性的语法
if 'key' not in st.session_state:
    st.session_state.key = 'value'
```

### 读取和更新

通过传递给 `st.write` 来读取会话状态中项目的价值并显示它：

```python
# 读取
st.write(st.session_state.key)

# 输出：value
```

通过为其分配值来更新会话状态中的项目：

```python
st.session_state.key = 'value2'     # 属性 API
st.session_state['key'] = 'value2'  # 字典式 API
```

好奇会话状态中有什么？使用 `st.write` 或魔法：

```python
st.write(st.session_state)

# 使用魔法：
st.session_state
```

如果访问未初始化的变量，Streamlit 会抛出一个方便的异常：

```python
st.write(st.session_state['value'])

# 抛出异常！
```

![state-uninitialized-exception](/images/state_uninitialized_exception.png)

### 删除项目

使用删除任何 Python 字典中项目的语法删除会话状态中的项目：

```python
# 删除单个键值对
del st.session_state[key]

# 删除会话状态中的所有项目
for key in st.session_state.keys():
    del st.session_state[key]
```

还可以通过转到设置 → 清除缓存，然后重新运行应用来清除会话状态。

![state-clear-cache](/images/clear_cache.png)

### 会话状态和窗口小部件状态关联

每个带有键的窗口小部件都会自动添加到会话状态：

```python
st.text_input("Your name", key="name")

# 这现在存在：
st.session_state.name
```

### 使用回调更新会话状态

回调是一个 Python 函数，当输入窗口小部件更改时被调用。

**执行顺序**：在响应**事件**更新会话状态时，回调函数首先被执行，然后应用从上到下执行。

回调可以使用参数 `on_change`（或 `on_click`）、`args` 和 `kwargs` 与窗口小部件一起使用：

**参数**

- **on_change** 或 **on_click** - 用作回调的函数名称
- **args** (_tuple_) - 要传递给回调函数的参数列表
- **kwargs** (_dict_) - 要传递给回调函数的命名参数

支持 `on_change` 事件的窗口小部件：

- `st.checkbox`
- `st.color_picker`
- `st.date_input`
- `st.data_editor`
- `st.file_uploader`
- `st.multiselect`
- `st.number_input`
- `st.radio`
- `st.select_slider`
- `st.selectbox`
- `st.slider`
- `st.text_area`
- `st.text_input`
- `st.time_input`
- `st.toggle`

支持 `on_click` 事件的窗口小部件：

- `st.button`
- `st.download_button`
- `st.form_submit_button`

要添加回调，在窗口小部件声明**上方**定义回调函数，并通过 `on_change`（或 `on_click`）参数将其传递给窗口小部件。

### 表单和回调

表单内的窗口小部件可以通过会话状态 API 访问和设置其值。`st.form_submit_button` 可以有与之关联的回调。回调在单击提交按钮时执行。例如：

```python
def form_callback():
    st.write(st.session_state.my_slider)
    st.write(st.session_state.my_checkbox)

with st.form(key='my_form'):
    slider_input = st.slider('My slider', 0, 10, 5, key='my_slider')
    checkbox_input = st.checkbox('Yes or No', key='my_checkbox')
    submit_button = st.form_submit_button(label='Submit', on_click=form_callback)
```

### 可序列化的会话状态

序列化是指将对象或数据结构转换为可以持久化和共享的格式，并允许您恢复数据的原始结构的过程。Python 的内置 [pickle](https://docs.python.org/3/develop/pickle.html) 模块将 Python 对象序列化为字节流（"pickling"）并将流反序列化为对象（"unpickling"）。

默认情况下，Streamlit 的[会话状态](/develop/concepts/architecture/session-state)允许您在会话期间持久化任何 Python 对象，无论对象的 pickle 可序列化性如何。此属性让您可以存储 Python 原始类型，如整数、浮点数、复数和布尔值、数据框，甚至函数返回的 [lambdas](https://docs.python.org/3/reference/expressions.html#lambda)。但是，一些执行环境可能需要序列化会话状态中的所有数据，因此在开发期间检测不兼容性可能很有用，或者当执行环境将来停止支持它时。

为此，Streamlit 提供了一个 `runner.enforceSerializableSessionState` [配置选项](/develop/concepts/configuration)，当设置为 `true` 时，只允许会话状态中的 pickle 可序列化对象。要启用该选项，请创建具有以下内容的全局或项目配置文件，或将其用作命令行标志：

```toml
# .streamlit/config.toml
[runner]
enforceSerializableSessionState = true
```

通过 "_pickle 可序列化_"，我们意味着调用 `pickle.dumps(obj)` 不应引发 [`PicklingError`](https://docs.python.org/3/develop/pickle.html#pickle.PicklingError) 异常。当配置选项启用时，向会话状态添加不可序列化数据应导致异常。例如，

```python
import streamlit as st

def unserializable_data():
		return lambda x: x

#👇 当 enforceSerializableSessionState 开启时导致异常
st.session_state.unserializable = unserializable_data()
```

<Image alt="UnserializableSessionStateError" src="/images/unserializable-session-state-error.png"/>
<Warning>

当 `runner.enforceSerializableSessionState` 设置为 `true` 时，会话状态隐式使用 `pickle` 模块，这已知是不安全的。确保从会话状态保存和检索的所有数据都是可信的，因为可以构造恶意 pickle 数据，在 unpickling 期间执行任意代码。永远不要以不安全模式加载可能来自不可信来源的数据或可能已被篡改的数据。**仅加载您信任的数据**。

</Warning>

### 注意事项和限制

- Streamlit 会话状态绑定到 WebSocket 连接。当用户重新加载浏览器选项卡或使用 Markdown 链接导航时，WebSocket 连接和关联的会话状态数据会被重置。
- 只有 `st.form_submit_button` 在表单中有回调。表单内的其他窗口小部件不允许有回调。
- `on_change` 和 `on_click` 事件仅在输入类型窗口小部件上受支持。
- 在实例化窗口小部件后，通过会话状态 API 修改其值是不允许的，并会引发 `StreamlitAPIException`。例如：

  ```python
  slider = st.slider(
      label='My Slider', min_value=1,
      max_value=10, value=5, key='my_slider')

  st.session_state.my_slider = 7

  # 抛出异常！
  ```

  ![state-modified-instantiated-exception](/images/state_modified_instantiated_exception.png)

- 通过会话状态 API 设置窗口小部件状态并在窗口小部件声明中使用 `value` 参数是不推荐的，并在第一次运行时抛出警告。例如：

  ```python
  st.session_state.my_slider = 7

  slider = st.slider(
      label='Choose a Value', min_value=1,
      max_value=10, value=5, key='my_slider')
  ```

  ![state-value-api-exception](/images/state_value_api_exception.png)

- 通过会话状态 API 设置按钮式窗口小部件的状态：`st.button`、`st.download_button` 和 `st.file_uploader` 是不允许的。此类窗口小部件默认情况下为 _False_，并且具有仅对单个运行有效的短暂 _True_ 状态。例如：

  ```python
  if 'my_button' not in st.session_state:
      st.session_state.my_button = True

  st.button('My button', key='my_button')

  # 抛出异常！
  ```

  ![state-button-exception](/images/state_button_exception.png)

---

# Chart elements

Source: https://docs.streamlit.io/develop/api-reference/charts


Streamlit 支持多种不同的图表库，我们的目标是不断添加更多支持。现在，我们武器库中最基本的库是 [Matplotlib](https://matplotlib.org/)。然后还有像 [Vega Lite](https://vega.github.io/vega-lite/)（2D 图表）和 [deck.gl](https://github.com/uber/deck.gl)（地图和 3D 图表）这样的交互式图表库。最后，我们还提供了一些"原生"于 Streamlit 的图表类型，如 `st.line_chart` 和 `st.area_chart`。

## Simple chart elements

<TileContainer>
<RefCard href="/develop/api-reference/charts/st.area_chart">
<Image>alt="screenshot" src="/images/api/area_chart.jpg" /&gt;

<h4>Simple area charts</h4>

显示面积图。

```python
st.area_chart(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.bar_chart">
<Image>alt="screenshot" src="/images/api/bar_chart.jpg" /&gt;

<h4>Simple bar charts</h4>

显示条形图。

```python
st.bar_chart(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.line_chart">
<Image>alt="screenshot" src="/images/api/line_chart.jpg" /&gt;

<h4>Simple line charts</h4>

显示线图。

```python
st.line_chart(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.scatter_chart">
<Image>alt="screenshot" src="/images/api/scatter_chart.svg" /&gt;

<h4>Simple scatter charts</h4>

显示散点图。

```python
st.scatter_chart(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.map">
<Image>alt="screenshot" src="/images/api/map.jpg" /&gt;

<h4>Scatterplots on maps</h4>

显示带有点的地图。

```python
st.map(my_data_frame)
```

</Image>
</RefCard>

## Advanced chart elements

<TileContainer>
<RefCard href="/develop/api-reference/charts/st.pyplot">
<Image>alt="screenshot" src="/images/api/pyplot.jpg" /&gt;

<h4>Matplotlib</h4>

显示 matplotlib.pyplot 图表。

```python
st.pyplot(my_mpl_figure)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.altair_chart">
<Image>alt="screenshot" src="/images/api/vega_lite_chart.jpg" /&gt;

<h4>Altair</h4>

使用 Altair 库显示图表。

```python
st.altair_chart(my_altair_chart)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.vega_lite_chart">
<Image>alt="screenshot" src="/images/api/vega_lite_chart.jpg" /&gt;

<h4>Vega-Lite</h4>

使用 Vega-Lite 库显示图表。

```python
st.vega_lite_chart(my_vega_lite_chart)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.plotly_chart">
<Image>alt="screenshot" src="/images/api/plotly_chart.jpg" /&gt;

<h4>Plotly</h4>

显示交互式 Plotly 图表。

```python
st.plotly_chart(my_plotly_chart)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.bokeh_chart">
<Image>alt="screenshot" src="/images/api/bokeh_chart.jpg" /&gt;

<h4>Bokeh</h4>

显示交互式 Bokeh 图表。

```python
st.bokeh_chart(my_bokeh_chart)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.pydeck_chart">
<Image>alt="screenshot" src="/images/api/pydeck_chart.jpg" /&gt;

<h4>PyDeck</h4>

使用 PyDeck 库显示图表。

```python
st.pydeck_chart(my_pydeck_chart)
```

</Image>
<RefCard href="/develop/api-reference/charts/st.graphviz_chart">
<Image>alt="screenshot" src="/images/api/graphviz_chart.jpg" /&gt;

<h4>GraphViz</h4>

使用 dagre-d3 库显示图表。

```python
st.graphviz_chart(my_graphviz_spec)
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/tvst/plost">
<Image>alt="screenshot" src="/images/api/components/plost.jpg" /&gt;

<h4>Plost</h4>

一个看似简单的 Streamlit 绘图库。由 [@tvst](https://github.com/tvst) 创建。

```python
import plost
plost.line_chart(my_dataframe, x='time', y='stock_value', color='stock_name',)
```

</Image>
<ComponentCard href="https://github.com/facebookresearch/hiplot">
<Image>alt="screenshot" src="/images/api/components/hiplot.jpg" /&gt;

<h4>HiPlot</h4>

高维交互式绘图。由 [@facebookresearch](https://github.com/facebookresearch) 创建。

```python
data = [{'dropout':0.1, 'lr': 0.001, 'loss': 10.0, 'optimizer': 'SGD'}, {'dropout':0.15, 'lr': 0.01, 'loss': 3.5, 'optimizer': 'Adam'}, {'dropout':0.3, 'lr': 0.1, 'loss': 4.5, 'optimizer': 'Adam'}]
hip.Experiment.from_iterable(data).display()
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-echarts">
<Image>alt="screenshot" src="/images/api/components/echarts.jpg" /&gt;

<h4>ECharts</h4>

Streamlit 的 ECharts 组件。由 [@andfanilo](https://github.com/andfanilo) 创建。

```python
from streamlit_echarts import st_echarts
st_echarts(options=options)
```

</Image>
<ComponentCard href="https://github.com/randyzwitch/streamlit-folium">
<Image>alt="screenshot" src="/images/api/components/folium.jpg" /&gt;

<h4>Streamlit Folium</h4>

用于渲染 Folium 地图的 Streamlit 组件。由 [@randyzwitch](https://github.com/randyzwitch) 创建。

```python
m = folium.Map(location=[39.949610, -75.150282], zoom_start=16)
st_data = st_folium(m, width=725)
```

</Image>
<ComponentCard href="https://github.com/explosion/spacy-streamlit">
<Image>alt="screenshot" src="/images/api/components/spacy.jpg" /&gt;

<h4>Spacy-Streamlit</h4>

Streamlit 应用的 spaCy 构建块和可视化工具。由 [@explosion](https://github.com/explosion) 创建。

```python
models = ["en_core_web_sm", "en_core_web_md"]
spacy_streamlit.visualize(models, "Sundar Pichai is the CEO of Google.")
```

</Image>
<ComponentCard href="https://github.com/ChrisDelClea/streamlit-agraph">
<Image>alt="screenshot" src="/images/api/components/agraph.jpg" /&gt;

<h4>Streamlit Agraph</h4>

基于 [react-grah-vis](https://github.com/crubier/react-graph-vis) 的 Streamlit 图可视化。由 [@ChrisDelClea](https://github.com/ChrisDelClea) 创建。

```python
from streamlit_agraph import agraph, Node, Edge, Config
agraph(nodes=nodes, edges=edges, config=config)
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-lottie">
<Image>alt="screenshot" src="/images/api/components/lottie.jpg" /&gt;

<h4>Streamlit Lottie</h4>

在您的 Streamlit 应用中集成 [Lottie](https://lottiefiles.com/) 动画。由 [@andfanilo](https://github.com/andfanilo) 创建。

```python
lottie_hello = load_lottieurl("https://assets5.lottiefiles.com/packages/lf20_V9t630.json")
st_lottie(lottie_hello, key="hello")
```

</Image>
<ComponentCard href="https://github.com/null-jones/streamlit-plotly-events">
<Image>alt="screenshot" src="/images/api/components/plotly-events.jpg" /&gt;

<h4>Plotly Events</h4>

让 Plotly 图表具有交互性！由 [@null-jones](https://github.com/null-jones/) 创建。

```python
fig = px.line(x=[1], y=[1])
selected_points = plotly_events(fig)
```

</Image>
<ComponentCard href="https://extras.streamlit.app/">
<Image>alt="screenshot" src="/images/api/components/extras-chart-annotations.jpg" /&gt;

<h4>Streamlit Extras</h4>

一个包含有用 Streamlit 扩展的库。由 [@arnaudmiribel](https://github.com/arnaudmiribel/) 创建。

```python
chart += get_annotations_chart(annotations=[("Mar 01, 2008", "Pretty good day for GOOG"), ("Dec 01, 2007", "Something's going wrong for GOOG  AAPL"), ("Nov 01, 2008", "Market starts again thanks to..."), ("Dec 01, 2009", "Small crash for GOOG after..."),],)
st.altair_chart(chart, use_container_width=True)
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.altair_chart


* Function signature:

   st.altair_chart(altair_chart, *, width=None, height="content", use_container_width=None, theme="streamlit", key=None, on_select="ignore", selection_mode=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | altair_chart | altair.Chart |  | The Altair chart object to display. See https://altair-viz.github.io/gallery/ for examples of graph descriptions. |
   | width | "stretch", "content", int, or None |  | The width of the chart element. This can be one of the following:  "stretch": The width of the element matches the width of the parent container.  "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container.  An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container.  None (default): Streamlit uses "stretch" for most charts, and uses "content" for the following multi-view charts:   Facet charts: the spec contains "facet" or encodings for "row", "column", or "facet". Horizontal concatenation charts: the spec contains "hconcat". Repeat charts: the spec contains "repeat". |
   | height | "content", "stretch", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None |  | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the parent container's width for all charts except those with known incompatibility (altair.Facet, altair.HConcatChart, and altair.RepeatChart). True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |
   | theme | "streamlit" or None | behavior | The theme of the chart. If theme is "streamlit" (default), Streamlit uses its own design default. If theme is None, Streamlit falls back to the default behavior of the library. The "streamlit" theme can be partially customized through the configuration options theme.chartCategoricalColors and theme.chartSequentialColors. Font configuration options are also applied. |
   | key | str |  | An optional string to use for giving this element a stable identity. If key is None (default), this element's identity will be determined based on the values of the other parameters. Additionally, if selections are activated and key is provided, Streamlit will register the key in Session State to store the selection state. The selection state is read-only. |
   | on_select | "ignore", "rerun", or callable |  | How the figure should respond to user selection events. This controls whether or not the figure behaves like an input widget. on_select can be one of the following:  "ignore" (default): Streamlit will not react to any selection events in the chart. The figure will not behave like an input widget. "rerun": Streamlit will rerun the app when the user selects data in the chart. In this case, st.altair_chart will return the selection data as a dictionary. A callable: Streamlit will rerun the app and execute the callable as a callback function before the rest of the app. In this case, st.altair_chart will return the selection data as a dictionary.  To use selection events, the object passed to altair_chart must include selection parameters. To learn about defining interactions in Altair and how to declare selection-type parameters, see Interactive Charts in Altair's documentation. |
   | selection_mode | str or Iterable of str |  | The selection parameters Streamlit should use. If selection_mode is None (default), Streamlit will use all selection parameters defined in the chart's Altair spec. When Streamlit uses a selection parameter, selections from that parameter will trigger a rerun and be included in the selection state. When Streamlit does not use a selection parameter, selections from that parameter will not trigger a rerun and not be included in the selection state. Selection parameters are identified by their name property. |

* Returns: element or dict

    If on_select is "ignore" (default), this command returns an
internal placeholder for the chart element that can be used with
the .add_rows() method. Otherwise, this command returns a
dictionary-like object that supports both key and attribute
notation. The attributes are described by the VegaLiteState
dictionary schema.



## 图表选择


* Function signature:

   VegaLiteState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | selection | dict |  | The state of the on_select event. This attribute returns a dictionary-like object that supports both key and attribute notation. The name of each Vega-Lite selection parameter becomes an attribute in the selection dictionary. The format of the data within each attribute is determined by the selection parameter definition within Vega-Lite. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.area_chart


* Function signature:

   st.area_chart(data=None, *, x=None, y=None, x_label=None, y_label=None, color=None, stack=None, width="stretch", height="content", use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | Data to be plotted. |
   | x | str or None |  | Column name or key associated to the x-axis data. If x is None (default), Streamlit uses the data index for the x-axis values. |
   | y | str, Sequence of str, or None |  | Column name(s) or key(s) associated to the y-axis data. If this is None (default), Streamlit draws the data of all remaining columns as data series. If this is a Sequence of strings, Streamlit draws several series on the same chart by melting your wide-format table into a long-format table behind the scenes. |
   | x_label | str or None |  | The label for the x-axis. If this is None (default), Streamlit will use the column name specified in x if available, or else no label will be displayed. |
   | y_label | str or None |  | The label for the y-axis. If this is None (default), Streamlit will use the column name(s) specified in y if available, or else no label will be displayed. |
   | color | str, tuple, Sequence of str, Sequence of tuple, or None | color | The color to use for different series in this chart. For an area chart with just 1 series, this can be:  None, to use the default color. A hex string like "#ffaa00" or "#ffaa0088". An RGB or RGBA tuple with the red, green, blue, and alpha components specified as ints from 0 to 255 or floats from 0.0 to 1.0.  For an area chart with multiple series, where the dataframe is in long format (that is, y is None or just one column), this can be:  None, to use the default colors.  The name of a column in the dataset. Data points will be grouped into series of the same color based on the value of this column. In addition, if the values in this column match one of the color formats above (hex string or color tuple), then that color will be used. For example: if the dataset has 1000 rows, but this column only contains the values "adult", "child", and "baby", then those 1000 datapoints will be grouped into three series whose colors will be automatically selected from the default palette. But, if for the same 1000-row dataset, this column contained the values "#ffaa00", "#f0f", "#0000ff", then then those 1000 datapoints would still be grouped into 3 series, but their colors would be "#ffaa00", "#f0f", "#0000ff" this time around.   For an area chart with multiple series, where the dataframe is in wide format (that is, y is a Sequence of columns), this can be:  None, to use the default colors. A list of string colors or color tuples to be used for each of the series in the chart. This list should have the same length as the number of y values (e.g. color=["#fd0", "#f0f", "#04f"] for three lines).  You can set the default colors in the theme.chartCategoryColors configuration option. |
   | stack | bool, "normalize", "center", or None |  | Whether to stack the areas. If this is None (default), Streamlit uses Vega's default. Other values can be as follows:  True: The areas form a non-overlapping, additive stack within the chart. False: The areas overlap each other without stacking. "normalize": The areas are stacked and the total height is normalized to 100% of the height of the chart. "center": The areas are stacked and shifted to center their baseline, which creates a steamgraph. |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "stretch", "content", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None | behavior | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the chart's default behavior. True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.bar_chart


* Function signature:

   st.bar_chart(data=None, *, x=None, y=None, x_label=None, y_label=None, color=None, horizontal=False, sort=True, stack=None, width="stretch", height="content", use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | Data to be plotted. |
   | x | str or None |  | Column name or key associated to the x-axis data. If x is None (default), Streamlit uses the data index for the x-axis values. |
   | y | str, Sequence of str, or None |  | Column name(s) or key(s) associated to the y-axis data. If this is None (default), Streamlit draws the data of all remaining columns as data series. If this is a Sequence of strings, Streamlit draws several series on the same chart by melting your wide-format table into a long-format table behind the scenes. |
   | x_label | str or None |  | The label for the x-axis. If this is None (default), Streamlit will use the column name specified in x if available, or else no label will be displayed. |
   | y_label | str or None |  | The label for the y-axis. If this is None (default), Streamlit will use the column name(s) specified in y if available, or else no label will be displayed. |
   | color | str, tuple, Sequence of str, Sequence of tuple, or None | color | The color to use for different series in this chart. For a bar chart with just one series, this can be:  None, to use the default color. A hex string like "#ffaa00" or "#ffaa0088". An RGB or RGBA tuple with the red, green, blue, and alpha components specified as ints from 0 to 255 or floats from 0.0 to 1.0.  For a bar chart with multiple series, where the dataframe is in long format (that is, y is None or just one column), this can be:  None, to use the default colors.  The name of a column in the dataset. Data points will be grouped into series of the same color based on the value of this column. In addition, if the values in this column match one of the color formats above (hex string or color tuple), then that color will be used. For example: if the dataset has 1000 rows, but this column only contains the values "adult", "child", and "baby", then those 1000 datapoints will be grouped into three series whose colors will be automatically selected from the default palette. But, if for the same 1000-row dataset, this column contained the values "#ffaa00", "#f0f", "#0000ff", then then those 1000 datapoints would still be grouped into 3 series, but their colors would be "#ffaa00", "#f0f", "#0000ff" this time around.   For a bar chart with multiple series, where the dataframe is in wide format (that is, y is a Sequence of columns), this can be:  None, to use the default colors. A list of string colors or color tuples to be used for each of the series in the chart. This list should have the same length as the number of y values (e.g. color=["#fd0", "#f0f", "#04f"] for three lines).  You can set the default colors in the theme.chartCategoryColors configuration option. |
   | horizontal | bool |  | Whether to make the bars horizontal. If this is False (default), the bars display vertically. If this is True, Streamlit swaps the x-axis and y-axis and the bars display horizontally. |
   | sort | bool or str | sorting | How to sort the bars. This can be one of the following:  True (default): The bars are sorted automatically along the independent/categorical axis with Altair's default sorting. This also correctly sorts ordered categorical columns (pd.Categorical). False: The bars are shown in data order without sorting. The name of a column (e.g. "col1"): The bars are sorted by that column in ascending order. The name of a column with a minus-sign prefix (e.g. "-col1"): The bars are sorted by that column in descending order. |
   | stack | bool, "normalize", "center", "layered", or None |  | Whether to stack the bars. If this is None (default), Streamlit uses Vega's default. Other values can be as follows:  True: The bars form a non-overlapping, additive stack within the chart. False: The bars display side by side. "layered": The bars overlap each other without stacking. "normalize": The bars are stacked and the total height is normalized to 100% of the height of the chart. "center": The bars are stacked and shifted to center the total height around an axis. |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "stretch", "content", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None | behavior | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the chart's default behavior. True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.bokeh_chart


* Function signature:

   st.bokeh_chart(figure, use_container_width=True)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | figure | bokeh.plotting.figure.Figure |  | A Bokeh figure to plot. |
   | use_container_width | bool |  | Whether to override the figure's native width with the width of the parent container. If use_container_width is True (default), Streamlit sets the width of the figure to match the width of the parent container. If use_container_width is False, Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.graphviz_chart


* Function signature:

   st.graphviz_chart(figure_or_dot, use_container_width=None, *, width="content", height="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | figure_or_dot | graphviz.dot.Graph, graphviz.dot.Digraph, graphviz.sources.Source, str |  | The Graphlib graph object or dot string to display |
   | use_container_width | bool |  | Whether to override the figure's native width with the width of the parent container. If use_container_width is False (default), Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. If use_container_width is True, Streamlit sets the width of the figure to match the width of the parent container. |
   | width | "content", "stretch", or int |  | The width of the chart element. This can be one of the following:  "content" (default): The width of the element matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "content", "stretch", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.line_chart


* Function signature:

   st.line_chart(data=None, *, x=None, y=None, x_label=None, y_label=None, color=None, width="stretch", height="content", use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | Data to be plotted. |
   | x | str or None |  | Column name or key associated to the x-axis data. If x is None (default), Streamlit uses the data index for the x-axis values. |
   | y | str, Sequence of str, or None |  | Column name(s) or key(s) associated to the y-axis data. If this is None (default), Streamlit draws the data of all remaining columns as data series. If this is a Sequence of strings, Streamlit draws several series on the same chart by melting your wide-format table into a long-format table behind the scenes. |
   | x_label | str or None |  | The label for the x-axis. If this is None (default), Streamlit will use the column name specified in x if available, or else no label will be displayed. |
   | y_label | str or None |  | The label for the y-axis. If this is None (default), Streamlit will use the column name(s) specified in y if available, or else no label will be displayed. |
   | color | str, tuple, Sequence of str, Sequence of tuple, or None | color | The color to use for different lines in this chart. For a line chart with just one line, this can be:  None, to use the default color. A hex string like "#ffaa00" or "#ffaa0088". An RGB or RGBA tuple with the red, green, blue, and alpha components specified as ints from 0 to 255 or floats from 0.0 to 1.0.  For a line chart with multiple lines, where the dataframe is in long format (that is, y is None or just one column), this can be:  None, to use the default colors.  The name of a column in the dataset. Data points will be grouped into lines of the same color based on the value of this column. In addition, if the values in this column match one of the color formats above (hex string or color tuple), then that color will be used. For example: if the dataset has 1000 rows, but this column only contains the values "adult", "child", and "baby", then those 1000 datapoints will be grouped into three lines whose colors will be automatically selected from the default palette. But, if for the same 1000-row dataset, this column contained the values "#ffaa00", "#f0f", "#0000ff", then then those 1000 datapoints would still be grouped into three lines, but their colors would be "#ffaa00", "#f0f", "#0000ff" this time around.   For a line chart with multiple lines, where the dataframe is in wide format (that is, y is a Sequence of columns), this can be:  None, to use the default colors. A list of string colors or color tuples to be used for each of the lines in the chart. This list should have the same length as the number of y values (e.g. color=["#fd0", "#f0f", "#04f"] for three lines).  You can set the default colors in the theme.chartCategoryColors configuration option. |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "content", "stretch", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None | behavior | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the chart's default behavior. True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.map


* Function signature:

   st.map(data=None, *, latitude=None, longitude=None, color=None, size=None, zoom=None, width="stretch", height=500, use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | The data to be plotted. |
   | latitude | str or None |  | The name of the column containing the latitude coordinates of the datapoints in the chart. If None, the latitude data will come from any column named 'lat', 'latitude', 'LAT', or 'LATITUDE'. |
   | longitude | str or None |  | The name of the column containing the longitude coordinates of the datapoints in the chart. If None, the longitude data will come from any column named 'lon', 'longitude', 'LON', or 'LONGITUDE'. |
   | color | str or tuple or None | color | The color of the circles representing each datapoint. Can be:  None, to use the default color. A hex string like "#ffaa00" or "#ffaa0088". An RGB or RGBA tuple with the red, green, blue, and alpha components specified as ints from 0 to 255 or floats from 0.0 to 1.0. The name of the column to use for the color. Cells in this column should contain colors represented as a hex string or color tuple, as described above. |
   | size | str or float or None | size | The size of the circles representing each point, in meters. This can be:  None, to use the default size. A number like 100, to specify a single size to use for all datapoints. The name of the column to use for the size. This allows each datapoint to be represented by a circle of a different size. |
   | zoom | int |  | Zoom level as specified in https://wiki.openstreetmap.org/wiki/Zoom_levels. |
   | width | "stretch" or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "stretch" or int |  | The height of the chart element. This can be one of the following:  An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. This is 500 by default. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. |
   | use_container_width | bool or None | behavior | Whether to override the map's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the map's default behavior. True: Streamlit sets the width of the map to match the width of the parent container. False: Streamlit sets the width of the map to fit its contents according to the plotting library, up to the width of the parent container. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.plotly_chart


* Function signature:

   st.plotly_chart(figure_or_data, use_container_width=None, *, width="stretch", height="content", theme="streamlit", key=None, on_select="ignore", selection_mode=('points', 'box', 'lasso'), config=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | figure_or_data | plotly.graph_objs.Figure, plotly.graph_objs.Data,            or dict/list of plotly.graph_objs.Figure/Data |  | The Plotly Figure or Data object to render. See https://plot.ly/python/ for examples of graph descriptions.  Note If your chart contains more than 1000 data points, Plotly will use a WebGL renderer to display the chart. Different browsers have different limits on the number of WebGL contexts per page. If you have multiple WebGL contexts on a page, you may need to switch to SVG rendering mode. You can do this by setting render_mode="svg" within the figure. For example, the following code defines a Plotly Express line chart that will render in SVG mode when passed to st.plotly_chart: px.line(df, x="x", y="y", render_mode="svg"). |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "content", "stretch", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None |  | Whether to override the figure's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the value of width. True: Streamlit sets the width of the figure to match the width of the parent container. False: Streamlit sets the width of the figure to fit its contents according to the plotting library, up to the width of the parent container. |
   | theme | "streamlit" or None | behavior | The theme of the chart. If theme is "streamlit" (default), Streamlit uses its own design default. If theme is None, Streamlit falls back to the default behavior of the library. The "streamlit" theme can be partially customized through the configuration options theme.chartCategoricalColors and theme.chartSequentialColors. Font configuration options are also applied. |
   | key | str |  | An optional string to use for giving this element a stable identity. If key is None (default), this element's identity will be determined based on the values of the other parameters. Additionally, if selections are activated and key is provided, Streamlit will register the key in Session State to store the selection state. The selection state is read-only. |
   | on_select | "ignore" or "rerun" or callable |  | How the figure should respond to user selection events. This controls whether or not the figure behaves like an input widget. on_select can be one of the following:  "ignore" (default): Streamlit will not react to any selection events in the chart. The figure will not behave like an input widget. "rerun": Streamlit will rerun the app when the user selects data in the chart. In this case, st.plotly_chart will return the selection data as a dictionary. A callable: Streamlit will rerun the app and execute the callable as a callback function before the rest of the app. In this case, st.plotly_chart will return the selection data as a dictionary. |
   | selection_mode | "points", "box", "lasso" or an Iterable of these |  | The selection mode of the chart. This can be one of the following:  "points": The chart will allow selections based on individual data points. "box": The chart will allow selections based on rectangular areas. "lasso": The chart will allow selections based on freeform areas. An Iterable of the above options: The chart will allow selections based on the modes specified.  All selections modes are activated by default. |
   | config | dict or None |  | A dictionary of Plotly configuration options. This is passed to Plotly's show() function. For more information about Plotly configuration options, see Plotly's documentation on Configuration in Python. |
   | **kwargs | None |  | Additional arguments accepted by Plotly's plot() function. This supports config, a dictionary of Plotly configuration options. For more information about Plotly configuration options, see Plotly's documentation on Configuration in Python. |

* Returns: element or dict

    If on_select is "ignore" (default), this command returns an
internal placeholder for the chart element. Otherwise, this command
returns a dictionary-like object that supports both key and
attribute notation. The attributes are described by the
PlotlyState dictionary schema.



## Chart selections


* Function signature:

   PlotlyState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | selection | dict |  | The state of the on_select event. This attribute returns a dictionary-like object that supports both key and attribute notation. The attributes are described by the PlotlySelectionState dictionary schema. |



* Function signature:

   PlotlySelectionState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | points | list[dict[str, Any]] |  | The selected data points in the chart, including the data points selected by the box and lasso mode. The data includes the values associated to each point and a point index used to populate point_indices. If additional information has been assigned to your points, such as size or legend group, this is also included. |
   | point_indices | list[int] |  | The numerical indices of all selected data points in the chart. The details of each identified point are included in points. |
   | box | list[dict[str, Any]] |  | The metadata related to the box selection. This includes the coordinates of the selected area. |
   | lasso | list[dict[str, Any]] |  | The metadata related to the lasso selection. This includes the coordinates of the selected area. |



## Theming

Plotly 图表默认使用 Streamlit 主题显示。这个主题简洁、用户友好，并包含 Streamlit 的调色板。额外的好处是您的图表能更好地与应用的其余设计集成。

从 Streamlit 1.16.0 开始，可以通过 `theme="streamlit"` 关键字参数使用 Streamlit 主题。要禁用它并使用 Plotly 的原生主题，请改用 `theme=None`。

让我们看看使用 Streamlit 主题和原生 Plotly 主题的图表示例：

```python
import plotly.express as px
import streamlit as st

df = px.data.gapminder()

fig = px.scatter(
    df.query("year==2007"),
    x="gdpPercap",
    y="lifeExp",
    size="pop",
    color="continent",
    hover_name="country",
    log_x=True,
    size_max=60,
)

tab1, tab2 = st.tabs(["Streamlit theme (default)", "Plotly native theme"])
with tab1:
    # Use the Streamlit theme.
    # This is the default. So you can also omit the theme argument.
    st.plotly_chart(fig, theme="streamlit", use_container_width=True)
with tab2:
    # Use the native Plotly theme.
    st.plotly_chart(fig, theme=None, use_container_width=True)
```

点击下方交互式应用中的选项卡，查看启用和禁用 Streamlit 主题的图表。

<Cloud height="525px" name="doc-plotly-chart-theme"/>

如果您想知道自己的自定义设置是否仍会被考虑，不要担心！您仍然可以对图表配置进行更改。换句话说，虽然我们现在默认启用 Streamlit 主题，但您可以用自定义颜色或字体覆盖它。例如，如果您希望图表线条是绿色而不是默认的红色，您可以这样做！

以下是一个定义了自定义颜色比例并反映在图表中的 Plotly 图表示例：

```python
import plotly.express as px
import streamlit as st

st.subheader("Define a custom colorscale")
df = px.data.iris()
fig = px.scatter(
    df,
    x="sepal_width",
    y="sepal_length",
    color="sepal_length",
    color_continuous_scale="reds",
)

tab1, tab2 = st.tabs(["Streamlit theme (default)", "Plotly native theme"])
with tab1:
    st.plotly_chart(fig, theme="streamlit", use_container_width=True)
with tab2:
    st.plotly_chart(fig, theme=None, use_container_width=True)
```

注意，即使启用 Streamlit 主题，自定义颜色比例仍会反映在图表中 👇

<Cloud height="650px" name="doc-plotly-custom-colors"/>

有关更多使用和不使用 Streamlit 主题的 Plotly 图表示例，请查看 [plotly.streamlit.app](https://plotly.streamlit.app)。

---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.pydeck_chart


* Function signature:

   st.pydeck_chart(pydeck_obj=None, *, width="stretch", use_container_width=None, height=500, selection_mode="single-object", on_select="ignore", key=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | pydeck_obj | pydeck.Deck or None |  | Object specifying the PyDeck chart to draw. |
   | width | "stretch" or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | use_container_width | bool or None | behavior | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the chart's default behavior. True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |
   | height | "stretch" or int |  | The height of the chart element. This can be one of the following:  An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. This is 500 by default. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. |
   | on_select | "ignore" or "rerun" or callable |  | How the figure should respond to user selection events. This controls whether or not the chart behaves like an input widget. on_select can be one of the following:  "ignore" (default): Streamlit will not react to any selection events in the chart. The figure will not behave like an input widget. "rerun": Streamlit will rerun the app when the user selects data in the chart. In this case, st.pydeck_chart will return the selection data as a dictionary. A callable: Streamlit will rerun the app and execute the callable as a callback function before the rest of the app. In this case, st.pydeck_chart will return the selection data as a dictionary.  If on_select is not "ignore", all layers must have a declared id to keep the chart stateful across reruns. |
   | selection_mode | "single-object" or "multi-object" |  | The selection mode of the chart. This can be one of the following:  "single-object" (default): Only one object can be selected at a time. "multi-object": Multiple objects can be selected at a time. |
   | key | str |  | An optional string to use for giving this element a stable identity. If key is None (default), this element's identity will be determined based on the values of the other parameters. Additionally, if selections are activated and key is provided, Streamlit will register the key in Session State to store the selection state. The selection state is read-only. |

* Returns: element or dict

    If on_select is "ignore" (default), this command returns an
internal placeholder for the chart element. Otherwise, this method
returns a dictionary-like object that supports both key and
attribute notation. The attributes are described by the
PydeckState dictionary schema.



## Chart selections


* Function signature:

   PydeckState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | selection | dict |  | The state of the on_select event. This attribute returns a dictionary-like object that supports both key and attribute notation. The attributes are described by the PydeckSelectionState dictionary schema. |



* Function signature:

   PydeckSelectionState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | indices | dict[str, list[int]] |  | A dictionary of selected objects by layer. Each key in the dictionary is a layer id, and each value is a list of object indices within that layer. |
   | objects | dict[str, list[dict[str, Any]]] |  | A dictionary of object attributes by layer. Each key in the dictionary is a layer id, and each value is a list of metadata dictionaries for the selected objects in that layer. |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.pyplot


* Function signature:

   st.pyplot(fig=None, clear_figure=None, *, width="stretch", use_container_width=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | fig | Matplotlib Figure |  | The Matplotlib Figure object to render. See https://matplotlib.org/stable/gallery/index.html for examples.  Note When this argument isn't specified, this function will render the global Matplotlib figure object. However, this feature is deprecated and will be removed in a later version. |
   | clear_figure | bool | based | If True, the figure will be cleared after being rendered. If False, the figure will not be cleared after being rendered. If left unspecified, we pick a default based on the value of fig.  If fig is set, defaults to False. If fig is not set, defaults to True. This simulates Jupyter's approach to matplotlib rendering. |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | use_container_width | bool |  | Whether to override the figure's native width with the width of the parent container. If use_container_width is True (default), Streamlit sets the width of the figure to match the width of the parent container. If use_container_width is False, Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |
   | **kwargs | any |  | Arguments to pass to Matplotlib's savefig function. |


<Warning>
    Matplotlib [不支持线程](https://matplotlib.org/3.3.2/faq/howto_faq.html#working-with-threads)。因此，如果您使用 Matplotlib，您应该用锁包装您的代码。当您部署和共享应用时，这个 Matplotlib 错误会更加突出，因为您更有可能获得并发用户。以下示例使用 `threading` 模块的 [`Rlock`](https://docs.python.org/3/library/threading.html#rlock-objects)。

    ```python
    import streamlit as st
    import matplotlib.pyplot as plt
    import numpy as np
    from threading import RLock

    _lock = RLock()

    x = np.random.normal(1, 1, 100)
    y = np.random.normal(1, 1, 100)

    with _lock:
        fig, ax = plt.subplots()
        ax.scatter(x, y)
        st.pyplot(fig)
    ```

</Warning>

---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.scatter_chart


* Function signature:

   st.scatter_chart(data=None, *, x=None, y=None, x_label=None, y_label=None, color=None, size=None, width="stretch", height="content", use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | Data to be plotted. |
   | x | str or None |  | Column name or key associated to the x-axis data. If x is None (default), Streamlit uses the data index for the x-axis values. |
   | y | str, Sequence of str, or None |  | Column name(s) or key(s) associated to the y-axis data. If this is None (default), Streamlit draws the data of all remaining columns as data series. If this is a Sequence of strings, Streamlit draws several series on the same chart by melting your wide-format table into a long-format table behind the scenes. |
   | x_label | str or None |  | The label for the x-axis. If this is None (default), Streamlit will use the column name specified in x if available, or else no label will be displayed. |
   | y_label | str or None |  | The label for the y-axis. If this is None (default), Streamlit will use the column name(s) specified in y if available, or else no label will be displayed. |
   | color | str, tuple, Sequence of str, Sequence of tuple, or None | color | The color of the circles representing each datapoint. This can be:  None, to use the default color.  A hex string like "#ffaa00" or "#ffaa0088".  An RGB or RGBA tuple with the red, green, blue, and alpha components specified as ints from 0 to 255 or floats from 0.0 to 1.0.  The name of a column in the dataset where the color of that datapoint will come from. If the values in this column are in one of the color formats above (hex string or color tuple), then that color will be used. Otherwise, the color will be automatically picked from the default palette. For example: if the dataset has 1000 rows, but this column only contains the values "adult", "child", and "baby", then those 1000 datapoints be shown using three colors from the default palette. But if this column only contains floats or ints, then those 1000 datapoints will be shown using a colors from a continuous color gradient. Finally, if this column only contains the values "#ffaa00", "#f0f", "#0000ff", then then each of those 1000 datapoints will be assigned "#ffaa00", "#f0f", or "#0000ff" as appropriate.   If the dataframe is in wide format (that is, y is a Sequence of columns), this can also be:  A list of string colors or color tuples to be used for each of the series in the chart. This list should have the same length as the number of y values (e.g. color=["#fd0", "#f0f", "#04f"] for three series). |
   | size | str, float, int, or None |  | The size of the circles representing each point. This can be:  A number like 100, to specify a single size to use for all datapoints. The name of the column to use for the size. This allows each datapoint to be represented by a circle of a different size. |
   | width | "stretch", "content", or int |  | The width of the chart element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "stretch", "content", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None | behavior | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the chart's default behavior. True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/charts/st.vega_lite_chart


* Function signature:

   st.vega_lite_chart(data=None, spec=None, *, width=None, height="content", use_container_width=None, theme="streamlit", key=None, on_select="ignore", selection_mode=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | Either the data to be plotted or a Vega-Lite spec containing the data (which more closely follows the Vega-Lite API). |
   | spec | dict or None |  | The Vega-Lite spec for the chart. If spec is None (default), Streamlit uses the spec passed in data. You cannot pass a spec to both data and spec. See https://vega.github.io/vega-lite/docs/ for more info. |
   | width | "stretch", "content", int, or None |  | The width of the chart element. This can be one of the following:  "stretch": The width of the element matches the width of the parent container.  "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container.  An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container.  None (default): Streamlit uses "stretch" for most charts, and uses "content" for the following multi-view charts:   Facet charts: the spec contains "facet" or encodings for "row", "column", or "facet". Horizontal concatenation charts: the spec contains "hconcat". Repeat charts: the spec contains "repeat". |
   | height | "content", "stretch", or int |  | The height of the chart element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | use_container_width | bool or None |  | Whether to override the chart's native width with the width of the parent container. This can be one of the following:  None (default): Streamlit will use the parent container's width for all charts except those with known incompatibility (altair.Facet, altair.HConcatChart, and altair.RepeatChart). True: Streamlit sets the width of the chart to match the width of the parent container. False: Streamlit sets the width of the chart to fit its contents according to the plotting library, up to the width of the parent container. |
   | theme | "streamlit" or None | behavior | The theme of the chart. If theme is "streamlit" (default), Streamlit uses its own design default. If theme is None, Streamlit falls back to the default behavior of the library. The "streamlit" theme can be partially customized through the configuration options theme.chartCategoricalColors and theme.chartSequentialColors. Font configuration options are also applied. |
   | key | str |  | An optional string to use for giving this element a stable identity. If key is None (default), this element's identity will be determined based on the values of the other parameters. Additionally, if selections are activated and key is provided, Streamlit will register the key in Session State to store the selection state. The selection state is read-only. |
   | on_select | "ignore", "rerun", or callable |  | How the figure should respond to user selection events. This controls whether or not the figure behaves like an input widget. on_select can be one of the following:  "ignore" (default): Streamlit will not react to any selection events in the chart. The figure will not behave like an input widget. "rerun": Streamlit will rerun the app when the user selects data in the chart. In this case, st.vega_lite_chart will return the selection data as a dictionary. A callable: Streamlit will rerun the app and execute the callable as a callback function before the rest of the app. In this case, st.vega_lite_chart will return the selection data as a dictionary.  To use selection events, the Vega-Lite spec defined in data or spec must include selection parameters from the charting library. To learn about defining interactions in Vega-Lite, see Dynamic Behaviors with Parameters in Vega-Lite's documentation. |
   | selection_mode | str or Iterable of str |  | The selection parameters Streamlit should use. If selection_mode is None (default), Streamlit will use all selection parameters defined in the chart's Vega-Lite spec. When Streamlit uses a selection parameter, selections from that parameter will trigger a rerun and be included in the selection state. When Streamlit does not use a selection parameter, selections from that parameter will not trigger a rerun and not be included in the selection state. Selection parameters are identified by their name property. |
   | **kwargs | any |  | The Vega-Lite spec for the chart as keywords. This is an alternative to spec. |

* Returns: element or dict

    If on_select is "ignore" (default), this command returns an
internal placeholder for the chart element that can be used with
the .add_rows() method. Otherwise, this command returns a
dictionary-like object that supports both key and attribute
notation. The attributes are described by the VegaLiteState
dictionary schema.



## Chart selections


* Function signature:

   VegaLiteState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | selection | dict |  | The state of the on_select event. This attribute returns a dictionary-like object that supports both key and attribute notation. The name of each Vega-Lite selection parameter becomes an attribute in the selection dictionary. The format of the data within each attribute is determined by the selection parameter definition within Vega-Lite. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

# Chat elements

Source: https://docs.streamlit.io/develop/api-reference/chat


Streamlit provides a few commands to help you build conversational apps. These chat elements are designed to be used in conjunction with each other, but you can also use them separately.

`st.chat_message` lets you insert a chat message container into the app so you can display messages from the user or the app. Chat containers can contain other Streamlit elements, including charts, tables, text, and more. `st.chat_input` lets you display a chat input widget so the user can type in a message. Remember to check out `st.status` to display output from long-running processes and external API calls.

<TileContainer>
<RefCard href="/develop/api-reference/chat/st.chat_input">
<Image>alt="screenshot" src="/images/api/chat_input.jpg" /&gt;

<h4>Chat input</h4>

Display a chat input widget.

```python
prompt = st.chat_input("Say something")
if prompt:
    st.write(f"The user has sent: {prompt}")
```

</Image>
<RefCard href="/develop/api-reference/chat/st.chat_message">
<Image>alt="screenshot" src="/images/api/chat_message.jpg" /&gt;

<h4>Chat message</h4>

Insert a chat message container.

```python
import numpy as np
with st.chat_message("user"):
    st.write("Hello 👋")
    st.line_chart(np.random.randn(30, 3))
```

</Image>
<RefCard href="/develop/api-reference/status/st.status">
<Image>alt="screenshot" src="/images/api/status.jpg" /&gt;

<h4>Status container</h4>

Display output of long-running tasks in a container.

```python
with st.status('Running'):
  do_something_slow()
```

</Image>
<RefCard href="/develop/api-reference/write-magic/st.write_stream">
<h4>st.write_stream</h4>

Write generators or streams to the app with a typewriter effect.

```python
st.write_stream(my_generator)
st.write_stream(my_llm_stream)
```

</RefCard>
</RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/chat/st.chat_input

<Tip>

Read the [Build a basic LLM chat app](/develop/tutorials/llms/build-conversational-apps) tutorial to learn how to use `st.chat_message` and `st.chat_input` to build chat-based apps.

</Tip>

* Function signature:

   st.chat_input(placeholder="Your message", *, key=None, max_chars=None, accept_file=False, file_type=None, accept_audio=False, audio_sample_rate=16000, disabled=False, on_submit=None, args=None, kwargs=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | placeholder | str | s | A placeholder text shown when the chat input is empty. This defaults to "Your message". For accessibility reasons, you should not use an empty string. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | max_chars | int or None |  | The maximum number of characters that can be entered. If this is None (default), there will be no maximum. |
   | accept_file | bool, "multiple", or "directory" |  | Whether the chat input should accept files. This can be one of the following values:  False (default): No files are accepted and the user can only submit a message. True: The user can add a single file to their submission. "multiple": The user can add multiple files to their submission. "directory": The user can add multiple files to their submission by selecting a directory. If file_type is set, only files matching those type(s) will be uploaded.  By default, uploaded files are limited to 200 MB each. You can configure this using the server.maxUploadSize config option. For more information on how to set config options, see config.toml. |
   | file_type | str, Sequence[str], or None |  | The allowed file extension(s) for uploaded files. This can be one of the following types:  None (default): All file extensions are allowed. A string: A single file extension is allowed. For example, to only accept CSV files, use "csv". A sequence of strings: Multiple file extensions are allowed. For example, to only accept JPG/JPEG and PNG files, use ["jpg", "jpeg", "png"].   Note This is a best-effort check, but doesn't provide a security guarantee against users uploading files of other types or type extensions. The correct handling of uploaded files is part of the app developer's responsibility. |
   | accept_audio | bool | s | Whether to show an audio recording button in the chat input. This defaults to False. If this is True, users can record and submit audio messages. Recorded audio is available as an UploadedFile object with MIME type audio/wav. |
   | audio_sample_rate | int or None | s | The target sample rate for audio recording in Hz when accept_audio is True. This defaults to 16000, which is optimal for speech recognition. The following values are supported: 8000 (telephone quality), 11025, 16000 (speech-recognition quality), 22050, 24000, 32000, 44100, 48000 (high-quality), or None. If this is None, the widget uses the browser's default sample rate (typically 44100 or 48000 Hz). |
   | disabled | bool | s | Whether the chat input should be disabled. This defaults to False. |
   | on_submit | callable |  | An optional callback invoked when the chat input's value is submitted. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | width | "stretch" or int |  | The width of the chat input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: None, str, or dict-like

    The user's submission. This is one of the following types:

None: If the user didn't submit a message, file, or audio
recording in the last rerun, the widget returns None.
A string: When the widget isn't configured to accept files or
audio recordings, and the user submitted a message in the last
rerun, the widget returns the user's message as a string.
A dict-like object: When the widget is configured to accept files
or audio recordings, and the user submitted any content in the
last rerun, the widget returns a dict-like object.
The object always includes the text attribute, and
optionally includes files and/or audio attributes depending
on the accept_file and accept_audio parameters.

When the widget is configured to accept files or audio recordings,
and the user submitted content in the last rerun, you can access
the user's submission with key or attribute notation from the
dict-like object. This is shown in Example 3 below.

The text attribute holds a string that is the user's message.
This is an empty string if the user only submitted one or more
files or audio recordings.
The files attribute is only present when accept_file
isn't False. When present, it holds a list of
UploadedFile objects. The list is empty if the user only
submitted a message or audio recording. Unlike
st.file_uploader, this attribute always returns a list, even
when the widget is configured to accept only one file at a time.
The audio attribute is only present when accept_audio is
True. When present, it holds an UploadedFile object if
audio was recorded or None if no audio was recorded.

The UploadedFile class is a subclass of BytesIO and
therefore is "file-like". This means you can pass an instance of it
anywhere a file is expected.



For an overview of the `st.chat_input` and `st.chat_message` API, check out this video tutorial by Chanin Nantasenamat ([@dataprofessor](https://www.youtube.com/dataprofessor)), a Senior Developer Advocate at Streamlit.

<YouTube videoId="4sPnOqeUDmk"/>

---

Source: https://docs.streamlit.io/develop/api-reference/chat/st.chat_message

<Tip>

Read the [Build a basic LLM chat app](/develop/tutorials/llms/build-conversational-apps) tutorial to learn how to use `st.chat_message` and `st.chat_input` to build chat-based apps.

</Tip>

* Function signature:

   st.chat_message(name, *, avatar=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | "user", "assistant", "ai", "human", or str |  | The name of the message author. Can be "human"/"user" or "ai"/"assistant" to enable preset styling and avatars. Currently, the name is not shown in the UI but is only set as an accessibility label. For accessibility reasons, you should not use an empty string. |
   | avatar | Anything supported by st.image (except list), str, or None | user | The avatar shown next to the message. If avatar is None (default), the icon will be determined from name as follows:  If name is "user" or "human", the message will have a default user icon. If name is "ai" or "assistant", the message will have a default bot icon. For all other values of name, the message will show the first letter of the name.  In addition to the types supported by st.image (except list), the following strings are valid:  A single-character emoji. For example, you can set avatar="🧑‍💻" or avatar="🦖". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch", "content", or int |  | The width of the chat message container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. "content": The width of the container matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |

* Returns: Container

    A single container that can hold multiple elements.



For an overview of the `st.chat_message` and `st.chat_input` API, check out this video tutorial by Chanin Nantasenamat ([@dataprofessor](https://www.youtube.com/dataprofessor)), a Senior Developer Advocate at Streamlit.

<YouTube videoId="4sPnOqeUDmk"/>

---

# Command-line interface

Source: https://docs.streamlit.io/develop/api-reference/cli


When you install Streamlit, a command-line (CLI) tool gets installed
as well. The purpose of this tool is to run Streamlit apps, change Streamlit configuration options,
and help you diagnose and fix issues.

## Available commands

- [`streamlit cache clear`](/develop/api-reference/cli/cache): Clear the on-disk cache.
- [`streamlit config show`](/develop/api-reference/cli/config): Show all configuration options.
- [`streamlit docs`](/develop/api-reference/cli/docs): Open the Streamlit docs.
- [`streamlit hello`](/develop/api-reference/cli/hello): Run an example Streamlit app.
- [`streamlit help`](/develop/api-reference/cli/help): Show the available CLI commands.
- [`streamlit init`](/develop/api-reference/cli/init): Create the files for a new Streamlit app.
- [`streamlit run`](/develop/api-reference/cli/run): Run your Streamlit app.
- [`streamlit version`](/develop/api-reference/cli/version): Show the version of Streamlit.

### Run your app

The most important command is `streamlit run`, which is summarized for convenience here:

```bash
streamlit run your_script.py
```

At any time, in your terminal, you can stop the server with **Ctrl+C**.

---

Source: https://docs.streamlit.io/develop/api-reference/cli/cache

## `$ streamlit cache clear`

Clear persisted files from the on-disk [Streamlit cache](/develop/api-reference/caching-and-state), if present.

### Syntax

```
streamlit cache clear
```

---

Source: https://docs.streamlit.io/develop/api-reference/cli/config

## `$ streamlit config show`

Print all the available configuration options, including their descriptions, default values, and current values. For more information about configuration options, see [`config.toml`](/develop/api-reference/configuration/config.toml).

### Syntax

```
streamlit config show
```

---

Source: https://docs.streamlit.io/develop/api-reference/cli/docs

## `$ streamlit docs`

Open the Streamlit docs in your default browser.

### Syntax

```
streamlit docs
```

---

Source: https://docs.streamlit.io/develop/api-reference/cli/hello

## `$ streamlit hello`

Run the Hello app, an example Streamlit app included with the Streamlit library.

### Syntax

```
streamlit hello
```

### Options

The `hello` command accepts configuration options (just like the `run` command does). Configuration options are passed in the form of `--<section>.<option>=<value>`. For example, if you want to set the primary color of your app to blue, you could use one of the three equivalent options:

- `--theme.primaryColor=blue`
- `--theme.primaryColor="blue"`
- `--theme.primaryColor=#0000FF`

For a complete list of configuration options, see [`config.toml`](/develop/api-reference/configuration/config.toml) in the API reference. For examples, see below.

### Example

#### Example 1: Run the Hello app with default settings

To verify that Streamlit is installed correctly, this command runs an example app included in the Streamlit library. From any directory, execute the following:

```
streamlit hello
```

Streamlit will start the Hello app and open it in your default browser. The source for the Hello app can be [viewed in GitHub](https://github.com/streamlit/streamlit/tree/develop/lib/streamlit/hello).

#### Example 2: Run the Hello app with a custom config option value

To run the Hello app with a blue accent color, from any directory, execute the following:

```
streamlit hello --theme.primaryColor=blue
```</value></option></section>

---

Source: https://docs.streamlit.io/develop/api-reference/cli/help

## `$ streamlit help`

Print the available commands for the Streamlit CLI tool. This command is equivalent to executing `streamlit --help`.

### Syntax

```
streamlit help
```

---

Source: https://docs.streamlit.io/develop/api-reference/cli/init

## `$ streamlit init`

This command creates the files for a new Streamlit app.

### Syntax

```
streamlit init <directory>
```

### Arguments

`<directory>` (Optional): The directory location of the new project. If no directory is provided, the current working directory will be used.

### Examples

#### Example 1: Create project files the current working directory

1. In your current working directory (CWD), execute the following:

   ```bash
   streamlit init
   ```

   Streamlit creates the following files:

   ```
   CWD/
   ├── requirements.txt
   └── streamlit_app.py
   ```

2. In your terminal, Streamlit prompts, `❓ Run the app now? [Y/n]`. Enter `Y` for yes.

   This is equivalent to executing `streamlit run streamlit_app.py` from your current working directory.

3. Begin editing your `streamlit_app.py` file and save your changes.

#### Example 2: Create project files in another directory

1. In your current working directory (CWD), execute the following:

   ```bash
   streamlit init project
   ```

   Streamlit creates the following files:

   ```
   CWD/
   └── project/
       ├── requirements.txt
       └── streamlit_app.py
   ```

2. In your terminal, Streamlit prompts, `❓ Run the app now? [Y/n]`. Enter `Y` for yes.

   This is equivalent to executing `streamlit run project/streamlit_app.py` from your current working directory.

3. Begin editing your `streamlit_app.py` file and save your changes.</directory></directory>

---

Source: https://docs.streamlit.io/develop/api-reference/cli/run

## `$ streamlit run`

This command starts your Streamlit app.

### Syntax

```
streamlit run [<entrypoint>or directory&gt;] [-- config options] [script args]
```

### Arguments

`<entrypoint>or directory&gt;` (optional): The path to your entrypoint file or directory for your Streamlit app.

- **If not provided**: Streamlit will try to run `streamlit_app.py` from the current working directory.
- **If a directory path is provided**: Streamlit will try to run `streamlit_app.py` in the specified directory.
- **If a file path is provided**: Streamlit will run the specified file.

In a multipage app with `st.navigation`, your entrypoint file acts as a router between your pages. Otherwise, your entrypoint file is your app's homepage.

### Options

Configuration options are passed in the form of `--<section>.<option>=<value>`. For example, if you want to set the primary color of your app to blue, you could use one of the three equivalent options:

- `--theme.primaryColor=blue`
- `--theme.primaryColor="blue"`
- `--theme.primaryColor=#0000FF`

For a complete list of configuration options, see [`config.toml`](/develop/api-reference/configuration/config.toml) in the API reference. For examples, see below.

### Script arguments

If you need to pass arguments directly to your script, you can pass them as positional arguments. If you use `sys.argv` to read your arguments, `sys.argv` returns a list of all arguments and does _not_ include any configuration options. Python interprets all arguments as strings.

- `sys.argv[0]` returns the the path to your entrypoint file, even if you did not explicitly provide it.
- `sys.argv[1:]` returns a list of arguments in order and does not include any configuration options.

### Examples

- If your app is named `streamlit_app.py` in your working directory, you can run it with the following command:

  ```
  streamlit run
  ```

- If your app has a different name and is in your working directory, run it like the following command:

  ```
  streamlit run your_app.py
  ```

- If your app is named `streamlit_app.py` in a subdirectory, you can run it like the following command:

  ```
  streamlit run your_subdirectory
  ```

- If your app has a different name and is in a subdirectory, run it like the following command:

  ```
  streamlit run your_subdirectory/your_app.py
  ```

- If your app is saved in a public GitHub repo or gist, run it like the following command:

  ```
  streamlit run https://raw.githubusercontent.com/streamlit/demo-uber-nyc-pickups/master/streamlit_app.py
  ```

- If you need to set one or more configuration options, run it like the following command:

  ```
  streamlit run your_app.py --client.showErrorDetails=False --theme.primaryColor=blue
  ```

  Or if using the default `streamlit_app.py`:

  ```
  streamlit run --client.showErrorDetails=False --theme.primaryColor=blue
  ```

- If you need to pass an argument to your script, run it like the following command:

  ```
  streamlit run your_app.py "my list" of arguments
  ```

  Within your script, the following statements will be true:

  ```
  sys.argv[0] == "your_app.py"
  sys.argv[1] == "my list"
  sys.argv[2] == "of"
  sys.argv[3] == "arguments"
  ```</value></option></section></entrypoint></entrypoint>

---

Source: https://docs.streamlit.io/develop/api-reference/cli/version

## `$ streamlit version`

Print Streamlit's version number. This command is equivalent to executing `streamlit --version`.

### Syntax

```
streamlit version
```

---

# Configuration

Source: https://docs.streamlit.io/develop/api-reference/configuration


<TileContainer>
<RefCard href="/develop/api-reference/configuration/config.toml">
<h4>Configuration file</h4>

Configures the default settings for your app.

```
your-project/
├── .streamlit/
│   └── config.toml
└── your_app.py
```

</RefCard>
<RefCard href="/develop/api-reference/configuration/st.get_option">
<h4>Get config option</h4>

Retrieve a single configuration option.

```python
st.get_option("theme.primaryColor")
```

</RefCard>
<RefCard href="/develop/api-reference/configuration/st.set_option">
<h4>Set config option</h4>

Set a single configuration option. (This is very limited.)

```python
st.set_option("deprecation.showPyplotGlobalUse", False)
```

</RefCard>
<RefCard href="/develop/api-reference/configuration/st.set_page_config">
<h4>Set page title, favicon, and more</h4>

Configures the default settings of the page.

```python
st.set_page_config(
  page_title="My app",
  page_icon=":shark:",
)
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/configuration/config.toml

## config.toml

`config.toml` is an optional file you can define for your working directory or global development environment. When `config.toml` is defined both globally and in your working directory, Streamlit combines the configuration options and gives precedence to the working-directory configuration. Additionally, you can use environment variables and command-line options to override additional configuration options. For more information, see [Configuration options](/develop/concepts/configuration/options).

### File location

To define your configuration locally or per-project, add `.streamlit/config.toml` to your working directory. Your working directory is wherever you call `streamlit run`. If you haven't previously created the `.streamlit` directory, you will need to add it.

To define your configuration globally, you must first locate your global `.streamlit` directory. Streamlit adds this hidden directory to your OS user profile during installation. For MacOS/Linux, this will be `~/.streamlit/config.toml`. For Windows, this will be `%userprofile%/.streamlit/config.toml`.

### File format

`config.toml` is a [TOML](https://toml.io/en/) file.

#### Example

```toml
[client]
showErrorDetails = "none"

[theme]
primaryColor = "#F63366"
backgroundColor = "black"
```

### Available configuration options

Below are all the sections and options you can have in your `.streamlit/config.toml` file. To see all configurations, use the following command in your terminal or CLI:

```bash
streamlit config show
```

#### Global

```toml
[global]

# By default, Streamlit displays a warning when a user sets both a widget
# default value in the function defining the widget and a widget value via
# the widget's key in `st.session_state`.
#
# If you'd like to turn off this warning, set this to True.
#
# Default: false
disableWidgetStateDuplicationWarning = false

# If True, will show a warning when you run a Streamlit-enabled script
# via "python my_script.py".
#
# Default: true
showWarningOnDirectExecution = true
```

#### Logger

```toml
[logger]

# Level of logging for Streamlit's internal logger: "error", "warning",
# "info", or "debug".
#
# Default: "info"
level = "info"

# String format for logging messages. If logger.datetimeFormat is set,
# logger messages will default to `%(asctime)s.%(msecs)03d %(message)s`.
#
# See Python's documentation for available attributes:
# https://docs.python.org/3/library/logging.html#formatter-objects
#
# Default: "%(asctime)s %(message)s"
messageFormat = "%(asctime)s %(message)s"
```

#### Client

```toml
[client]

# Controls whether uncaught app exceptions and deprecation warnings
# are displayed in the browser. This can be one of the following:
#
# - "full"       : In the browser, Streamlit displays app deprecation
#                  warnings and exceptions, including exception types,
#                  exception messages, and associated tracebacks.
# - "stacktrace" : In the browser, Streamlit displays exceptions,
#                  including exception types, generic exception messages,
#                  and associated tracebacks. Deprecation warnings and
#                  full exception messages will only print to the
#                  console.
# - "type"       : In the browser, Streamlit displays exception types and
#                  generic exception messages. Deprecation warnings, full
#                  exception messages, and associated tracebacks only
#                  print to the console.
# - "none"       : In the browser, Streamlit displays generic exception
#                  messages. Deprecation warnings, full exception
#                  messages, associated tracebacks, and exception types
#                  will only print to the console.
# - True         : This is deprecated. Streamlit displays "full"
#                  error details.
# - False        : This is deprecated. Streamlit displays "stacktrace"
#                  error details.
#
# Default: "full"
showErrorDetails = "full"

# Change the visibility of items in the toolbar, options menu,
# and settings dialog (top right of the app).
#
# Allowed values:
# - "auto"      : Show the developer options if the app is accessed through
#                 localhost or through Streamlit Community Cloud as a developer.
#                 Hide them otherwise.
# - "developer" : Show the developer options.
# - "viewer"    : Hide the developer options.
# - "minimal"   : Show only options set externally (e.g. through
#                 Streamlit Community Cloud) or through st.set_page_config.
#                 If there are no options left, hide the menu.
#
# Default: "auto"
toolbarMode = "auto"

# Controls whether to display the default sidebar page navigation in a
# multi-page app. This only applies when app's pages are defined by the
# `pages/` directory.
#
# Default: true
showSidebarNavigation = true
```

#### Runner

```toml
[runner]

# Allows you to type a variable or string by itself in a single line of
# Python code to write it to the app.
#
# Default: true
magicEnabled = true

# Handle script rerun requests immediately, rather than waiting for
# script execution to reach a yield point.
#
# This makes Streamlit much more responsive to user interaction, but it
# can lead to race conditions in apps that mutate session_state data
# outside of explicit session_state assignment statements.
#
# Default: true
fastReruns = true

# Raise an exception after adding unserializable data to Session State.
#
# Some execution environments may require serializing all data in Session
# State, so it may be useful to detect incompatibility during development,
# or when the execution environment will stop supporting it in the future.
#
# Default: false
enforceSerializableSessionState = false

# Adjust how certain 'options' widgets like radio, selectbox, and
# multiselect coerce Enum members.
#
# This is useful when the Enum class gets re-defined during a script
# re-run. For more information, check out the docs:
# https://docs.streamlit.io/develop/concepts/design/custom-classes#enums
#
# Allowed values:
# - "off"          : Disables Enum coercion.
# - "nameOnly"     : Enum classes can be coerced if their member names match.
# - "nameAndValue" : Enum classes can be coerced if their member names AND
#                    member values match.
#
# Default: "nameOnly"
enumCoercion = "nameOnly"
```

#### Server

```toml
[server]

# List of directories to watch for changes.
#
# By default, Streamlit watches files in the current working directory
# and its subdirectories. Use this option to specify additional
# directories to watch. Paths must be absolute.
#
# Default: []
folderWatchList = []

# List of directories to ignore for changes.
#
# By default, Streamlit watches files in the current working directory
# and its subdirectories. Use this option to specify exceptions within
# watched directories. Paths can be absolute or relative to the current
# working directory.
#
# Example: ['/home/user1/env', 'relative/path/to/folder']
#
# Default: []
folderWatchBlacklist = []

# Change the type of file watcher used by Streamlit, or turn it off
# completely.
#
# Allowed values:
# - "auto"     : Streamlit will attempt to use the watchdog module, and
#                falls back to polling if watchdog isn't available.
# - "watchdog" : Force Streamlit to use the watchdog module.
# - "poll"     : Force Streamlit to always use polling.
# - "none"     : Streamlit will not watch files.
#
# Default: "auto"
fileWatcherType = "auto"

# Symmetric key used to produce signed cookies. If deploying on multiple
# replicas, this should be set to the same value across all replicas to ensure
# they all share the same secret.
#
# Default: randomly generated secret key.
cookieSecret = "a-random-key-appears-here"

# If false, will attempt to open a browser window on start.
#
# Default: false unless (1) we are on a Linux box where DISPLAY is unset, or
# (2) we are running in the Streamlit Atom plugin.
headless = false

# Whether to show a terminal prompt for the user's email address when
# they run Streamlit (locally) for the first time. If you set
# `server.headless=True`, Streamlit will not show this prompt.
#
# Default: true
showEmailPrompt = true

# Automatically rerun script when the file is modified on disk.
#
# Default: false
runOnSave = false

# The address where the server will listen for client and browser
# connections.
#
# Use this if you want to bind the server to a specific address.
# If set, the server will only be accessible from this address, and not from
# any aliases (like localhost).
#
# Default: (unset)
address =

# The port where the server will listen for browser connections.
#
# Default: 8501
port = 8501

# The base path for the URL where Streamlit should be served from.
#
# Default: ""
baseUrlPath = ""

# Enables support for Cross-Origin Resource Sharing (CORS) protection,
# for added security.
#
# If XSRF protection is enabled and CORS protection is disabled at the
# same time, Streamlit will enable them both instead.
#
# Default: true
enableCORS = true

# Allowed list of origins.
#
# If CORS protection is enabled (`server.enableCORS=True`), use this
# option to set a list of allowed origins that the Streamlit server will
# accept traffic from.
#
# This config option does nothing if CORS protection is disabled.
#
# Example: ['http://example.com', 'https://streamlit.io']
#
# Default: []
corsAllowedOrigins = []

# Enables support for Cross-Site Request Forgery (XSRF) protection, for
# added security.
#
# If XSRF protection is enabled and CORS protection is disabled at the
# same time, Streamlit will enable them both instead.
#
# Default: true
enableXsrfProtection = true

# Max size, in megabytes, for files uploaded with the file_uploader.
#
# Default: 200
maxUploadSize = 200

# Max size, in megabytes, of messages that can be sent via the WebSocket
# connection.
#
# Default: 200
maxMessageSize = 200

# Enables support for websocket compression.
#
# Default: false
enableWebsocketCompression = false

# The interval (in seconds) at which the server pings the client to keep
# the websocket connection alive.
#
# The default value should work for most deployments. However, if you're
# experiencing frequent disconnections in certain proxy setups (e.g.,
# "Connection error" messages), you may want to try adjusting this value.
#
# Note: When you set this option, Streamlit automatically sets the ping
# timeout to match this interval. For Tornado &gt;=6.5, a value less than 30
# may cause connection issues.
websocketPingInterval =

# Enable serving files from a `static` directory in the running app's
# directory.
#
# Default: false
enableStaticServing = false

# TTL in seconds for sessions whose websockets have been disconnected.
#
# The server may choose to clean up session state, uploaded files, etc
# for a given session with no active websocket connection at any point
# after this time has passed. If you are using load balancing or
# replication in your deployment, you must enable session stickiness
# in your proxy to guarantee reconnection to the existing session. For
# more information, see https://docs.streamlit.io/replication.
#
# Default: 120
disconnectedSessionTTL = 120

# Server certificate file for connecting via HTTPS.
# Must be set at the same time as "server.sslKeyFile".
#
# ['DO NOT USE THIS OPTION IN A PRODUCTION ENVIRONMENT. It has not gone through
# security audits or performance tests. For a production environment, we
# recommend performing SSL termination through a load balancer or reverse
# proxy.']
sslCertFile =

# Cryptographic key file for connecting via HTTPS.
# Must be set at the same time as "server.sslCertFile".
#
# ['DO NOT USE THIS OPTION IN A PRODUCTION ENVIRONMENT. It has not gone through
# security audits or performance tests. For a production environment, we
# recommend performing SSL termination through a load balancer or reverse
# proxy.']
sslKeyFile =
```

#### Browser

```toml
[browser]

# Internet address where users should point their browsers in order to
# connect to the app. Can be IP address or DNS name and path.
#
# This is used to:
# - Set the correct URL for CORS and XSRF protection purposes.
# - Show the URL on the terminal
# - Open the browser
#
# Default: "localhost"
serverAddress = "localhost"

# Whether to send usage statistics to Streamlit.
#
# Default: true
gatherUsageStats = true

# Port where users should point their browsers in order to connect to the
# app.
#
# This is used to:
# - Set the correct URL for XSRF protection purposes.
# - Show the URL on the terminal (part of `streamlit run`).
# - Open the browser automatically (part of `streamlit run`).
#
# This option is for advanced use cases. To change the port of your app, use
# `server.Port` instead.
#
# Default: whatever value is set in server.port.
serverPort = 8501
```

#### Mapbox

```toml
[mapbox]

# If you'd like to show maps using Mapbox rather than Carto, use this
# to pass the Mapbox API token.
#
# THIS IS DEPRECATED.
#
# Instead of this, you should use either the MAPBOX_API_KEY environment
# variable or PyDeck's `api_keys` argument.
#
# This option will be removed on or after 2026-05-01.
#
# Default: ""
token = ""
```

#### Theme

To define switchable light and dark themes, the configuration options in the
`[theme]` table can be used in separate `[theme.dark]` and `[theme.light]`
tables, except for the following options:

- `base`
- `fontFaces`
- `baseFontSize`
- `baseFontWeight`
- `showSidebarBorder`
- `chartCategoricalColors`
- `chartSequentialColors`

```toml
[theme]

# The theme that your custom theme inherits from.
#
# This can be one of the following:
# - "light": Streamlit's default light theme.
# - "dark" : Streamlit's default dark theme.
# - A local file path to a TOML theme file: A local custom theme, like
#   "themes/custom.toml".
# - A URL to a TOML theme file: An externally hosted custom theme, like
#   "https://example.com/theme.toml".
#
# A TOML theme file must contain a [theme] table with theme options.
# Any theme options defined in the app's config.toml file will override
# those defined in the TOML theme file.
base =

# Primary accent color.
primaryColor =

# Background color of the app.
backgroundColor =

# Background color used for most interactive widgets.
secondaryBackgroundColor =

# Color used for almost all text.
textColor =

# Red color used in the basic color palette.
#
# By default, this is #ff4b4b for the light theme and #ff2b2b for the
# dark theme.
#
# If `redColor` is provided, and `redBackgroundColor` isn't, then
# `redBackgroundColor` will be derived from `redColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
redColor =

# Orange color used in the basic color palette.
#
# By default, this is #ffa421 for the light theme and #ff8700 for the
# dark theme.
#
# If `orangeColor` is provided, and `orangeBackgroundColor` isn't, then
# `orangeBackgroundColor` will be derived from `orangeColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
orangeColor =

# Yellow color used in the basic color palette.
#
# By default, this is #faca2b for the light theme and #ffe312 for the
# dark theme.
#
# If `yellowColor` is provided, and `yellowBackgroundColor` isn't, then
# `yellowBackgroundColor` will be derived from `yellowColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
yellowColor =

# Blue color used in the basic color palette.
#
# By default, this is #1c83e1 for the light theme and #0068c9 for the
# dark theme.
#
# If a `blueColor` is provided, and `blueBackgroundColor` isn't, then
# `blueBackgroundColor` will be derived from `blueColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
blueColor =

# Green color used in the basic color palette.
#
# By default, this is #21c354 for the light theme and #09ab3b for the
# dark theme.
#
# If `greenColor` is provided, and `greenBackgroundColor` isn't, then
# `greenBackgroundColor` will be derived from `greenColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
greenColor =

# Violet color used in the basic color palette.
#
# By default, this is #803df5 for both the light and dark themes.
#
# If a `violetColor` is provided, and `violetBackgroundColor` isn't, then
# `violetBackgroundColor` will be derived from `violetColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
violetColor =

# Gray color used in the basic color palette.
#
# By default, this is #a3a8b8 for the light theme and #555867 for the
# dark theme.
#
# If `grayColor` is provided, and `grayBackgroundColor` isn't, then
# `grayBackgroundColor` will be derived from `grayColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
grayColor =

# Red background color used in the basic color palette.
#
# If `redColor` is provided, this defaults to `redColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ff2b2b with 10% opacity for light theme and
# #ff6c6c with 20% opacity for dark theme.
redBackgroundColor =

# Orange background color used for the basic color palette.
#
# If `orangeColor` is provided, this defaults to `orangeColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ffa421 with 10% opacity for the light theme and
# #ff8700 with 20% opacity for the dark theme.
orangeBackgroundColor =

# Yellow background color used for the basic color palette.
#
# If `yellowColor` is provided, this defaults to `yellowColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ffff12 with 10% opacity for the light theme and
# #ffff12 with 20% opacity for the dark theme.
yellowBackgroundColor =

# Blue background color used for the basic color palette.
#
# If `blueColor` is provided, this defaults to `blueColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #1c83ff with 10% opacity for the light theme and
# #3d9df3 with 20% opacity for the dark theme.
blueBackgroundColor =

# Green background color used for the basic color palette.
#
# If `greenColor` is provided, this defaults to `greenColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #21c354 with 10% opacity for the light theme and
# #3dd56d with 20% opacity for the dark theme.
greenBackgroundColor =

# Violet background color used for the basic color palette.
#
# If `violetColor` is provided, this defaults to `violetColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #9a5dff with 10% opacity for light theme and
# #9a5dff with 20% opacity for dark theme.
violetBackgroundColor =

# Gray background color used for the basic color palette.
#
# If `grayColor` is provided, this defaults to `grayColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #31333f with 10% opacity for the light theme and
# #808495 with 20% opacity for the dark theme.
grayBackgroundColor =

# Red text color used for the basic color palette.
#
# If `redColor` is provided, this defaults to `redColor`, darkened by 15%
# for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #bd4043 for the light theme and #ff6c6c for the dark
# theme.
redTextColor =

# Orange text color used for the basic color palette.
#
# If `orangeColor` is provided, this defaults to `orangeColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #e2660c for the light theme and #ffbd45 for the dark
# theme.
orangeTextColor =

# Yellow text color used for the basic color palette.
#
# If `yellowColor` is provided, this defaults to `yellowColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #926c05 for the light theme and #ffffc2 for the dark
# theme.
yellowTextColor =

# Blue text color used for the basic color palette.
#
# If `blueColor` is provided, this defaults to `blueColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #0054a3 for the light theme and #3d9df3 for the dark
# theme.
blueTextColor =

# Green text color used for the basic color palette.
#
# If `greenColor` is provided, this defaults to `greenColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #158237 for the light theme and #5ce488 for the dark
# theme.
greenTextColor =

# Violet text color used for the basic color palette.
#
# If `violetColor` is provided, this defaults to `violetColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #583f84 for the light theme and #b27eff for the dark
# theme.
violetTextColor =

# Gray text color used for the basic color palette.
#
# If `grayColor` is provided, this defaults to `grayColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #31333f with 60% opacity for the light theme and
# #fafafa with 60% opacity for the dark theme.
grayTextColor =

# Color used for all links.
#
# This defaults to the resolved value of `blueTextColor`.
linkColor =

# Whether or not links should be displayed with an underline.
linkUnderline =

# Text color used for code blocks.
#
# This defaults to the resolved value of `greenTextColor`.
codeTextColor =

# Background color used for code blocks.
codeBackgroundColor =

# The font family for all text, except code blocks.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "Nunito:https://fonts.googleapis.com/css2?family=Nunito=swap")
# - A comma-separated list of these (as a single string) to specify
#   fallbacks
#
# For example, you can use the following:
#
# font = "cool-font, fallback-cool-font, sans-serif"
font =

# An array of fonts to use in your app.
#
# Each font in the array is a table (dictionary) that can have the
# following attributes, closely resembling CSS font-face definitions:
# - family
# - url
# - weight (optional)
# - style (optional)
# - unicodeRange (optional)
#
# To host a font with your app, enable static file serving with
# `server.enableStaticServing=true`.
#
# You can define multiple [[theme.fontFaces]] tables, including multiple
# tables with the same family if your font is defined by multiple files.
#
# For example, a font hosted with your app may have a [[theme.fontFaces]]
# table as follows:
#
# [[theme.fontFaces]]
# family = "font_name"
# url = "app/static/font_file.woff"
# weight = "400"
# style = "normal"
fontFaces =

# The root font size (in pixels) for the app.
#
# This determines the overall scale of text and UI elements. This is a
# positive integer.
#
# If this isn't set, the font size will be 16px.
baseFontSize =

# The root font weight for the app.
#
# This determines the overall weight of text and UI elements. This is an
# integer multiple of 100. Values can be between 100 and 600, inclusive.
#
# If this isn't set, the font weight will be set to 400 (normal weight).
baseFontWeight =

# The font family to use for headings.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "Nunito:https://fonts.googleapis.com/css2?family=Nunito=swap")
# - A comma-separated list of these (as a single string) to specify
#   fallbacks
#
# If this isn't set, Streamlit uses `theme.font` for headings.
headingFont =

# One or more font sizes for h1-h6 headings.
#
# If no sizes are set, Streamlit will use the default sizes for h1-h6
# headings. Heading font sizes set in [theme] are not inherited by
# [theme.sidebar]. The following sizes are used by default:
# [
#     "2.75rem", # h1 (1.5rem for sidebar)
#     "2.25rem", # h2 (1.25rem for sidebar)
#     "1.75rem", # h3 (1.125rem for sidebar)
#     "1.5rem", # h4 (1rem for sidebar)
#     "1.25rem", # h5 (0.875rem for sidebar)
#     "1rem", # h6 (0.75rem for sidebar)
# ]
#
# If you specify an array with fewer than six sizes, the unspecified
# heading sizes will be the default values. For example, you can use the
# following array to set the font sizes for h1-h3 headings while keeping
# h4-h6 headings at their default sizes:
# headingFontSizes = ["3rem", "2.875rem", "2.75rem"]
#
# Setting a single value (not in an array) will set the font size for all
# h1-h6 headings to that value:
# headingFontSizes = "2.75rem"
#
# Font sizes can be specified in pixels or rem, but rem is recommended.
headingFontSizes =

# One or more font weights for h1-h6 headings.
#
# If no weights are set, Streamlit will use the default weights for h1-h6
# headings. Heading font weights set in [theme] are not inherited by
# [theme.sidebar]. The following weights are used by default:
# [
#     700, # h1 (bold)
#     600, # h2 (semi-bold)
#     600, # h3 (semi-bold)
#     600, # h4 (semi-bold)
#     600, # h5 (semi-bold)
#     600, # h6 (semi-bold)
# ]
#
# If you specify an array with fewer than six weights, the unspecified
# heading weights will be the default values. For example, you can use
# the following array to set the font weights for h1-h2 headings while
# keeping h3-h6 headings at their default weights:
# headingFontWeights = [800, 700]
#
# Setting a single value (not in an array) will set the font weight for
# all h1-h6 headings to that value:
# headingFontWeights = 500
headingFontWeights =

# The font family to use for code (monospace) in the sidebar.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "'Space Mono':https://fonts.googleapis.com/css2?family=Space+Mono=swap")
# - A comma-separated list of these (as a single string) to specify
#   fallbacks
codeFont =

# The font size (in pixels or rem) for code blocks and code text.
#
# This applies to font in code blocks, `st.json`, and `st.help`. It
# doesn't apply to inline code, which is set by default to 0.75em.
#
# If this isn't set, the code font size will be 0.875rem.
codeFontSize =

# The font weight for code blocks and code text.
#
# This applies to font in inline code, code blocks, `st.json`, and
# `st.help`. This is an integer multiple of 100. Values can be between
# 100 and 600, inclusive.
#
# If this isn't set, the code font weight will be 400 (normal weight).
codeFontWeight =

# The radius used as basis for the corners of most UI elements.
#
# This can be one of the following:
# - "none"
# - "small"
# - "medium"
# - "large"
# - "full"
# - The number in pixels or rem.
#
# For example, you can use "10px", "0.5rem", or "2rem". To follow best
# practices, use rem instead of pixels when specifying a numeric size.
baseRadius =

# The radius used as basis for the corners of buttons.
#
# This can be one of the following:
# - "none"
# - "small"
# - "medium"
# - "large"
# - "full"
# - The number in pixels or rem.
#
# For example, you can use "10px", "0.5rem", or "2rem". To follow best
# practices, use rem instead of pixels when specifying a numeric size.
#
# If this isn't set, Streamlit uses `theme.baseRadius` instead.
buttonRadius =

# The color of the border around elements.
borderColor =

# The color of the border around dataframes and tables.
#
# If this isn't set, Streamlit uses `theme.borderColor` instead.
dataframeBorderColor =

# The background color of the dataframe's header.
#
# This color applies to all non-interior cells of the dataframe. This
# includes the header row, the row-selection column (if present), and
# the bottom row of data editors with a dynamic number of rows. If this
# isn't set, Streamlit uses a mix of `theme.backgroundColor` and
# `theme.secondaryBackgroundColor`.
dataframeHeaderBackgroundColor =

# Whether to show a border around input widgets.
showWidgetBorder =

# Whether to show a vertical separator between the sidebar and the main
# content area.
showSidebarBorder =

# An array of colors to use for categorical chart data.
#
# This is a list of one or more color strings which are applied in order
# to categorical data. These colors apply to Plotly, Altair, and
# Vega-Lite charts.
#
# Invalid colors are skipped, and colors repeat cyclically if there are
# more categories than colors. If no chart categorical colors are set,
# Streamlit uses a default set of colors.
#
# For light themes, the following colors are the default:
# [
#     "#0068c9", # blue80
#     "#83c9ff", # blue40
#     "#ff2b2b", # red80
#     "#ffabab", # red40
#     "#29b09d", # blueGreen80
#     "#7defa1", # green40
#     "#ff8700", # orange80
#     "#ffd16a", # orange50
#     "#6d3fc0", # purple80
#     "#d5dae5", # gray40
# ]
# For dark themes, the following colors are the default:
# [
#     "#83c9ff", # blue40
#     "#0068c9", # blue80
#     "#ffabab", # red40
#     "#ff2b2b", # red80
#     "#7defa1", # green40
#     "#29b09d", # blueGreen80
#     "#ffd16a", # orange50
#     "#ff8700", # orange80
#     "#6d3fc0", # purple80
#     "#d5dae5", # gray40
# ]
chartCategoricalColors =

# An array of ten colors to use for sequential or continuous chart data.
#
# The ten colors create a gradient color scale. These colors apply to
# Plotly, Altair, and Vega-Lite charts.
#
# Invalid color strings are skipped. If there are not exactly ten
# valid colors specified, Streamlit uses a default set of colors.
#
# For light themes, the following colors are the default:
# [
#     "#e4f5ff", #blue10
#     "#c7ebff", #blue20
#     "#a6dcff", #blue30
#     "#83c9ff", #blue40
#     "#60b4ff", #blue50
#     "#3d9df3", #blue60
#     "#1c83e1", #blue70
#     "#0068c9", #blue80
#     "#0054a3", #blue90
#     "#004280", #blue100
# ]
# For dark themes, the following colors are the default:
# [
#     "#004280", #blue100
#     "#0054a3", #blue90
#     "#0068c9", #blue80
#     "#1c83e1", #blue70
#     "#3d9df3", #blue60
#     "#60b4ff", #blue50
#     "#83c9ff", #blue40
#     "#a6dcff", #blue30
#     "#c7ebff", #blue20
#     "#e4f5ff", #blue10
# ]
chartSequentialColors =
```

#### Sidebar theme

To define switchable light and dark themes, the configuration options in the
`[theme.sidebar]` table can be used in separate `[theme.dark.sidebar]` and
`[theme.light.sidebar]`.

```toml
[theme.sidebar]

# Primary accent color.
primaryColor =

# Background color of the app.
backgroundColor =

# Background color used for most interactive widgets.
secondaryBackgroundColor =

# Color used for almost all text.
textColor =

# Red color used in the basic color palette.
#
# By default, this is #ff4b4b for the light theme and #ff2b2b for the
# dark theme.
#
# If `redColor` is provided, and `redBackgroundColor` isn't, then
# `redBackgroundColor` will be derived from `redColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
redColor =

# Orange color used in the basic color palette.
#
# By default, this is #ffa421 for the light theme and #ff8700 for the
# dark theme.
#
# If `orangeColor` is provided, and `orangeBackgroundColor` isn't, then
# `orangeBackgroundColor` will be derived from `orangeColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
orangeColor =

# Yellow color used in the basic color palette.
#
# By default, this is #faca2b for the light theme and #ffe312 for the
# dark theme.
#
# If `yellowColor` is provided, and `yellowBackgroundColor` isn't, then
# `yellowBackgroundColor` will be derived from `yellowColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
yellowColor =

# Blue color used in the basic color palette.
#
# By default, this is #1c83e1 for the light theme and #0068c9 for the
# dark theme.
#
# If a `blueColor` is provided, and `blueBackgroundColor` isn't, then
# `blueBackgroundColor` will be derived from `blueColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
blueColor =

# Green color used in the basic color palette.
#
# By default, this is #21c354 for the light theme and #09ab3b for the
# dark theme.
#
# If `greenColor` is provided, and `greenBackgroundColor` isn't, then
# `greenBackgroundColor` will be derived from `greenColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
greenColor =

# Violet color used in the basic color palette.
#
# By default, this is #803df5 for both the light and dark themes.
#
# If a `violetColor` is provided, and `violetBackgroundColor` isn't, then
# `violetBackgroundColor` will be derived from `violetColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
violetColor =

# Gray color used in the basic color palette.
#
# By default, this is #a3a8b8 for the light theme and #555867 for the
# dark theme.
#
# If `grayColor` is provided, and `grayBackgroundColor` isn't, then
# `grayBackgroundColor` will be derived from `grayColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
grayColor =

# Red background color used in the basic color palette.
#
# If `redColor` is provided, this defaults to `redColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ff2b2b with 10% opacity for light theme and
# #ff6c6c with 20% opacity for dark theme.
redBackgroundColor =

# Orange background color used for the basic color palette.
#
# If `orangeColor` is provided, this defaults to `orangeColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ffa421 with 10% opacity for the light theme and
# #ff8700 with 20% opacity for the dark theme.
orangeBackgroundColor =

# Yellow background color used for the basic color palette.
#
# If `yellowColor` is provided, this defaults to `yellowColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #ffff12 with 10% opacity for the light theme and
# #ffff12 with 20% opacity for the dark theme.
yellowBackgroundColor =

# Blue background color used for the basic color palette.
#
# If `blueColor` is provided, this defaults to `blueColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #1c83ff with 10% opacity for the light theme and
# #3d9df3 with 20% opacity for the dark theme.
blueBackgroundColor =

# Green background color used for the basic color palette.
#
# If `greenColor` is provided, this defaults to `greenColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #21c354 with 10% opacity for the light theme and
# #3dd56d with 20% opacity for the dark theme.
greenBackgroundColor =

# Violet background color used for the basic color palette.
#
# If `violetColor` is provided, this defaults to `violetColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #9a5dff with 10% opacity for light theme and
# #9a5dff with 20% opacity for dark theme.
violetBackgroundColor =

# Gray background color used for the basic color palette.
#
# If `grayColor` is provided, this defaults to `grayColor` using 10%
# opacity for the light theme and 20% opacity for the dark theme.
#
# Otherwise, this is #31333f with 10% opacity for the light theme and
# #808495 with 20% opacity for the dark theme.
grayBackgroundColor =

# Red text color used for the basic color palette.
#
# If `redColor` is provided, this defaults to `redColor`, darkened by 15%
# for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #bd4043 for the light theme and #ff6c6c for the dark
# theme.
redTextColor =

# Orange text color used for the basic color palette.
#
# If `orangeColor` is provided, this defaults to `orangeColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #e2660c for the light theme and #ffbd45 for the dark
# theme.
orangeTextColor =

# Yellow text color used for the basic color palette.
#
# If `yellowColor` is provided, this defaults to `yellowColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #926c05 for the light theme and #ffffc2 for the dark
# theme.
yellowTextColor =

# Blue text color used for the basic color palette.
#
# If `blueColor` is provided, this defaults to `blueColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #0054a3 for the light theme and #3d9df3 for the dark
# theme.
blueTextColor =

# Green text color used for the basic color palette.
#
# If `greenColor` is provided, this defaults to `greenColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #158237 for the light theme and #5ce488 for the dark
# theme.
greenTextColor =

# Violet text color used for the basic color palette.
#
# If `violetColor` is provided, this defaults to `violetColor`, darkened
# by 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #583f84 for the light theme and #b27eff for the dark
# theme.
violetTextColor =

# Gray text color used for the basic color palette.
#
# If `grayColor` is provided, this defaults to `grayColor`, darkened by
# 15% for the light theme and lightened by 15% for the dark theme.
#
# Otherwise, this is #31333f with 60% opacity for the light theme and
# #fafafa with 60% opacity for the dark theme.
grayTextColor =

# Color used for all links.
#
# This defaults to the resolved value of `blueTextColor`.
linkColor =

# Whether or not links should be displayed with an underline.
linkUnderline =

# Text color used for code blocks.
#
# This defaults to the resolved value of `greenTextColor`.
codeTextColor =

# Background color used for code blocks.
codeBackgroundColor =

# The font family for all text, except code blocks.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "Nunito:https://fonts.googleapis.com/css2?family=Nunito=swap")
# - A comma-separated list of these (as a single string) to specify
#   fallbacks
#
# For example, you can use the following:
#
# font = "cool-font, fallback-cool-font, sans-serif"
font =

# The font family to use for headings.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "Nunito:https://fonts.googleapis.com/css2?family=Nunito=swap")
# - A comma-separated list of these (as a single string) to specify
#   fallbacks
#
# If this isn't set, Streamlit uses `theme.font` for headings.
headingFont =

# One or more font sizes for h1-h6 headings.
#
# If no sizes are set, Streamlit will use the default sizes for h1-h6
# headings. Heading font sizes set in [theme] are not inherited by
# [theme.sidebar]. The following sizes are used by default:
# [
#     "2.75rem", # h1 (1.5rem for sidebar)
#     "2.25rem", # h2 (1.25rem for sidebar)
#     "1.75rem", # h3 (1.125rem for sidebar)
#     "1.5rem", # h4 (1rem for sidebar)
#     "1.25rem", # h5 (0.875rem for sidebar)
#     "1rem", # h6 (0.75rem for sidebar)
# ]
#
# If you specify an array with fewer than six sizes, the unspecified
# heading sizes will be the default values. For example, you can use the
# following array to set the font sizes for h1-h3 headings while keeping
# h4-h6 headings at their default sizes:
# headingFontSizes = ["3rem", "2.875rem", "2.75rem"]
#
# Setting a single value (not in an array) will set the font size for all
# h1-h6 headings to that value:
# headingFontSizes = "2.75rem"
#
# Font sizes can be specified in pixels or rem, but rem is recommended.
headingFontSizes =

# One or more font weights for h1-h6 headings.
#
# If no weights are set, Streamlit will use the default weights for h1-h6
# headings. Heading font weights set in [theme] are not inherited by
# [theme.sidebar]. The following weights are used by default:
# [
#     700, # h1 (bold)
#     600, # h2 (semi-bold)
#     600, # h3 (semi-bold)
#     600, # h4 (semi-bold)
#     600, # h5 (semi-bold)
#     600, # h6 (semi-bold)
# ]
#
# If you specify an array with fewer than six weights, the unspecified
# heading weights will be the default values. For example, you can use
# the following array to set the font weights for h1-h2 headings while
# keeping h3-h6 headings at their default weights:
# headingFontWeights = [800, 700]
#
# Setting a single value (not in an array) will set the font weight for
# all h1-h6 headings to that value:
# headingFontWeights = 500
headingFontWeights =

# The font family to use for code (monospace) in the sidebar.
#
# This can be one of the following:
# - "sans-serif"
# - "serif"
# - "monospace"
# - The `family` value for a custom font table under [[theme.fontFaces]]
# - A URL to a CSS file in the format of "<font>:<url>" (like
#   "'Space Mono':https://fonts.googleapis.com/css2?family=Space+Mono=swap")
# - A comma-separated list of these (as a single string) to specify
# fallbacks
codeFont =

# The font size (in pixels or rem) for code blocks and code text.
#
# This applies to font in code blocks, `st.json`, and `st.help`. It
# doesn't apply to inline code, which is set by default to 0.75em.
#
# If this isn't set, the code font size will be 0.875rem.
codeFontSize =

# The font weight for code blocks and code text.
#
# This applies to font in inline code, code blocks, `st.json`, and
# `st.help`. This is an integer multiple of 100. Values can be between
# 100 and 600, inclusive.
#
# If this isn't set, the code font weight will be 400 (normal weight).
codeFontWeight =

# The radius used as basis for the corners of most UI elements.
#
# This can be one of the following:
# - "none"
# - "small"
# - "medium"
# - "large"
# - "full"
# - The number in pixels or rem.
#
# For example, you can use "10px", "0.5rem", or "2rem". To follow best
# practices, use rem instead of pixels when specifying a numeric size.
baseRadius =

# The radius used as basis for the corners of buttons.
#
# This can be one of the following:
# - "none"
# - "small"
# - "medium"
# - "large"
# - "full"
# - The number in pixels or rem.
#
# For example, you can use "10px", "0.5rem", or "2rem". To follow best
# practices, use rem instead of pixels when specifying a numeric size.
#
# If this isn't set, Streamlit uses `theme.baseRadius` instead.
buttonRadius =

# The color of the border around elements.
borderColor =

# The color of the border around dataframes and tables.
#
# If this isn't set, Streamlit uses `theme.borderColor` instead.
dataframeBorderColor =

# The background color of the dataframe's header.
#
# This color applies to all non-interior cells of the dataframe. This
# includes the header row, the row-selection column (if present), and
# the bottom row of data editors with a dynamic number of rows. If this
# isn't set, Streamlit uses a mix of `theme.backgroundColor` and
# `theme.secondaryBackgroundColor`.
dataframeHeaderBackgroundColor =

# Whether to show a border around input widgets.
showWidgetBorder =
```

#### Secrets

```toml
[secrets]

# List of locations where secrets are searched.
#
# An entry can be a path to a TOML file or directory path where
# Kubernetes style secrets are saved. Order is important, import is
# first to last, so secrets in later files will take precedence over
# earlier ones.
#
# Default: [ <path>local environment's secrets.toml file&gt;, <path>project's secrets.toml file&gt;,]
files = [ "~/.streamlit/secrets.toml", "~/project directory/.streamlit/secrets.toml",]
```</path></path></url></font></url></font></url></font></url></font></url></font></url></font>

---

Source: https://docs.streamlit.io/develop/api-reference/configuration/st.get_option


* Function signature:

   st.get_option(key)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | key | str |  | The config option key of the form "section.optionName". To see all available options, run streamlit config show in a terminal. |



---

Source: https://docs.streamlit.io/develop/api-reference/configuration/st.set_option


* Function signature:

   st.set_option(key, value)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | key | str |  | The config option key of the form "section.optionName". To see all available options, run streamlit config show in a terminal. |
   | value | None |  | The new value to assign to this config option. |



---

Source: https://docs.streamlit.io/develop/api-reference/configuration/st.set_page_config


* Function signature:

   st.set_page_config(page_title=None, page_icon=None, layout=None, initial_sidebar_state=None, menu_items=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | page_title | str or None |  | The page title, shown in the browser tab. If this is None (default), the page title is inherited from the previous call of st.set_page_config. If this is None and no previous call exists, the page title is inferred from the page source. If a page source is a Python file, its inferred title is derived from the filename. If a page source is a callable object, its inferred title is derived from the callable's name. |
   | page_icon | Anything supported by st.image (except list), str, or None |  | The page favicon. If page_icon is None (default), the page icon is inherited from the previous call of st.set_page_config. If this is None and no previous call exists, the favicon is a monochrome Streamlit logo. In addition to the types supported by st.image (except list), the following strings are valid:  A single-character emoji. For example, you can set page_icon="🦈".  An emoji short code. For example, you can set page_icon=":shark:". For a list of all supported codes, see https://share.streamlit.io/streamlit/emoji-shortcodes.  The string literal, "random". You can set page_icon="random" to set a random emoji from the supported list above.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, page_icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.    Note Colors are not supported for Material icons. When you use a Material icon for favicon, it will be black, regardless of browser theme. |
   | layout | "centered", "wide", or None |  | How the page content should be laid out. If this is None (default), the page layout is inherited from the previous call of st.set_page_config. If this is None and no previous call exists, the page layout is "centered". "centered" constrains the elements into a centered column of fixed width. "wide" uses the entire screen. |
   | initial_sidebar_state | "auto", "expanded", "collapsed", or None |  | How the sidebar should start out. If this is None (default), the sidebar state is inherited from the previous call of st.set_page_config. If no previous call exists, the sidebar state is "auto". The folowing states are supported:  "auto": The sidebar is hidden on small devices and shown otherwise. "expanded": The sidebar is shown initially. "collapsed": The sidebar is hidden initially.  In most cases, "auto" provides the best user experience across devices of different sizes. |
   | menu_items | dict |  | Configure the menu that appears on the top-right side of this app. The keys in this dict denote the menu item to configure. The following keys can have string or None values:  "Get help": The URL this menu item should point to. "Report a Bug": The URL this menu item should point to. "About": A markdown string to show in the About dialog.  A URL may also refer to an email address e.g. mailto:john@example.com. If you do not include a key, its menu item will be hidden (unless it was set by a previous call to st.set_page_config). To remove an item that was specified in a previous call to st.set_page_config, set its value to None in the dictionary. |



---

# Connections and databases

Source: https://docs.streamlit.io/develop/api-reference/connections


## Setup your connection

<TileContainer>
<RefCard href="/develop/api-reference/connections/st.connection" size="half">
<Image>alt="screenshot" src="/images/api/connection.svg" /&gt;

<h4>Create a connection</h4>

Connect to a data source or API

```python
conn = st.connection('pets_db', type='sql')
pet_owners = conn.query('select * from pet_owners')
st.dataframe(pet_owners)
```

</Image>
</RefCard>

## Built-in connections

<TileContainer>
<RefCard href="/develop/api-reference/connections/st.connections.snowflakeconnection" size="half">
<Image>alt="screenshot" src="/images/api/connections.SnowflakeConnection.svg" /&gt;

<h4>SnowflakeConnection</h4>

A connection to Snowflake.

```python
conn = st.connection('snowflake')
```

</Image>
<RefCard href="/develop/api-reference/connections/st.connections.sqlconnection" size="half">
<Image>alt="screenshot" src="/images/api/connections.SQLConnection.svg" /&gt;

<h4>SQLConnection</h4>

A connection to a SQL database using SQLAlchemy.

```python
conn = st.connection('sql')
```

</Image>
</RefCard>

## Third-party connections

<TileContainer>
<RefCard href="/develop/api-reference/connections/st.connections.baseconnection" size="half">
<h4>Connection base class</h4>

Build your own connection with `BaseConnection`.

```python
class MyConnection(BaseConnection[myconn.MyConnection]):
    def _connect(self, **kwargs) -&gt; MyConnection:
        return myconn.connect(**self._secrets, **kwargs)
    def query(self, query):
        return self._instance.query(query)
```

</RefCard>
</TileContainer>

## Secrets

<TileContainer>
<RefCard href="/develop/api-reference/connections/st.secrets" size="half">
<h4>Secrets singleton</h4>

Access secrets from a local TOML file.

```python
key = st.secrets["OpenAI_key"]
```

</RefCard>
<RefCard href="/develop/api-reference/connections/secrets.toml" size="half">
<h4>Secrets file</h4>

Save your secrets in a per-project or per-profile TOML file.

```python
OpenAI_key = "<YOUR_SECRET_KEY>"
```

</YOUR_SECRET_KEY>
</RefCard>

## Deprecated classes

<TileContainer>
<RefCard href="/develop/api-reference/connections/st.connections.snowparkconnection" size="half">{true}&gt;

<h4>SnowparkConnection</h4>

A connection to Snowflake.

```python
conn = st.connection("snowpark")
```

</RefCard>
</TileContainer></TileContainer></RefCard></TileContainer></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/connections/secrets.toml

## secrets.toml

`secrets.toml` is an optional file you can define for your working directory or global development environment. When `secrets.toml` is defined both globally and in your working directory, Streamlit combines the secrets and gives precendence to the working-directory secrets. For more information, see [Secrets management](/develop/concepts/connections/secrets-management).

### File location

To define your secrets locally or per-project, add `.streamlit/secrets.toml` to your working directory. Your working directory is wherever you call `streamlit run`. If you haven't previously created the `.streamlit` directory, you will need to add it.

To define your configuration globally, you must first locate your global `.streamlit` directory. Streamlit adds this hidden directory to your OS user profile during installation. For MacOS/Linux, this will be `~/.streamlit/secrets.toml`. For Windows, this will be `%userprofile%/.streamlit/secrets.toml`.

Optionally, you can change where Streamlit searches for secrets through the configuration option, [`secrets.files`](/develop/api-reference/configuration/config.toml#secrets).

### File format

`secrets.toml` is a [TOML](https://toml.io/en/) file.

#### Example

```toml
OpenAI_key = "your OpenAI key"
whitelist = ["sally", "bob", "joe"]

[database]
user = "your username"
password = "your password"
```

In your Streamlit app, the following values would be true:

```python
st.secrets["OpenAI_key"] == "your OpenAI key"
"sally" in st.secrets.whitelist
st.secrets["database"]["user"] == "your username"
st.secrets.database.password == "your password"
```

---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connection

<Tip>

This page only contains the `st.connection` API. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connection(name, type=None, max_entries=None, ttl=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | str |  | The connection name used for secrets lookup in secrets.toml. Streamlit uses secrets under [connections.] for the connection. type will be inferred if name is one of the following: "snowflake", "snowpark", or "sql". |
   | type | str, connection class, or None |  | The type of connection to create. This can be one of the following:  None (default): Streamlit will infer the connection type from name. If the type is not inferable from name, the type must be specified in secrets.toml instead. "snowflake": Streamlit will initialize a connection with SnowflakeConnection. "snowpark": Streamlit will initialize a connection with SnowparkConnection. This is deprecated. "sql": Streamlit will initialize a connection with SQLConnection. A string path to an importable class: This must be a dot-separated module path ending in the importable class. Streamlit will import the class and initialize a connection with it. The class must extend st.connections.BaseConnection. An imported class reference: Streamlit will initialize a connection with the referenced class, which must extend st.connections.BaseConnection. |
   | max_entries | int or None |  | The maximum number of connections to keep in the cache. If this is None (default), the cache is unbounded. Otherwise, when a new entry is added to a full cache, the oldest cached entry is removed. |
   | ttl | float, timedelta, or None |  | The maximum number of seconds to keep results in the cache. If this is None (default), cached results do not expire with time. |
   | **kwargs | any |  | Connection-specific keyword arguments that are passed to the connection's ._connect() method. **kwargs are typically combined with (and take precedence over) key-value pairs in secrets.toml. To learn more, see the specific connection's documentation. |

* Returns: Subclass of BaseConnection

    An initialized connection object of the specified type.



For a comprehensive overview of this feature, check out this video tutorial by Joshua Carroll, Streamlit's Product Manager for Developer Experience. You'll learn about the feature's utility in creating and managing data connections within your apps by using real-world examples.

<YouTube videoId="xQwDfW7UHMo"/>

---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connections.baseconnection

<Tip>

This page only contains information on the `st.connections.BaseConnection` class. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connections.BaseConnection(connection_name, **kwargs)



* Function signature:

   BaseConnection.reset()

* Returns: None



---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connections.experimentalbaseconnection

<Important>

This is an experimental feature. Experimental features and their APIs may change or be removed at any time. To learn more, click [here](/develop/quick-reference/prerelease#experimental-features).

</Important>
<Tip>

This page only contains information on the `st.connections.ExperimentalBaseConnection` class. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connections.ExperimentalBaseConnection(connection_name, **kwargs)



---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connections.snowflakeconnection

<Tip>

This page only contains the `st.connections.SnowflakeConnection` class. For a deeper dive into creating and managing data connections within Streamlit apps, see [Connect Streamlit to Snowflake](/develop/tutorials/databases/snowflake) and [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connections.SnowflakeConnection(connection_name, **kwargs)



* Function signature:

   SnowflakeConnection.cursor()

* Returns: snowflake.connector.cursor.SnowflakeCursor

    A cursor object for the connection.



* Function signature:

   SnowflakeConnection.query(sql, *, ttl=None, show_spinner="Running `snowflake.query(...)`.", params=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | sql | str |  | The read-only SQL query to execute. |
   | ttl | float, int, timedelta or None |  | The maximum number of seconds to keep results in the cache. If this is None (default), cached results do not expire with time. |
   | show_spinner | boolean or string | to | Whether to enable the spinner. When a cached query is executed, no spinner is displayed because the result is immediately available. When a new query is executed, the default is to show a spinner with the message "Running snowflake.query(...)." If this is False, no spinner displays while executing the query. If this is a string, the string will be used as the message for the spinner. |
   | params | list, tuple, dict or None | s | List of parameters to pass to the Snowflake Connector for Python Cursor.execute() method. This connector supports binding data to a SQL statement using qmark bindings. For more information and examples, see the Snowflake Connector for Python documentation. This defaults to None. |

* Returns: pandas.DataFrame

    The result of running the query, formatted as a pandas DataFrame.



* Function signature:

   SnowflakeConnection.raw_connection

* Returns: snowflake.connector.connection.SnowflakeConnection

    The connection object.



* Function signature:

   SnowflakeConnection.reset()

* Returns: None



* Function signature:

   SnowflakeConnection.session()

* Returns: snowflake.snowpark.Session

    A new Snowpark session for this connection.



* Function signature:

   SnowflakeConnection.write_pandas(df, table_name, database=None, schema=None, chunk_size=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | df | pandas.DataFrame |  | The pandas.DataFrame object containing the data to be copied into the table. |
   | table_name | str |  | Name of the table where the data should be copied to. |
   | database | str |  | Name of the database containing the table. By default, the function writes to the database that is currently in use in the session.  Note If you specify this parameter, you must also specify the schema parameter. |
   | schema | str |  | Name of the schema containing the table. By default, the function writes to the table in the schema that is currently in use in the session. |
   | chunk_size | int |  | Number of elements to insert at a time. By default, the function inserts all elements in one chunk. |
   | **kwargs | Any |  | Additional keyword arguments for snowflake.connector.pandas_tools.write_pandas(). |

* Returns: tuple[bool, int, int]

    A tuple containing three values:

A boolean value that is True if the write was successful.
An integer giving the number of chunks of data that were copied.
An integer giving the number of rows that were inserted.



---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connections.snowparkconnection

<Tip>

This page only contains the `st.connections.SnowparkConnection` class. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connections.SnowparkConnection(connection_name, **kwargs)



---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.connections.sqlconnection

<Tip>

This page only contains the `st.connections.SQLConnection` class. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>

* Function signature:

   st.connections.SQLConnection(connection_name, **kwargs)



* Function signature:

   SQLConnection.connect()

* Returns: sqlalchemy.engine.Connection

    A new SQLAlchemy connection object.



* Function signature:

   SQLConnection.query(sql, *, show_spinner="Running `sql.query(...)`.", ttl=None, index_col=None, chunksize=None, params=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | sql | str |  | The read-only SQL query to execute. |
   | show_spinner | boolean or string | to | Enable the spinner. The default is to show a spinner when there is a "cache miss" and the cached resource is being created. If a string, the value of the show_spinner param will be used for the spinner text. |
   | ttl | float, int, timedelta or None | None | The maximum number of seconds to keep results in the cache, or None if cached results should not expire. The default is None. |
   | index_col | str, list of str, or None | None | Column(s) to set as index(MultiIndex). Default is None. |
   | chunksize | int or None | None | If specified, return an iterator where chunksize is the number of rows to include in each chunk. Default is None. |
   | params | list, tuple, dict or None | None | List of parameters to pass to the execute method. The syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249 paramstyle, is supported. Default is None. |
   | **kwargs | dict |  | Additional keyword arguments are passed to pandas.read_sql. |

* Returns: pandas.DataFrame

    The result of running the query, formatted as a pandas DataFrame.



* Function signature:

   SQLConnection.reset()

* Returns: None



* Function signature:

   SQLConnection.driver

* Returns: str

    The name of the driver. For example, "pyodbc" or "psycopg2".



* Function signature:

   SQLConnection.engine

* Returns: sqlalchemy.engine.base.Engine

    The underlying SQLAlchemy Engine.



* Function signature:

   SQLConnection.session

* Returns: sqlalchemy.orm.Session

    A SQLAlchemy Session.



---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.experimental_connection

<Important>

This is an experimental feature. Experimental features and their APIs may change or be removed at any time. To learn more, click [here](/develop/quick-reference/prerelease#experimental-features).

</Important>
<Tip>

This page only contains the `st.experimental_connection` API. For a deeper dive into creating and managing data connections within Streamlit apps, read [Connecting to data](/develop/concepts/connections/connecting-to-data).

</Tip>
[Function 'streamlit.experimental_connection' not found]

---

Source: https://docs.streamlit.io/develop/api-reference/connections/st.secrets

## st.secrets

`st.secrets` provides a dictionary-like interface to access secrets stored in a `secrets.toml` file. It behaves similarly to `st.session_state`. `st.secrets` can be used with both key and attribute notation. For example, `st.secrets.your_key` and `st.secrets["your_key"]` refer to the same value. For more information about using `st.secrets`, see [Secrets management](/develop/concepts/connections/secrets-management).

### secrets.toml

By default, secrets can be saved globally or per-project. When both types of secrets are saved, Streamlit will combine the saved values but give precedence to per-project secrets if there are duplicate keys. For information on how to format and locate your `secrets.toml` file for your development environment, see [`secrets.toml`](/develop/api-reference/connections/secrets.toml).

### Configure secrets locations

You can configure where Streamlit searches for secrets through the configuration option, [`secrets.files`](/develop/api-reference/configuration/config.toml#secrets). With this option, you can list additional secrets locations and change the order of precedence. You can specify other TOML files or include Kubernetes style secret files.

#### Example

```toml
OpenAI_key = "your OpenAI key"
whitelist = ["sally", "bob", "joe"]

[database]
user = "your username"
password = "your password"
```

In your Streamlit app, the following values would be true:

```python
st.secrets["OpenAI_key"] == "your OpenAI key"
"sally" in st.secrets.whitelist
st.secrets["database"]["user"] == "your username"
st.secrets.database.password == "your password"
```

---

# Custom components

Source: https://docs.streamlit.io/develop/api-reference/custom-components


Streamlit custom components extend your app beyond built-in widgets with custom UI elements. V2 components offer better performance and multiple callbacks without iframes, while V1 components run in iframes with single callbacks.

## V2 custom components

### Backend (Python)

<TileContainer>
<RefCard href="/develop/api-reference/custom-components/st.components.v2.component">
<h4>Register</h4>

Register a custom component.

```python
my_component = st.components.v2.component(
    html=HTML,
    js=JS
)
my_component()
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/st.components.v2.types.bidicomponentcallable">
<h4>Mount</h4>

Mount a custom component.

```python
my_component = st.components.v2.component(
    html=HTML,
    js=JS
)
my_component()
```

</RefCard>
</TileContainer>

### Frontend (TypeScript)

<TileContainer>
<RefCard href="/develop/api-reference/custom-components/component-v2-lib">
<h4>npm support code</h4>

Support code published through npm.

```bash
npm i @streamlit/component-v2-lib
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/component-v2-lib-component">
<h4>Component</h4>

Type alias for the component function.

```typescript
import { Component } from "@streamlit/component-v2-lib";
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/component-v2-lib-componentargs">
<h4>ComponentArgs</h4>

Type alias for the component arguments.

```typescript
import { ComponentArgs } from "@streamlit/component-v2-lib";
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/component-v2-lib-componentstate">
<h4>ComponentState</h4>

Type alias for the component state.

```typescript
import { ComponentState } from "@streamlit/component-v2-lib";
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/component-v2-lib-optionalcomponentcleanupfunction" size="two-third">
<h4>OptionalComponentCleanupFunction</h4>

Type alias for the component cleanup function.

```typescript
import { OptionalComponentCleanupFunction } from "@streamlit/component-v2-lib";
```

</RefCard>
</TileContainer>

## V1 custom components

<TileContainer>
<RefCard href="/develop/api-reference/custom-components/st.components.v1.declare_component">
<h4>Declare a component</h4>

Create and register a custom component.

```python
from st.components.v1 import declare_component
declare_component(
    "custom_slider",
    "/frontend",
)
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/st.components.v1.html">
<h4>HTML</h4>

Display an HTML string in an iframe.

```python
from st.components.v1 import html
html(
    "<p>Foo bar.</p>"
)
```

</RefCard>
<RefCard href="/develop/api-reference/custom-components/st.components.v1.iframe">
<h4>iframe</h4>

Load a remote URL in an iframe.

```python
from st.components.v1 import iframe
iframe(
    "docs.streamlit.io"
)
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/component-v2-lib

## `@streamlit/component-v2-lib`

The [`@streamlit/component-v2-lib`](https://www.npmjs.com/package/@streamlit/component-v2-lib) package provides TypeScript type definitions and utilities for building Streamlit custom components using the v2 API.

### Installation

Install the package from npm:

```bash
npm i @streamlit/component-v2-lib
```

### Package Information

- **Package name**: `@streamlit/component-v2-lib`
- **Registry**: [npm](https://www.npmjs.com/package/@streamlit/component-v2-lib)
- **Purpose**: TypeScript type aliases and utilities for custom components v2

This package enables type-safe development when creating custom Streamlit components with modern JavaScript frameworks.

---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/component-v2-lib-component


* Function signature:

   Component&amp;lt;TComponentState extends ComponentState = ComponentState, TDataShape = unknown&amp;gt; = (componentArgs: ComponentArgs&amp;lt;TComponentState, TDataShape&amp;gt;) =&amp;gt; OptionalComponentCleanupFunction

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | componentArgs | ComponentArgs&amp;lt;TComponentState, TDataShape&amp;gt; |  | The inputs and utilities provided by Streamlit to your component. |

* Returns: OptionalComponentCleanupFunction

    An optional cleanup function that Streamlit will call when the component is unmounted.



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/component-v2-lib-componentargs


* Function signature:

   ComponentArgs&amp;lt;TComponentState = ComponentState, TDataShape = unknown,&amp;gt;

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | TDataShape |  | The data payload sent from Python through the component's mounting command. This is the primary input for your component, typed by the component author via the TDataShape generic. |
   | key | string |  | A stable identifier for this component instance generated by Streamlit. This key is independent from the key parameter passed to the component's mounting command in Python. This frontend key is automatically generated to be unique among all instances of all components and to avoid collisions with classes and IDs in the app's DOM. Important If a component is mounted without a key parameter in Python, and one of the parameters in the mounting command changes, then this frontend key may change between app runs. |
   | name | string |  | The component's name, as registered by Streamlit on the Python side. This is the same as the name parameter passed to st.components.v2.component. |
   | parentElement | HTMLElement or ShadowRoot |  | The host element for your component. Your HTML, JavaScript, and CSS are mounted inside this container. This is a ShadowRoot if isolate_styles is set to true in the component definition, otherwise it's an HTMLElement. |



* Function signature:

   setStateValue(name, value)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | string |  | The state key to set. If you are using TypeScript, this should be a key from TComponentState.To assign a value to a state key, in the component's mounting command in Python, an on__change callback isn't required. However, the presence of a callback will ensure that the state key is always present in the result. |
   | value | Any |  | The value to associate with the key. Type must match the corresponding property type in your TComponentState interface. |

* Returns: None



* Function signature:

   setTriggerValue(name, value)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | string |  | The trigger key to set. If you are using TypeScript, this should be a key from TComponentState.To assign a value to a trigger key, in the component's mounting command in Python, an on__change callback isn't required. However, the presence of a callback will ensure that the trigger key is always present in the result. |
   | value | Any |  | The value for this trigger. If you are using TypeScript, this should match the corresponding property type in your TComponentState interface. |

* Returns: None



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/component-v2-lib-componentstate


* Function signature:

   ComponentState = Record&amp;lt;string, unknown&amp;gt;



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/component-v2-lib-optionalcomponentcleanupfunction


* Function signature:

   OptionalComponentCleanupFunction = ComponentCleanupFunction | void



* Function signature:

   ComponentCleanupFunction = () =&gt; void



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v1.declare_component


* Function signature:

   st.components.v1.declare_component(name, path=None, url=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | str |  | A short, descriptive name for the component, like "slider". |
   | path | str, Path, or None |  | The path to serve the component's frontend files from. The path should be absolute. If path is None (default), Streamlit will serve the component from the location in url. Either path or url must be specified. If both are specified, then url will take precedence. |
   | url | str or None |  | The URL that the component is served from. If url is None (default), Streamlit will serve the component from the location in path. Either path or url must be specified. If both are specified, then url will take precedence. |

* Returns: CustomComponent

    A CustomComponent that can be called like a function.
Calling the component will create a new instance of the component
in the Streamlit app.



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v1.html


* Function signature:

   st.components.v1.html(html, width=None, height=None, scrolling=False, *, tab_index=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | html | str |  | The HTML string to embed in the iframe. |
   | width | int | element | The width of the iframe in CSS pixels. By default, this is the app's default element width. |
   | height | int |  | The height of the frame in CSS pixels. By default, this is 150. |
   | scrolling | bool |  | Whether to allow scrolling in the iframe. If this False (default), Streamlit crops any content larger than the iframe and does not show a scrollbar. If this is True, Streamlit shows a scrollbar when the content is larger than the iframe. |
   | tab_index | int or None | behavior | Specifies how and if the iframe is sequentially focusable. Users typically use the Tab key for sequential focus navigation. This can be one of the following values:  None (default): Uses the browser's default behavior. -1: Removes the iframe from sequential navigation, but still allows it to be focused programmatically. 0: Includes the iframe in sequential navigation in the order it appears in the document but after all elements with a positive tab_index. Positive integer: Includes the iframe in sequential navigation. Elements are navigated in ascending order of their positive tab_index.  For more information, see the tabindex documentation on MDN. |



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v1.iframe


* Function signature:

   st.components.v1.iframe(src, width=None, height=None, scrolling=False, *, tab_index=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | src | str |  | The URL of the page to embed. |
   | width | int | element | The width of the iframe in CSS pixels. By default, this is the app's default element width. |
   | height | int |  | The height of the frame in CSS pixels. By default, this is 150. |
   | scrolling | bool |  | Whether to allow scrolling in the iframe. If this False (default), Streamlit crops any content larger than the iframe and does not show a scrollbar. If this is True, Streamlit shows a scrollbar when the content is larger than the iframe. |
   | tab_index | int or None | behavior | Specifies how and if the iframe is sequentially focusable. Users typically use the Tab key for sequential focus navigation. This can be one of the following values:  None (default): Uses the browser's default behavior. -1: Removes the iframe from sequential navigation, but still allows it to be focused programmatically. 0: Includes the iframe in sequential navigation in the order it appears in the document but after all elements with a positive tab_index. Positive integer: Includes the iframe in sequential navigation. Elements are navigated in ascending order of their positive tab_index.  For more information, see the tabindex documentation on MDN. |



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v2.component


* Function signature:

   st.components.v2.component(name, *, html=None, css=None, js=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | name | str |  | A short, descriptive identifier for the component. This is used internally by Streamlit to manage instances of the component. Component names must be unique across an app. The names of imported components are prefixed by their module name to avoid collisions. If you register multiple components with the same name, a warning is logged and the last-registered component is used. Because this can lead to unexpected behavior, ensure that component names are unique. If you intend to have multiple instances of a component in one app, avoid wrapping a component definition together with its mounting command so you don't re-register your component with each instance. |
   | html | str or None |  | Inline HTML markup for the component root. This can be one of the following strings:  Raw HTML. This doesn't require any , , or  tags; just provide the inner HTML. A path or glob to an HTML file, relative to the component's asset directory.  If any HTML depends on data passed at mount time, use a placeholder element and populate it via JavaScript. Alternatively, you can append a new element to the parent. For more information, see Example 2. html and js can't both be None. At least one of them must be provided. |
   | css | str or None |  | Inline CSS. This can be one of the following strings:  Raw CSS (without a  block). A path or glob to a CSS file, relative to the component's asset directory. |
   | js | str or None |  | Inline JavaScript. This can be one of the following strings:  Raw JavaScript (without a  block). A path or glob to a JS file, relative to the component's asset directory.  html and js can't both be None. At least one of them must be provided. |

* Returns: BidiComponentCallable

    The component's mounting command.
This callable accepts the component parameters like key and
data and returns a BidiComponentResult object with the
component's state. The mounting command can be included in a
user-friendly wrapper function to provide a simpler API. A mounting
command can be called multiple times in an app to create multiple
instances of the component.



---

Source: https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v2.types.bidicomponentcallable


* Function signature:

   BidiComponentCallable(*args, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | key | str or None |  | An optional string to use as the unique key for the component instance. If this is omitted, an internal key is generated for the component instance based on its mounting parameters. No two Streamlit elements may have the same key. When a key is defined, the component's state is available in Session State via the key.  Note If you want to access this key in your component's frontend, you must pass it explicitly within the data parameter. The key parameter in BidiComponentCallable is not the same as the key property in ComponentArgs in the component's frontend code. The frontend key is automatically generated to be unique among all instances of all components and to avoid collisions with classes and IDs in the app's DOM. |
   | data | Any or None |  | Data to pass to the component. This can be one of the following:  A JSON-serializable object, like Dict[str, str | int] or List[str]. An Arrow-serializable object, like pandas.DataFrame. Raw bytes. A dictionary of JSON-serializable and Arrow-serializable objects. The dictionary's keys must be Python primitives.  Because this data is sent to the frontend, it must be serializable by one of the supported serialization methods (JSON, Arrow, or raw bytes). You can't pass arbitrary Python objects. Arrow-serialization is only supported at the top level of the data parameter or one level deep in a dictionary. Raw bytes are only supported at the top level. |
   | default | dict[str, Any] or None | state | Default state values for the component. Each key in the dictionary must correspond to a valid state attribute with an on__change callback. This callback can be empty, but must be included as a parameter when the component is mounted. Trigger values do not support manual defaults. All trigger and state values defined by an associated callback are initialized to None by default. |
   | width | "stretch", "content", or int |  | Width of the component. This can be one of the following:  "stretch" (default): The component is wrapped in a  with CSS style width: 100%;. "content": The component is wrapped in a  with CSS style width: fit-content;. An integer specifying the width in pixels: The component is wrapped in a  with the specified pixel width.  You are responsible for ensuring the component's inner HTML content is responsive to the  wrapper. |
   | height | "content", "stretch", or int |  | Height of the component. This can be one of the following:  "content" (default): The component is wrapped in a  with CSS style height: auto;. "stretch": The component is wrapped in a  with CSS style height: 100%;. An integer specifying the height in pixels: The component is wrapped in a  with the specified pixel height. If the component content is larger than the specified height, scrolling is enabled.   Note Use scrolling containers sparingly. If you use scrolling containers, avoid heights that exceed 500 pixels. Otherwise, the scroll surface of the container might cover the majority of the screen on mobile devices, which makes it hard to scroll the rest of the app. If you want to disable scrolling for a fixed-height component, include an inner  wrapper in your component's HTML to control the overflow behavior.  You are responsible for ensuring the component's inner HTML content is responsive to the  wrapper. |
   | isolate_styles | bool |  | Whether to sandbox the component styles in a shadow root. If this is True (default), the component's HTML is mounted inside a shadow DOM and, in your component's JavaScript, parentElement returns a ShadowRoot. If this is False, the component's HTML is mounted directly into the app's DOM tree, and parentElement returns a regular HTMLElement. |
   | **callbacks | Callable or None |  | Callbacks with the naming pattern on__change for each state and trigger key. For example, if your component has a state key of "value" and a trigger key of "click", its callbacks can include on_value_change and on_click_change. Only names that follow this pattern are recognized. Custom components don't currently support callbacks with arguments. Callbacks are required for any state values defined in the default parameter. Otherwise, a callback is optional. To ensure your component's result always returns the expected attributes, you can pass empty callbacks like lambda: None. |

* Returns: BidiComponentResult

    Component state object that exposes state and trigger values.



* Function signature:

   BidiComponentResult

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | &amp;lt;state_keys&amp;gt; | Any |  | All state values from the component. State values are persistent across app reruns until explicitly changed. You can have multiple state keys as attributes. |
   | &amp;lt;trigger_keys&amp;gt; | Any |  | All trigger values from the component. Trigger values are transient and reset to None after one script run. You can have multiple trigger keys as attributes. |



---

# Data elements

Source: https://docs.streamlit.io/develop/api-reference/data


When you're working with data, it is extremely valuable to visualize that
data quickly, interactively, and from multiple different angles. That's what
Streamlit is actually built and optimized for.

You can display data via [charts](#display-charts), and you can display it in
raw form. These are the Streamlit commands you can use to display and interact with raw data.

<TileContainer>
<RefCard href="/develop/api-reference/data/st.dataframe">
<Image>alt="screenshot" src="/images/api/dataframe.jpg" /&gt;

<h4>Dataframes</h4>

Display a dataframe as an interactive table.

```python
st.dataframe(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/data/st.data_editor">
<Image>alt="screenshot" src="/images/api/data_editor.jpg" /&gt;

<h4>Data editor</h4>

Display a data editor widget.

```python
edited = st.data_editor(df, num_rows="dynamic")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config">
<Image>alt="screenshot" src="/images/api/column_config.jpg" /&gt;

<h4>Column configuration</h4>

Configure the display and editing behavior of dataframes and data editors.

```python
st.column_config.NumberColumn("Price (in USD)", min_value=0, format="$%d")
```

</Image>
<RefCard href="/develop/api-reference/data/st.table">
<Image>alt="screenshot" src="/images/api/table.jpg" /&gt;

<h4>Static tables</h4>

Display a static table.

```python
st.table(my_data_frame)
```

</Image>
<RefCard href="/develop/api-reference/data/st.metric">
<Image>alt="screenshot" src="/images/api/metric.jpg" /&gt;

<h4>Metrics</h4>

Display a metric in big bold font, with an optional indicator of how the metric changed.

```python
st.metric("My metric", 42, 2)
```

</Image>
<RefCard href="/develop/api-reference/data/st.json">
<Image>alt="screenshot" src="/images/api/json.jpg" /&gt;

<h4>Dicts and JSON</h4>

Display object or string as a pretty-printed JSON string.

```python
st.json(my_dict)
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/PablocFonseca/streamlit-aggrid">
<Image>alt="screenshot" src="/images/api/components/aggrid.jpg" /&gt;

<h4>Streamlit Aggrid</h4>

Implementation of Ag-Grid component for Streamlit. Created by [@PablocFonseca](https://github.com/PablocFonseca).

```python
df = pd.DataFrame({'col1': [1, 2, 3], 'col2': [4, 5, 6]})
grid_return = AgGrid(df, editable=True)

new_df = grid_return['data']
```

</Image>
<ComponentCard href="https://github.com/randyzwitch/streamlit-folium">
<Image>alt="screenshot" src="/images/api/components/folium.jpg" /&gt;

<h4>Streamlit Folium</h4>

Streamlit Component for rendering Folium maps. Created by [@randyzwitch](https://github.com/randyzwitch).

```python
m = folium.Map(location=[39.949610, -75.150282], zoom_start=16)
folium.Marker([39.949610, -75.150282], popup="Liberty Bell", tooltip="Liberty Bell").add_to(m)

st_data = st_folium(m, width=725)
```

</Image>
<ComponentCard href="https://github.com/okld/streamlit-pandas-profiling">
<Image>alt="screenshot" src="/images/api/components/pandas-profiling.jpg" /&gt;

<h4>Pandas Profiling</h4>

Pandas profiling component for Streamlit. Created by [@okld](https://github.com/okld/).

```python
df = pd.read_csv("https://storage.googleapis.com/tf-datasets/titanic/train.csv")
pr = df.profile_report()

st_profile_report(pr)
```

</Image>
<ComponentCard href="https://github.com/blackary/streamlit-image-coordinates">
<Image>alt="screenshot" src="/images/api/components/image-coordinates.jpg" /&gt;

<h4>Image Coordinates</h4>

Get the coordinates of clicks on an image. Created by [@blackary](https://github.com/blackary/).

```python
from streamlit_image_coordinates import streamlit_image_coordinates
value = streamlit_image_coordinates("https://placekitten.com/200/300")

st.write(value)
```

</Image>
<ComponentCard href="https://github.com/null-jones/streamlit-plotly-events">
<Image>alt="screenshot" src="/images/api/components/plotly-events.jpg" /&gt;

<h4>Plotly Events</h4>

Make Plotly charts interactive!. Created by [@null-jones](https://github.com/null-jones/).

```python
from streamlit_plotly_events import plotly_events
fig = px.line(x=[1], y=[1])

selected_points = plotly_events(fig)
```

</Image>
<ComponentCard href="https://extras.streamlit.app/">
<Image>alt="screenshot" src="/images/api/components/extras-metric-cards.jpg" /&gt;

<h4>Streamlit Extras</h4>

A library with useful Streamlit extras. Created by [@arnaudmiribel](https://github.com/arnaudmiribel/).

```python
from streamlit_extras.metric_cards import style_metric_cards
col3.metric(label="No Change", value=5000, delta=0)

style_metric_cards()
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

# Column configuration

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config


When working with data in Streamlit, the `st.column_config` class is a powerful tool for configuring data display and interaction. Specifically designed for the `column_config` parameter in [`st.dataframe`](/develop/api-reference/data/st.dataframe) and [`st.data_editor`](/develop/api-reference/data/st.data_editor), it provides a suite of methods to tailor your columns to various data types - from simple text and numbers to lists, URLs, images, and more.

Whether it's translating temporal data into user-friendly formats or utilizing charts and progress bars for clearer data visualization, column configuration not only provides the user with an enriched data viewing experience but also ensures that you're equipped with the tools to present and interact with your data, just the way you want it.

<TileContainer>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.column">
<Image>alt="screenshot" src="/images/api/column_config.column.jpg" /&gt;

<h4>Column</h4>

Configure a generic column.

```python
Column("Streamlit Widgets", width="medium", help="Streamlit **widget** commands 🎈")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.textcolumn">
<Image>alt="screenshot" src="/images/api/column_config.textcolumn.jpg" /&gt;

<h4>Text column</h4>

Configure a text column.

```python
TextColumn("Widgets", max_chars=50, validate="^st\.[a-z_]+$")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.numbercolumn">
<Image>alt="screenshot" src="/images/api/column_config.numbercolumn.jpg" /&gt;

<h4>Number column</h4>

Configure a number column.

```python
NumberColumn("Price (in USD)", min_value=0, format="$%d")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.checkboxcolumn">
<Image>alt="screenshot" src="/images/api/column_config.checkboxcolumn.jpg" /&gt;

<h4>Checkbox column</h4>

Configure a checkbox column.

```python
CheckboxColumn("Your favorite?", help="Select your **favorite** widgets")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.selectboxcolumn">
<Image>alt="screenshot" src="/images/api/column_config.selectboxcolumn.jpg" /&gt;

<h4>Selectbox column</h4>

Configure a selectbox column.

```python
SelectboxColumn("App Category", options=["🤖 LLM", "📈 Data Viz"])
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.multiselectcolumn">
<Image>alt="screenshot" src="/images/api/column_config.multiselectcolumn.jpg" /&gt;

<h4>Multiselect column</h4>

Configure a multiselect column.

```python
MultiselectColumn("App Category", options=["LLM", "Visualization"])
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.datetimecolumn">
<Image>alt="screenshot" src="/images/api/column_config.datetimecolumn.jpg" /&gt;

<h4>Datetime column</h4>

Configure a datetime column.

```python
DatetimeColumn("Appointment", min_value=datetime(2023, 6, 1), format="D MMM YYYY, h:mm a")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.datecolumn">
<Image>alt="screenshot" src="/images/api/column_config.datecolumn.jpg" /&gt;

<h4>Date column</h4>

Configure a date column.

```python
DateColumn("Birthday", max_value=date(2005, 1, 1), format="DD.MM.YYYY")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.timecolumn">
<Image>alt="screenshot" src="/images/api/column_config.timecolumn.jpg" /&gt;

<h4>Time column</h4>

Configure a time column.

```python
TimeColumn("Appointment", min_value=time(8, 0, 0), format="hh:mm a")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.jsoncolumn">
<Image>alt="screenshot" src="/images/api/column_config.jsoncolumn.jpg" /&gt;

<h4>JSON column</h4>

Configure a JSON column.

```python
JSONColumn("Properties", width="medium")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.listcolumn">
<Image>alt="screenshot" src="/images/api/column_config.listcolumn.jpg" /&gt;

<h4>List column</h4>

Configure a list column.

```python
ListColumn("Sales (last 6 months)", width="medium")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.linkcolumn">
<Image>alt="screenshot" src="/images/api/column_config.linkcolumn.jpg" /&gt;

<h4>Link column</h4>

Configure a link column.

```python
LinkColumn("Trending apps", max_chars=100, validate="^https://.*$")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.imagecolumn">
<Image>alt="screenshot" src="/images/api/column_config.imagecolumn.jpg" /&gt;

<h4>Image column</h4>

Configure an image column.

```python
ImageColumn("Preview Image", help="The preview screenshots")
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.areachartcolumn">
<Image>alt="screenshot" src="/images/api/column_config.areachartcolumn.jpg" /&gt;

<h4>Area chart column</h4>

Configure an area chart column.

```python
AreaChartColumn("Sales (last 6 months)" y_min=0, y_max=100)
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.linechartcolumn">
<Image>alt="screenshot" src="/images/api/column_config.linechartcolumn.jpg" /&gt;

<h4>Line chart column</h4>

Configure a line chart column.

```python
LineChartColumn("Sales (last 6 months)" y_min=0, y_max=100)
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.barchartcolumn">
<Image>alt="screenshot" src="/images/api/column_config.barchartcolumn.jpg" /&gt;

<h4>Bar chart column</h4>

Configure a bar chart column.

```python
BarChartColumn("Marketing spend" y_min=0, y_max=100)
```

</Image>
<RefCard href="/develop/api-reference/data/st.column_config/st.column_config.progresscolumn">
<Image>alt="screenshot" src="/images/api/column_config.progresscolumn.jpg" /&gt;

<h4>Progress column</h4>

Configure a progress column.

```python
ProgressColumn("Sales volume", min_value=0, max_value=1000, format="$%f")
```

</Image>
</RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.areachartcolumn


* Function signature:

   st.column_config.AreaChartColumn(label=None, *, width=None, help=None, pinned=None, y_min=None, y_max=None, color=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | y_min | int, float, or None |  | The minimum value on the y-axis for all cells in the column. If this is None (default), every cell will use the minimum of its data. |
   | y_max | int, float, or None |  | The maximum value on the y-axis for all cells in the column. If this is None (default), every cell will use the maximum of its data. |
   | color | "auto", "auto-inverse", str, or None |  | The color to use for the chart. This can be one of the following:  None (default): The primary color is used. "auto": If the data is increasing, the chart is green; if the data is decreasing, the chart is red. "auto-inverse": If the data is increasing, the chart is red; if the data is decreasing, the chart is green. A single color value that is applied to all charts in the column. In addition to the basic color palette (red, orange, yellow, green, blue, violet, gray/grey, and primary), this supports hex codes like "#483d8b".  The basic color palette can be configured in the theme settings. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.barchartcolumn


* Function signature:

   st.column_config.BarChartColumn(label=None, *, width=None, help=None, pinned=None, y_min=None, y_max=None, color=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | y_min | int, float, or None |  | The minimum value on the y-axis for all cells in the column. If this is None (default), every cell will use the minimum of its data. |
   | y_max | int, float, or None |  | The maximum value on the y-axis for all cells in the column. If this is None (default), every cell will use the maximum of its data. |
   | color | "auto", "auto-inverse", str, or None |  | The color to use for the chart. This can be one of the following:  None (default): The primary color is used. "auto": If the data is increasing, the chart is green; if the data is decreasing, the chart is red. "auto-inverse": If the data is increasing, the chart is red; if the data is decreasing, the chart is green. A single color value that is applied to all charts in the column. In addition to the basic color palette (red, orange, yellow, green, blue, violet, gray/grey, and primary), this supports hex codes like "#483d8b". |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.checkboxcolumn


* Function signature:

   st.column_config.CheckboxColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | bool or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.column


* Function signature:

   st.column_config.Column(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.datecolumn


* Function signature:

   st.column_config.DateColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, format=None, min_value=None, max_value=None, step=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | datetime.date or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | format | str, "localized", "distance", "iso8601", or None | locale | A format string controlling how dates are displayed. This can be one of the following values:  None (default): Show the date in "YYYY-MM-DD" format (e.g. "2025-03-04"). "localized": Show the date in the default locale format (e.g. "Mar 4, 2025" in the America/Los_Angeles timezone). "distance": Show the date in a relative format (e.g. "a few seconds ago"). "iso8601": Show the date in ISO 8601 format (e.g. "2025-03-04"). A momentJS format string: Format the date with a string, like "ddd, MMM Do" to show "Tue, Mar 4th". For available formats, see momentJS.  Formatting from column_config always takes precedence over formatting from pandas.Styler. The formatting does not impact the return value when used in st.data_editor. |
   | min_value | datetime.date or None |  | The minimum date that can be entered. If this is None (default), there will be no minimum. |
   | max_value | datetime.date or None |  | The maximum date that can be entered. If this is None (default), there will be no maximum. |
   | step | int or None |  | The stepping interval in days. If this is None (default), the step will be 1 day. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.datetimecolumn


* Function signature:

   st.column_config.DatetimeColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, format=None, min_value=None, max_value=None, step=None, timezone=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | datetime.datetime or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | format | str, "localized", "distance", "calendar", "iso8601", or None | locale | A format string controlling how datetimes are displayed. This can be one of the following values:  None (default): Show the datetime in "YYYY-MM-DD HH:mm:ss" format (e.g. "2025-03-04 20:00:00"). "localized": Show the datetime in the default locale format (e.g. "Mar 4, 2025, 12:00:00 PM" in the America/Los_Angeles timezone). "distance": Show the datetime in a relative format (e.g. "a few seconds ago"). "calendar": Show the datetime in a calendar format (e.g. "Today at 8:00 PM"). "iso8601": Show the datetime in ISO 8601 format (e.g. "2025-03-04T20:00:00.000Z"). A momentJS format string: Format the datetime with a string, like "ddd ha" to show "Tue 8pm". For available formats, see momentJS.  Formatting from column_config always takes precedence over formatting from pandas.Styler. The formatting does not impact the return value when used in st.data_editor. |
   | min_value | datetime.datetime or None |  | The minimum datetime that can be entered. If this is None (default), there will be no minimum. |
   | max_value | datetime.datetime or None |  | The maximum datetime that can be entered. If this is None (default), there will be no maximum. |
   | step | int, float, datetime.timedelta, or None |  | The stepping interval in seconds. If this is None (default), the step will be 1 second. |
   | timezone | str or None |  | The timezone of this column. If this is None (default), the timezone is inferred from the underlying data. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.imagecolumn


* Function signature:

   st.column_config.ImageColumn(label=None, *, width=None, help=None, pinned=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.jsoncolumn


* Function signature:

   st.column_config.JsonColumn(label=None, *, width=None, help=None, pinned=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.linechartcolumn


* Function signature:

   st.column_config.LineChartColumn(label=None, *, width=None, help=None, pinned=None, y_min=None, y_max=None, color=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | y_min | int, float, or None |  | The minimum value on the y-axis for all cells in the column. If this is None (default), every cell will use the minimum of its data. |
   | y_max | int, float, or None |  | The maximum value on the y-axis for all cells in the column. If this is None (default), every cell will use the maximum of its data. |
   | color | "auto", "auto-inverse", str, or None |  | The color to use for the chart. This can be one of the following:  None (default): The primary color is used. "auto": If the data is increasing, the chart is green; if the data is decreasing, the chart is red. "auto-inverse": If the data is increasing, the chart is red; if the data is decreasing, the chart is green. A single color value that is applied to all charts in the column. In addition to the basic color palette (red, orange, yellow, green, blue, violet, gray/grey, and primary), this supports hex codes like "#483d8b". |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.linkcolumn


* Function signature:

   st.column_config.LinkColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, max_chars=None, validate=None, display_text=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | str or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | max_chars | int or None |  | The maximum number of characters that can be entered. If this is None (default), there will be no maximum. |
   | validate | str or None |  | A JS-flavored regular expression (e.g. "^https://.+$") that edited values are validated against. If the user input is invalid, it will not be submitted. |
   | display_text | str or None |  | The text that is displayed in the cell. This can be one of the following:  None (default) to display the URL itself. A string that is displayed in every cell, e.g. "Open link". A Material icon that is displayed in every cell, e.g. ":material/open_in_new:". A JS-flavored regular expression (detected by usage of parentheses) to extract a part of the URL via a capture group. For example, use "https://(.*?)\.example\.com" to extract the display text "foo" from the URL "https://foo.example.com".   For more complex cases, you may use Pandas Styler's format function on the underlying dataframe. Note that this makes the app slow, doesn't work with editable columns, and might be removed in the future. Text formatting from column_config always takes precedence over text formatting from pandas.Styler. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.listcolumn


* Function signature:

   st.column_config.ListColumn(label=None, *, width=None, help=None, pinned=None, disabled=None, required=None, default=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | default | Iterable of str or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.multiselectcolumn


* Function signature:

   st.column_config.MultiselectColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, options=None, accept_new_options=None, color=None, format_func=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If None (default), the column name is used. |
   | width | "small", "medium", "large", or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None | False | Whether editing should be disabled for this column. Defaults to False. |
   | required | bool or None | False | Whether edited cells in the column need to have a value. If True, an edited cell can only be submitted if it has a value other than None. Defaults to False. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | Iterable of str or None | value | Specifies the default value in this column when a new row is added by the user. |
   | options | Iterable of str or None |  | The options that can be selected during editing. |
   | accept_new_options | bool or None |  | Whether the user can add selections that aren't included in options. If this is False (default), the user can only select from the items in options. If this is True, the user can enter new items that don't exist in options. When a user enters and selects a new item, it is included in the returned cell list value as a string. The new item is not added to the options drop-down menu. |
   | color | str, Iterable of str, or None |  | The color to use for different options. This can be:  None (default): The options are displayed without color.  "auto": The options are colored based on the configured categorical chart colors.  A single color value that is used for all options. This can be one of the following strings:   "primary" to use the primary theme color. A CSS named color name like "darkBlue" or "maroon". A hex color code like "#483d8b" or "#6A5ACD80". An RGB or RGBA color code like "rgb(255,0,0)" or "RGB(70, 130, 180, .7)". An HSL or HSLA color code like "hsl(248, 53%, 58%)" or "HSL(147, 50%, 47%, .3)".    An iterable of color values that are mapped to the options. The colors are applied in sequence, cycling through the iterable if there are more options than colors. |
   | format_func | function or None |  | Function to modify the display of the options. It receives the raw option defined in options as an argument and should output the label to be shown for that option. When used in st.data_editor, this has no impact on the returned value. If this is None (default), the raw option is used as the label. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.numbercolumn


* Function signature:

   st.column_config.NumberColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, format=None, min_value=None, max_value=None, step=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | int, float, or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | format | str, "plain", "localized", "percent", "dollar", "euro", "yen", "accounting", "compact", "scientific", "engineering", or None | locale | A format string controlling how numbers are displayed. This can be one of the following values:  None (default): Streamlit infers the formatting from the data. "plain": Show the full number without any formatting (e.g. "1234.567"). "localized": Show the number in the default locale format (e.g. "1,234.567"). "percent": Show the number as a percentage (e.g. "123456.70%"). "dollar": Show the number as a dollar amount (e.g. "$1,234.57"). "euro": Show the number as a euro amount (e.g. "€1,234.57"). "yen": Show the number as a yen amount (e.g. "¥1,235"). "accounting": Show the number in an accounting format (e.g. "1,234.00"). "bytes": Show the number in a byte format (e.g. "1.2KB"). "compact": Show the number in a compact format (e.g. "1.2K"). "scientific": Show the number in scientific notation (e.g. "1.235E3"). "engineering": Show the number in engineering notation (e.g. "1.235E3"). printf-style format string: Format the number with a printf specifier, like "%d" to show a signed integer (e.g. "1234") or "%X" to show an unsigned hexadecimal integer (e.g. "4D2"). You can also add prefixes and suffixes. To show British pounds, use "£ %.2f" (e.g. "£ 1234.57"). For more information, see sprint-js.  Formatting from column_config always takes precedence over formatting from pandas.Styler. The formatting does not impact the return value when used in st.data_editor. |
   | min_value | int, float, or None |  | The minimum value that can be entered. If this is None (default), there will be no minimum. |
   | max_value | int, float, or None |  | The maximum value that can be entered. If this is None (default), there will be no maximum. |
   | step | int, float, or None |  | The precision of numbers that can be entered. If this None (default), integer columns will have a step of 1 and float columns will have unrestricted precision. In this case, some floats may display like integers. Setting step for float columns will ensure a consistent number of digits after the decimal are displayed. If format is a predefined format like "dollar", step overrides the display precision. If format is a printf-style format string, step will not change the display precision. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.progresscolumn


* Function signature:

   st.column_config.ProgressColumn(label=None, *, width=None, help=None, pinned=None, format=None, min_value=None, max_value=None, step=None, color=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | format | str, "plain", "localized", "percent", "dollar", "euro", "yen", "accounting", "compact", "scientific", "engineering", or None | locale | A format string controlling how the numbers are displayed. This can be one of the following values:  None (default): Streamlit infers the formatting from the data. "plain": Show the full number without any formatting (e.g. "1234.567"). "localized": Show the number in the default locale format (e.g. "1,234.567"). "percent": Show the number as a percentage (e.g. "123456.70%"). "dollar": Show the number as a dollar amount (e.g. "$1,234.57"). "euro": Show the number as a euro amount (e.g. "€1,234.57"). "yen": Show the number as a yen amount (e.g. "¥1,235"). "accounting": Show the number in an accounting format (e.g. "1,234.00"). "bytes": Show the number in a byte format (e.g. "1.2KB"). "compact": Show the number in a compact format (e.g. "1.2K"). "scientific": Show the number in scientific notation (e.g. "1.235E3"). "engineering": Show the number in engineering notation (e.g. "1.235E3"). printf-style format string: Format the number with a printf specifier, like "%d" to show a signed integer (e.g. "1234") or "%X" to show an unsigned hexadecimal integer (e.g. "4D2"). You can also add prefixes and suffixes. To show British pounds, use "£ %.2f" (e.g. "£ 1234.57"). For more information, see sprint-js.  Number formatting from column_config always takes precedence over number formatting from pandas.Styler. The number formatting does not impact the return value when used in st.data_editor. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | min_value | int, float, or None |  | The minimum value of the progress bar. If this is None (default), the minimum will be 0. |
   | max_value | int, float, or None |  | The maximum value of the progress bar. If this is None (default), the maximum will be 100 for integer values and 1.0 for float values. |
   | step | int, float, or None |  | The precision of numbers. If this is None (default), integer columns will have a step of 1 and float columns will have a step of 0.01. Setting step for float columns will ensure a consistent number of digits after the decimal are displayed. |
   | color | "auto", "auto-inverse", str, or None |  | The color to use for the chart. This can be one of the following:  None (default): The primary color is used. "auto": If the value is more than half, the bar is green; if the value is less than half, the bar is red. "auto-inverse": If the value is more than half, the bar is red; if the value is less than half, the bar is green. A single color value that is applied to all charts in the column. In addition to the basic color palette (red, orange, yellow, green, blue, violet, gray/grey, and primary), this supports hex codes like "#483d8b". |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.selectboxcolumn


* Function signature:

   st.column_config.SelectboxColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, options=None, format_func=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | str, int, float, bool, or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | options | Iterable[str, int, float, bool] or None |  | The options that can be selected during editing. If this is None (default), the options will be inferred from the underlying dataframe column if its dtype is "category". For more information, see Pandas docs). |
   | format_func | function or None |  | Function to modify the display of the options. It receives the raw option defined in options as an argument and should output the label to be shown for that option. If this is None (default), the raw option is used as the label. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.textcolumn


* Function signature:

   st.column_config.TextColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, max_chars=None, validate=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | str or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | max_chars | int or None |  | The maximum number of characters that can be entered. If this is None (default), there will be no maximum. |
   | validate | str or None |  | A JS-flavored regular expression (e.g. "^[a-z]+$") that edited values are validated against. If the user input is invalid, it will not be submitted. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.column_config/st.column_config.timecolumn


* Function signature:

   st.column_config.TimeColumn(label=None, *, width=None, help=None, disabled=None, required=None, pinned=None, default=None, format=None, min_value=None, max_value=None, step=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | The label shown at the top of the column. If this is None (default), the column name is used. |
   | width | "small", "medium", "large", int, or None |  | The display width of the column. If this is None (default), the column will be sized to fit the cell contents. Otherwise, this can be one of the following:  "small": 75px wide "medium": 200px wide "large": 400px wide An integer specifying the width in pixels  If the total width of all columns is less than the width of the dataframe, the remaining space will be distributed evenly among all columns. |
   | help | str or None |  | A tooltip that gets displayed when hovering over the column label. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool or None |  | Whether editing should be disabled for this column. If this is None (default), Streamlit will enable editing wherever possible. If a column has mixed types, it may become uneditable regardless of disabled. |
   | required | bool or None |  | Whether edited cells in the column need to have a value. If this is False (default), the user can submit empty values for this column. If this is True, an edited cell in this column can only be submitted if its value is not None, and a new row will only be submitted after the user fills in this column. |
   | pinned | bool or None |  | Whether the column is pinned. A pinned column will stay visible on the left side no matter where the user scrolls. If this is None (default), Streamlit will decide: index columns are pinned, and data columns are not pinned. |
   | default | datetime.time or None | value | Specifies the default value in this column when a new row is added by the user. This defaults to None. |
   | format | str, "localized", "iso8601", or None | locale | A format string controlling how times are displayed. This can be one of the following values:  None (default): Show the time in "HH:mm:ss" format (e.g. "20:00:00"). "localized": Show the time in the default locale format (e.g. "12:00:00 PM" in the America/Los_Angeles timezone). "iso8601": Show the time in ISO 8601 format (e.g. "20:00:00.000Z"). A momentJS format string: Format the time with a string, like "ha" to show "8pm". For available formats, see momentJS.  Formatting from column_config always takes precedence over formatting from pandas.Styler. The formatting does not impact the return value when used in st.data_editor. |
   | min_value | datetime.time or None |  | The minimum time that can be entered. If this is None (default), there will be no minimum. |
   | max_value | datetime.time or None |  | The maximum time that can be entered. If this is None (default), there will be no maximum. |
   | step | int, float, datetime.timedelta, or None |  | The stepping interval in seconds. If this is None (default), the step will be 1 second. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.data_editor

<Tip>

This page only contains information on the `st.data_editor` API. For an overview of working with dataframes and to learn more about the data editor's capabilities and limitations, read [Dataframes](/develop/concepts/design/dataframes).

</Tip>

* Function signature:

   st.data_editor(data, *, width="stretch", height="auto", use_container_width=None, hide_index=None, column_order=None, column_config=None, num_rows="fixed", disabled=False, key=None, on_change=None, args=None, kwargs=None, row_height=None, placeholder=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe | to | The data to edit in the data editor.  Note  Styles from pandas.Styler will only be applied to non-editable columns. Text and number formatting from column_config always takes precedence over text and number formatting from pandas.Styler. If your dataframe starts with an empty column, you should set the column datatype in the underlying dataframe to ensure your intended datatype, especially for integers versus floats. Mixing data types within a column can make the column uneditable. Additionally, the following data types are not yet supported for editing: complex, tuple, bytes, bytearray, memoryview, dict, set, frozenset, fractions.Fraction, pandas.Interval, and pandas.Period. To prevent overflow in JavaScript, columns containing datetime.timedelta and pandas.Timedelta values will default to uneditable, but this can be changed through column configuration. |
   | width | "stretch", "content", or int |  | The width of the data editor. This can be one of the following:  "stretch" (default): The width of the editor matches the width of the parent container. "content": The width of the editor matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The editor has a fixed width. If the specified width is greater than the width of the parent container, the width of the editor matches the width of the parent container. |
   | height | "auto", "content", "stretch", or int |  | The height of the data editor. This can be one of the following:  "auto" (default): Streamlit sets the height to show at most ten rows. "content": The height of the editor matches the height of its content. The height is capped at 10,000 pixels to prevent performance issues with very large dataframes. "stretch": The height of the editor expands to fill the available vertical space in its parent container. When multiple elements with stretch height are in the same container, they share the available vertical space evenly. The editor will maintain a minimum height to display up to three rows, but otherwise won't exceed the available height in its parent container. An integer specifying the height in pixels: The editor has a fixed height.  Vertical scrolling within the editor is enabled when the height does not accommodate all rows. |
   | use_container_width | bool |  | Whether to override width with the width of the parent container. If this is True (default), Streamlit sets the width of the data editor to match the width of the parent container. If this is False, Streamlit sets the data editor's width according to width. |
   | hide_index | bool or None |  | Whether to hide the index column(s). If hide_index is None (default), the visibility of index columns is automatically determined based on the data. |
   | column_order | Iterable[str] or None |  | The ordered list of columns to display. If this is None (default), Streamlit displays all columns in the order inherited from the underlying data structure. If this is a list, the indicated columns will display in the order they appear within the list. Columns may be omitted or repeated within the list. For example, column_order=("col2", "col1") will display "col2" first, followed by "col1", and will hide all other non-index columns. column_order does not accept positional column indices and can't move the index column(s). |
   | column_config | dict or None |  | Configuration to customize how columns are displayed. If this is None (default), columns are styled based on the underlying data type of each column. Column configuration can modify column names, visibility, type, width, format, editing properties like min/max, and more. If this is a dictionary, the keys are column names (strings) and/or positional column indices (integers), and the values are one of the following:  None to hide the column. A string to set the display label of the column. One of the column types defined under st.column_config. For example, to show a column as dollar amounts, use st.column_config.NumberColumn("Dollar values", format="$ %d"). See more info on the available column types and config options here.  To configure the index column(s), use "_index" as the column name, or use a positional column index where 0 refers to the first index column. |
   | num_rows | "fixed" or "dynamic" | s | Specifies if the user can add and delete rows in the data editor. If "fixed", the user cannot add or delete rows. If "dynamic", the user can add and delete rows in the data editor, but column sorting is disabled. Defaults to "fixed". |
   | disabled | bool or Iterable[str | int] |  | Controls the editing of columns. This can be one of the following:  False (default): All columns that support editing are editable. True: All columns are disabled for editing. An Iterable of column names and/or positional indices: The specified columns are disabled for editing while the remaining columns are editable where supported. For example, disabled=["col1", "col2"] will disable editing for the columns named "col1" and "col2".  To disable editing for the index column(s), use "_index" as the column name, or use a positional column index where 0 refers to the first index column. |
   | key | str |  | An optional string to use as the unique key for this widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | on_change | callable |  | An optional callback invoked when this data_editor's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | row_height | int or None | row | The height of each row in the data editor in pixels. If row_height is None (default), Streamlit will use a default row height, which fits one line of text. |
   | placeholder | str or None |  | The text that should be shown for missing values. If this is None (default), missing values are displayed as "None". To leave a cell empty, use an empty string (""). Other common values are "null", "NaN" and "-". |

* Returns: pandas.DataFrame, pandas.Series, pyarrow.Table, numpy.ndarray, list, set, tuple, or dict.

    The edited data. The edited data is returned in its original data type if
it corresponds to any of the supported return types. All other data types
are returned as a pandas.DataFrame.



### Configuring columns

You can configure the display and editing behavior of columns in `st.dataframe` and `st.data_editor` via the [Column configuration API](/develop/api-reference/data/st.column_config). We have developed the API to let you add images, charts, and clickable URLs in dataframe and data editor columns. Additionally, you can make individual columns editable, set columns as categorical and specify which options they can take, hide the index of the dataframe, and much more.

<Cloud height="480px" name="doc-column-config-overview" query="embed_options=disable_scrolling"/>

---

Source: https://docs.streamlit.io/develop/api-reference/data/st.dataframe

<Tip>

Learn more in our [Dataframes](/develop/concepts/design/dataframes) guide and check out our tutorial, [Get dataframe row-selections from users](/develop/tutorials/elements/dataframe-row-selections).

</Tip>

* Function signature:

   st.dataframe(data=None, width="stretch", height="auto", *, use_container_width=None, hide_index=None, column_order=None, column_config=None, key=None, on_select="ignore", selection_mode="multi-row", row_height=None, placeholder=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | dataframe-like, collection-like, or None |  | The data to display. Dataframe-like objects include dataframe and series objects from popular libraries like Dask, Modin, Numpy, pandas, Polars, PyArrow, Snowpark, Xarray, and more. You can use database cursors and clients that comply with the Python Database API Specification v2.0 (PEP 249). Additionally, you can use anything that supports the Python dataframe interchange protocol. For example, you can use the following:  pandas.DataFrame, pandas.Series, pandas.Index, pandas.Styler, and pandas.Array polars.DataFrame, polars.LazyFrame, and polars.Series snowflake.snowpark.dataframe.DataFrame, snowflake.snowpark.table.Table  If a data type is not recognized, Streamlit will convert the object to a pandas.DataFrame or pyarrow.Table using a .to_pandas() or .to_arrow() method, respectively, if available. If data is a pandas.Styler, it will be used to style its underlying pandas.DataFrame. Streamlit supports custom cell values, colors, and font weights. It does not support some of the more exotic styling options, like bar charts, hovering, and captions. For these styling options, use column configuration instead. Text and number formatting from column_config always takes precedence over text and number formatting from pandas.Styler. Collection-like objects include all Python-native Collection types, such as dict, list, and set. If data is None, Streamlit renders an empty table. |
   | width | "stretch", "content", or int |  | The width of the dataframe element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | height | "auto", "content", "stretch", or int |  | The height of the dataframe element. This can be one of the following:  "auto" (default): Streamlit sets the height to show at most ten rows. "content": The height of the element matches the height of its content. The height is capped at 10,000 pixels to prevent performance issues with very large dataframes. "stretch": The height of the element expands to fill the available vertical space in its parent container. When multiple elements with stretch height are in the same container, they share the available vertical space evenly. The dataframe will maintain a minimum height to display up to three rows, but otherwise won't exceed the available height in its parent container. An integer specifying the height in pixels: The element has a fixed height.  Vertical scrolling within the dataframe element is enabled when the height does not accommodate all rows. |
   | use_container_width | bool |  | Whether to override width with the width of the parent container. If this is True (default), Streamlit sets the width of the dataframe to match the width of the parent container. If this is False, Streamlit sets the dataframe's width according to width. |
   | hide_index | bool or None |  | Whether to hide the index column(s). If hide_index is None (default), the visibility of index columns is automatically determined based on the data and other configurations. |
   | column_order | Iterable[str] or None |  | The ordered list of columns to display. If this is None (default), Streamlit displays all columns in the order inherited from the underlying data structure. If this is a list, the indicated columns will display in the order they appear within the list. Columns may be omitted or repeated within the list. For example, column_order=("col2", "col1") will display "col2" first, followed by "col1", and will hide all other non-index columns. column_order does not accept positional column indices and can't move the index column(s). |
   | column_config | dict or None |  | Configuration to customize how columns are displayed. If this is None (default), columns are styled based on the underlying data type of each column. Column configuration can modify column names, visibility, type, width, format, and more. If this is a dictionary, the keys are column names (strings) and/or positional column indices (integers), and the values are one of the following:  None to hide the column. A string to set the display label of the column. One of the column types defined under st.column_config. For example, to show a column as dollar amounts, use st.column_config.NumberColumn("Dollar values", format="$ %d"). See more info on the available column types and config options here.  To configure the index column(s), use "_index" as the column name, or use a positional column index where 0 refers to the first index column. |
   | key | str |  | An optional string to use for giving this element a stable identity. If key is None (default), this element's identity will be determined based on the values of the other parameters. Additionally, if selections are activated and key is provided, Streamlit will register the key in Session State to store the selection state. The selection state is read-only. |
   | on_select | "ignore" or "rerun" or callable |  | How the dataframe should respond to user selection events. This controls whether or not the dataframe behaves like an input widget. on_select can be one of the following:  "ignore" (default): Streamlit will not react to any selection events in the dataframe. The dataframe will not behave like an input widget. "rerun": Streamlit will rerun the app when the user selects rows, columns, or cells in the dataframe. In this case, st.dataframe will return the selection data as a dictionary. A callable: Streamlit will rerun the app and execute the callable as a callback function before the rest of the app. In this case, st.dataframe will return the selection data as a dictionary. |
   | selection_mode | "single-row", "multi-row", "single-column",             "multi-column", "single-cell", "multi-cell", or Iterable of these |  | The types of selections Streamlit should allow when selections are enabled with on_select. This can be one of the following:  "multi-row" (default): Multiple rows can be selected at a time. "single-row": Only one row can be selected at a time. "multi-column": Multiple columns can be selected at a time. "single-column": Only one column can be selected at a time. "multi-cell": A rectangular range of cells can be selected. "single-cell": Only one cell can be selected at a time. An Iterable of the above options: The table will allow selection based on the modes specified. For example, to allow the user to select multiple rows and multiple cells, use ["multi-row", "multi-cell"].  When column selections are enabled, column sorting is disabled. |
   | row_height | int or None | row | The height of each row in the dataframe in pixels. If row_height is None (default), Streamlit will use a default row height, which fits one line of text. |
   | placeholder | str or None |  | The text that should be shown for missing values. If this is None (default), missing values are displayed as "None". To leave a cell empty, use an empty string (""). Other common values are "null", "NaN" and "-". |

* Returns: element or dict

    If on_select is "ignore" (default), this command returns an
internal placeholder for the dataframe element that can be used
with the .add_rows() method. Otherwise, this command returns a
dictionary-like object that supports both key and attribute
notation. The attributes are described by the DataframeState
dictionary schema.



## Dataframe selections


* Function signature:

   DataframeState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | selection | dict |  | The state of the on_select event. This attribute returns a dictionary-like object that supports both key and attribute notation. The attributes are described by the DataframeSelectionState dictionary schema. |



* Function signature:

   DataframeSelectionState

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | rows | list[int] |  | The selected rows, identified by their integer position. The integer positions match the original dataframe, even if the user sorts the dataframe in their browser. For a pandas.DataFrame, you can retrieve data from its integer position using methods like .iloc[] or .iat[]. |
   | columns | list[str] |  | The selected columns, identified by their names. |
   | cells | list[tuple[int, str]] |  | The selected cells, provided as a tuple of row integer position and column name. For example, the first cell in a column named "col 1" is represented as (0, "col 1"). Cells within index columns are not returned. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.experimental_data_editor

[Function 'streamlit.experimental_data_editor' not found]

---

Source: https://docs.streamlit.io/develop/api-reference/data/st.json


* Function signature:

   st.json(body, *, expanded=True, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | object or str |  | The object to print as JSON. All referenced objects should be serializable to JSON as well. If object is a string, we assume it contains serialized JSON. |
   | expanded | bool or int |  | The initial expansion state of the JSON element. This can be one of the following:  True (default): The element is fully expanded. False: The element is fully collapsed. An integer: The element is expanded to the depth specified. The integer must be non-negative. expanded=0 is equivalent to expanded=False.  Regardless of the initial expansion state, users can collapse or expand any key-value pair to show or hide any part of the object. |
   | width | "stretch" or int |  | The width of the JSON element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.metric


* Function signature:

   st.metric(label, value, delta=None, delta_color="normal", *, help=None, label_visibility="visible", border=False, width="stretch", height="content", chart_data=None, chart_type="line", delta_arrow="auto")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | The header or title for the metric. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | value | int, float, decimal.Decimal, str, or None |  | Value of the metric. None is rendered as a long dash. |
   | delta | int, float, decimal.Decimal, str, or None |  | Indicator of how the metric changed, rendered with an arrow below the metric. If delta is negative (int/float) or starts with a minus sign (str), the arrow points down and the text is red; else the arrow points up and the text is green. If None (default), no delta indicator is shown. |
   | delta_color | "normal", "inverse", or "off" |  | If "normal" (default), the delta indicator is shown as described above. If "inverse", it is red when positive and green when negative. This is useful when a negative change is considered good, e.g. if cost decreased. If "off", delta is  shown in gray regardless of its value. |
   | help | str or None |  | A tooltip that gets displayed next to the metric label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | border | bool |  | Whether to show a border around the metric container. If this is False (default), no border is shown. If this is True, a border is shown. |
   | height | "content", "stretch", or int |  | The height of the metric element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled. |
   | width | "stretch", "content", or int |  | The width of the metric element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | chart_data | Iterable or None |  | A sequence of numeric values to display as a sparkline chart. If this is None (default), no chart is displayed. The sequence can be anything supported by st.dataframe, including a list or set. If the sequence is dataframe-like, the first column will be used. Each value will be cast to float internally by default. |
   | chart_type | "line", "bar", or "area" |  | The type of sparkline chart to display. This can be one of the following:  "line" (default): A simple sparkline. "area": A sparkline with area shading. "bar": A bar chart. |
   | delta_arrow | "auto", "up", "down", or "off" |  | Controls the direction of the delta indicator arrow. This can be one of the following strings:  "auto" (default): The arrow direction follows the sign of delta. "up" or "down": The arrow is forced to point in the specified direction. "off": No arrow is shown, but the delta value remains visible. |



---

Source: https://docs.streamlit.io/develop/api-reference/data/st.table

<Tip>

Static tables with `st.table` are the most basic way to display dataframes. For the majority of cases, we recommend using [`st.dataframe`](/develop/api-reference/data/st.dataframe) to display interactive dataframes, and [`st.data_editor`](/develop/api-reference/data/st.data_editor) to let users edit dataframes.

</Tip>

* Function signature:

   st.table(data=None, *, border=True)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | Anything supported by st.dataframe |  | The table data. All cells including the index and column headers can optionally contain GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | border | bool or "horizontal" |  | Whether to show borders around the table and between cells. This can be one of the following:  True (default): Show borders around the table and between cells. False: Don't show any borders. "horizontal": Show only horizontal borders between rows. |



* Function signature:

   element.add_rows(data=None, **kwargs)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | pandas.DataFrame, pandas.Styler, pyarrow.Table, numpy.ndarray, pyspark.sql.DataFrame, snowflake.snowpark.dataframe.DataFrame, Iterable, dict, or None |  | Table to concat. Optional. |
   | **kwargs | pandas.DataFrame, numpy.ndarray, Iterable, dict, or None |  | The named dataset to concat. Optional. You can only pass in 1 dataset (including the one in the data parameter). |



---

# Execution flow

Source: https://docs.streamlit.io/develop/api-reference/execution-flow


## Change execution

By default, Streamlit apps execute the script entirely, but we allow some functionality to handle control flow in your applications.

<TileContainer>
<RefCard href="/develop/api-reference/execution-flow/st.dialog" size="full">
<Image>alt="screenshot" src="/images/api/dialog.jpg" /&gt;

<h4>Modal dialog</h4>

Insert a modal dialog that can rerun independently from the rest of the script.

```python
@st.dialog("Sign up")
def email_form():
    name = st.text_input("Name")
    email = st.text_input("Email")
```

</Image>
<RefCard href="/develop/api-reference/execution-flow/st.fragment">
<h4>Fragments</h4>

Define a fragment to rerun independently from the rest of the script.

```python
@st.fragment(run_every="10s")
def fragment():
    df = get_data()
    st.line_chart(df)
```

</RefCard>
<RefCard href="/develop/api-reference/execution-flow/st.rerun">
<h4>Rerun script</h4>

Rerun the script immediately.

```python
st.rerun()
```

</RefCard>
<RefCard href="/develop/api-reference/execution-flow/st.stop">
<h4>Stop execution</h4>

Stops execution immediately.

```python
st.stop()
```

</RefCard>
</RefCard>

## Group multiple widgets

By default, Streamlit reruns your script everytime a user interacts with your app.
However, sometimes it's a better user experience to wait until a group of related
widgets is filled before actually rerunning the script. That's what `st.form` is for!

<TileContainer>
<RefCard href="/develop/api-reference/execution-flow/st.form" size="half">
<h4>Forms</h4>

Create a form that batches elements together with a “Submit" button.

```python
with st.form(key='my_form'):
    name = st.text_input("Name")
    email = st.text_input("Email")
    st.form_submit_button("Sign up")
```

</RefCard>
<RefCard href="/develop/api-reference/execution-flow/st.form_submit_button" size="half">
<h4>Form submit button</h4>

Display a form submit button.

```python
with st.form(key='my_form'):
    name = st.text_input("Name")
    email = st.text_input("Email")
    st.form_submit_button("Sign up")
```

</RefCard>
</TileContainer>
<ComponentSlider>
<ComponentCard href="https://github.com/kmcgrady/streamlit-autorefresh">
<Image>alt="screenshot" src="/images/api/components/autorefresh.jpg" /&gt;

<h4>Autorefresh</h4>

Force a refresh without tying up a script. Created by [@kmcgrady](https://github.com/kmcgrady).

```python
from streamlit_autorefresh import st_autorefresh

st_autorefresh(interval=2000, limit=100,
  key="fizzbuzzcounter")
```

</Image>
<ComponentCard href="https://github.com/lukasmasuch/streamlit-pydantic">
<Image>alt="screenshot" src="/images/api/components/pydantic.jpg" /&gt;

<h4>Pydantic</h4>

Auto-generate Streamlit UI from Pydantic Models and Dataclasses. Created by [@lukasmasuch](https://github.com/lukasmasuch).

```python
import streamlit_pydantic as sp

sp.pydantic_form(key="my_form",
  model=ExampleModel)
```

</Image>
<ComponentCard href="https://github.com/blackary/st_pages">
<Image>alt="screenshot" src="/images/api/components/pages.jpg" /&gt;

<h4>Streamlit Pages</h4>

An experimental version of Streamlit Multi-Page Apps. Created by [@blackary](https://github.com/blackary).

```python
from st_pages import Page, show_pages, add_page_title

show_pages([ Page("streamlit_app.py", "Home", "🏠"),
  Page("other_pages/page2.py", "Page 2", ":books:"), ])
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentSlider></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.dialog


* Function signature:

   st.dialog(title, *, width="small", dismissible=True, on_dismiss="ignore")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | title | str |  | The title to display at the top of the modal dialog. It cannot be empty. The title can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | width | "small", "medium", "large" |  | The width of the modal dialog. This can be one of the following:  "small" (default): The modal dialog will be a maximum of 500 pixels wide. "medium": The modal dialog will be up to 750 pixels wide. "large": The modal dialog will be up to 1280 pixels wide. |
   | dismissible | bool |  | Whether the modal dialog can be dismissed by the user. If this is True (default), the user can dismiss the dialog by clicking outside of it, clicking the "X" in its upper-right corner, or pressing ESC on their keyboard. If this is False, the "X" in the upper-right corner is hidden and the dialog must be closed programmatically by calling st.rerun() inside the dialog function.  Note Setting dismissible to False does not guarantee that all interactions in the main app are blocked. Don't rely on dismissible for security-critical checks. |
   | on_dismiss | "ignore", "rerun", or callable |  | How the dialog should respond to dismissal events. This can be one of the following:  "ignore" (default): Streamlit will not rerun the app when the user dismisses the dialog. "rerun": Streamlit will rerun the app when the user dismisses the dialog. A callable: Streamlit will rerun the app when the user dismisses the dialog and execute the callable as a callback function before the rest of the app. |



---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.experimental_rerun

[Function 'streamlit.experimental_rerun' not found]

---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.form

<Tip>

This page only contains information on the `st.forms` API. For a deeper dive into creating and using forms within Streamlit apps, read our guide on [Using forms](/develop/concepts/architecture/forms).

</Tip>

* Function signature:

   st.form(key, clear_on_submit=False, *, enter_to_submit=True, border=True, width="stretch", height="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | key | str |  | A string that identifies the form. Each form must have its own key. (This key is not displayed to the user in the interface.) |
   | clear_on_submit | bool | values | If True, all widgets inside the form will be reset to their default values after the user presses the Submit button. Defaults to False. (Note that Custom Components are unaffected by this flag, and will not be reset to their defaults on form submission.) |
   | enter_to_submit | bool |  | Whether to submit the form when a user presses Enter while interacting with a widget inside the form. If this is True (default), pressing Enter while interacting with a form widget is equivalent to clicking the first st.form_submit_button in the form. If this is False, the user must click an st.form_submit_button to submit the form. If the first st.form_submit_button in the form is disabled, the form will override submission behavior with enter_to_submit=False. |
   | border | bool | True | Whether to show a border around the form. Defaults to True.  Note Not showing a border can be confusing to viewers since interacting with a widget in the form will do nothing. You should only remove the border if there's another border (e.g. because of an expander) or the form is small (e.g. just a text input and a submit button). |
   | width | "stretch", "content", or int |  | The width of the form container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. "content": The width of the container matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |
   | height | "content", "stretch", or int |  | The height of the form container. This can be one of the following:  "content" (default): The height of the container matches the height of its content. "stretch": The height of the container matches the height of its content or the height of the parent container, whichever is larger. If the container is not in a parent container, the height of the container matches the height of its content. An integer specifying the height in pixels: The container has a fixed height. If the content is larger than the specified height, scrolling is enabled.   Note Use scrolling containers sparingly. If you use scrolling containers, avoid heights that exceed 500 pixels. Otherwise, the scroll surface of the container might cover the majority of the screen on mobile devices, which makes it hard to scroll the rest of the app. |



---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.form_submit_button


* Function signature:

   st.form_submit_button(label="Submit", help=None, on_click=None, args=None, kwargs=None, *, key=None, type="secondary", icon=None, disabled=False, use_container_width=None, width="content", shortcut=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str | s | A short label explaining to the user what this button is for. This defaults to "Submit". The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | help | str or None |  | A tooltip that gets displayed when the button is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_click | callable |  | An optional callback invoked when this button is clicked. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | type | "primary", "secondary", or "tertiary" |  | An optional string that specifies the button type. This can be one of the following:  "primary": The button's background is the app's primary color for additional emphasis. "secondary" (default): The button's background coordinates with the app's background color for normal emphasis. "tertiary": The button is plain text without a border or background for subtlety. |
   | icon | str or None |  | An optional emoji or icon to display next to the button label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | disabled | bool |  | Whether to disable the button. If this is False (default), the user can interact with the button. If this is True, the button is grayed-out and can't be clicked. If the first st.form_submit_button in the form is disabled, the form will override submission behavior with enter_to_submit=False. |
   | use_container_width | bool |  | Whether to expand the button's width to fill its parent container. If use_container_width is False (default), Streamlit sizes the button to fit its contents. If use_container_width is True, the width of the button matches its parent container. In both cases, if the contents of the button are wider than the parent container, the contents will line wrap. |
   | width | "content", "stretch", or int |  | The width of the button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container. |
   | shortcut | str or None |  | An optional keyboard shortcut that triggers the button. This can be one of the following strings:  A single alphanumeric key like "K" or "4". A function key like "F11". A special key like "Enter", "Esc", or "Tab". Any of the above combined with modifiers. For example, you can use "Ctrl+K" or "Cmd+Shift+O".   Important The keys "C" and "R" are reserved and can't be used, even with modifiers. Punctuation keys like "." and "," aren't currently supported.  For a list of supported keys and modifiers, see the documentation for st.button. |

* Returns: bool

    True if the button was clicked.



---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.fragment


* Function signature:

   st.fragment(func=None, *, run_every=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | func | callable |  | The function to turn into a fragment. |
   | run_every | int, float, timedelta, str, or None |  | The time interval between automatic fragment reruns. This can be one of the following:   None (default). An int or float specifying the interval in seconds. A string specifying the time in a format supported by Pandas' Timedelta constructor, e.g. "1d", "1.5 days", or "1h23s". A timedelta object from Python's built-in datetime library, e.g. timedelta(days=1).   If run_every is None, the fragment will only rerun from user-triggered events. |



---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.rerun


* Function signature:

   st.rerun(*, scope="app")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | scope | "app" or "fragment" |  | Specifies what part of the app should rerun. If scope is "app" (default), the full app reruns. If scope is "fragment", Streamlit only reruns the fragment from which this command is called. Setting scope="fragment" is only valid inside a fragment during a fragment rerun. If st.rerun(scope="fragment") is called during a full-app rerun or outside of a fragment, Streamlit will raise a StreamlitAPIException. |



### Caveats for `st.rerun`

`st.rerun` is one of the tools to control the logic of your app. While it is great for prototyping, there can be adverse side effects:

- Additional script runs may be inefficient and slower.
- Excessive reruns may complicate your app's logic and be harder to follow.
- If misused, infinite looping may crash your app.

In many cases where `st.rerun` works, [callbacks](/develop/api-reference/caching-and-state/st.session_state#use-callbacks-to-update-session-state) may be a cleaner alternative. [Containers](/develop/api-reference/layout) may also be helpful.

### A simple example in three variations

###### Using `st.rerun` to update an earlier header

```python
import streamlit as st

if "value" not in st.session_state:
    st.session_state.value = "Title"

##### Option using st.rerun #####
st.header(st.session_state.value)

if st.button("Foo"):
    st.session_state.value = "Foo"
    st.rerun()
```

###### Using a callback to update an earlier header

```python
##### Option using a callback #####
st.header(st.session_state.value)

def update_value():
    st.session_state.value = "Bar"

st.button("Bar", on_click=update_value)
```

###### Using containers to update an earlier header

```python
##### Option using a container #####
container = st.container()

if st.button("Baz"):
    st.session_state.value = "Baz"

container.header(st.session_state.value)
```

---

Source: https://docs.streamlit.io/develop/api-reference/execution-flow/st.stop


* Function signature:

   st.stop()



---

# Layouts and Containers

Source: https://docs.streamlit.io/develop/api-reference/layout


## Complex layouts

Streamlit provides several options for controlling how different elements are laid out on the screen.

<TileContainer>
<RefCard href="/develop/api-reference/layout/st.columns">
<Image>alt="screenshot" src="/images/api/columns.jpg" /&gt;

<h4>Columns</h4>

Insert containers laid out as side-by-side columns.

```python
col1, col2 = st.columns(2)
col1.write("this is column 1")
col2.write("this is column 2")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.container">
<Image>alt="screenshot" src="/images/api/container.jpg" /&gt;

<h4>Container</h4>

Insert a multi-element container.

```python
c = st.container()
st.write("This will show last")
c.write("This will show first")
c.write("This will show second")
```

</Image>
<RefCard href="/develop/api-reference/execution-flow/st.dialog">
<Image>alt="screenshot" src="/images/api/dialog.jpg" /&gt;

<h4>Modal dialog</h4>

Insert a modal dialog that can rerun independently from the rest of the script.

```python
@st.dialog("Sign up")
def email_form():
    name = st.text_input("Name")
    email = st.text_input("Email")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.empty">
<Image>alt="screenshot" src="/images/api/empty.jpg" /&gt;

<h4>Empty</h4>

Insert a single-element container.

```python
c = st.empty()
st.write("This will show last")
c.write("This will be replaced")
c.write("This will show first")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.expander">
<Image>alt="screenshot" src="/images/api/expander.jpg" /&gt;

<h4>Expander</h4>

Insert a multi-element container that can be expanded/collapsed.

```python
with st.expander("Open to see more"):
  st.write("This is more content")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.popover">
<Image>alt="screenshot" src="/images/api/popover.svg" /&gt;

<h4>Popover</h4>

Insert a multi-element popover container that can be opened/closed.

```python
with st.popover("Settings"):
  st.checkbox("Show completed")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.sidebar">
<Image>alt="screenshot" src="/images/api/sidebar.jpg" /&gt;

<h4>Sidebar</h4>

Display items in a sidebar.

```python
st.sidebar.write("This lives in the sidebar")
st.sidebar.button("Click me!")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.space">
<Image>alt="screenshot" src="/images/api/space.jpg" /&gt;

<h4>Space</h4>

Add vertical or horizontal space.

```python
st.space("small")
```

</Image>
<RefCard href="/develop/api-reference/layout/st.tabs">
<Image>alt="screenshot" src="/images/api/tabs.jpg" /&gt;

<h4>Tabs</h4>

Insert containers separated into tabs.

```python
tab1, tab2 = st.tabs(["Tab 1", "Tab2"])
tab1.write("this is tab 1")
tab2.write("this is tab 2")
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/okld/streamlit-elements">
<Image>alt="screenshot" src="/images/api/components/elements.jpg" /&gt;

<h4>Streamlit Elements</h4>

Create a draggable and resizable dashboard in Streamlit. Created by [@okls](https://github.com/okls).

```python
from streamlit_elements import elements, mui, html

with elements("new_element"):
  mui.Typography("Hello world")
```

</Image>
<ComponentCard href="https://github.com/lukasmasuch/streamlit-pydantic">
<Image>alt="screenshot" src="/images/api/components/pydantic.jpg" /&gt;

<h4>Pydantic</h4>

Auto-generate Streamlit UI from Pydantic Models and Dataclasses. Created by [@lukasmasuch](https://github.com/lukasmasuch).

```python
import streamlit_pydantic as sp

sp.pydantic_form(key="my_form",
  model=ExampleModel)
```

</Image>
<ComponentCard href="https://github.com/blackary/st_pages">
<Image>alt="screenshot" src="/images/api/components/pages.jpg" /&gt;

<h4>Streamlit Pages</h4>

An experimental version of Streamlit Multi-Page Apps. Created by [@blackary](https://github.com/blackary).

```python
from st_pages import Page, show_pages, add_page_title

show_pages([ Page("streamlit_app.py", "Home", "🏠"),
  Page("other_pages/page2.py", "Page 2", ":books:"), ])
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.columns


* Function signature:

   st.columns(spec, *, gap="small", vertical_alignment="top", border=False, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | spec | int or Iterable of numbers |  | Controls the number and width of columns to insert. Can be one of:  An integer that specifies the number of columns. All columns have equal width in this case. An Iterable of numbers (int or float) that specify the relative width of each column. E.g. [0.7, 0.3] creates two columns where the first one takes up 70% of the available with and the second one takes up 30%. Or [1, 2, 3] creates three columns where the second one is two times the width of the first one, and the third one is three times that width. |
   | gap | "small", "medium", "large", or None |  | The size of the gap between the columns. This can be one of the following:  "small" (default): 1rem gap between the columns. "medium": 2rem gap between the columns. "large": 4rem gap between the columns. None: No gap between the columns.  The rem unit is relative to the theme.baseFontSize configuration option. |
   | vertical_alignment | "top", "center", or "bottom" | is | The vertical alignment of the content inside the columns. The default is "top". |
   | border | bool |  | Whether to show a border around the column containers. If this is False (default), no border is shown. If this is True, a border is shown around each column. |
   | width | "stretch" or int |  | The width of the column group. This can be one of the following:  "stretch" (default): The width of the column group matches the width of the parent container. An integer specifying the width in pixels: The column group has a fixed width. If the specified width is greater than the width of the parent container, the width of the column group matches the width of the parent container. |

* Returns: list of containers

    A list of container objects.



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.container


* Function signature:

   st.container(*, border=None, key=None, width="stretch", height="content", horizontal=False, horizontal_alignment="left", vertical_alignment="top", gap="small")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | border | bool or None |  | Whether to show a border around the container. If None (default), a border is shown if the container is set to a fixed height and not shown otherwise. |
   | key | str or None |  | An optional string to give this container a stable identity. Additionally, if key is provided, it will be used as CSS class name prefixed with st-key-. |
   | width | "stretch", "content", or int |  | The width of the container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. "content": The width of the container matches the width of its content. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |
   | height | "content", "stretch", or int |  | The height of the container. This can be one of the following:  "content" (default): The height of the container matches the height of its content. "stretch": The height of the container matches the height of its content or the height of the parent container, whichever is larger. If the container is not in a parent container, the height of the container matches the height of its content. An integer specifying the height in pixels: The container has a fixed height. If the content is larger than the specified height, scrolling is enabled.   Note Use scrolling containers sparingly. If you use scrolling containers, avoid heights that exceed 500 pixels. Otherwise, the scroll surface of the container might cover the majority of the screen on mobile devices, which makes it hard to scroll the rest of the app. |
   | horizontal | bool |  | Whether to use horizontal flexbox layout. If this is False (default), the container's elements are laid out vertically. If this is True, the container's elements are laid out horizontally and will overflow to the next line if they don't fit within the container's width. |
   | horizontal_alignment | "left", "center", "right", or "distribute" |  | The horizontal alignment of the elements inside the container. This can be one of the following:  "left" (default): Elements are aligned to the left side of the container.  "center": Elements are horizontally centered inside the container.  "right": Elements are aligned to the right side of the container.  "distribute": Elements are distributed evenly in the container. This increases the horizontal gap between elements to fill the width of the container. A standalone element is aligned to the left. When horizontal is False, "distribute" aligns the elements the same as "left". |
   | vertical_alignment | "top", "center", "bottom", or "distribute" |  | The vertical alignment of the elements inside the container. This can be one of the following:  "top" (default): Elements are aligned to the top of the container.  "center": Elements are vertically centered inside the container.  "bottom": Elements are aligned to the bottom of the container.  "distribute": Elements are distributed evenly in the container. This increases the vertical gap between elements to fill the height of the container. A standalone element is aligned to the top. When horizontal is True, "distribute" aligns the elements the same as "top". |
   | gap | "small", "medium", "large", or None |  | The minimum gap size between the elements inside the container. This can be one of the following:  "small" (default): 1rem gap between the elements. "medium": 2rem gap between the elements. "large": 4rem gap between the elements. None: No gap between the elements.  The rem unit is relative to the theme.baseFontSize configuration option. The minimum gap applies to both the vertical and horizontal gaps between the elements. Elements may have larger gaps in one direction if you use a distributed horizontal alignment or fixed height. |



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.empty


* Function signature:

   st.empty()



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.expander


* Function signature:

   st.expander(label, expanded=False, *, icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A string to use as the header for the expander. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | expanded | bool | s | If True, initializes the expander in "expanded" state. Defaults to False (collapsed). |
   | icon | str, None |  | An optional emoji or icon to display next to the expander label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the expander container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.popover


* Function signature:

   st.popover(label, *, type="secondary", help=None, icon=None, disabled=False, use_container_width=None, width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | The label of the button that opens the popover container. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | help | str or None |  | A tooltip that gets displayed when the popover button is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | type | "primary", "secondary", or "tertiary" |  | An optional string that specifies the button type. This can be one of the following:  "primary": The button's background is the app's primary color for additional emphasis. "secondary" (default): The button's background coordinates with the app's background color for normal emphasis. "tertiary": The button is plain text without a border or background for subtlety. |
   | icon | str |  | An optional emoji or icon to display next to the button label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | disabled | bool | is | An optional boolean that disables the popover button if set to True. The default is False. |
   | use_container_width | bool |  | Whether to expand the button's width to fill its parent container. If use_container_width is False (default), Streamlit sizes the button to fit its content. If use_container_width is True, the width of the button matches its parent container. In both cases, if the content of the button is wider than the parent container, the content will line wrap. The popover container's minimum width matches the width of its button. The popover container may be wider than its button to fit the container's content. |
   | width | int, "stretch", or "content" |  | The width of the button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container.  The popover container's minimum width matches the width of its button. The popover container may be wider than its button to fit the container's contents. |



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.sidebar

## st.sidebar

## Add widgets to sidebar

Not only can you add interactivity to your app with widgets, you can organize them into a sidebar. Elements can be passed to `st.sidebar` using object notation and `with` notation.

The following two snippets are equivalent:

```python
# Object notation
st.sidebar.[element_name]
```

```python
# "with" notation
with st.sidebar:
    st.[element_name]
```

Each element that's passed to `st.sidebar` is pinned to the left, allowing users to focus on the content in your app.

<Tip>

The sidebar is resizable! Drag and drop the right border of the sidebar to resize it! ↔️

</Tip>

Here's an example of how you'd add a selectbox and a radio button to your sidebar:

```python
import streamlit as st

# Using object notation
add_selectbox = st.sidebar.selectbox(
    "How would you like to be contacted?",
    ("Email", "Home phone", "Mobile phone")
)

# Using "with" notation
with st.sidebar:
    add_radio = st.radio(
        "Choose a shipping method",
        ("Standard (5-15 days)", "Express (2-5 days)")
    )
```

<Important>

The only elements that aren't supported using object notation are `st.echo`, `st.spinner`, and `st.toast`. To use these elements, you must use `with` notation.

</Important>

Here's an example of how you'd add [`st.echo`](/develop/api-reference/text/st.echo) and [`st.spinner`](/develop/api-reference/status/st.spinner) to your sidebar:

```python
import streamlit as st
import time

with st.sidebar:
    with st.echo():
        st.write("This code will be printed to the sidebar.")

    with st.spinner("Loading..."):
        time.sleep(5)
    st.success("Done!")
```

---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.space


* Function signature:

   st.space(size="small")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | size | "small", "medium", "large", "stretch", or int |  | The size of the space. This can be one of the following values:  "small" (default): 0.75rem, which is the height of a widget label. This is useful for aligning buttons with labeled widgets. "medium": 2.5rem, which is the height of a button or (unlabeled) input field. "large": 4.25rem, which is the height of a labeled input field or unlabeled media widget, like st.file_uploader. "stretch": Expands to fill remaining space in the container. An integer: Fixed size in pixels. |



---

Source: https://docs.streamlit.io/develop/api-reference/layout/st.tabs


* Function signature:

   st.tabs(tabs, *, width="stretch", default=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | tabs | list of str |  | Creates a tab for each string in the list. The first tab is selected by default. The string is used as the name of the tab and can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | width | "stretch" or int |  | The width of the tab container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |
   | default | str or None | tab | The default tab to select. If this is None (default), the first tab is selected. If this is a string, it must be one of the tab labels. If two tabs have the same label as default, the first one is selected. |

* Returns: list of containers

    A list of container objects.



---

# Media elements

Source: https://docs.streamlit.io/develop/api-reference/media


It's easy to embed images, videos, and audio files directly into your Streamlit apps.

<TileContainer>
<RefCard href="/develop/api-reference/media/st.image">
<Image>alt="screenshot" src="/images/api/image.jpg" /&gt;

<h4>Image</h4>

Display an image or list of images.

```python
st.image(numpy_array)
st.image(image_bytes)
st.image(file)
st.image("https://example.com/myimage.jpg")
```

</Image>
<RefCard href="/develop/api-reference/media/st.logo">
<Image>alt="screenshot" src="/images/api/logo.jpg" /&gt;

<h4>Logo</h4>

Display a logo in the upper-left corner of your app and its sidebar.

```python
st.logo("logo.jpg")
```

</Image>
<RefCard href="/develop/api-reference/media/st.pdf">
<Image>alt="screenshot" src="/images/api/pdf.jpg" /&gt;

<h4>PDF</h4>

Display a PDF file.

```python
st.pdf("my_document.pdf")
```

</Image>
<RefCard href="/develop/api-reference/media/st.audio">
<Image>alt="screenshot" src="/images/api/audio.jpg" /&gt;

<h4>Audio</h4>

Display an audio player.

```python
st.audio(numpy_array)
st.audio(audio_bytes)
st.audio(file)
st.audio("https://example.com/myaudio.mp3", format="audio/mp3")
```

</Image>
<RefCard href="/develop/api-reference/media/st.video">
<Image>alt="screenshot" src="/images/api/video.jpg" /&gt;

<h4>Video</h4>

Display a video player.

```python
st.video(numpy_array)
st.video(video_bytes)
st.video(file)
st.video("https://example.com/myvideo.mp4", format="video/mp4")
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/whitphx/streamlit-webrtc">
<Image>alt="screenshot" src="/images/api/components/webrtc.jpg" /&gt;

<h4>Streamlit Webrtc</h4>

Handling and transmitting real-time video/audio streams with Streamlit. Created by [@whitphx](https://github.com/whitphx).

```python
from streamlit_webrtc import webrtc_streamer

webrtc_streamer(key="sample")
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-drawable-canvas">
<Image>alt="screenshot" src="/images/api/components/drawable-canvas.jpg" /&gt;

<h4>Drawable Canvas</h4>

Provides a sketching canvas using [Fabric.js](http://fabricjs.com/). Created by [@andfanilo](https://github.com/andfanilo).

```python
from streamlit_drawable_canvas import st_canvas

st_canvas(fill_color="rgba(255, 165, 0, 0.3)", stroke_width=stroke_width, stroke_color=stroke_color, background_color=bg_color, background_image=Image.open(bg_image) if bg_image else None, update_streamlit=realtime_update, height=150, drawing_mode=drawing_mode, point_display_radius=point_display_radius if drawing_mode == 'point' else 0, key="canvas",)
```

</Image>
<ComponentCard href="https://github.com/fcakyon/streamlit-image-comparison">
<Image>alt="screenshot" src="/images/api/components/image-comparison.jpg" /&gt;

<h4>Image Comparison</h4>

Compare images with a slider using [JuxtaposeJS](https://juxtapose.knightlab.com/). Created by [@fcakyon](https://github.com/fcakyon).

```python
from streamlit_image_comparison import image_comparison

image_comparison(img1="image1.jpg", img2="image2.jpg",)
```

</Image>
<ComponentCard href="https://github.com/turner-anderson/streamlit-cropper">
<Image>alt="screenshot" src="/images/api/components/cropper.jpg" /&gt;

<h4>Streamlit Cropper</h4>

A simple image cropper for Streamlit. Created by [@turner-anderson](https://github.com/turner-anderson).

```python
from streamlit_cropper import st_cropper

st_cropper(img, realtime_update=realtime_update, box_color=box_color, aspect_ratio=aspect_ratio)
```

</Image>
<ComponentCard href="https://github.com/blackary/streamlit-image-coordinates">
<Image>alt="screenshot" src="/images/api/components/image-coordinates.jpg" /&gt;

<h4>Image Coordinates</h4>

Get the coordinates of clicks on an image. Created by [@blackary](https://github.com/blackary/).

```python
from streamlit_image_coordinates import streamlit_image_coordinates

streamlit_image_coordinates("https://placekitten.com/200/300")
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-lottie">
<Image>alt="screenshot" src="/images/api/components/lottie.jpg" /&gt;

<h4>Streamlit Lottie</h4>

Integrate [Lottie](https://lottiefiles.com/) animations inside your Streamlit app. Created by [@andfanilo](https://github.com/andfanilo).

```python
lottie_hello = load_lottieurl("https://assets5.lottiefiles.com/packages/lf20_V9t630.json")

st_lottie(lottie_hello, key="hello")
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/media/st.audio


* Function signature:

   st.audio(data, format="audio/wav", start_time=0, *, sample_rate=None, end_time=None, loop=False, autoplay=False, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | str, Path, bytes, BytesIO, numpy.ndarray, or file | channel | The audio to play. This can be one of the following:  A URL (string) for a hosted audio file. A path to a local audio file. The path can be a str or Path object. Paths can be absolute or relative to the working directory (where you execute streamlit run). Raw audio data. Raw data formats must include all necessary file headers to match the file format specified via format.  If data is a NumPy array, it must either be a 1D array of the waveform or a 2D array of shape (C, S) where C is the number of channels and S is the number of samples. See the default channel order at http://msdn.microsoft.com/en-us/library/windows/hardware/dn653308(v=vs.85).aspx |
   | format | str | s | The MIME type for the audio file. This defaults to "audio/wav". For more information about MIME types, see https://www.iana.org/assignments/media-types/media-types.xhtml. |
   | start_time | int, float, timedelta, str, or None |  | The time from which the element should start playing. This can be one of the following:  None (default): The element plays from the beginning. An int or float specifying the time in seconds. float values are rounded down to whole seconds. A string specifying the time in a format supported by Pandas' Timedelta constructor, e.g. "2 minute", "20s", or "1m14s". A timedelta object from Python's built-in datetime library, e.g. timedelta(seconds=70). |
   | sample_rate | int or None |  | The sample rate of the audio data in samples per second. This is only required if data is a NumPy array. |
   | end_time | int, float, timedelta, str, or None |  | The time at which the element should stop playing. This can be one of the following:  None (default): The element plays through to the end. An int or float specifying the time in seconds. float values are rounded down to whole seconds. A string specifying the time in a format supported by Pandas' Timedelta constructor, e.g. "2 minute", "20s", or "1m14s". A timedelta object from Python's built-in datetime library, e.g. timedelta(seconds=70). |
   | loop | bool |  | Whether the audio should loop playback. |
   | autoplay | bool |  | Whether the audio file should start playing automatically. This is False by default. Browsers will not autoplay audio files if the user has not interacted with the page by clicking somewhere. |
   | width | "stretch" or int |  | The width of the audio player element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/media/st.image


* Function signature:

   st.image(image, caption=None, width="content", use_column_width=None, clamp=False, channels="RGB", output_format="auto", *, use_container_width=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | image | numpy.ndarray, BytesIO, str, Path, or list of these |  | The image to display. This can be one of the following:  A URL (string) for a hosted image. A path to a local image file. The path can be a str or Path object. Paths can be absolute or relative to the working directory (where you execute streamlit run). An SVG string like xmlns=.... A byte array defining an image. This includes monochrome images of shape (w,h) or (w,h,1), color images of shape (w,h,3), or RGBA images of shape (w,h,4), where w and h are the image width and height, respectively. A list of any of the above. Streamlit displays the list as a row of images that overflow to additional rows as needed. |
   | caption | str or list of str |  | Image caption(s). If this is None (default), no caption is displayed. If image is a list of multiple images, caption must be a list of captions (one caption for each image) or None. Captions can optionally contain GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | width | "content", "stretch", or int | width | The width of the image element. This can be one of the following:  "content" (default): The width of the element matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container.  When using an SVG image without a default width, use "stretch" or an integer. |
   | use_column_width | "auto", "always", "never", or bool |  | If "auto", set the image's width to its natural size, but do not exceed the width of the column. If "always" or True, set the image's width to the column width. If "never" or False, set the image's width to its natural size. Note: if set, use_column_width takes precedence over the width parameter. |
   | clamp | bool |  | Whether to clamp image pixel values to a valid range (0-255 per channel). This is only used for byte array images; the parameter is ignored for image URLs and files. If this is False (default) and an image has an out-of-range value, a RuntimeError will be raised. |
   | channels | "RGB" or "BGR" |  | The color format when image is an nd.array. This is ignored for other image types. If this is "RGB" (default), image[:, :, 0] is the red channel, image[:, :, 1] is the green channel, and image[:, :, 2] is the blue channel. For images coming from libraries like OpenCV, you should set this to "BGR" instead. |
   | output_format | "JPEG", "PNG", or "auto" |  | The output format to use when transferring the image data. If this is "auto" (default), Streamlit identifies the compression type based on the type and format of the image. Photos should use the "JPEG" format for lossy compression while diagrams should use the "PNG" format for lossless compression. |
   | use_container_width | bool |  | Whether to override width with the width of the parent container. If use_container_width is False (default), Streamlit sets the image's width according to width. If use_container_width is True, Streamlit sets the width of the image to match the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/media/st.logo


* Function signature:

   st.logo(image, *, size="medium", link=None, icon_image=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | image | Anything supported by st.image (except list) |  | The image to display in the upper-left corner of your app and its sidebar. This can be any of the types supported by st.image except a list. If icon_image is also provided, then Streamlit will only display image in the sidebar. Streamlit scales the image to a max height set by size and a max width to fit within the sidebar. |
   | size | "small", "medium", or "large" |  | The size of the image displayed in the upper-left corner of the app and its sidebar. The possible values are as follows:  "small": 20px max height "medium" (default): 24px max height "large": 32px max height |
   | link | str or None |  | The external URL to open when a user clicks on the logo. The URL must start with "http://" or "https://". If link is None (default), the logo will not include a hyperlink. |
   | icon_image | Anything supported by st.image (except list) or None |  | An optional, typically smaller image to replace image in the upper-left corner when the sidebar is closed. This can be any of the types supported by st.image except a list. If icon_image is None (default), Streamlit will always display image in the upper-left corner, regardless of whether the sidebar is open or closed. Otherwise, Streamlit will render icon_image in the upper-left corner of the app when the sidebar is closed. Streamlit scales the image to a max height set by size and a max width to fit within the sidebar. If the sidebar is closed, the max width is retained from when it was last open. For best results, pass a wide or horizontal image to image and a square image to icon_image. Or, pass a square image to image and leave icon_image=None. |



---

Source: https://docs.streamlit.io/develop/api-reference/media/st.pdf


* Function signature:

   st.pdf(data, *, height=500, key=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | str, Path, BytesIO, or bytes |  | The PDF file to show. This can be one of the following:  A URL (string) for a hosted PDF file. A path to a local PDF file. If you use a relative path, it must be relative to the current working directory. A file-like object. For example, this can be an UploadedFile from st.file_uploader, or this can be a local file opened with open(). Raw bytes data. |
   | height | int or "stretch" |  | The height of the PDF viewer. This can be one of the following:  An integer specifying the height in pixels: The viewer has a fixed height. If the content is larger than the specified height, scrolling is enabled. This is 500 by default. "stretch": The height of the viewer matches the height of its content or the height of the parent container, whichever is larger. If the viewer is not in a parent container, the height of the viewer matches the height of its content. |



---

Source: https://docs.streamlit.io/develop/api-reference/media/st.video


* Function signature:

   st.video(data, format="video/mp4", start_time=0, *, subtitles=None, end_time=None, loop=False, autoplay=False, muted=False, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | data | str, Path, bytes, io.BytesIO, numpy.ndarray, or file |  | The video to play. This can be one of the following:  A URL (string) for a hosted video file, including YouTube URLs. A path to a local video file. The path can be a str or Path object. Paths can be absolute or relative to the working directory (where you execute streamlit run). Raw video data. Raw data formats must include all necessary file headers to match the file format specified via format. |
   | format | str | s | The MIME type for the video file. This defaults to "video/mp4". For more information about MIME types, see https://www.iana.org/assignments/media-types/media-types.xhtml. |
   | start_time | int, float, timedelta, str, or None |  | The time from which the element should start playing. This can be one of the following:  None (default): The element plays from the beginning. An int or float specifying the time in seconds. float values are rounded down to whole seconds. A string specifying the time in a format supported by Pandas' Timedelta constructor, e.g. "2 minute", "20s", or "1m14s". A timedelta object from Python's built-in datetime library, e.g. timedelta(seconds=70). |
   | subtitles | str, bytes, Path, io.BytesIO, or dict |  | Optional subtitle data for the video, supporting several input types:  None (default): No subtitles. A string, bytes, or Path: File path to a subtitle file in .vtt or .srt formats, or the raw content of subtitles conforming to these formats. Paths can be absolute or relative to the working directory (where you execute streamlit run). If providing raw content, the string must adhere to the WebVTT or SRT format specifications. io.BytesIO: A BytesIO stream that contains valid .vtt or .srt formatted subtitle data. A dictionary: Pairs of labels and file paths or raw subtitle content in .vtt or .srt formats to enable multiple subtitle tracks. The label will be shown in the video player. Example: {"English": "path/to/english.vtt", "French": "path/to/french.srt"}  When provided, subtitles are displayed by default. For multiple tracks, the first one is displayed by default. If you don't want any subtitles displayed by default, use an empty string for the value in a dictrionary's first pair: {"None": "", "English": "path/to/english.vtt"} Not supported for YouTube videos. |
   | end_time | int, float, timedelta, str, or None |  | The time at which the element should stop playing. This can be one of the following:  None (default): The element plays through to the end. An int or float specifying the time in seconds. float values are rounded down to whole seconds. A string specifying the time in a format supported by Pandas' Timedelta constructor, e.g. "2 minute", "20s", or "1m14s". A timedelta object from Python's built-in datetime library, e.g. timedelta(seconds=70). |
   | loop | bool |  | Whether the video should loop playback. |
   | autoplay | bool |  | Whether the video should start playing automatically. This is False by default. Browsers will not autoplay unmuted videos if the user has not interacted with the page by clicking somewhere. To enable autoplay without user interaction, you must also set muted=True. |
   | muted | bool |  | Whether the video should play with the audio silenced. This is False by default. Use this in conjunction with autoplay=True to enable autoplay without user interaction. |
   | width | "stretch" or int |  | The width of the video player element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

# Navigation and pages

Source: https://docs.streamlit.io/develop/api-reference/navigation


<TileContainer>
<RefCard href="/develop/api-reference/navigation/st.navigation">
<Image>alt="screenshot" src="/images/api/navigation.jpg" /&gt;

<h4>Navigation</h4>

Configure the available pages in a multipage app.

```python
st.navigation({
    "Your account" : [log_out, settings],
    "Reports" : [overview, usage],
    "Tools" : [search]
})
```

</Image>
<RefCard href="/develop/api-reference/navigation/st.page">
<Image>alt="screenshot" src="/images/api/page.jpg" /&gt;

<h4>Page</h4>

Define a page in a multipage app.

```python
home = st.Page(
    "home.py",
    title="Home",
    icon=":material/home:"
)
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.page_link">
<Image>alt="screenshot" src="/images/api/page_link.jpg" /&gt;

<h4>Page link</h4>

Display a link to another page in a multipage app.

```python
st.page_link("app.py", label="Home", icon="🏠")
st.page_link("pages/profile.py", label="Profile")
```

</Image>
<RefCard href="/develop/api-reference/navigation/st.switch_page">
<h4>Switch page</h4>

Programmatically navigates to a specified page.

```python
st.switch_page("pages/my_page.py")
```

</RefCard>
</RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/navigation/st.navigation


* Function signature:

   st.navigation(pages, *, position="sidebar", expanded=False)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | pages | Sequence[page-like], Mapping[str, Sequence[page-like]] | title | The available pages for the app. To create a navigation menu with no sections or page groupings, pages must be a list of page-like objects. Page-like objects are anything that can be passed to st.Page or a StreamlitPage object returned by st.Page. To create labeled sections or page groupings within the navigation menu, pages must be a dictionary. Each key is the label of a section and each value is the list of page-like objects for that section. If you use position="top", each grouping will be a collapsible item in the navigation menu. For top navigation, if you use an empty string as a section header, the pages in that section will be displayed at the beginning of the menu before the collapsible sections. When you use a string or path as a page-like object, they are internally passed to st.Page and converted to StreamlitPage objects. In this case, the page will have the default title, icon, and path inferred from its path or filename. To customize these attributes for your page, initialize your page with st.Page. |
   | position | "sidebar", "top", or "hidden" |  | The position of the navigation menu. If this is "sidebar" (default), the navigation widget appears at the top of the sidebar. If this is "top", the navigation appears in the top header of the app. If this is "hidden", the navigation widget is not displayed. If there is only one page in pages, the navigation will be hidden for any value of position. |
   | expanded | bool |  | Whether the navigation menu should be expanded. If this is False (default), the navigation menu will be collapsed and will include a button to view more options when there are too many pages to display. If this is True, the navigation menu will always be expanded; no button to collapse the menu will be displayed. If st.navigation changes from expanded=True to expanded=False on a rerun, the menu will stay expanded and a collapse button will be displayed. The parameter is only used when position="sidebar". |

* Returns: StreamlitPage

    The current page selected by the user. To run the page, you must use
the .run() method on it.



---

Source: https://docs.streamlit.io/develop/api-reference/navigation/st.page


* Function signature:

   st.Page(page, *, title=None, icon=None, url_path=None, default=False)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | page | str, Path, or callable |  | The page source as a Callable or path to a Python file. If the page source is defined by a Python file, the path can be a string or pathlib.Path object. Paths can be absolute or relative to the entrypoint file. If the page source is defined by a Callable, the Callable can't accept arguments. |
   | title | str or None |  | The title of the page. If this is None (default), the page title (in the browser tab) and label (in the navigation menu) will be inferred from the filename or callable name in page. For more information, see Overview of multipage apps. |
   | icon | str or None | Streamlit | An optional emoji or icon to display next to the page title and label. If icon is None (default), no icon is displayed next to the page label in the navigation menu, and a Streamlit icon is displayed next to the title (in the browser tab). If icon is a string, the following options are valid:   A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.     An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.    "spinner": Displays a spinner as an icon. In this case, the spinner only displays next to the page label in the navigation menu. The spinner isn't used as the page favicon next to the title in the browser tab. The favicon is the default Streamlit icon unless otherwise specified with the page_icon parameter of st.set_page_config. |
   | url_path | str or None | page | The page's URL pathname, which is the path relative to the app's root URL. If this is None (default), the URL pathname will be inferred from the filename or callable name in page. For more information, see Overview of multipage apps. The default page will have a pathname of "", indicating the root URL of the app. If you set default=True, url_path is ignored. url_path can't include forward slashes; paths can't include subdirectories. |
   | default | bool | page | Whether this page is the default page to be shown when the app is loaded. If default is False (default), the page will have a nonempty URL pathname. However, if no default page is passed to st.navigation and this is the first page, this page will become the default page. If default is True, then the page will have an empty pathname and url_path will be ignored. |

* Returns: StreamlitPage

    The page object associated to the given script.



* Function signature:

   StreamlitPage(page, *, title=None, icon=None, url_path=None, default=False)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | icon | str |  | The icon of the page. If no icon was declared in st.Page, this property returns "". |
   | title | str |  | The title of the page. Unless declared otherwise in st.Page, the page title is inferred from the filename or callable name. For more information, see Overview of multipage apps. |
   | url_path | str | page | The page's URL pathname, which is the path relative to the app's root URL. Unless declared otherwise in st.Page, the URL pathname is inferred from the filename or callable name. For more information, see Overview of multipage apps. The default page will always have a url_path of "" to indicate the root URL (e.g. homepage). |



* Function signature:

   StreamlitPage.run()



---

Source: https://docs.streamlit.io/develop/api-reference/navigation/st.switch_page


* Function signature:

   st.switch_page(page, *, query_params=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | page | str, Path, or st.Page |  | The file path (relative to the main script) or an st.Page indicating the page to switch to. |
   | query_params | dict, list of tuples, or None |  | Query parameters to apply when navigating to the target page. This can be a dictionary or an iterable of key-value tuples. Values can be strings or iterables of strings (for repeated keys). When this is None (default), all non-embed query parameters are cleared during navigation. |



---

# Display progress and status

Source: https://docs.streamlit.io/develop/api-reference/status


Streamlit provides a few methods that allow you to add animation to your
apps. These animations include progress bars, status messages (like
warnings), and celebratory balloons.

## Animated status elements

<TileContainer>
<RefCard href="/develop/api-reference/status/st.progress">
<Image>alt="screenshot" src="/images/api/progress.jpg" /&gt;

<h4>Progress bar</h4>

Display a progress bar.

```python
for i in range(101):
  st.progress(i)
  do_something_slow()
```

</Image>
<RefCard href="/develop/api-reference/status/st.spinner">
<Image>alt="screenshot" src="/images/api/spinner.jpg" /&gt;

<h4>Spinner</h4>

Temporarily displays a message while executing a block of code.

```python
with st.spinner("Please wait..."):
  do_something_slow()
```

</Image>
<RefCard href="/develop/api-reference/status/st.status">
<Image>alt="screenshot" src="/images/api/status.jpg" /&gt;

<h4>Status container</h4>

Display output of long-running tasks in a container.

```python
with st.status('Running'):
  do_something_slow()
```

</Image>
<RefCard href="/develop/api-reference/status/st.toast">
<Image>alt="screenshot" src="/images/api/toast.jpg" /&gt;

<h4>Toast</h4>

Briefly displays a toast message in the bottom-right corner.

```python
st.toast('Butter!', icon='🧈')
```

</Image>
<RefCard href="/develop/api-reference/status/st.balloons">
<Image>alt="screenshot" src="/images/api/balloons.jpg" /&gt;

<h4>Balloons</h4>

Display celebratory balloons!

```python
st.balloons()
```

</Image>
<RefCard href="/develop/api-reference/status/st.snow">
<Image>alt="screenshot" src="/images/api/snow.jpg" /&gt;

<h4>Snowflakes</h4>

Display celebratory snowflakes!

```python
st.snow()
```

</Image>
</RefCard>

## Simple callout messages

<TileContainer>
<RefCard href="/develop/api-reference/status/st.success">
<Image>alt="screenshot" src="/images/api/success.jpg" /&gt;

<h4>Success box</h4>

Display a success message.

```python
st.success("Match found!")
```

</Image>
<RefCard href="/develop/api-reference/status/st.info">
<Image>alt="screenshot" src="/images/api/info.jpg" /&gt;

<h4>Info box</h4>

Display an informational message.

```python
st.info("Dataset is updated every day at midnight.")
```

</Image>
<RefCard href="/develop/api-reference/status/st.warning">
<Image>alt="screenshot" src="/images/api/warning.jpg" /&gt;

<h4>Warning box</h4>

Display warning message.

```python
st.warning("Unable to fetch image. Skipping...")
```

</Image>
<RefCard href="/develop/api-reference/status/st.error">
<Image>alt="screenshot" src="/images/api/error.jpg" /&gt;

<h4>Error box</h4>

Display error message.

```python
st.error("We encountered an error")
```

</Image>
<RefCard href="/develop/api-reference/status/st.exception">
<Image>alt="screenshot" src="/images/api/exception.jpg" /&gt;

<h4>Exception output</h4>

Display an exception.

```python
e = RuntimeError("This is an exception of type RuntimeError")
st.exception(e)
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/Wirg/stqdm">
<Image>alt="screenshot" src="/images/api/components/stqdm.jpg" /&gt;

<h4>Stqdm</h4>

The simplest way to handle a progress bar in streamlit app. Created by [@Wirg](https://github.com/Wirg).

```python
from stqdm import stqdm

for _ in stqdm(range(50)):
    sleep(0.5)
```

</Image>
<ComponentCard href="https://github.com/Socvest/streamlit-custom-notification-box">
<Image>alt="screenshot" src="/images/api/components/custom-notification-box.jpg" /&gt;

<h4>Custom notification box</h4>

A custom notification box with the ability to close it out. Created by [@Socvest](https://github.com/Socvest).

```python
from streamlit_custom_notification_box import custom_notification_box

styles = {'material-icons':{'color': 'red'}, 'text-icon-link-close-container': {'box-shadow': '#3896de 0px 4px'}, 'notification-text': {'':''}, 'close-button':{'':''}, 'link':{'':''}}
custom_notification_box(icon='info', textDisplay='We are almost done with your registration...', externalLink='more info', url='#', styles=styles, key="foo")
```

</Image>
<ComponentCard href="https://extras.streamlit.app/">
<Image>alt="screenshot" src="/images/api/components/extras-emojis.jpg" /&gt;

<h4>Streamlit Extras</h4>

A library with useful Streamlit extras. Created by [@arnaudmiribel](https://github.com/arnaudmiribel/).

```python
from streamlit_extras.let_it_rain import rain

rain(emoji="🎈", font_size=54,
  falling_speed=5, animation_length="infinite",)
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></TileContainer></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/status/st.balloons


* Function signature:

   st.balloons()



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.error


* Function signature:

   st.error(body, *, icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str, None |  | An optional emoji or icon to display next to the alert. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the alert element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.exception


* Function signature:

   st.exception(exception, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | exception | Exception |  | The exception to display. |
   | width | "stretch" or int |  | The width of the exception element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.info


* Function signature:

   st.info(body, *, icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str, None |  | An optional emoji or icon to display next to the alert. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the info element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.progress


* Function signature:

   st.progress(value, text=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | value | int or float |  | 0  0.0 |
   | text | str or None |  | A message to display above the progress bar. The text can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | width | "stretch" or int |  | The width of the progress element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.snow


* Function signature:

   st.snow()



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.spinner


* Function signature:

   st.spinner(text="In progress...", *, show_time=False, width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | text | str | s | The text to display next to the spinner. This defaults to "In progress...". The text can optionally contain GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | show_time | bool |  | Whether to show the elapsed time next to the spinner text. If this is False (default), no time is displayed. If this is True, elapsed time is displayed with a precision of 0.1 seconds. The time format is not configurable. |
   | width | "content", "stretch", or int |  | The width of the spinner element. This can be one of the following:  "content" (default): The width of the element matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.status


* Function signature:

   st.status(label, *, expanded=False, state="running", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | The initial label of the status container. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | expanded | bool | s | If True, initializes the status container in "expanded" state. Defaults to False (collapsed). |
   | state | "running", "complete", or "error" |  | The initial state of the status container which determines which icon is shown:  running (default): A spinner icon is shown. complete: A checkmark icon is shown. error: An error icon is shown. |
   | width | "stretch" or int |  | The width of the status container. This can be one of the following:  "stretch" (default): The width of the container matches the width of the parent container. An integer specifying the width in pixels: The container has a fixed width. If the specified width is greater than the width of the parent container, the width of the container matches the width of the parent container. |

* Returns: StatusContainer

    A mutable status container that can hold multiple elements. The label, state,
and expanded state can be updated after creation via .update().



* Function signature:

   StatusContainer.update(*, label=None, expanded=None, state=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str or None |  | A new label of the status container. If None, the label is not changed. |
   | expanded | bool or None |  | The new expanded state of the status container. If None, the expanded state is not changed. |
   | state | "running", "complete", "error", or None |  | The new state of the status container. This mainly changes the icon. If None, the state is not changed. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.success


* Function signature:

   st.success(body, *, icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str, None |  | An optional emoji or icon to display next to the alert. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the success element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.toast


* Function signature:

   st.toast(body, *, icon=None, duration="short")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The string to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str, None |  | An optional emoji or icon to display next to the alert. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | duration | "short", "long", "infinite", or int |  | The time to display the toast message. This can be one of the following:  "short" (default): Displays for 4 seconds. "long": Displays for 10 seconds. "infinite": Shows the toast until the user dismisses it. An integer: Displays for the specified number of seconds. |



---

Source: https://docs.streamlit.io/develop/api-reference/status/st.warning


* Function signature:

   st.warning(body, *, icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str, None |  | An optional emoji or icon to display next to the alert. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the warning element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

# Text elements

Source: https://docs.streamlit.io/develop/api-reference/text


Streamlit apps usually start with a call to `st.title` to set the
app's title. After that, there are 2 heading levels you can use:
`st.header` and `st.subheader`.

Pure text is entered with `st.text`, and Markdown with
`st.markdown`.

We also offer a "swiss-army knife" command called `st.write`, which accepts
multiple arguments, and multiple data types. And as described above, you can
also use [magic commands](/develop/api-reference/write-magic/magic) in place of `st.write`.

## Headings and body text

<TileContainer>
<RefCard href="/develop/api-reference/text/st.markdown">
<Image>alt="screenshot" src="/images/api/markdown.jpg" /&gt;

<h4>Markdown</h4>

Display string formatted as Markdown.

```python
st.markdown("Hello **world**!")
```

</Image>
<RefCard href="/develop/api-reference/text/st.title">
<Image>alt="screenshot" src="/images/api/title.jpg" /&gt;

<h4>Title</h4>

Display text in title formatting.

```python
st.title("The app title")
```

</Image>
<RefCard href="/develop/api-reference/text/st.header">
<Image>alt="screenshot" src="/images/api/header.jpg" /&gt;

<h4>Header</h4>

Display text in header formatting.

```python
st.header("This is a header")
```

</Image>
<RefCard href="/develop/api-reference/text/st.subheader">
<Image>alt="screenshot" src="/images/api/subheader.jpg" /&gt;

<h4>Subheader</h4>

Display text in subheader formatting.

```python
st.subheader("This is a subheader")
```

</Image>
</RefCard>

## Formatted text

<TileContainer>
<RefCard href="/develop/api-reference/text/st.badge">
<Image>alt="screenshot" src="/images/api/badge.jpg" /&gt;

<h4>Badge</h4>

Display a small, colored badge.

```python
st.badge("New")
```

</Image>
<RefCard href="/develop/api-reference/text/st.caption">
<Image>alt="screenshot" src="/images/api/caption.jpg" /&gt;

<h4>Caption</h4>

Display text in small font.

```python
st.caption("This is written small caption text")
```

</Image>
<RefCard href="/develop/api-reference/text/st.code">
<Image>alt="screenshot" src="/images/api/code.jpg" /&gt;

<h4>Code block</h4>

Display a code block with optional syntax highlighting.

```python
st.code("a = 1234")
```

</Image>
<RefCard href="/develop/api-reference/text/st.echo">
<Image>alt="screenshot" src="/images/api/code.jpg" /&gt;

<h4>Echo</h4>

Display some code on the app, then execute it. Useful for tutorials.

```python
with st.echo():
  st.write('This code will be printed')
```

</Image>
<RefCard href="/develop/api-reference/text/st.text">
<Image>alt="screenshot" src="/images/api/text.jpg" /&gt;

<h4>Preformatted text</h4>

Write fixed-width and preformatted text.

```python
st.text("Hello world")
```

</Image>
<RefCard href="/develop/api-reference/text/st.latex">
<Image>alt="screenshot" src="/images/api/latex.jpg" /&gt;

<h4>LaTeX</h4>

Display mathematical expressions formatted as LaTeX.

```python
st.latex("\int a x^2 \,dx")
```

</Image>
<RefCard href="/develop/api-reference/text/st.divider">
<Image>alt="screenshot" src="/images/api/divider.jpg" /&gt;

<h4>Divider</h4>

Display a horizontal rule.

```python
st.divider()
```

</Image>
</RefCard>

## Utilities

<TileContainer>
<RefCard href="/develop/api-reference/text/st.help" size="half">
<h4>Get help</h4>

Display object’s doc string, nicely formatted.

```python
st.help(st.write)
st.help(pd.DataFrame)
```

</RefCard>
<RefCard href="/develop/api-reference/text/st.html" size="half">
<h4>Render HTML</h4>

Renders HTML strings to your app.

```python
st.html("<p>Foo bar.</p>")
```

</RefCard>
</TileContainer>
<ComponentSlider>
<ComponentCard href="https://github.com/tvst/st-annotated-text">
<Image>alt="screenshot" src="/images/api/components/annotated-text.jpg" /&gt;

<h4>Annotated text</h4>

Display annotated text in Streamlit apps. Created by [@tvst](https://github.com/tvst).

```python
annotated_text("This ", ("is", "verb"), " some ", ("annotated", "adj"), ("text", "noun"), " for those of ", ("you", "pronoun"), " who ", ("like", "verb"), " this sort of ", ("thing", "noun"), ".")
```

</Image>
<ComponentCard href="https://github.com/andfanilo/streamlit-drawable-canvas">
<Image>alt="screenshot" src="/images/api/components/drawable-canvas.jpg" /&gt;

<h4>Drawable Canvas</h4>

Provides a sketching canvas using [Fabric.js](http://fabricjs.com/). Created by [@andfanilo](https://github.com/andfanilo).

```python
st_canvas(fill_color="rgba(255, 165, 0, 0.3)", stroke_width=stroke_width, stroke_color=stroke_color, background_color=bg_color, background_image=Image.open(bg_image) if bg_image else None, update_streamlit=realtime_update, height=150, drawing_mode=drawing_mode, point_display_radius=point_display_radius if drawing_mode == 'point' else 0, key="canvas",)
```

</Image>
<ComponentCard href="https://github.com/gagan3012/streamlit-tags">
<Image>alt="screenshot" src="/images/api/components/tags.jpg" /&gt;

<h4>Tags</h4>

Add tags to your Streamlit apps. Created by [@gagan3012](https://github.com/gagan3012).

```python
st_tags(label='# Enter Keywords:', text='Press enter to add more', value=['Zero', 'One', 'Two'], suggestions=['five', 'six', 'seven', 'eight', 'nine', 'three', 'eleven', 'ten', 'four'], maxtags = 4, key='1')
```

</Image>
<ComponentCard href="https://github.com/JohnSnowLabs/nlu">
<Image>alt="screenshot" src="/images/api/components/nlu.jpg" /&gt;

<h4>NLU</h4>

Apply text mining on a dataframe. Created by [@JohnSnowLabs](https://github.com/JohnSnowLabs/).

```python
nlu.load('sentiment').predict('I love NLU! </Image></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.badge


* Function signature:

   st.badge(label, *, icon=None, color="blue", width="content", help=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | The label to display in the badge. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code. See the body parameter of st.markdown for additional, supported Markdown directives. Because this command escapes square brackets ([ ]) in this parameter, any directive requiring square brackets is not supported. |
   | icon | str or None |  | An optional emoji or icon to display next to the badge label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols font library. |
   | color | str | s | The color to use for the badge. This defaults to "blue". This can be one of the following supported colors: red, orange, yellow, blue, green, violet, gray/grey, or primary. If you use "primary", Streamlit will use the default primary accent color unless you set the theme.primaryColor configuration option. |
   | width | "content", "stretch", or int |  | The width of the badge element. This can be one of the following:  "content" (default): The width of the element matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | help | str or None |  | A tooltip to display when hovering over the badge. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.caption


* Function signature:

   st.caption(body, unsafe_allow_html=False, *, help=None, width="stretch", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | unsafe_allow_html | bool |  | Whether to render HTML within body. If this is False (default), any HTML tags found in body will be escaped and therefore treated as raw text. If this is True, any HTML expressions within body will be rendered. Adding custom HTML to your app impacts safety, styling, and maintainability.  Note If you only want to insert HTML or CSS without Markdown text, we recommend using st.html instead. |
   | help | str or None |  | A tooltip that gets displayed next to the caption. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | width | "stretch", "content", or int |  | The width of the caption element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |


<Image src="/images/api/st.caption.png"/>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.code


* Function signature:

   st.code(body, language="python", *, line_numbers=False, wrap_lines=False, height="content", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The string to display as code or monospace text. |
   | language | str or None | s | The language that the code is written in, for syntax highlighting. This defaults to "python". If this is None, the code will be plain, monospace text. For a list of available language values, see react-syntax-highlighter on GitHub. |
   | line_numbers | bool | s | An optional boolean indicating whether to show line numbers to the left of the code block. This defaults to False. |
   | wrap_lines | bool | s | An optional boolean indicating whether to wrap lines. This defaults to False. |
   | height | "content", "stretch", or int |  | The height of the code block element. This can be one of the following:  "content" (default): The height of the element matches the height of its content. "stretch": The height of the element matches the height of its content or the height of the parent container, whichever is larger. If the element is not in a parent container, the height of the element matches the height of its content. An integer specifying the height in pixels: The element has a fixed height. If the content is larger than the specified height, scrolling is enabled.   Note Use scrolling containers sparingly. If you use scrolling containers, avoid heights that exceed 500 pixels. Otherwise, the scroll surface of the container might cover the majority of the screen on mobile devices, which makes it hard to scroll the rest of the app. |
   | width | "stretch", "content", or int |  | The width of the code block element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.divider


* Function signature:

   st.divider(*, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | width | "stretch" or int |  | The width of the divider element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



Here's what it looks like in action when you have multiple elements in the app:

```python
import streamlit as st

st.write("This is some text.")

st.slider("This is a slider", 0, 100, (25, 75))

st.divider()  # 👈 Draws a horizontal rule

st.write("This text is between the horizontal rules.")

st.divider()  # 👈 Another horizontal rule
```

<Image src="/images/api/st.divider.png"/>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.echo


* Function signature:

   st.echo(code_location="above")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | code_location | "above" or "below" |  | Whether to show the echoed code before or after the results of the executed code block. |



### Display code

Sometimes you want your Streamlit app to contain _both_ your usual
Streamlit graphic elements _and_ the code that generated those elements.
That's where `st.echo()` comes in.

Ok so let's say you have the following file, and you want to make its
app a little bit more self-explanatory by making that middle section
visible in the Streamlit app:

```python
import streamlit as st

def get_user_name():
    return 'John'

# ------------------------------------------------
# Want people to see this part of the code...

def get_punctuation():
    return '!!!'

greeting = "Hi there, "
user_name = get_user_name()
punctuation = get_punctuation()

st.write(greeting, user_name, punctuation)

# ...up to here
# ------------------------------------------------

foo = 'bar'
st.write('Done!')
```

The file above creates a Streamlit app containing the words "Hi there,
`John`", and then "Done!".

Now let's use `st.echo()` to make that middle section of the code visible
in the app:

```python
import streamlit as st

def get_user_name():
    return 'John'

with st.echo():
    # Everything inside this block will be both printed to the screen
    # and executed.

    def get_punctuation():
        return '!!!'

    greeting = "Hi there, "
    value = get_user_name()
    punctuation = get_punctuation()

    st.write(greeting, value, punctuation)

# And now we're back to _not_ printing to the screen
foo = 'bar'
st.write('Done!')
```

It's _that_ simple!

<Note>

You can have multiple `st.echo()` blocks in the same file.
Use it as often as you wish!

</Note>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.header


* Function signature:

   st.header(body, anchor=None, *, help=None, divider=False, width="stretch", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | anchor | str or False |  | The anchor name of the header that can be accessed with #anchor in the URL. If omitted, it generates an anchor using the body. If False, the anchor is not shown in the UI. |
   | help | str or None |  | A tooltip that gets displayed next to the header. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | divider | bool, "blue", "green", "orange", "red", "violet", "yellow", "gray"/"grey", or "rainbow" |  | Shows a colored divider below the header. If this is True, successive headers will cycle through divider colors, except gray and rainbow. That is, the first header will have a blue line, the second header will have a green line, and so on. If this is a string, the color can be set to one of the following: blue, green, orange, red, violet, yellow, gray/grey, or rainbow. |
   | width | "stretch", "content", or int |  | The width of the header element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.help


* Function signature:

   st.help(obj=&lt;module 'streamlit' from '/Users/dmatthews/Documents/GitHub/streamlit/lib/streamlit/__init__.py'&gt;, *, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | obj | any |  | The object whose information should be displayed. If left unspecified, this call will display help for Streamlit itself. |
   | width | "stretch" or int |  | The width of the help element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.html


* Function signature:

   st.html(body, *, width="stretch", unsafe_allow_javascript=False)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | any |  | The HTML code to insert. This can be one of the following:  A string of HTML code. A path to a local file with HTML code. The path can be a str or Path object. Paths can be absolute or relative to the working directory (where you execute streamlit run). Any object. If body is not a string or path, Streamlit will convert the object to a string. body._repr_html_() takes precedence over str(body) when available.  If the resulting HTML content is empty, Streamlit will raise an error. If body is a path to a CSS file, Streamlit will wrap the CSS content in  tags automatically. When the resulting HTML content only contains style tags, Streamlit will send the content to the event container instead of the main container to avoid taking up space in the app. |
   | width | "stretch", "content", or int |  | The width of the HTML element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | unsafe_allow_javascript | bool |  | Whether to execute JavaScript contained in your HTML. If this is False (default), JavaScript is ignored. If this is True, JavaScript is executed. Use this with caution and never pass untrusted input. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.latex


* Function signature:

   st.latex(body, *, help=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str or SymPy expression |  | The string or SymPy expression to display as LaTeX. If str, it's a good idea to use raw Python strings since LaTeX uses backslashes a lot. |
   | help | str or None |  | A tooltip that gets displayed next to the LaTeX expression. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | width | "stretch", "content", or int |  | The width of the LaTeX element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |


<Image src="/images/api/st.latex.png"/>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.markdown


* Function signature:

   st.markdown(body, unsafe_allow_html=False, *, help=None, width="stretch", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | any | primary | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. If anything other than a string is passed, it will be converted into a string behind the scenes using str(body). This also supports:  Emoji shortcodes, such as :+1:  and :sunglasses:. For a list of all supported codes, see https://share.streamlit.io/streamlit/emoji-shortcodes. Streamlit logo shortcode. Use :streamlit: to add a little Streamlit flair to your text. A limited set of typographical symbols. "-&gt;  -- &gt;=  becomes "← → ↔ — ≥ ≤ ≈" when parsed as Markdown. Google Material Symbols (rounded style), using the syntax :material/icon_name:, where "icon_name" is the name of the icon in snake case. For a complete list of icons, see Google's Material Symbols font library. LaTeX expressions, by wrapping them in "$" or "$$" (the "$$" must be on their own lines). Supported LaTeX functions are listed at https://katex.org/docs/supported.html. Colored text and background colors for text, using the syntax :color[text to be colored] and :color-background[text to be colored], respectively. color must be replaced with any of the following supported colors: red, orange, yellow, green, blue, violet, gray/grey, rainbow, or primary. For example, you can use :orange[your text here] or :blue-background[your text here]. If you use "primary" for color, Streamlit will use the default primary accent color unless you set the theme.primaryColor configuration option. Colored badges, using the syntax :color-badge[text in the badge]. color must be replaced with any of the following supported colors: red, orange, yellow, green, blue, violet, gray/grey, or primary. For example, you can use :orange-badge[your text here] or :blue-badge[your text here]. Small text, using the syntax :small[text to show small]. |
   | unsafe_allow_html | bool |  | Whether to render HTML within body. If this is False (default), any HTML tags found in body will be escaped and therefore treated as raw text. If this is True, any HTML expressions within body will be rendered. Adding custom HTML to your app impacts safety, styling, and maintainability.  Note If you only want to insert HTML or CSS without Markdown text, we recommend using st.html instead. |
   | help | str or None |  | A tooltip that gets displayed next to the Markdown. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | width | "stretch", "content", or int |  | The width of the Markdown element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |



```python
import streamlit as st

md = st.text_area('Type in your markdown string (without outer quotes)',
                  "Happy Streamlit-ing! :balloon:")

st.code(f"""
import streamlit as st

st.markdown('''{md}''')
""")

st.markdown(md)
```

<Cloud height="500px" name="doc-markdown1"/>

---

Source: https://docs.streamlit.io/develop/api-reference/text/st.subheader


* Function signature:

   st.subheader(body, anchor=None, *, help=None, divider=False, width="stretch", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | anchor | str or False |  | The anchor name of the header that can be accessed with #anchor in the URL. If omitted, it generates an anchor using the body. If False, the anchor is not shown in the UI. |
   | help | str or None |  | A tooltip that gets displayed next to the subheader. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | divider | bool, "blue", "green", "orange", "red", "violet", "yellow", "gray"/"grey", or "rainbow" |  | Shows a colored divider below the header. If this is True, successive headers will cycle through divider colors, except gray and rainbow. That is, the first header will have a blue line, the second header will have a green line, and so on. If this is a string, the color can be set to one of the following: blue, green, orange, red, violet, yellow, gray/grey, or rainbow. |
   | width | "stretch", "content", or int |  | The width of the subheader element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.text


* Function signature:

   st.text(body, *, help=None, width="content", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The string to display. |
   | help | str or None |  | A tooltip that gets displayed next to the text. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | width | "content", "stretch", or int |  | The width of the text element. This can be one of the following:  "content" (default): The width of the element matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the element matches the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |



---

Source: https://docs.streamlit.io/develop/api-reference/text/st.title


* Function signature:

   st.title(body, anchor=None, *, help=None, width="stretch", text_alignment="left")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | body | str |  | The text to display as GitHub-flavored Markdown. Syntax information can be found at: https://github.github.com/gfm. See the body parameter of st.markdown for additional, supported Markdown directives. |
   | anchor | str or False |  | The anchor name of the header that can be accessed with #anchor in the URL. If omitted, it generates an anchor using the body. If False, the anchor is not shown in the UI. |
   | help | str or None |  | A tooltip that gets displayed next to the title. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | width | "stretch", "content", or int |  | The width of the title element. This can be one of the following:  "stretch" (default): The width of the element matches the width of the parent container. "content": The width of the element matches the width of its content, but doesn't exceed the width of the parent container. An integer specifying the width in pixels: The element has a fixed width. If the specified width is greater than the width of the parent container, the width of the element matches the width of the parent container. |
   | text_alignment | "left", "center", "right", or "justify" |  | The horizontal alignment of the text within the element. This can be one of the following:  "left" (default): Text is aligned to the left edge. "center": Text is centered. "right": Text is aligned to the right edge. "justify": Text is justified (stretched to fill the available width with the last line left-aligned).   Note For text alignment to have a visible effect, the element's width must be wider than its content. If you use width="content" with short text, the alignment may not be noticeable. |



---

# Authentication and user info

Source: https://docs.streamlit.io/develop/api-reference/user


Streamlit provides native support for user authentication so you can personalize your apps. You can also directly read headers and cookies.

<TileContainer>
<RefCard href="/develop/api-reference/user/st.login">
<h4>Log in a user</h4>

`st.login()` starts an authentication flow with an identity provider.

```python
st.login()
```

</RefCard>
<RefCard href="/develop/api-reference/user/st.logout">
<h4>Log out a user</h4>

`st.logout()` removes a user's identity information.

```python
st.logout()
```

</RefCard>
<RefCard href="/develop/api-reference/user/st.user">
<h4>User info</h4>

`st.user` returns information about a logged-in user.

```python
if st.user.is_logged_in:
  st.write(f"Welcome back, {st.user.name}!")
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/user/st.login

<Tip>

Learn more in [User authentication and information](/develop/concepts/connections/authentication).

</Tip>

* Function signature:

   st.login(provider=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | provider | str or None |  | The name of your provider configuration to use for login. If provider is None (default), Streamlit will use all settings in the [auth] dictionary within your app's secrets.toml file. Otherwise, use an [auth.{provider}] dictionary for the named provider, as shown in the examples that follow. When you pass a string to provider, Streamlit will use redirect_uri and cookie_secret, while ignoring any other values in the [auth] dictionary. Due to internal implementation details, Streamlit does not support using an underscore within provider at this time. |



---

Source: https://docs.streamlit.io/develop/api-reference/user/st.logout

<Tip>

Learn more in [User authentication and information](/develop/concepts/connections/authentication).

</Tip>

* Function signature:

   st.logout()



---

Source: https://docs.streamlit.io/develop/api-reference/user/st.user


* Function signature:

   st.user()

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | is_logged_in | bool |  | Whether a user is logged in. For a locally running app, this attribute is only available when authentication (st.login()) is configured in secrets.toml. Otherwise, it does not exist. |



### Community Cloud

Starting from Streamlit version 1.42.0, you can't use `st.user` to retrieve a user's Community Cloud account email. To access user information, you must set up an identity provider and configure authentication (`[auth]`) in your app's secrets. Remember to update your identity provider's configuration and your app's secrets to allow your new domain. A list of [IP addresses](/deploy/streamlit-community-cloud/status#ip-addresses) used by Community Cloud is available if needed. An authentication-configured app counts as your single allowed private app.


* Function signature:

   st.user.to_dict()

* Returns: Dict[str,str]

    A dictionary of the current user's information.



---

# Input widgets

Source: https://docs.streamlit.io/develop/api-reference/widgets


使用小部件，Streamlit 允许您使用按钮、滑块、文本输入等直接为您的应用添加交互性。

## Button elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.button">
<Image>alt="screenshot" src="/images/api/button.svg" /&gt;

<h4>Button</h4>

显示按钮小部件。

```python
clicked = st.button("Click me")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.download_button">
<Image>alt="screenshot" src="/images/api/download_button.svg" /&gt;

<h4>Download button</h4>

显示下载按钮小部件。

```python
st.download_button("Download file", file)
```

</Image>
<RefCard href="/develop/api-reference/execution-flow/st.form_submit_button">
<Image>alt="screenshot" src="/images/api/form_submit_button.svg" /&gt;

<h4>Form button</h4>

显示表单提交按钮。与 `st.form` 一起使用。

```python
st.form_submit_button("Sign up")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.link_button">
<Image>alt="screenshot" src="/images/api/link_button.svg" /&gt;

<h4>Link button</h4>

显示链接按钮。

```python
st.link_button("Go to gallery", url)
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.page_link">
<Image>alt="screenshot" src="/images/api/page_link.jpg" /&gt;

<h4>Page link</h4>

显示指向多页应用中另一页的链接。

```python
st.page_link("app.py", label="Home", icon="🏠")
st.page_link("pages/profile.py", label="My profile")
```

</Image>
</RefCard>

## Selection elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.checkbox">
<Image>alt="screenshot" src="/images/api/checkbox.jpg" /&gt;

<h4>Checkbox</h4>

显示复选框小部件。

```python
selected = st.checkbox("I agree")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.color_picker">
<Image>alt="screenshot" src="/images/api/color_picker.jpg" /&gt;

<h4>Color picker</h4>

显示颜色选择器小部件。

```python
color = st.color_picker("Pick a color")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.feedback">
<Image>alt="screenshot" src="/images/api/feedback.jpg" /&gt;

<h4>Feedback</h4>

显示评分或情感按钮组。

```python
st.feedback("stars")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.multiselect">
<Image>alt="screenshot" src="/images/api/multiselect.jpg" /&gt;

<h4>Multiselect</h4>

显示多选小部件。多选小部件初始为空。

```python
choices = st.multiselect("Buy", ["milk", "apples", "potatoes"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.pills">
<Image>alt="screenshot" src="/images/api/pills.jpg" /&gt;

<h4>Pills</h4>

显示药丸按钮选择小部件。

```python
st.pills("Tags", ["Sports", "AI", "Politics"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.radio">
<Image>alt="screenshot" src="/images/api/radio.jpg" /&gt;

<h4>Radio</h4>

显示单选按钮小部件。

```python
choice = st.radio("Pick one", ["cats", "dogs"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.segmented_control">
<Image>alt="screenshot" src="/images/api/segmented_control.jpg" /&gt;

<h4>Segmented control</h4>

显示分段按钮选择小部件。

```python
st.segmented_control("Filter", ["Open", "Closed", "All"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.select_slider">
<Image>alt="screenshot" src="/images/api/select_slider.jpg" /&gt;

<h4>Select slider</h4>

显示滑块小部件以从列表中选择项目。

```python
size = st.select_slider("Pick a size", ["S", "M", "L"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.selectbox">
<Image>alt="screenshot" src="/images/api/selectbox.jpg" /&gt;

<h4>Selectbox</h4>

显示选择小部件。

```python
choice = st.selectbox("Pick one", ["cats", "dogs"])
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.toggle">
<Image>alt="screenshot" src="/images/api/toggle.jpg" /&gt;

<h4>Toggle</h4>

显示切换小部件。

```python
activated = st.toggle("Activate")
```

</Image>
</RefCard>

## Numeric input elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.number_input">
<Image>alt="screenshot" src="/images/api/number_input.jpg" /&gt;

<h4>Number input</h4>

显示数字输入小部件。

```python
choice = st.number_input("Pick a number", 0, 10)
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.slider">
<Image>alt="screenshot" src="/images/api/slider.jpg" /&gt;

<h4>Slider</h4>

显示滑块小部件。

```python
number = st.slider("Pick a number", 0, 100)
```

</Image>
</RefCard>

## Date and time input elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.date_input">
<Image>alt="screenshot" src="/images/api/date_input.jpg" /&gt;

<h4>Date input</h4>

显示日期输入小部件。

```python
date = st.date_input("Your birthday")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.datetime_input">
<Image>alt="screenshot" src="/images/api/datetime_input.jpg" /&gt;

<h4>Datetime input</h4>

显示日期时间输入小部件。

```python
datetime = st.datetime_input("Schedule your event")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.time_input">
<Image>alt="screenshot" src="/images/api/time_input.jpg" /&gt;

<h4>Time input</h4>

显示时间输入小部件。

```python
time = st.time_input("Meeting time")
```

</Image>
</RefCard>

## Text input elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.text_input">
<Image>alt="screenshot" src="/images/api/text_input.jpg" /&gt;

<h4>Text input</h4>

显示单行文本输入小部件。

```python
name = st.text_input("First name")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.text_area">
<Image>alt="screenshot" src="/images/api/text_area.jpg" /&gt;

<h4>Text area</h4>

显示多行文本输入小部件。

```python
text = st.text_area("Text to translate")
```

</Image>
<RefCard href="/develop/api-reference/chat/st.chat_input">
<Image>alt="screenshot" src="/images/api/chat_input.jpg" /&gt;

<h4>Chat input</h4>

显示聊天输入小部件。

```python
prompt = st.chat_input("Say something")
if prompt:
    st.write(f"The user has sent: {prompt}")
```

</Image>
</RefCard>

## Other input elements

<TileContainer>
<RefCard href="/develop/api-reference/widgets/st.audio_input">
<Image>alt="screenshot" src="/images/api/audio_input.jpg" /&gt;

<h4>Audio input</h4>

显示允许用户使用麦克风录制的窗口小部件。

```python
speech = st.audio_input("Record a voice message")
```

</Image>
<RefCard href="/develop/api-reference/data/st.data_editor">
<Image>alt="screenshot" src="/images/api/data_editor.jpg" /&gt;

<h4>Data editor</h4>

显示数据编辑器小部件。

```python
edited = st.data_editor(df, num_rows="dynamic")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.file_uploader">
<Image>alt="screenshot" src="/images/api/file_uploader.jpg" /&gt;

<h4>File uploader</h4>

显示文件上传器小部件。

```python
data = st.file_uploader("Upload a CSV")
```

</Image>
<RefCard href="/develop/api-reference/widgets/st.camera_input">
<Image>alt="screenshot" src="/images/api/camera_input.jpg" /&gt;

<h4>Camera input</h4>

显示允许用户直接从相机上传图像的小部件。

```python
image = st.camera_input("Take a picture")
```

</Image>
</RefCard>
<ComponentSlider>
<ComponentCard href="https://github.com/okld/streamlit-elements">
<Image>alt="screenshot" src="/images/api/components/elements.jpg" /&gt;

<h4>Streamlit Elements</h4>

在 Streamlit 中创建可拖拽和可调整大小的仪表板。由 [@okls](https://github.com/okls) 创建。

```python
from streamlit_elements import elements, mui, html

with elements("new_element"):
  mui.Typography("Hello world")
```

</Image>
<ComponentCard href="https://github.com/gagan3012/streamlit-tags">
<Image>alt="screenshot" src="/images/api/components/tags.jpg" /&gt;

<h4>Tags</h4>

为您的 Streamlit 应用添加标签。由 [@gagan3012](https://github.com/gagan3012) 创建。

```python
from streamlit_tags import st_tags

st_tags(label='# Enter Keywords:', text='Press enter to add more', value=['Zero', 'One', 'Two'],
suggestions=['five', 'six', 'seven', 'eight', 'nine', 'three', 'eleven', 'ten', 'four'], maxtags = 4, key='1')
```

</Image>
<ComponentCard href="https://github.com/Wirg/stqdm">
<Image>alt="screenshot" src="/images/api/components/stqdm.jpg" /&gt;

<h4>Stqdm</h4>

在 Streamlit 应用中处理进度条的最简单方法。由 [@Wirg](https://github.com/Wirg) 创建。

```python
from stqdm import stqdm

for _ in stqdm(range(50)):
    sleep(0.5)
```

</Image>
<ComponentCard href="https://github.com/innerdoc/streamlit-timeline">
<Image>alt="screenshot" src="/images/api/components/timeline.jpg" /&gt;

<h4>Timeline</h4>

使用 [TimelineJS](https://timeline.knightlab.com/) 在 Streamlit 应用中显示时间线。由 [@innerdoc](https://github.com/innerdoc) 创建。

```python
from streamlit_timeline import timeline

with open('example.json', "r") as f:
  timeline(f.read(), height=800)
```

</Image>
<ComponentCard href="https://github.com/blackary/streamlit-camera-input-live">
<Image>alt="screenshot" src="/images/api/components/camera-live.jpg" /&gt;

<h4>Camera input live</h4>

st.camera_input 的替代方案，可实时返回网络摄像头图像。由 [@blackary](https://github.com/blackary) 创建。

```python
from camera_input_live import camera_input_live

image = camera_input_live()
st.image(value)
```

</Image>
<ComponentCard href="https://github.com/okld/streamlit-ace">
<Image>alt="screenshot" src="/images/api/components/ace.jpg" /&gt;

<h4>Streamlit Ace</h4>

Streamlit 的 Ace 编辑器组件。由 [@okld](https://github.com/okld) 创建。

```python
from streamlit_ace import st_ace

content = st_ace()
content
```

</Image>
<ComponentCard href="https://github.com/AI-Yash/st-chat">
<Image>alt="screenshot" src="/images/api/components/chat.jpg" /&gt;

<h4>Streamlit Chat</h4>

聊天机器人 UI 的 Streamlit 组件。由 [@AI-Yash](https://github.com/AI-Yash) 创建。

```python
from streamlit_chat import message

message("My message")
message("Hello bot!", is_user=True)  # align's the message to the right
```

</Image>
<ComponentCard href="https://github.com/victoryhb/streamlit-option-menu">
<Image>alt="screenshot" src="/images/api/components/option-menu.jpg" /&gt;

<h4>Streamlit Option Menu</h4>

从菜单中的选项列表中选择单个项目。由 [@victoryhb](https://github.com/victoryhb) 创建。

```python
from streamlit_option_menu import option_menu

option_menu("Main Menu", ["Home", 'Settings'],
  icons=['house', 'gear'], menu_icon="cast", default_index=1)
```

</Image>
<ComponentCard href="https://extras.streamlit.app/">
<Image>alt="screenshot" src="/images/api/components/extras-toggle.jpg" /&gt;

<h4>Streamlit Extras</h4>

一个包含有用 Streamlit 扩展的库。由 [@arnaudmiribel](https://github.com/arnaudmiribel/) 创建。

```python
from streamlit_extras.stoggle import stoggle

stoggle(
    "Click me!", """🥷 Surprise! Here's some additional content""",)
```

</Image>
</ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentCard></ComponentSlider></RefCard></RefCard></RefCard></TileContainer></RefCard></RefCard></TileContainer></RefCard></RefCard></TileContainer></RefCard></TileContainer></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></RefCard></TileContainer></RefCard></RefCard></RefCard></RefCard></TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.audio_input


* Function signature:

   st.audio_input(label, *, sample_rate=16000, key=None, help=None, on_change=None, args=None, kwargs=None, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this widget is used for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | sample_rate | int or None | s | The target sample rate for the audio recording in Hz. This defaults to 16000, which is optimal for speech recognition. The following values are supported: 8000 (telephone quality), 11025, 16000 (speech-recognition quality), 22050, 24000, 32000, 44100, 48000 (high-quality), or None. If this is None, the widget uses the browser's default sample rate (typically 44100 or 48000 Hz). |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this audio input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the audio input if set to True. Default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the audio input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: None or UploadedFile

    The UploadedFile class is a subclass of BytesIO, and
therefore is "file-like". This means you can pass an instance of it
anywhere a file is expected. The MIME type for the audio data is
audio/wav.

Note
The resulting UploadedFile is subject to the size
limitation configured in server.maxUploadSize. If you
expect large sound files, update the configuration option
appropriately.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.button


* Function signature:

   st.button(label, key=None, help=None, on_click=None, args=None, kwargs=None, *, type="secondary", icon=None, disabled=False, use_container_width=None, width="content", shortcut=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this button is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed when the button is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_click | callable |  | An optional callback invoked when this button is clicked. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | type | "primary", "secondary", or "tertiary" |  | An optional string that specifies the button type. This can be one of the following:  "primary": The button's background is the app's primary color for additional emphasis. "secondary" (default): The button's background coordinates with the app's background color for normal emphasis. "tertiary": The button is plain text without a border or background for subtlety. |
   | icon | str or None |  | An optional emoji or icon to display next to the button label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | disabled | bool | is | An optional boolean that disables the button if set to True. The default is False. |
   | use_container_width | bool |  | Whether to expand the button's width to fill its parent container. If use_container_width is False (default), Streamlit sizes the button to fit its contents. If use_container_width is True, the width of the button matches its parent container. In both cases, if the contents of the button are wider than the parent container, the contents will line wrap. |
   | width | "content", "stretch", or int |  | The width of the button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container. |
   | shortcut | str or None |  | An optional keyboard shortcut that triggers the button. This can be one of the following strings:  A single alphanumeric key like "K" or "4". A function key like "F11". A special key like "Enter", "Esc", or "Tab". Any of the above combined with modifiers. For example, you can use "Ctrl+K" or "Cmd+Shift+O".   Important The keys "C" and "R" are reserved and can't be used, even with modifiers. Punctuation keys like "." and "," aren't currently supported.  The following special keys are supported: Backspace, Delete, Down, End, Enter, Esc, Home, Left, PageDown, PageUp, Right, Space, Tab, and Up. The following modifiers are supported: Alt, Ctrl, Cmd, Meta, Mod, Option, Shift.  Ctrl, Cmd, Meta, and Mod are interchangeable and will display to the user to match their platform. Option and Alt are interchangeable and will display to the user to match their platform. |

* Returns: bool

    True if the button was clicked on the last run of the app,
False otherwise.



### Advanced functionality

虽然按钮是最简单的输入小部件，但按钮通常与 [`st.session_state`](/develop/api-reference/caching-and-state/st.session_state) 的使用紧密相关。请查看我们关于[按钮行为和示例](/develop/concepts/design/buttons)的进阶指南。

### Featured videos

查看我们关于如何使用 Streamlit 核心功能之一的视频：按钮！

<YouTube videoId="JSeQSnGovSE"/>

在下面的视频中，我们将更进一步，学习如何组合[按钮](/develop/api-reference/widgets/st.button)、[复选框](/develop/api-reference/widgets/st.checkbox)和[单选按钮](/develop/api-reference/widgets/st.radio)！

<YouTube videoId="EnXJBsCIl_A"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.camera_input


* Function signature:

   st.camera_input(label, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this widget is used for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this camera_input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the camera input if set to True. Default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the camera input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: None or UploadedFile

    The UploadedFile class is a subclass of BytesIO, and therefore is
"file-like". This means you can pass an instance of it anywhere a
file is expected.



要将图像文件缓冲区作为字节读取，您可以在 `UploadedFile` 对象上使用 `getvalue()`。

```python
import streamlit as st

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # 要将图像文件缓冲区作为字节读取：
    bytes_data = img_file_buffer.getvalue()
    # 检查 bytes_data 的类型：
    # 应该输出：<class>'bytes'&gt;
    st.write(type(bytes_data))
```

<Important>

`st.camera_input` 返回 `UploadedFile` 类的对象，这是 BytesIO 的子类。因此它是一个"类似文件"的对象。这意味着您可以在任何期望文件的地方传递它，类似于 `st.file_uploader`。

</Important>

## Image processing examples

您可以将 `st.camera_input` 的输出用于各种下游任务，包括图像处理。下面，我们演示如何将 `st.camera_input` 小部件与流行的图像和数据处理库一起使用，例如 [Pillow](https://pillow.readthedocs.io/en/stable/installation.html)、[NumPy](https://numpy.org/)、[OpenCV](https://pypi.org/project/opencv-python-headless/)、[TensorFlow](https://www.tensorflow.org/)、[torchvision](https://pytorch.org/vision/stable/index.html) 和 [PyTorch](https://pytorch.org/)。

虽然我们为最流行的用例和库提供了示例，但欢迎您根据自己的需求和喜爱的库调整这些示例。

### Pillow (PIL) and NumPy

确保您已安装 [Pillow](https://pillow.readthedocs.io/en/stable/installation.html) 和 [NumPy](https://numpy.org/)。

要将图像文件缓冲区作为 PIL Image 读取并转换为 NumPy 数组：

```python
import streamlit as st
from PIL import Image
import numpy as np

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # To read image file buffer as a PIL Image:
    img = Image.open(img_file_buffer)

    # To convert PIL Image to numpy array:
    img_array = np.array(img)

    # Check the type of img_array:
    # Should output: <class>'numpy.ndarray'&gt;
    st.write(type(img_array))

    # Check the shape of img_array:
    # Should output shape: (height, width, channels)
    st.write(img_array.shape)
```

### OpenCV (cv2)

Ensure you have installed [OpenCV](https://pypi.org/project/opencv-python-headless/) and [NumPy](https://numpy.org/).

To read the image file buffer with OpenCV:

```python
import streamlit as st
import cv2
import numpy as np

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # To read image file buffer with OpenCV:
    bytes_data = img_file_buffer.getvalue()
    cv2_img = cv2.imdecode(np.frombuffer(bytes_data, np.uint8), cv2.IMREAD_COLOR)

    # Check the type of cv2_img:
    # Should output: <class>'numpy.ndarray'&gt;
    st.write(type(cv2_img))

    # Check the shape of cv2_img:
    # Should output shape: (height, width, channels)
    st.write(cv2_img.shape)
```

### TensorFlow

Ensure you have installed [TensorFlow](https://www.tensorflow.org/install/).

To read the image file buffer as a 3 dimensional uint8 tensor with TensorFlow:

```python
import streamlit as st
import tensorflow as tf

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # To read image file buffer as a 3D uint8 tensor with TensorFlow:
    bytes_data = img_file_buffer.getvalue()
    img_tensor = tf.io.decode_image(bytes_data, channels=3)

    # Check the type of img_tensor:
    # Should output: <class>'tensorflow.python.framework.ops.EagerTensor'&gt;
    st.write(type(img_tensor))

    # Check the shape of img_tensor:
    # Should output shape: (height, width, channels)
    st.write(img_tensor.shape)
```

### Torchvision

Ensure you have installed [Torchvision](https://pypi.org/project/torchvision/) (it is not bundled with PyTorch) and [PyTorch](https://pytorch.org/).

To read the image file buffer as a 3 dimensional uint8 tensor with `torchvision.io`:

```python
import streamlit as st
import torch
import torchvision

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # To read image file buffer as a 3D uint8 tensor with `torchvision.io`:
    bytes_data = img_file_buffer.getvalue()
    torch_img = torchvision.io.decode_image(
        torch.frombuffer(bytes_data, dtype=torch.uint8)
    )

    # Check the type of torch_img:
    # Should output: <class>'torch.Tensor'&gt;
    st.write(type(torch_img))

    # Check the shape of torch_img:
    # Should output shape: torch.Size([channels, height, width])
    st.write(torch_img.shape)
```

### PyTorch

Ensure you have installed [PyTorch](https://pytorch.org/) and [NumPy](https://numpy.org/).

To read the image file buffer as a 3 dimensional uint8 tensor with PyTorch:

```python
import streamlit as st
import torch
import numpy as np

img_file_buffer = st.camera_input("Take a picture")

if img_file_buffer is not None:
    # To read image file buffer as a 3D uint8 tensor with PyTorch:
    bytes_data = img_file_buffer.getvalue()
    torch_img = torch.ops.image.decode_image(
        torch.from_numpy(np.frombuffer(bytes_data, np.uint8)), 3
    )

    # Check the type of torch_img:
    # Should output: <class>'torch.Tensor'&gt;
    st.write(type(torch_img))

    # Check the shape of torch_img:
    # Should output shape: torch.Size([channels, height, width])
    st.write(torch_img.shape)
```</class></class></class></class></class></class>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.checkbox


* Function signature:

   st.checkbox(label, value=False, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this checkbox is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | bool |  | Preselect the checkbox when it first renders. This will be cast to bool internally. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this checkbox's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the checkbox if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the checkbox widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: bool

    Whether or not the checkbox is checked.



### Featured videos

查看我们关于如何使用 Streamlit 核心功能之一的视频：复选框！☑

<YouTube videoId="Jte0Reue7z8"/>

在下面的视频中，我们将更进一步，学习如何组合[按钮](/develop/api-reference/widgets/st.button)、[复选框](/develop/api-reference/widgets/st.checkbox)和[单选按钮](/develop/api-reference/widgets/st.radio)！

<YouTube videoId="EnXJBsCIl_A"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.color_picker


* Function signature:

   st.color_picker(label, value=None, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | str | black | The hex value of this widget when it first renders. If None, defaults to black. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this color_picker's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the color picker if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the color picker widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: str

    The selected color as a hex string.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.date_input


* Function signature:

   st.date_input(label, value="today", min_value=None, max_value=None, key=None, help=None, on_change=None, args=None, kwargs=None, *, format="YYYY/MM/DD", disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this date input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | "today", datetime.date, datetime.datetime, str, list/tuple of these, or None |  | The value of this widget when it first renders. This can be one of the following:  "today" (default): The widget initializes with the current date. A datetime.date or datetime.datetime object: The widget initializes with the given date, ignoring any time if included. An ISO-formatted date (YYYY-MM-DD) or datetime (YYYY-MM-DD hh:mm:ss) string: The widget initializes with the given date, ignoring any time if included. A list or tuple with up to two of the above: The widget will initialize with the given date interval and return a tuple of the selected interval. You can pass an empty list to initialize the widget with an empty interval or a list with one value to initialize only the beginning date of the iterval. None: The widget initializes with no date and returns None until the user selects a date. |
   | min_value | "today", datetime.date, datetime.datetime, str, or None |  | The minimum selectable date. This can be any of the date types accepted by value, except list or tuple. If this is None (default), the minimum selectable date is ten years before the initial value. If the initial value is an interval, the minimum selectable date is ten years before the start date of the interval. If no initial value is set, the minimum selectable date is ten years before today. |
   | max_value | "today", datetime.date, datetime.datetime, str, or None |  | The maximum selectable date. This can be any of the date types accepted by value, except list or tuple. If this is None (default), the maximum selectable date is ten years after the initial value. If the initial value is an interval, the maximum selectable date is ten years after the end date of the interval. If no initial value is set, the maximum selectable date is ten years after today. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this date_input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | format | str |  | A format string controlling how the interface should display dates. Supports "YYYY/MM/DD" (default), "DD/MM/YYYY", or "MM/DD/YYYY". You may also use a period (.) or hyphen (-) as separators. |
   | disabled | bool | is | An optional boolean that disables the date input if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the date input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: datetime.date or a tuple with 0-2 dates or None

    The current value of the date input widget or None if no date has been
selected.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.datetime_input


* Function signature:

   st.datetime_input(label, value="now", min_value=None, max_value=None, *, key=None, help=None, on_change=None, args=None, kwargs=None, format="YYYY/MM/DD", step=0:15:00, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this datetime input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | "now", datetime.datetime, datetime.date, datetime.time, str, or None |  | The value of this widget when it first renders. This can be one of the following:  "now" (default): The widget initializes with the current date and time. A datetime.datetime object: The widget initializes with the given datetime, stripping any timezone information. A datetime.date object: The widget initializes with the given date at 00:00. A datetime.time object: The widget initializes with today's date and the provided time. An ISO-formatted datetime (YYYY-MM-DD hh:mm[:ss]) or date/time string: The widget initializes with the parsed value. None: The widget initializes with no value and returns None until the user selects a datetime. |
   | min_value | "now", datetime.datetime, datetime.date, datetime.time, str, or None |  | The minimum selectable datetime. This can be any of the datetime types accepted by value. If this is None (default), the minimum selectable datetime is ten years before the initial value. If no initial value is set, the minimum selectable datetime is ten years before today at 00:00. |
   | max_value | "now", datetime.datetime, datetime.date, datetime.time, str, or None |  | The maximum selectable datetime. This can be any of the datetime types accepted by value. If this is None (default), the maximum selectable datetime is ten years after the initial value. If no initial value is set, the maximum selectable datetime is ten years after today at 23:59. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this datetime_input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | format | str |  | A format string controlling how the interface displays dates. Supports "YYYY/MM/DD" (default), "DD/MM/YYYY", or "MM/DD/YYYY". You may also use a period (.) or hyphen (-) as separators. This doesn't affect the time format. |
   | step | int or timedelta | s | The stepping interval in seconds. This defaults to 900 (15 minutes). You can also pass a datetime.timedelta object. The value must be between 60 seconds and 23 hours. |
   | disabled | bool | is | An optional boolean that disables the widget if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the widget matches the container width. |

* Returns: datetime.datetime or None

    The current value of the datetime input widget (without timezone)
or None if no value has been selected.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.download_button


* Function signature:

   st.download_button(label, data, file_name=None, mime=None, key=None, help=None, on_click="rerun", args=None, kwargs=None, *, type="secondary", icon=None, disabled=False, use_container_width=None, width="content", shortcut=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this button is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | data | str, bytes, file-like, or callable |  | The contents of the file to be downloaded or a callable that returns the contents of the file. File contents can be a string, bytes, or file-like object. File-like objects include io.BytesIO, io.StringIO, or any class that implements the abstract base class io.RawIOBase. If a callable is passed, it is executed when the user clicks the download button and runs on a separate thread from the resulting script rerun. This deferred generation is helpful for large files to avoid blocking the page script. The callable can't accept any arguments. If any Streamlit commands are executed inside the callable, they will be ignored. To prevent unnecessary recomputation, use caching when converting your data for download. For more information, see the Example 1 below. |
   | file_name | str |  | An optional string to use as the name of the file to be downloaded, such as "my_file.csv". If not specified, the name will be automatically generated. |
   | mime | str or None |  | The MIME type of the data. If this is None (default), Streamlit sets the MIME type depending on the value of data as follows:  If data is a string or textual file (i.e. str or io.TextIOWrapper object), Streamlit uses the "text/plain" MIME type. If data is a binary file or bytes (i.e. bytes, io.BytesIO, io.BufferedReader, or io.RawIOBase object), Streamlit uses the "application/octet-stream" MIME type.  For more information about MIME types, see https://www.iana.org/assignments/media-types/media-types.xhtml. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed when the button is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_click | callable, "rerun", "ignore", or None |  | How the button should respond to user interaction. This controls whether or not the button triggers a rerun and if a callback function is called. This can be one of the following values:  "rerun" (default): The user downloads the file and the app reruns. No callback function is called. "ignore": The user downloads the file and the app doesn't rerun. No callback function is called. A callable: The user downloads the file and app reruns. The callable is called before the rest of the app. None: This is same as on_click="rerun". This value exists for backwards compatibility and shouldn't be used. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | type | "primary", "secondary", or "tertiary" |  | An optional string that specifies the button type. This can be one of the following:  "primary": The button's background is the app's primary color for additional emphasis. "secondary" (default): The button's background coordinates with the app's background color for normal emphasis. "tertiary": The button is plain text without a border or background for subtlety. |
   | icon | str or None |  | An optional emoji or icon to display next to the button label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | disabled | bool | is | An optional boolean that disables the download button if set to True. The default is False. |
   | use_container_width | bool |  | Whether to expand the button's width to fill its parent container. If use_container_width is False (default), Streamlit sizes the button to fit its contents. If use_container_width is True, the width of the button matches its parent container. In both cases, if the contents of the button are wider than the parent container, the contents will line wrap. |
   | width | "content", "stretch", or int |  | The width of the download button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container. |
   | shortcut | str or None |  | An optional keyboard shortcut that triggers the button. This can be one of the following strings:  A single alphanumeric key like "K" or "4". A function key like "F11". A special key like "Enter", "Esc", or "Tab". Any of the above combined with modifiers. For example, you can use "Ctrl+K" or "Cmd+Shift+O".   Important The keys "C" and "R" are reserved and can't be used, even with modifiers. Punctuation keys like "." and "," aren't currently supported.  For a list of supported keys and modifiers, see the documentation for st.button. |

* Returns: bool

    True if the button was clicked on the last run of the app,
False otherwise.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.feedback


* Function signature:

   st.feedback(options="thumbs", *, key=None, default=None, disabled=False, on_change=None, args=None, kwargs=None, width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | options | "thumbs", "faces", or "stars" |  | The feedback options displayed to the user. options can be one of the following:  "thumbs" (default): Streamlit displays a thumb-up and thumb-down button group. "faces": Streamlit displays a row of five buttons with facial expressions depicting increasing satisfaction from left to right. "stars": Streamlit displays a row of star icons, allowing the user to select a rating from one to five stars. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | default | int or None | feedback | Default feedback value. This must be consistent with the feedback type in options:  0 or 1 if options="thumbs". Between 0 and 4, inclusive, if options="faces" or options="stars". |
   | disabled | bool | is | An optional boolean that disables the feedback widget if set to True. The default is False. |
   | on_change | callable |  | An optional callback invoked when this feedback widget's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | width | "content", "stretch", or int |  | The width of the feedback widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: int or None

    An integer indicating the user's selection, where 0 is the
lowest feedback. Higher values indicate more positive feedback.
If no option was selected, the widget returns None.

For options="thumbs", a return value of 0 indicates
thumbs-down, and 1 indicates thumbs-up.
For options="faces" and options="stars", return values
range from 0 (least satisfied) to 4 (most satisfied).



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.file_uploader


* Function signature:

   st.file_uploader(label, type=None, accept_multiple_files=False, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this file uploader is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | type | str, list of str, or None |  | The allowed file extension(s) for uploaded files. This can be one of the following types:  None (default): All file extensions are allowed. A string: A single file extension is allowed. For example, to only accept CSV files, use "csv". A sequence of strings: Multiple file extensions are allowed. For example, to only accept JPG/JPEG and PNG files, use ["jpg", "jpeg", "png"].   Note This is a best-effort check, but doesn't provide a security guarantee against users uploading files of other types or type extensions. The correct handling of uploaded files is part of the app developer's responsibility. |
   | accept_multiple_files | bool or "directory" |  | Whether to accept more than one file in a submission. This can be one of the following values:  False (default): The user can only submit one file at a time. True: The user can upload multiple files at the same time. "directory": The user can select a directory to upload all files in the directory and its subdirectories. If type is set, only files matching those type(s) will be uploaded.  When this is True or "directory", the return value will be a list and a user can additively select files if they click the browse button on the widget multiple times. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this file_uploader's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the file uploader if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the file uploader widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: None, UploadedFile, or list of UploadedFile

    If accept_multiple_files is False, returns either None or
an UploadedFile object.
If accept_multiple_files is True or "directory", returns
a list with the uploaded files as UploadedFile objects. If no
files were uploaded, returns an empty list.

The UploadedFile class is a subclass of BytesIO, and
therefore is "file-like". This means you can pass an instance of it
anywhere a file is expected.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.link_button


* Function signature:

   st.link_button(label, url, *, help=None, type="secondary", icon=None, disabled=False, use_container_width=None, width="content", shortcut=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this button is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | url | str |  | The url to be opened on user click |
   | help | str or None |  | A tooltip that gets displayed when the button is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | type | "primary", "secondary", or "tertiary" |  | An optional string that specifies the button type. This can be one of the following:  "primary": The button's background is the app's primary color for additional emphasis. "secondary" (default): The button's background coordinates with the app's background color for normal emphasis. "tertiary": The button is plain text without a border or background for subtlety. |
   | icon | str or None |  | An optional emoji or icon to display next to the button label. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | disabled | bool | is | An optional boolean that disables the link button if set to True. The default is False. |
   | use_container_width | bool |  | Whether to expand the button's width to fill its parent container. If use_container_width is False (default), Streamlit sizes the button to fit its contents. If use_container_width is True, the width of the button matches its parent container. In both cases, if the contents of the button are wider than the parent container, the contents will line wrap. |
   | width | "content", "stretch", or int |  | The width of the link button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container. |
   | shortcut | str or None |  | An optional keyboard shortcut that triggers the button. This can be one of the following strings:  A single alphanumeric key like "K" or "4". A function key like "F11". A special key like "Enter", "Esc", or "Tab". Any of the above combined with modifiers. For example, you can use "Ctrl+K" or "Cmd+Shift+O".   Important The keys "C" and "R" are reserved and can't be used, even with modifiers. Punctuation keys like "." and "," aren't currently supported.  For a list of supported keys and modifiers, see the documentation for st.button. |



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.multiselect


* Function signature:

   st.multiselect(label, options, default=None, format_func=special_internal_function, key=None, help=None, on_change=None, args=None, kwargs=None, *, max_selections=None, placeholder=None, disabled=False, label_visibility="visible", accept_new_options=False, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this select widget is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable |  | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default. |
   | default | Iterable of V, V, or None | values | List of default values. Can also be a single value. |
   | format_func | function |  | Function to modify the display of the options. It receives the raw option as an argument and should output the label to be shown for that option. This has no impact on the return value of the command. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this widget's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | max_selections | int |  | The max selections that can be selected at a time. |
   | placeholder | str or  None |  | A string to display when no options are selected. If this is None (default), the widget displays placeholder text based on the widget's configuration:  "Choose options" is displayed when options are available and accept_new_options=False. "Choose or add options" is displayed when options are available and accept_new_options=True. "Add options" is displayed when no options are available and accept_new_options=True. "No options to select" is displayed when no options are available and accept_new_options=False. The widget is also disabled in this case. |
   | disabled | bool | is | An optional boolean that disables the multiselect widget if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | accept_new_options | bool |  | Whether the user can add selections that aren't included in options. If this is False (default), the user can only select from the items in options. If this is True, the user can enter new items that don't exist in options. When a user enters and selects a new item, it is included in the widget's returned list as a string. The new item is not added to the widget's drop-down menu. Streamlit will use a case-insensitive match from options before adding a new item, and a new item can't be added if a case-insensitive match is already selected. The max_selections argument is still enforced. |
   | width | "stretch" or int |  | The width of the multiselect widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: list

    A list of the selected options.
The list contains copies of the selected options, not the originals.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.number_input


* Function signature:

   st.number_input(label, min_value=None, max_value=None, value="min", step=None, format=None, key=None, help=None, on_change=None, args=None, kwargs=None, *, placeholder=None, disabled=False, label_visibility="visible", icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | min_value | int, float, or None |  | The minimum permitted value. If this is None (default), there will be no minimum for float values and a minimum of - (1 + 1 for integer values. |
   | max_value | int, float, or None |  | The maximum permitted value. If this is None (default), there will be no maximum for float values and a maximum of (1 - 1 for integer values. |
   | value | int, float, "min" or None |  | The value of this widget when it first renders. If this is "min" (default), the initial value is min_value unless min_value is None. If min_value is None, the widget initializes with a value of 0.0 or 0. If value is None, the widget will initialize with no value and return None until the user provides input. |
   | step | int, float, or None | 1 | The stepping interval. Defaults to 1 if the value is an int, 0.01 otherwise. If the value is not specified, the format parameter will be used. |
   | format | str or None |  | A printf-style format string controlling how the interface should display numbers. The output must be purely numeric. This does not impact the return value of the widget. For more information about the formatting specification, see sprintf.js. For example, format="%0.1f" adjusts the displayed decimal precision to only show one digit after the decimal. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this number_input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | placeholder | str or None |  | An optional string displayed when the number input is empty. If None, no placeholder is displayed. |
   | disabled | bool | is | An optional boolean that disables the number input if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | icon | str, None |  | An optional emoji or icon to display within the input field to the left of the value. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the number input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: int or float or None

    The current value of the numeric input widget or None if the widget
is empty. The return type will match the data type of the value parameter.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.page_link

<Tip>

查看我们的[教程](/develop/tutorials/multipage/st.page_link-nav)，了解如何使用 `st.page_link` 构建自定义动态菜单。

</Tip>

* Function signature:

   st.page_link(page, *, label=None, icon=None, help=None, disabled=False, use_container_width=None, width="content", query_params=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | page | str, Path, or StreamlitPage |  | The file path (relative to the main script) or a StreamlitPage indicating the page to switch to. Alternatively, this can be the URL to an external page (must start with "http://" or "https://"). |
   | label | str |  | The label for the page link. Labels are required for external pages. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. |
   | icon | str or None |  | An optional emoji or icon to display next to the button label. If icon is None (default), the icon is inferred from the StreamlitPage object or no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | help | str or None |  | A tooltip that gets displayed when the link is hovered over. If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | disabled | bool | is | An optional boolean that disables the page link if set to True. The default is False. |
   | use_container_width | bool | is | Whether to expand the link's width to fill its parent container. The default is True for page links in the sidebar and False for those in the main app. |
   | width | "content", "stretch", or int |  | The width of the page-link button. This can be one of the following:  "content" (default): The width of the button matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the button matches the width of the parent container. An integer specifying the width in pixels: The button has a fixed width. If the specified width is greater than the width of the parent container, the width of the button matches the width of the parent container. |
   | query_params | dict, list of tuples, or None |  | Query parameters to apply when navigating to the target page. This can be a dictionary or an iterable of key-value tuples. Values can be strings or iterables of strings (for repeated keys). When this is None (default), all non-embed query parameters are cleared during navigation. |



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.pills


* Function signature:

   st.pills(label, options, *, selection_mode="single", default=None, format_func=None, key=None, help=None, on_change=None, args=None, kwargs=None, disabled=False, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this widget is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable of V | and | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default and can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | selection_mode | "single" or "multi" |  | The selection mode for the widget. If this is "single" (default), only one option can be selected. If this is "multi", multiple options can be selected. |
   | default | Iterable of V, V, or None |  | The value of the widget when it first renders. If the selection_mode is multi, this can be a list of values, a single value, or None. If the selection_mode is "single", this can be a single value or None. |
   | format_func | function |  | Function to modify the display of the options. It receives the raw option as an argument and should output the label to be shown for that option. This has no impact on the return value of the command. The output can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this widget's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the widget if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the pills widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: list of V, V, or None

    If the selection_mode is multi, this is a list of selected
options or an empty list. If the selection_mode is
"single", this is a selected option or None.
This contains copies of the selected options, not the originals.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.radio


* Function signature:

   st.radio(label, options, index=0, format_func=special_internal_function, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, horizontal=False, captions=None, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this radio group is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable |  | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default. Labels can include markdown as described in the label parameter and will be cast to str internally by default. |
   | index | int or None | 0 | The index of the preselected option on first render. If None, will initialize empty and return None until the user selects an option. Defaults to 0 (the first option). |
   | format_func | function |  | Function to modify the display of radio options. It receives the raw option as an argument and should output the label to be shown for that option. This has no impact on the return value of the radio. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this radio's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the radio button if set to True. The default is False. |
   | horizontal | bool | false | An optional boolean, which orients the radio group horizontally. The default is false (vertical buttons). |
   | captions | iterable of str or None |  | A list of captions to show below each radio button. If None (default), no captions are shown. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the radio button widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: any

    The selected option or None if no option is selected.
This is a copy of the selected option, not the original.


<br/>

小部件可以使用 `label_visibility` 参数自定义如何隐藏其标签。如果为"hidden"，标签不会显示，但在小部件上方仍有空白空间（相当于 `label=""`）。如果为"collapsed"，则标签和空间都会被移除。默认值为"visible"。单选按钮也可以使用 `disabled` 参数禁用，并使用 `horizontal` 参数水平定向：

```python
import streamlit as st

# 将小部件的初始值存储在会话状态中
if "visibility" not in st.session_state:
    st.session_state.visibility = "visible"
    st.session_state.disabled = False
    st.session_state.horizontal = False

col1, col2 = st.columns(2)

with col1:
    st.checkbox("禁用单选小部件", key="disabled")
    st.checkbox("水平定向单选选项", key="horizontal")

with col2:
    st.radio(
        "设置标签可见性 👇",
        ["visible", "hidden", "collapsed"],
        key="visibility",
        label_visibility=st.session_state.visibility,
        disabled=st.session_state.disabled,
        horizontal=st.session_state.horizontal,
    )
```

<Cloud height="300px" name="doc-radio1"/>

### Featured videos

查看我们关于如何使用 Streamlit 核心功能之一的视频：单选按钮！🔘

<YouTube videoId="CVHIMGVAzwA"/>

在下面的视频中，我们将更进一步，学习如何组合[按钮](/develop/api-reference/widgets/st.button)、[复选框](/develop/api-reference/widgets/st.checkbox)和单选按钮！

<YouTube videoId="EnXJBsCIl_A"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.segmented_control


* Function signature:

   st.segmented_control(label, options, *, selection_mode="single", default=None, format_func=None, key=None, help=None, on_change=None, args=None, kwargs=None, disabled=False, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this widget is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable of V | and | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default and can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | selection_mode | "single" or "multi" |  | The selection mode for the widget. If this is "single" (default), only one option can be selected. If this is "multi", multiple options can be selected. |
   | default | Iterable of V, V, or None |  | The value of the widget when it first renders. If the selection_mode is multi, this can be a list of values, a single value, or None. If the selection_mode is "single", this can be a single value or None. |
   | format_func | function |  | Function to modify the display of the options. It receives the raw option as an argument and should output the label to be shown for that option. This has no impact on the return value of the command. The output can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this widget's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the widget if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the segmented control widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: list of V, V, or None

    If the selection_mode is multi, this is a list of selected
options or an empty list. If the selection_mode is
"single", this is a selected option or None.
This contains copies of the selected options, not the originals.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.select_slider


* Function signature:

   st.select_slider(label, options=(), value=None, format_func=special_internal_function, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this slider is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable |  | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default. |
   | value | a supported type or a tuple/list of supported types or None | first | The value of the slider when it first renders. If a tuple/list of two values is passed here, then a range slider with those lower and upper bounds is rendered. For example, if set to (1, 10) the slider will have a selectable range between 1 and 10. Defaults to first option. |
   | format_func | function |  | Function to modify the display of the labels from the options. argument. It receives the option as an argument and its output will be cast to str. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this select_slider's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the select slider if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the slider widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: any value or tuple of any value

    The current value of the slider widget. The return type will match
the data type of the value parameter.
This contains copies of the selected options, not the originals.



### Featured videos

查看我们关于如何使用 Streamlit 核心功能之一的视频：选择滑块！🎈
<YouTube videoId="MTaL_1UCb2g"/>

在下面的视频中，我们将更进一步，制作双端滑块。
<YouTube videoId="sCvdt79asrE"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.selectbox


* Function signature:

   st.selectbox(label, options, index=0, format_func=special_internal_function, key=None, help=None, on_change=None, args=None, kwargs=None, *, placeholder=None, disabled=False, label_visibility="visible", accept_new_options=False, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this select widget is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | options | Iterable |  | Labels for the select options in an Iterable. This can be a list, set, or anything supported by st.dataframe. If options is dataframe-like, the first column will be used. Each label will be cast to str internally by default. |
   | index | int or None | 0 | The index of the preselected option on first render. If None, will initialize empty and return None until the user selects an option. Defaults to 0 (the first option). |
   | format_func | function |  | Function to modify the display of the options. It receives the raw option as an argument and should output the label to be shown for that option. This has no impact on the return value of the command. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this selectbox's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | placeholder | str or None |  | A string to display when no options are selected. If this is None (default), the widget displays placeholder text based on the widget's configuration:  "Choose an option" is displayed when options are available and accept_new_options=False. "Choose or add an option" is displayed when options are available and accept_new_options=True. "Add an option" is displayed when no options are available and accept_new_options=True. "No options to select" is displayed when no options are available and accept_new_options=False. The widget is also disabled in this case. |
   | disabled | bool | is | An optional boolean that disables the selectbox if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | accept_new_options | bool |  | Whether the user can add a selection that isn't included in options. If this is False (default), the user can only select from the items in options. If this is True, the user can enter a new item that doesn't exist in options. When a user enters a new item, it is returned by the widget as a string. The new item is not added to the widget's drop-down menu. Streamlit will use a case-insensitive match from options before adding a new item. |
   | width | "stretch" or int |  | The width of the selectbox widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: any

    The selected option or None if no option is selected.
This is a copy of the selected option, not the original.


<br/>

选择小部件可以使用 `label_visibility` 参数自定义如何隐藏其标签。如果为"hidden"，标签不会显示，但在小部件上方仍有空白空间（相当于 `label=""`）。如果为"collapsed"，则标签和空间都会被移除。默认值为"visible"。选择小部件也可以使用 `disabled` 参数禁用：

```python
import streamlit as st

# 将小部件的初始值存储在会话状态中
if "visibility" not in st.session_state:
    st.session_state.visibility = "visible"
    st.session_state.disabled = False

col1, col2 = st.columns(2)

with col1:
    st.checkbox("禁用选择框小部件", key="disabled")
    st.radio(
        "设置选择框标签可见性 👉",
        key="visibility",
        options=["visible", "hidden", "collapsed"],
    )

with col2:
    option = st.selectbox(
        "您希望如何被联系？",
        ("Email", "Home phone", "Mobile phone"),
        label_visibility=st.session_state.visibility,
        disabled=st.session_state.disabled,
    )
```

<Cloud height="300px" name="doc-selectbox1"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.slider


* Function signature:

   st.slider(label, min_value=None, max_value=None, value=None, step=None, format=None, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this slider is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | min_value | a supported type or None |  | The minimum permitted value. If this is None (default), the minimum value depends on the type as follows:  integer: 0 float: 0.0 date or datetime: value - timedelta(days=14) time: time.min |
   | max_value | a supported type or None |  | The maximum permitted value. If this is None (default), the maximum value depends on the type as follows:  integer: 100 float: 1.0 date or datetime: value + timedelta(days=14) time: time.max |
   | value | a supported type or a tuple/list of supported types or None | s | The value of the slider when it first renders. If a tuple/list of two values is passed here, then a range slider with those lower and upper bounds is rendered. For example, if set to (1, 10) the slider will have a selectable range between 1 and 10. This defaults to min_value. If the type is not otherwise specified in any of the numeric parameters, the widget will have an integer value. |
   | step | int, float, timedelta, or None | 1 | The stepping interval. Defaults to 1 if the value is an int, 0.01 if a float, timedelta(days=1) if a date/datetime, timedelta(minutes=15) if a time (or if max_value - min_value |
   | format | str or None |  | A printf-style format string controlling how the interface should display numbers. This does not impact the return value. For information about formatting integers and floats, see sprintf.js. For example, format="%0.1f" adjusts the displayed decimal precision to only show one digit after the decimal. For information about formatting datetimes, dates, and times, see momentJS. For example, format="ddd ha" adjusts the displayed datetime to show the day of the week and the hour ("Tue 8pm"). |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this slider's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the slider if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the slider widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: int/float/date/time/datetime or tuple of int/float/date/time/datetime

    The current value of the slider widget. The return type will match
the data type of the value parameter.



### Featured videos

查看我们关于如何使用 Streamlit 核心功能之一的视频：滑块！
<YouTube videoId="tzAdd-MuWPw"/>

在下面的视频中，我们将更进一步，制作双端滑块。
<YouTube videoId="sCvdt79asrE"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.text_area


* Function signature:

   st.text_area(label, value="", height=None, max_chars=None, key=None, help=None, on_change=None, args=None, kwargs=None, *, placeholder=None, disabled=False, label_visibility="visible", width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | object or None | empty | The text value of this widget when it first renders. This will be cast to str internally. If None, will initialize empty and return None until the user provides input. Defaults to empty string. |
   | height | "content", "stretch", int, or None |  | The height of the text area widget. This can be one of the following:  None (default): The height of the widget fits three lines. "content": The height of the widget matches the height of its content. "stretch": The height of the widget matches the height of its content or the height of the parent container, whichever is larger. If the widget is not in a parent container, the height of the widget matches the height of its content. An integer specifying the height in pixels: The widget has a fixed height. If the content is larger than the specified height, scrolling is enabled.  The widget's height can't be smaller than the height of two lines. When label_visibility="collapsed", the minimum height is 68 pixels. Otherwise, the minimum height is 98 pixels. |
   | max_chars | int or None |  | Maximum number of characters allowed in text area. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this text_area's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | placeholder | str or None |  | An optional string displayed when the text area is empty. If None, no text is displayed. |
   | disabled | bool | is | An optional boolean that disables the text area if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "stretch" or int |  | The width of the text area widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: str or None

    The current value of the text area widget or None if no value has been
provided by the user.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.text_input


* Function signature:

   st.text_input(label, value="", max_chars=None, key=None, type="default", help=None, autocomplete=None, on_change=None, args=None, kwargs=None, *, placeholder=None, disabled=False, label_visibility="visible", icon=None, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | object or None | empty | The text value of this widget when it first renders. This will be cast to str internally. If None, will initialize empty and return None until the user provides input. Defaults to empty string. |
   | max_chars | int or None |  | Max number of characters allowed in text input. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | type | "default" or "password" | s | The type of the text input. This can be either "default" (for a regular text input), or "password" (for a text input that masks the user's typed value). Defaults to "default". |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | autocomplete | str |  | An optional value that will be passed to the  element's autocomplete property. If unspecified, this value will be set to "new-password" for "password" inputs, and the empty string for "default" inputs. For more details, see https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete |
   | on_change | callable |  | An optional callback invoked when this text input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | placeholder | str or None |  | An optional string displayed when the text input is empty. If None, no text is displayed. |
   | disabled | bool | is | An optional boolean that disables the text input if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. |
   | icon | str, None |  | An optional emoji or icon to display within the input field to the left of the value. If icon is None (default), no icon is displayed. If icon is a string, the following options are valid:  A single-character emoji. For example, you can set icon="🚨" or icon="🔥". Emoji short codes are not supported.  An icon from the Material Symbols library (rounded style) in the format ":material/icon_name:" where "icon_name" is the name of the icon in snake case. For example, icon=":material/thumb_up:" will display the Thumb Up icon. Find additional icons in the Material Symbols  font library.  "spinner": Displays a spinner as an icon. |
   | width | "stretch" or int |  | The width of the text input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: str or None

    The current value of the text input widget or None if no value has been
provided by the user.


<br/>

文本输入小部件可以使用 `label_visibility` 参数自定义如何隐藏其标签。如果为"hidden"，标签不会显示，但在小部件上方仍有空白空间（相当于 `label=""`）。如果为"collapsed"，则标签和空间都会被移除。默认值为"visible"。文本输入小部件也可以使用 `disabled` 参数禁用，并可以使用 `placeholder` 参数在文本输入为空时显示可选占位符文本：

```python
import streamlit as st

# 将小部件的初始值存储在会话状态中
if "visibility" not in st.session_state:
    st.session_state.visibility = "visible"
    st.session_state.disabled = False

col1, col2 = st.columns(2)

with col1:
    st.checkbox("禁用文本输入小部件", key="disabled")
    st.radio(
        "设置文本输入标签可见性 👉",
        key="visibility",
        options=["visible", "hidden", "collapsed"],
    )
    st.text_input(
        "其他文本输入小部件的占位符",
        "这是一个占位符",
        key="placeholder",
    )

with col2:
    text_input = st.text_input(
        "输入一些文本 👇",
        label_visibility=st.session_state.visibility,
        disabled=st.session_state.disabled,
        placeholder=st.session_state.placeholder,
    )

    if text_input:
        st.write("您输入了：", text_input)
```

<Cloud height="400px" name="doc-text-input1"/>

---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.time_input


* Function signature:

   st.time_input(label, value="now", key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", step=0:15:00, width="stretch")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this time input is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | "now", datetime.time, datetime.datetime, str, or None |  | The value of this widget when it first renders. This can be one of the following:  "now" (default): The widget initializes with the current time. A datetime.time or datetime.datetime object: The widget initializes with the given time, ignoring any date if included. An ISO-formatted time (hh:mm[:ss.sss]) or datetime (YYYY-MM-DD hh:mm[:ss]) string: The widget initializes with the given time, ignoring any date if included. None: The widget initializes with no time and returns None until the user selects a time. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this time_input's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the time input if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | step | int or timedelta | s | The stepping interval in seconds. This defaults to 900 (15 minutes). You can also pass a datetime.timedelta object. The value must be between 60 seconds and 23 hours. |
   | width | "stretch" or int |  | The width of the time input widget. This can be one of the following:  "stretch" (default): The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: datetime.time or None

    The current value of the time input widget or None if no time has been
selected.



---

Source: https://docs.streamlit.io/develop/api-reference/widgets/st.toggle


* Function signature:

   st.toggle(label, value=False, key=None, help=None, on_change=None, args=None, kwargs=None, *, disabled=False, label_visibility="visible", width="content")

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | label | str |  | A short label explaining to the user what this toggle is for. The label can optionally contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. Unsupported Markdown elements are unwrapped so only their children (text contents) render. Display unsupported elements as literal characters by backslash-escaping them. E.g., "1\. Not an ordered list". See the body parameter of st.markdown for additional, supported Markdown directives. For accessibility reasons, you should never set an empty label, but you can hide it with label_visibility if needed. In the future, we may disallow empty labels by raising an exception. |
   | value | bool |  | Preselect the toggle when it first renders. This will be cast to bool internally. |
   | key | str or int |  | An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. No two widgets may have the same key. |
   | help | str or None |  | A tooltip that gets displayed next to the widget label. Streamlit only displays the tooltip when label_visibility="visible". If this is None (default), no tooltip is displayed. The tooltip can optionally contain GitHub-flavored Markdown, including the Markdown directives described in the body parameter of st.markdown. |
   | on_change | callable |  | An optional callback invoked when this toggle's value changes. |
   | args | list or tuple |  | An optional list or tuple of args to pass to the callback. |
   | kwargs | dict |  | An optional dict of kwargs to pass to the callback. |
   | disabled | bool | is | An optional boolean that disables the toggle if set to True. The default is False. |
   | label_visibility | "visible", "hidden", or "collapsed" | is | The visibility of the label. The default is "visible". If this is "hidden", Streamlit displays an empty spacer instead of the label, which can help keep the widget aligned with other widgets. If this is "collapsed", Streamlit displays no label or spacer. |
   | width | "content", "stretch", or int |  | The width of the toggle widget. This can be one of the following:  "content" (default): The width of the widget matches the width of its content, but doesn't exceed the width of the parent container. "stretch": The width of the widget matches the width of the parent container. An integer specifying the width in pixels: The widget has a fixed width. If the specified width is greater than the width of the parent container, the width of the widget matches the width of the parent container. |

* Returns: bool

    Whether or not the toggle is checked.



---

# st.write and magic commands

Source: https://docs.streamlit.io/develop/api-reference/write-magic


Streamlit has two easy ways to display information into your app, which should typically be the
first thing you try: `st.write` and magic.

<TileContainer>
<RefCard href="/develop/api-reference/write-magic/st.write">
<h4>st.write</h4>

Write arguments to the app.

```python
st.write("Hello **world**!")
st.write(my_data_frame)
st.write(my_mpl_figure)
```

</RefCard>
<RefCard href="/develop/api-reference/write-magic/st.write_stream">
<h4>st.write_stream</h4>

Write generators or streams to the app with a typewriter effect.

```python
st.write_stream(my_generator)
st.write_stream(my_llm_stream)
```

</RefCard>
<RefCard href="/develop/api-reference/write-magic/magic">
<h4>Magic</h4>

Any time Streamlit sees either a variable or literal value on its own line, it automatically writes that to your app using `st.write`

```python
"Hello **world**!"
my_data_frame
my_mpl_figure
```

</RefCard>
</TileContainer>

---

Source: https://docs.streamlit.io/develop/api-reference/write-magic/magic

## Magic

Magic commands are a feature in Streamlit that allows you to write almost anything (markdown, data,
charts) without having to type an explicit command at all. Just put the thing you want to show on
its own line of code, and it will appear in your app. Here's an example:

```python
# Draw a title and some text to the app:
'''
# This is the document title

This is some _markdown_.
'''

import pandas as pd
df = pd.DataFrame({'col1': [1,2,3]})
df  # 👈 Draw the dataframe

x = 10
'x', x  # 👈 Draw the string 'x' and then the value of x

# Also works with most supported chart types
import matplotlib.pyplot as plt
import numpy as np

arr = np.random.normal(1, 1, size=100)
fig, ax = plt.subplots()
ax.hist(arr, bins=20)

fig  # 👈 Draw a Matplotlib chart
```

### How Magic works

Any time Streamlit sees either a variable or literal
value on its own line, it automatically writes that to your app using
[`st.write`](/develop/api-reference/write-magic/st.write) (which you'll learn about later).

Also, magic is smart enough to ignore docstrings. That is, it ignores the
strings at the top of files and functions.

If you prefer to call Streamlit commands more explicitly, you can always turn
magic off in your `~/.streamlit/config.toml` with the following setting:

```toml
[runner]
magicEnabled = false
```

<Important>
<p>Right now, Magic only works in the main Python app file, not in imported files. See GitHub issue #288 for a discussion of the issues.</p>
</Important>

### Featured video

Learn what the [`st.write`](/develop/api-reference/write-magic/st.write) and [magic](/develop/api-reference/write-magic/magic) commands are and how to use them.

<YouTube videoId="wpDuY9I2fDg"/>

---

Source: https://docs.streamlit.io/develop/api-reference/write-magic/st.write


* Function signature:

   st.write(*args, unsafe_allow_html=False)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | *args | any |  | One or many objects to display in the app.  Each type of argument is handled as follows:      Type Handling    str Uses st.markdown().  dataframe-like, dict, or list Uses st.dataframe().  Exception Uses st.exception().  function, module, or class Uses st.help().  DeltaGenerator Uses st.help().  Altair chart Uses st.altair_chart().  Bokeh figure Uses st.bokeh_chart().  Graphviz graph Uses st.graphviz_chart().  Keras model Converts model and uses st.graphviz_chart().  Matplotlib figure Uses st.pyplot().  Plotly figure Uses st.plotly_chart().  PIL.Image Uses st.image().  generator or stream (like openai.Stream) Uses st.write_stream().  SymPy expression Uses st.latex().  An object with ._repr_html() Uses st.html().  Database cursor Displays DB API 2.0 cursor results in a table.  Any Displays str(arg) as inline code. |
   | unsafe_allow_html | bool |  | Whether to render HTML within *args. This only applies to strings or objects falling back on _repr_html_(). If this is False (default), any HTML tags found in body will be escaped and therefore treated as raw text. If this is True, any HTML expressions within body will be rendered. Adding custom HTML to your app impacts safety, styling, and maintainability.  Note If you only want to insert HTML or CSS without Markdown text, we recommend using st.html instead. |

* Returns: None



### Featured video

Learn what the [`st.write`](/develop/api-reference/write-magic/st.write) and [magic](/develop/api-reference/write-magic/magic) commands are and how to use them.

<YouTube videoId="wpDuY9I2fDg"/>

---

Source: https://docs.streamlit.io/develop/api-reference/write-magic/st.write_stream


* Function signature:

   st.write_stream(stream, *, cursor=None)

* Parameters:

   | name | type | default | description |
   |---|---|---|---|
   | stream | Callable, Generator, Iterable, OpenAI Stream, or LangChain Stream |  | The generator or iterable to stream. If you pass an async generator, Streamlit will internally convert it to a sync generator. If the generator depends on a cached object with async references, this can raise an error.  Note To use additional LLM libraries, you can create a wrapper to manually define a generator function and include custom output parsing. |
   | cursor | str or None |  | A string to append to text as it's being written. If this is None (default), no cursor is shown. Otherwise, the string is rendered as Markdown and appears as a cursor at the end of the streamed text. For example, you can use an emoji, emoji shortcode, or Material icon. The first line of the cursor string can contain GitHub-flavored Markdown of the following types: Bold, Italics, Strikethroughs, Inline Code, Links, and Images. Images display like icons, with a max height equal to the font height. If you pass a multiline string, additional lines display after the text with the full Markdown rendering capabilities of st.markdown. See the body parameter of st.markdown for additional, supported Markdown directives. |

* Returns: str or list

    The full response. If the streamed output only contains text, this
is a string. Otherwise, this is a list of all the streamed objects.
The return value is fully compatible as input for st.write.


<Tip>

If your stream object is not compatible with `st.write_stream`, define a wrapper around your stream object to create a compatible generator function.

```python
for chunk in unsupported_stream:
    yield preprocess(chunk)
```

For an example, see how we use [Replicate](https://replicate.com/docs/get-started/python) with [Snowflake Arctic](https://www.snowflake.com/en/data-cloud/arctic/) in [this code](https://github.com/streamlit/snowflake-arctic-st-demo/blob/0f0d8b49f328f72ae58ced2e9000790fb5e56e6f/simple_app.py#L58).

</Tip>

---

# 开发概念

Source: https://docs.streamlit.io/develop/concepts


本部分为您提供 Streamlit 如何工作的不同部分的背景信息。

<TileContainer>
<RefCard href="/develop/concepts/architecture" size="half">
<h5>Streamlit 的架构和执行模型</h5>

Streamlit 的执行模型可以轻松将您的脚本转换为美观、交互式的网络应用。

- 了解如何运行您的应用。
- 了解 Streamlit 的执行和客户端-服务器模型。
- 了解处理 Streamlit 重新运行的主要工具。

</RefCard>
<RefCard href="/develop/concepts/multipage-apps" size="half">
<h5>多页应用</h5>

Streamlit 通过目录结构提供了一种自动化的方式来构建多页应用。

- 学习如何构造和配置您的多页应用。

</RefCard>
<RefCard href="/develop/concepts/design" size="half">
<h5>应用设计考虑</h5>

将 Streamlit 的架构和执行模型结合在一起来设计您的应用。使用 Streamlit 命令为您的用户呈现动态和交互式内容。

- 了解如何使您的应用高效且易于管理。
- 了解如何构造和设计您的项目。

</RefCard>
<RefCard href="/develop/concepts/connections" size="half">
<h5>连接和密钥</h5>

- 了解如何使用 Streamlit 的便捷的内置功能管理连接和密钥。

</RefCard>
<RefCard href="/develop/concepts/custom-components" size="half">
<h5>创建自定义组件</h5>

自定义组件扩展 Streamlit 的功能。

- 了解如何构建您自己的自定义组件。
- 了解如何安装第三方组件。

</RefCard>
<RefCard href="/develop/concepts/configuration" size="half">
<h5>配置和主题</h5>

Streamlit 提供多种选项来自定义和配置您的应用。

- 了解如何使用配置选项，包括服务器设置、客户端设置和主题。

</RefCard>
<RefCard href="/develop/concepts/app-testing" size="half">
<h5>应用测试</h5>

Streamlit 应用测试使开发者能够构建和运行自动化测试。使用您喜欢的测试自动化软件，并享受模拟用户输入和检查呈现输出的简单语法。

</RefCard>
</TileContainer>

---

# Streamlit 原生应用测试框架

Source: https://docs.streamlit.io/develop/concepts/app-testing


Streamlit 应用测试使开发者能够构建和运行自动化测试。带上你喜欢的测试自动化软件，享受简单的语法来模拟用户输入并检查渲染输出。

提供的类 AppTest 模拟运行的应用，并提供方法来通过 API（而不是浏览器 UI）设置、操纵和检查应用内容。AppTest 提供与浏览器自动化工具（如 Selenium 或 Playwright）类似的功能，但编写和执行测试的开销更少。将我们的测试框架与 [pytest](https://docs.pytest.org/) 之类的工具一起使用来执行或自动化你的测试。典型的模式是为应用构建一套测试，以确保应用随着发展的一致功能。测试在本地和/或 CI 环境（如 GitHub Actions）中运行。

<InlineCalloutContainer>
<InlineCallout bold="入门" color="indigo-70" href="/develop/concepts/app-testing/get-started" icon="science">向你介绍应用测试框架以及如何使用 <code>pytest</code> 执行测试。了解如何初始化和运行模拟的应用，包括如何检索、操纵和检查应用元素。</InlineCallout>
<InlineCallout bold="超越基础知识" color="indigo-70" href="/develop/concepts/app-testing/beyond-the-basics" icon="password">解释如何在应用测试中使用 secrets 和 Session State，包括如何测试多页应用。</InlineCallout>
<InlineCallout bold="自动化你的测试" color="indigo-70" href="/develop/concepts/app-testing/automate-tests" icon="play_circle">使用持续集成 (CI) 随时间验证应用更改。</InlineCallout>
<InlineCallout bold="示例" color="indigo-70" href="/develop/concepts/app-testing/examples" icon="quiz">将上面解释的概念放在一起。查看已实施多个测试的应用。</InlineCallout>
<InlineCallout bold="速查表" color="indigo-70" href="/develop/concepts/app-testing/cheat-sheet" icon="saved_search">是总结可用语法的紧凑参考。</InlineCallout>
</InlineCalloutContainer>

---

# 使用 CI 自动化测试

Source: https://docs.streamlit.io/develop/concepts/app-testing/automate-tests


应用测试的一个关键好处是可以使用持续集成（CI）来自动化测试。通过在开发过程中自动运行测试，您可以验证对应用的更改不会破坏现有功能。您可以在提交代码时验证应用代码，及早发现错误，并在部署前防止意外中断。

有许多流行的 CI 工具，包括 GitHub Actions、Jenkins、GitLab CI、Azure DevOps 和 Circle CI。Streamlit 应用测试可以轻松集成到其中任何一个工具中，类似于其他 Python 测试。

## GitHub Actions

由于许多 Streamlit 应用（以及所有社区云应用）都在 GitHub 中构建，本页面使用 [GitHub Actions](https://docs.github.com/en/actions) 的示例。有关 GitHub Actions 的更多信息，请参见：

- [GitHub Actions 快速入门](https://docs.github.com/en/actions/quickstart)
- [GitHub Actions：关于持续集成](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)
- [GitHub Actions：构建和测试 Python](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python)

## Streamlit 应用 Action

[Streamlit 应用 Action](https://github.com/marketplace/actions/streamlit-app-action) 提供了一种简单的方法，将自动化测试添加到您在 GitHub 中的应用仓库中。它还包括对应用每个页面的基本冒烟测试，而无需您编写任何测试代码。

要安装 Streamlit 应用 Action，请在仓库的 `.github/workflows/` 文件夹中添加一个工作流 `.yml` 文件。例如：

```yaml
# .github/workflows/streamlit-app.yml
name: Streamlit 应用

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: read

jobs:
  streamlit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - uses: streamlit/streamlit-app-action@v0.0.3
        with:
          app-path: streamlit_app.py
```

让我们更详细地看看这个动作工作流在做什么。

### 触发工作流

```yaml
on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
```

当针对 `main` 分支发起拉取请求时，以及推送到 `main` 分支的任何新提交时，将触发并执行此工作流。请注意，它还将对任何开放的拉取请求的后续提交执行测试。有关更多信息和示例，请参见 [GitHub Actions：触发工作流](https://docs.github.com/en/actions/using-workflows/triggering-a-workflow)。

### 设置测试环境

```yaml
jobs:
  streamlit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
```

工作流有一个执行一系列步骤的 `streamlit` 作业。该作业在使用 `ubuntu-latest` 镜像的 Docker 容器上运行。

- `actions/checkout@v4` 从 GitHub 检出当前仓库代码，并将代码复制到作业环境中。
- `actions/setup-python@v5` 安装 Python 3.11 版本。

### 运行应用测试

```yaml
- uses: streamlit/streamlit-app-action@v0.0.3
  with:
    app-path: streamlit_app.py
```

Streamlit 应用 Action 执行以下操作：

- 安装 `pytest` 并安装 `requirements.txt` 中指定的任何依赖项。
- 运行内置的应用冒烟测试。
- 运行在仓库中找到的任何其他 Python 测试。

<Tip>

如果您的应用仓库根目录中不包含 `requirements.txt`，您需要添加一个步骤，使用您选择的包管理器安装依赖项，然后再运行 Streamlit 应用 Action。

</Tip>

内置冒烟测试具有以下行为：

- 在 AppTest 中运行 `app-path` 指定的应用。
- 验证它能成功完成且不会导致未捕获的异常。
- 对相对于 `app-path` 的应用任何附加 `pages/` 执行相同的操作。

如果您想在不使用冒烟测试的情况下运行 Streamlit 应用 Action，可以设置 `skip-smoke: true`。

### 检查应用代码

Linting 是对源代码进行程序性和风格错误的自动检查。这是通过使用 lint 工具（也称为 linter）完成的。Linting 对减少错误和提高代码的整体质量很重要，特别是对于有多个开发者的仓库或公共仓库。

您可以通过向 Streamlit 应用 Action 传递 `ruff: true` 来使用 [Ruff](https://docs.astral.sh/ruff/) 添加自动 linting。

```yaml
- uses: streamlit/streamlit-app-action@v0.0.3
  with:
    app-path: streamlit_app.py
    ruff: true
```

<Tip>

您可能希望在本地开发环境中添加像 [ruff-pre-commit](https://github.com/astral-sh/ruff-pre-commit) 这样的预提交钩子，在到达 CI 之前修复 linting 错误。

</Tip>

### 查看结果

如果测试失败，CI 工作流将失败，您将在 GitHub 中看到结果。通过点击工作流运行可以获取控制台日志，[如这里所述](https://docs.github.com/en/actions/using-workflows/about-workflows#viewing-the-activity-for-a-workflow-run)。

![](/images/test-results-logs.png)

对于更高级别的测试结果，您可以使用 [pytest-results-action](https://github.com/marketplace/actions/pytest-results-actions)。您可以将此与 Streamlit 应用 Action 结合使用，如下所示：

```yaml
# ... 如上设置 ...
- uses: streamlit/streamlit-app-action@v0.0.3
  with:
    app-path: streamlit_app.py
    # 添加 pytest-args 以输出 junit xml
    pytest-args: -v --junit-xml=test-results.xml
- if: always()
  uses: pmeier/pytest-results-action@v0.6.0
  with:
    path: test-results.xml
    summary: true
    display-options: fEX
```

![](/images/test-results-summary.png)

## 编写自己的 Actions

以上只是一个示例。Streamlit 应用 Action 是一个快速入门的方法。一旦您学会了所选 CI 工具的基础知识，就很容易构建和自定义自己的自动化工作流。这对于提高开发者整体生产力和应用质量是非常好的方法。

## 工作示例

作为最终的工作示例，看看我们的 [`streamlit/llm-examples` Actions](https://github.com/streamlit/llm-examples/actions)，在[这个工作流文件](https://github.com/streamlit/llm-examples/blob/main/.github/workflows/app-testing.yml)中定义。

---

# 超越应用测试基础

Source: https://docs.streamlit.io/develop/concepts/app-testing/beyond-the-basics


既然您已经熟悉了为 Streamlit 应用执行基本测试，让我们来看看 [`AppTest`](/develop/api-reference/app-testing/st.testing.v1.apptest) 的可变属性：

- `AppTest.secrets`
- `AppTest.session_state`
- `AppTest.query_params`

您可以使用类似字典的语法为这三个属性读取和更新值。对于 `.secrets` 和 `.query_params`，您可以使用键表示法，但不能使用属性表示法。例如，`AppTest` 的 `.secrets` 属性接受 `at.secrets["my_key"]`，但**不接受** `at.secrets.my_key`。这与您在主库中使用关联命令的方式不同。另一方面，`.session_state` 允许键表示法和属性表示法。

对于这些属性，典型的模式是在执行应用首次运行之前声明任何值。可以在测试中的任何时候检查值。对于 secrets 和会话状态，还有一些额外的注意事项，我们现在将介绍。

## 在应用测试中使用 secrets

请小心不要直接在测试中包含 secrets。考虑这个使用 `pytest` 在项目根目录执行的简单项目：

```none
myproject/
├── .streamlit/
│   ├── config.toml
│   └── secrets.toml
├── app.py
└── tests/
    └── test_app.py
```

```bash
cd myproject
pytest tests/
```

在上述场景中，您的模拟应用将可以访问您的 `secrets.toml` 文件。但是，由于您不希望将 secrets 提交到您的仓库，您可能需要编写安全地将 secrets 拉入内存或使用虚拟 secrets 的测试。

### 示例：在测试中声明 secrets

在测试中，在初始化 `AppTest` 实例后但在首次运行之前声明每个 secret。（缺少 secret 可能导致应用无法运行！）例如，考虑以下 secrets 文件和相应的测试初始化以手动分配相同的 secrets：

Secrets 文件：

```toml
db_username = "Jane"
db_password = "mypassword"

[my_other_secrets]
things_i_like = ["Streamlit", "Python"]
```

具有等效 secrets 的测试文件：

```python
# 初始化 AppTest 实例。
at = AppTest.from_file("app.py")
# 声明 secrets。
at.secrets["db_username"] = "Jane"
at.secrets["db_password"] = "mypassword"
at.secrets["my_other_secrets.things_i_like"] = ["Streamlit", "Python"]
# 运行应用。
at.run()
```

通常，您希望避免直接在测试中输入您的 secrets。如果您的测试不需要真实的 secrets，您可以声明虚拟 secrets，如上面的示例。如果您的应用使用 secrets 连接到数据库或 API 等外部服务，请考虑在应用测试中模拟该服务。如果您需要使用真实的 secrets 并实际连接，您应该使用 API 来安全匿名地传递它们。如果您正在使用 GitHub Actions 自动化测试，请查看他们的 [安全指南](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions)。

```python
at.secrets["my_key"] = <通过>提供的值&gt;
```

## 在应用测试中使用会话状态

`AppTest` 的 `.session_state` 属性允许您使用键表示法（`at.session_state["my_key"]`）和属性表示法（`at.session_state.my_key`）读取和更新会话状态值。通过在会话状态中手动声明值，您可以直接跳转到特定状态，而不是模拟许多步骤来达到那里。此外，测试框架不为多页面应用提供原生支持。`AppTest` 的实例只能测试一个页面。您必须手动声明会话状态值以模拟用户从另一页携带数据。

### 示例：测试多页面应用

考虑一个简单的多页面应用，其中第一页可以修改会话状态中的值。要测试第二页，在测试中手动设置会话状态并运行模拟应用：

项目结构：

```none
myproject/
├── pages/
│   └── second.py
├── first.py
└── tests/
    └── test_second.py
```

第一个应用页面：

```python
"""first.py"""
import streamlit as st

st.session_state.magic_word = st.session_state.get("magic_word", "Streamlit")

new_word = st.text_input("魔法词:")

if st.button("设置魔法词"):
    st.session_state.magic_word = new_word
```

第二个应用页面：

```python
"""second.py"""
import streamlit as st

st.session_state.magic_word = st.session_state.get("magic_word", "Streamlit")

if st.session_state.magic_word == "Balloons":
    st.markdown(":balloon:")
```

测试文件：

```python
"""test_second.py"""
from streamlit.testing.v1 import AppTest

def test_balloons():
    at = AppTest.from_file("pages/second.py")
    at.session_state["magic_word"] = "Balloons"
    at.run()
    assert at.markdown[0].value == ":balloon:"
```

通过在测试中设置值 `at.session_state["magic_word"] = "Balloons"`，您可以模拟用户在 `first.py` 上输入并保存 "Balloons" 后导航到 `second.py` 的操作。</通过>

---

# 应用测试速查表

Source: https://docs.streamlit.io/develop/concepts/app-testing/cheat-sheet


## 文本元素

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 标题
assert "我的应用" in at.title[0].value
assert "新主题" in at.header[0].value
assert "有趣的子主题" in at.subheader[0].value
assert len(at.divider) == 2

# 正文 / 代码
assert "Hello, world!" in at.markdown[0].value
assert "import streamlit as st" in at.code[0].value
assert "一个很酷的图表" in at.caption[0].value
assert "Hello again, world!" in at.text[0].value
assert "\int a x^2 \,dx" in at.latex[0].value
```

## 输入部件

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 按钮
assert at.button[0].value == False
at.button[0].click().run()
assert at.button[0].value == True

# 复选框
assert at.checkbox[0].value == False
at.checkbox[0].check().run() # uncheck() 也支持
assert at.checkbox[0].value == True

# 颜色选择器
assert at.color_picker[0].value == "#FFFFFF"
at.color_picker[0].pick("#000000").run()

# 日期输入
assert at.date_input[0].value == datetime.date(2019, 7, 6)
at.date_input[0].set_value(datetime.date(2022, 12, 21)).run()

# 表单提交按钮 - 显示得像普通按钮一样
assert at.button[0].value == False
at.button[0].click().run()
assert at.button[0].value == True

# 多选
assert at.multiselect[0].value == ["foo", "bar"]
at.multiselect[0].select("baz").unselect("foo").run()

# 数字输入
assert at.number_input[0].value == 5
at.number_input[0].increment().run()

# 单选按钮
assert at.radio[0].value == "Bar"
assert at.radio[0].index == 3
at.radio[0].set_value("Foo").run()

# 选择框
assert at.selectbox[0].value == "Bar"
assert at.selectbox[0].index == 3
at.selectbox[0].set_value("Foo").run()

# 选择滑块
assert at.select_slider[0].value == "Feb"
at.select_slider[0].set_value("Mar").run()
at.select_slider[0].set_range("Apr", "Jun").run()

# 滑块
assert at.slider[0].value == 2
at.slider[0].set_value(3).run()
at.slider[0].set_range(4, 6).run()

# 文本区域
assert at.text_area[0].value == "Hello, world!"
at.text_area[0].set_value("Hello, yourself!").run()

# 文本输入
assert at.text_input[0].value == "Hello, world!")
at.text_input[0].set_value("Hello, yourself!").run()

# 时间输入
assert at.time_input[0].value == datetime.time(8, 45)
at.time_input[0].set_value(datetime.time(12, 30))

# 开关
assert at.toggle[0].value == False
assert at.toggle[0].label == "调试模式"
at.toggle[0].set_value(True).run()
assert at.toggle[0].value == True
```

## 数据元素

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 数据框
expected_df = pd.DataFrame([1, 2, 3])
assert at.dataframe[0].value.equals(expected_df)

# 指标
assert at.metric[0].value == "9500"
assert at.metric[0].delta == "1000"

# json
assert at.json[0].value == '["hi", {"foo": "bar"}]'

# 表格
table_df = pd.DataFrame([1, 2, 3])
assert at.table[0].value.equals(table_df)
```

## 布局和容器

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 侧边栏
at.sidebar.text_input[0].set_value("Jane Doe")

# 列
at.columns[1].markdown[0].value == "Hello, world!"

# 选项卡
at.tabs[2].markdown[0].value == "Hello, yourself!"
```

## 聊天元素

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 聊天输入
at.chat_input[0].set_value("你知道什么笑话吗？").run()
# 注意：chat_input 值在每次重新运行后清除（像真实应用中一样）

# 聊天消息
assert at.chat_message[0].markdown[0].value == "你知道什么笑话吗？"
assert at.chat_message[0].avatar == "user"
```

## 状态元素

```python
from streamlit.testing.v1 import AppTest

at = AppTest.from_file("cheatsheet_app.py")

# 异常
assert len(at.exception) == 1
assert "TypeError" in at.exception[0].value

# 其他内联警报：success, info, warning, error
assert at.success[0].value == "做得好！"
assert at.info[0].value == "请输入API密钥以继续"
assert at.warning[0].value == "抱歉，密码不匹配"
assert at.error[0].value == "出了些问题 :("

# toast
assert at.toast[0].value == "那真是太棒了！" and at.toast[0].icon == "🔥"
```

## 限制

截至 Streamlit 1.28，以下 Streamlit 功能不被 `AppTest` 原生支持。但是，通过使用 `AppTest.get()` 直接检查底层 proto，许多功能可以实现变通方法。我们计划定期添加对缺失元素的支持，直到所有功能都得到支持。

- 图表元素（`st.bar_chart`、`st.line_chart` 等）
- 媒体元素（`st.image`、`st.video`、`st.audio`）
- `st.file_uploader`
- `st.data_editor`
- `st.expander`
- `st.status`
- `st.camera_input`
- `st.download_button`
- `st.link_button`

---

# 应用测试示例

Source: https://docs.streamlit.io/develop/concepts/app-testing/examples


## 测试登录页面

让我们考虑一个登录页面。在此示例中，`secrets.toml` 不存在。我们将在测试中直接手动声明虚拟密钥。为了避免[定时攻击](https://en.wikipedia.org/wiki/Timing_attack)，登录脚本使用 `hmac` 将用户的密码与密钥值进行比较，作为安全最佳实践。

### 项目摘要

#### 登录页面行为

在深入应用代码之前，让我们思考一下这个页面应该做什么。无论您使用测试驱动开发还是在代码之后编写单元测试，考虑需要测试的功能都是一个好主意。登录页面应该表现如下：

- 在用户与应用交互之前：
  - 他们的状态是"未验证"。
  - 显示密码提示。
- 如果用户输入错误密码：
  - 他们的状态是"错误"。
  - 显示错误消息。
  - 从输入中清除密码尝试。
- 如果用户输入正确密码：
  - 他们的状态是"已验证"。
  - 显示确认消息。
  - 显示注销按钮（没有登录提示）。
- 如果已登录用户点击**注销**按钮：
  - 他们的状态是"未验证"。
  - 显示密码提示。

#### 登录页面项目结构

```none
myproject/
├── app.py
└── tests/
    └── test_app.py
```

#### 登录页面 Python 文件

页面规范中提到的用户状态在 `st.session_state.status` 中编码。此值在脚本开始时初始化为"未验证"，并在密码提示接收到新条目时通过回调更新。

```python
"""app.py"""
import streamlit as st
import hmac

st.session_state.status = st.session_state.get("status", "unverified")
st.title("我的登录页面")


def check_password():
    if hmac.compare_digest(st.session_state.password, st.secrets.password):
        st.session_state.status = "verified"
    else:
        st.session_state.status = "incorrect"
    st.session_state.password = ""

def login_prompt():
    st.text_input("输入密码:", key="password", on_change=check_password)
    if st.session_state.status == "incorrect":
        st.warning("密码错误。请重试。")

def logout():
    st.session_state.status = "unverified"

def welcome():
    st.success("登录成功。")
    st.button("注销", on_click=logout)


if st.session_state.status != "verified":
    login_prompt()
    st.stop()
welcome()
```

#### 登录页面测试文件

这些测试严格遵循上述应用规范。在每个测试中，在运行应用并继续进行进一步模拟和检查之前，会设置虚拟密钥。

```python
from streamlit.testing.v1 import AppTest

def test_no_interaction():
    at = AppTest.from_file("app.py")
    at.secrets["password"] = "streamlit"
    at.run()
    assert at.session_state["status"] == "unverified"
    assert len(at.text_input) == 1
    assert len(at.warning) == 0
    assert len(at.success) == 0
    assert len(at.button) == 0
    assert at.text_input[0].value == ""

def test_incorrect_password():
    at = AppTest.from_file("app.py")
    at.secrets["password"] = "streamlit"
    at.run()
    at.text_input[0].input("balloon").run()
    assert at.session_state["status"] == "incorrect"
    assert len(at.text_input) == 1
    assert len(at.warning) == 1
    assert len(at.success) == 0
    assert len(at.button) == 0
    assert at.text_input[0].value == ""
    assert "密码错误" in at.warning[0].value

def test_correct_password():
    at = AppTest.from_file("app.py")
    at.secrets["password"] = "streamlit"
    at.run()
    at.text_input[0].input("streamlit").run()
    assert at.session_state["status"] == "verified"
    assert len(at.text_input) == 0
    assert len(at.warning) == 0
    assert len(at.success) == 1
    assert len(at.button) == 1
    assert "登录成功" in at.success[0].value
    assert at.button[0].label == "注销"

def test_log_out():
    at = AppTest.from_file("app.py")
    at.secrets["password"] = "streamlit"
    at.session_state["status"] = "verified"
    at.run()
    at.button[0].click().run()
    assert at.session_state["status"] == "unverified"
    assert len(at.text_input) == 1
    assert len(at.warning) == 0
    assert len(at.success) == 0
    assert len(at.button) == 0
    assert at.text_input[0].value == ""
```

看到最后一个测试中如何修改会话状态了吗？测试不是完全模拟用户登录，而是通过设置 `at.session_state["status"] = "verified"` 直接跳转到已登录状态。运行应用后，测试继续模拟用户注销。

### 自动化测试

如果将 `myproject/` 作为仓库推送到 GitHub，您可以使用 [Streamlit 应用 Action](https://github.com/marketplace/actions/streamlit-app-action) 添加 GitHub Actions 测试自动化。这就像在 `myproject/.github/workflows/` 添加工作流文件一样简单：

```yaml
# .github/workflows/streamlit-app.yml
name: Streamlit 应用

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: read

jobs:
  streamlit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - uses: streamlit/streamlit-app-action@v0.0.3
        with:
          app-path: app.py
```

---

# 开始应用测试

Source: https://docs.streamlit.io/develop/concepts/app-testing/get-started


本指南将介绍一个简单的示例，说明测试在项目中的结构以及如何使用 `pytest` 执行它们。在了解了整体情况后，请继续阅读以了解[应用测试基础](#应用测试基础)：

- 初始化和运行模拟应用
- 检索元素
- 操作部件
- 检查结果

Streamlit 的应用测试框架不绑定到任何特定的测试工具，但我们将使用 `pytest` 作为示例，因为它是最常见的 Python 测试框架之一。要尝试本指南中的示例，请确保在开始之前将 `pytest` 安装到您的 Streamlit 开发环境中：

```bash
pip install pytest
```

## 使用 `pytest` 进行简单测试示例

本节解释了如何使用 `pytest` 构建和执行简单测试。有关 `pytest` 的全面介绍，请查看 Real Python 的 [Effective Python testing with pytest](https://realpython.com/pytest-python-testing/) 指南。

### `pytest` 的结构

`pytest` 使用文件和函数的命名约定来方便地执行测试。将测试脚本命名为 `test_<name>.py` 或 `<name>_test.py` 形式。例如，您可以使用 `test_myapp.py` 或 `myapp_test.py`。在您的测试脚本中，每个测试都写成一个函数。每个函数的名称以 `test` 开头或结尾。在本指南的示例中，我们将所有测试脚本和测试函数都以前缀 `test_` 开头。

您可以在单个测试脚本中编写任意数量的测试（函数）。当在目录中调用 `pytest` 时，其中的所有 `test_<name>.py` 文件都将用于测试。这包括子目录中的文件。这些文件中的每个 `test_<something>` 函数都将作为测试执行。您可以将测试文件放在项目目录中的任何位置，但通常会将测试收集到一个专门的 `tests/` 目录中。有关结构化和执行测试的其他方法，请查看 `pytest` 文档中的 [How to invoke pytest](https://docs.pytest.org/how-to/usage.html)。

### 包含应用测试的示例项目

考虑以下项目：

```none
myproject/
├── app.py
└── tests/
    └── test_app.py
```

主应用文件：

```python
"""app.py"""
import streamlit as st

# 初始化 st.session_state.beans
st.session_state.beans = st.session_state.get("beans", 0)

st.title("豆子计数器 :paw_prints:")

addend = st.number_input("要添加的豆子", 0, 10)
if st.button("添加"):
    st.session_state.beans += addend
st.markdown(f"已计算的豆子: {st.session_state.beans}")
```

测试文件：

```python
"""test_app.py"""
from streamlit.testing.v1 import AppTest

def test_increment_and_add():
    """用户增加数字输入，然后点击添加"""
    at = AppTest.from_file("app.py").run()
    at.number_input[0].increment().run()
    at.button[0].click().run()
    assert at.markdown[0].value == "Beans counted: 1"
```

在运行之前，让我们快速了解一下此应用和测试中的内容。主应用文件 (`app.py`) 在渲染时包含四个元素：`st.title`、`st.number_input`、`st.button` 和 `st.markdown`。测试脚本 (`test_app.py`) 包含单个测试（名为 `test_increment_and_add` 的函数）。我们将在本指南的后半部分详细介绍测试语法，但这里是对此测试的简要说明：

1. 初始化模拟应用并执行第一次脚本运行。
   ```python
   at = AppTest.from_file("app.py").run()
   ```
2. 模拟用户点击加号图标 (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;add</i>) 来增加数字输入（以及由此产生的脚本重新运行）。
   ```python
   at.number_input[0].increment().run()
   ```
3. 模拟用户点击"**添加**"按钮（以及由此产生的脚本重新运行）。
   ```python
   at.button[0].click().run()
   ```
4. 检查是否在末尾显示了正确的消息。
   ```python
   assert at.markdown[0].value == "Beans counted: 1"
   ```

断言是测试的核心。当断言为真时，测试通过。当断言为假时，测试失败。一个测试可以有多个断言，但保持测试专注是好习惯。当测试专注于单一行为时，更容易理解和响应失败。

### 使用 `pytest` 尝试简单测试

1. 将上面的文件复制到新的 "myproject" 目录中。
2. 打开终端并切换到您的项目目录。
   ```bash
   cd myproject
   ```
3. 执行 `pytest`:
   ```bash
   pytest
   ```

测试应该成功执行。您的终端应该显示如下内容：

![使用 pytest 成功完成的测试](/images/app-testing-pytest-intro.png)

通过在项目目录的根目录执行 `pytest`，所有带有测试前缀的 Python 文件（`test_<name>.py`）将被扫描以查找测试函数。在每个测试文件中，每个带有测试前缀的函数都将作为测试执行。`pytest` 然后计算成功次数并列出失败项。您也可以指导 `pytest` 仅扫描您的测试目录。例如，从项目目录的根目录执行：

```bash
pytest tests/
```

### 使用 `pytest` 处理文件路径和导入

测试脚本中的导入和路径应相对于调用 `pytest` 的目录。这就是为什么测试函数使用路径 `app.py` 而不是 `../app.py`，即使应用文件比测试脚本高一级目录。您通常会在包含主应用文件的目录中调用 `pytest`。这通常是项目目录的根目录。

另外，如果在您调用 `pytest` 的目录中存在 `.streamlit/`，其中的任何 `config.toml` 和 `secrets.toml` 都可供您的模拟应用访问。例如，您的模拟应用将能够访问此常见设置中的 `config.toml` 和 `secrets.toml` 文件：

项目结构：

```none
myproject/
├── .streamlit/
│   ├── config.toml
│   └── secrets.toml
├── app.py
└── tests/
    └── test_app.py
```

在 `test_app.py` 中的初始化：

```python
# 应用文件路径相对于 myproject/
at = AppTest.from_file("app.py").run()
```

执行测试的命令：

```bash
cd myproject
pytest tests/
```

## 应用测试基础

现在您了解了 `pytest` 的基础知识，让我们深入了解使用 Streamlit 的应用测试框架。每个测试都始于初始化和运行您的模拟应用。使用其他命令来检索、操作和检查元素。

在下一页，我们将[超越基础](/develop/concepts/app-testing/beyond-the-basics)并涵盖更高级的场景，如使用 secrets、会话状态或多功能页面应用。

### 如何初始化和运行模拟应用

要测试 Streamlit 应用，您必须首先使用应用一个页面的代码初始化 [`AppTest`](/develop/api-reference/app-testing/st.testing.v1.apptest) 的实例。有三种初始化模拟应用的方法。这些作为类方法提供给 `AppTest`。我们将重点关注 `AppTest.from_file()`，它允许您提供应用页面的路径。这是在应用开发期间构建自动测试的最常见场景。`AppTest.from_string()` 和 `AppTest.from_function()` 可能对某些简单或实验性场景有帮助。

让我们继续[上面的示例](#包含应用测试的示例项目)。

回想测试文件：

```python
"""test_app.py"""
from streamlit.testing.v1 import AppTest

def test_increment_and_add():
    """用户增加数字输入，然后点击添加"""
    at = AppTest.from_file("app.py").run()
    at.number_input[0].increment().run()
    at.button[0].click().run()
    assert at.markdown[0].value == "Beans counted: 1"
```

查看测试函数中的第一行：

```python
at = AppTest.from_file("app.py").run()
```

这正在做两件事，等效于：

```python
# 初始化应用。
at = AppTest.from_file("app.py")
# 运行应用。
at.run()
```

`AppTest.from_file()` 返回一个 `AppTest` 实例，用 `app.py` 的内容初始化。`.run()` 方法用于首次运行应用。查看测试，注意 `.run()` 方法手动执行每次脚本运行。测试必须显式运行应用每次。这适用于应用的首次运行和任何因模拟用户输入而导致的重新运行。

### 如何检索元素

`AppTest` 类的属性返回元素序列。元素按渲染应用中的显示顺序排序。可以通过索引检索特定元素。此外，具有键的部件可以通过键检索。

#### 按索引检索元素

`AppTest` 的每个属性都返回关联元素类型的序列。可以通过索引检索特定元素。在上面的示例中，`at.number_input` 返回应用中所有 `st.number_input` 元素的序列。因此，`at.number_input[0]` 是应用中的第一个此类元素。同样，`at.markdown` 返回所有 `st.markdown` 元素的集合，其中 `at.markdown[0]` 是第一个此类元素。

查看 [`AppTest`](/develop/api-reference/app-testing/st.testing.v1.apptest) 类或[应用测试速查表](/develop/concepts/app-testing/cheat-sheet)的"属性"部分中支持的元素的当前列表。您也可以使用 `.get()` 方法并传递属性名称。`at.get("number_input")` 和 `at.get("markdown")` 分别等效于 `at.number_input` 和 `at.markdown`。

返回的元素序列按页面上的外观顺序排列。如果使用容器以不同顺序插入元素，这些序列可能与代码中的顺序不匹配。考虑以下使用容器在页面上切换两个按钮顺序的示例：

```python
import streamlit as st

first = st.container()
second = st.container()

second.button("A")
first.button("B")
```

如果测试上述应用，第一个按钮（`at.button[0]`）将标记为"B"，第二个按钮（`at.button[1]`）将标记为"A"。作为真实断言，这些将是：

```python
assert at.button[0].label == "B"
assert at.button[1].label == "A"
```

#### 按键检索部件

您可以按其键而非页面上的顺序检索带键的部件。部件的键作为参数或关键字参数传递。例如，查看此应用和以下（真实的）断言：

```python
import streamlit as st

st.button("下一步", key="submit")
st.button("返回", key="cancel")
```

```python
assert at.button(key="submit").label == "下一步"
assert at.button("cancel").label == "返回"
```

#### 检索容器

您还可以通过检索特定容器来缩小元素序列。每个检索到的容器具有与 `AppTest` 相同的属性。例如，`at.sidebar.checkbox` 返回侧边栏中所有复选框的序列。`at.main.selectbox` 返回应用主体中所有选择框的序列（不在侧边栏中）。

对于 `AppTest.columns` 和 `AppTest.tabs`，返回容器序列。因此 `at.columns[0].button` 将是应用中第一个列中所有按钮的序列。

### 如何操作部件

所有部件都有一个通用的 `.set_value()` 方法。此外，许多部件有特定的方法来操作它们的值。[测试元素类](/develop/api-reference/app-testing/testing-element-classes) 的名称与 `AppTest` 属性的名称紧密匹配。例如，查看 [`AppTest.button`](/develop/api-reference/app-testing/st.testing.v1.apptest#apptestbutton) 的返回类型以查看相应的 [`Button`](/develop/api-reference/app-testing/testing-element-classes#sttestingv1element_treebutton) 类。除了使用 `.set_value()` 设置按钮的值外，您还可以使用 `.click()`。查看每个测试元素类以了解其特定方法。

### 如何检查元素

所有元素（包括部件）都有一个通用的 `.value` 属性。这返回元素的内容。对于部件，这与会话状态中的返回值或值相同。对于非输入元素，这将是主要内容参数的值。例如，`.value` 返回 `st.markdown` 或 `st.error` 的 `body` 值。它返回 `st.dataframe` 或 `st.table` 的 `data` 值。

此外，您可以检查部件的许多其他详细信息，如标签或禁用状态。有许多参数可用于检查，但并非全部。使用 linting 软件查看当前支持的内容。这是一个示例：

```python
import streamlit as st

st.selectbox("A", [1,2,3], None, help="选择一个数字", placeholder="选择我")
```

```python
assert at.selectbox[0].value == None
assert at.selectbox[0].label == "A"
assert at.selectbox[0].options == ["1","2","3"]
assert at.selectbox[0].index == None
assert at.selectbox[0].help == "选择一个数字"
assert at.selectbox[0].placeholder == "选择我"
assert at.selectbox[0].disabled == False
```

<Tip>

请注意，`st.selectbox` 的 `options` 被声明为整数，但断言为字符串。如 [`st.selectbox`](/develop/api-reference/widgets/st.selectbox) 文档中所述，选项在内部转换为字符串。如果您发现自己得到意外结果，请仔细检查文档中有关内部类型转换的任何注释。
</Tip></name></something></name></name></name>

---

# 使用 Streamlit 的执行模型

Source: https://docs.streamlit.io/develop/concepts/architecture


<TileContainer layout="list">
<RefCard href="/develop/concepts/architecture/run-your-app">
<h5>运行你的应用</h5>

了解如何启动你的 Streamlit 应用。

</RefCard>
<RefCard href="/develop/concepts/architecture/architecture">
<h5>Streamlit 的架构</h5>

了解 Streamlit 的客户端-服务器架构和相关考虑。

</RefCard>
<RefCard href="/develop/concepts/architecture/app-chrome">
<h5>应用 chrome</h5>

每个 Streamlit 应用的右上角都有一些小部件，以在你开发应用时帮助你，并在用户查看你的应用时帮助用户。这称为应用 chrome。

</RefCard>
<RefCard href="/develop/concepts/architecture/caching">
<h5>缓存</h5>

通过缓存结果以避免每次重新运行时进行不必要的重新计算，使你的应用性能更好。

</RefCard>
<RefCard href="/develop/concepts/architecture/session-state">
<h5>会话状态</h5>

使用会话状态管理你的应用的状态性。

</RefCard>
<RefCard href="/develop/concepts/architecture/forms">
<h5>表单</h5>

使用表单隔离用户输入并防止不必要的应用重新运行。

</RefCard>
<RefCard href="/develop/concepts/architecture/widget-behavior">
<h5>小部件行为</h5>

详细了解小部件如何工作。

</RefCard>
</TileContainer>

---

# 应用 chrome

Source: https://docs.streamlit.io/develop/concepts/architecture/app-chrome


你的 Streamlit 应用在右上角有一些小部件，可以在你开发时帮助你。这些小部件也可以在你的观看者使用你的应用时帮助他们。我们称这些东西为"应用 chrome"。chrome 包括一个状态区域、工具栏和应用菜单。

你的应用菜单是可配置的。默认情况下，当在本地查看应用或在 Streamlit Community Cloud 上查看并以具有管理员访问权限的帐户登录时，你可以从应用菜单访问开发者选项。查看应用时，点击右上角的图标来访问菜单。

![应用菜单](/images/app-menu/app-menu-developer.png)

## 菜单选项

菜单分为两个部分。上部分包含对所有观看者都可用的选项，下部分包含开发者的选项。在此页面的末尾了解有关[自定义此菜单](#customize-the-menu)的更多信息。

### 重新运行

你可以通过从应用菜单中点击"**重新运行**"来手动触发应用的重新运行。此重新运行不会重置你的会话。你的小部件状态和存储在 [`st.session_state`](/develop/concepts/architecture/session-state) 中的值将被保留。作为快捷方式，不打开应用菜单，你可以通过按键盘上的"**R**"来重新运行你的应用（如果你当前未专注于输入元素）。

### 设置

使用"**设置**"选项，你可以控制应用运行时的外观。如果在本地查看应用，你可以设置应用如何响应源代码的更改。请参阅[基本概念](/get-started/fundamentals/main-concepts#development-flow)中有关开发流的更多信息。你也可以强制你的应用以宽模式显示，即使未在使用 [`st.set_page_config`](/develop/api-reference/configuration/st.set_page_config) 的脚本中设置。

#### 主题设置

从应用菜单中点击"**设置**"后，你可以为应用的基础主题选择"**浅色**"、"**深色**"或"**使用系统设置**"。点击"**编辑活动主题**"来逐个修改主题颜色。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Settings" src="/images/app-menu/app-menu-settings-modal.png"/>
</div>
<br/>
<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Theme" src="/images/app-menu/app-menu-settings-theme.png"/>
</div>

### 打印

点击"**打印**"或使用键盘快捷键（`⌘+P` 或 `Ctrl+P`）打开打印对话框。此选项使用你浏览器的内置打印为 PDF 功能。要修改打印的外观，你可以执行以下操作：

- 在打印前展开或折叠侧边栏，分别将其包括或排除在打印中。
- 通过点击和拖动其右边框，在你的应用中调整侧边栏的大小以实现你想要的宽度。
- 如果在深色模式下打印，你可能需要在打印对话框中启用"**背景图形**"。
- 你可能需要在[设置](#settings)中禁用宽模式或调整打印缩放以防止元素裁剪出页面。

### 录制截屏

你可以直接从应用中轻松录制屏幕！最新版本的 Chrome、Edge 和 Firefox 支持屏幕录制。确保你的浏览器是最新的以兼容。根据你的当前设置，你可能需要授予浏览器权限来录制你的屏幕或使用你的麦克风来录制旁白。

1. 查看你的应用时，从右上角打开应用菜单。
2. 点击"**录制截屏**"。
3. 如果你想通过麦克风录制音频，请检查"**也录制音频**"。
4. 点击"**开始录制**"。（你的操作系统可能会提示你的浏览器来录制你的屏幕或使用你的麦克风。）

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record-2.png"/>
</div>

5. 从列出的选项中选择要录制的选项卡、窗口或监视器。界面将根据你的浏览器而有所不同。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record-3.png"/>
</div>

6. 点击"**分享**"。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record-4.png"/>
</div>

7. 录制时，你会在应用的标签页和应用菜单图标上看到红色圆圈。如果你想取消录制，请在应用的底部点击"**停止分享**"。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record-5.png"/>
</div>

8. 完成录制后，在键盘上按"**Esc**"或从你的应用菜单中点击"**停止录制**"。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record-6.png"/>
</div>

9. 按照你浏览器的说明保存你的录制。你保存的录制将在你的浏览器保存下载的地方。

整个过程如下所示：

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Record" src="/images/app-menu/app-menu-record.gif"/>
</div>

### 关于

你可以方便地从"**关于**"选项中检查正在运行的 Streamlit 版本。开发者也可以选择使用 [`st.set_page_config`](/develop/api-reference/configuration/st.set_page_config) 自定义此处显示的消息。

## 开发者选项

默认情况下，开发者选项仅在本地查看应用时或在 Streamlit Community Cloud 应用上查看时以管理员权限登录时显示。如果你想为所有用户提供这些选项，你可以[自定义菜单](#customize-the-menu)。

### 清除缓存

通过从应用的菜单中点击"**清除缓存**"或在不专注于输入元素时在键盘上按"**C**"来重置应用的缓存。这将删除 [`@st.cache_data`](/develop/api-reference/caching-and-state/st.cache_data) 和 [`@st.cache_resource`](/develop/api-reference/caching-and-state/st.cache_resource) 的所有缓存条目。

### 部署此应用

如果你在 git 仓库中本地运行应用，你可以通过几次简单点击将应用部署到 Streamlit Community Cloud！在开始之前，请确保你的工作已推送到在线 GitHub 仓库。为了获得最大的便利，请确保你已经创建了[社区云帐户](/deploy/streamlit-community-cloud/get-started/create-your-account)并已登录。

1. 点击应用菜单图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>）旁边的"**部署**"。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Settings" src="/images/app-menu/app-menu-deploy.png"/>
</div>

2. 点击"**立即部署**"。

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Settings" src="/images/app-menu/app-menu-deploy-1.png"/>
</div>

3. 你将被带到 Community Cloud 的"部署应用"页面。你的应用的仓库、分支和文件名将被预填充以匹配你的当前应用！了解更多关于在 Streamlit Community Cloud 上[部署应用](/deploy/streamlit-community-cloud/deploy-your-app)的信息。

整个过程如下所示：

<div>{{ maxWidth: '90%', margin: '0 2em 0 2em' }}&gt;
    <Image alt="Settings" src="/images/app-menu/deploy-from-local.gif"/>
</div>

## 自定义菜单

使用你应用的[配置](/develop/concepts/configuration)中的 `client.toolbarMode`，你可以使应用菜单以以下方式显示：

- `"developer"`  向所有观看者显示开发者选项。
- `"viewer"`  隐藏所有观看者的开发者选项。
- `"minimal"`  仅显示在外部设置的那些选项。这些选项可以通过 [`st.set_page_config`](/develop/api-reference/configuration/st.set_page_config) 声明或通过 Streamlit Community Cloud 填充。
- `"auto"`  这是默认设置，当通过 localhost 访问或通过 Streamlit Community Cloud 访问应用的管理员帐户登录时，将显示开发者选项。否则，开发者选项将不显示。

---

# 理解 Streamlit 的客户端-服务器架构

Source: https://docs.streamlit.io/develop/concepts/architecture/architecture


Streamlit 应用有一个客户端-服务器结构。你的应用的 Python 后端是服务器。你通过浏览器查看的前端是客户端。当你在本地开发应用时，你的计算机同时运行服务器和客户端。如果有人通过本地或全球网络查看你的应用，服务器和客户端会在不同的机器上运行。如果你打算共享或部署你的应用，理解这个客户端-服务器结构很重要，以避免常见的陷阱。

## Python 后端（服务器）

当你执行命令 `streamlit run your_app.py` 时，你的计算机使用 Python 启动一个 Streamlit 服务器。这个服务器是你的应用的大脑，并为查看你的应用的所有用户执行计算。无论用户是通过本地网络还是互联网查看你的应用，Streamlit 服务器都在初始化该应用的 `streamlit run` 的那台机器上运行。运行你的 Streamlit 服务器的机器也称为主机。

## 浏览器前端（客户端）

当有人通过浏览器查看你的应用时，他们的设备是一个 Streamlit 客户端。当你从运行或开发应用的同一台计算机查看应用时，服务器和客户端恰好在同一台机器上运行。但是，当用户通过本地网络或互联网查看你的应用时，客户端在与服务器不同的机器上运行。

## 服务器-客户端对应用设计的影响

构建 Streamlit 应用时，请记住以下考虑事项：

- 运行或托管你的 Streamlit 应用的计算机负责为所有用户提供必要的计算和存储来运行你的应用，并必须大小恰当以处理并发用户。
- 你的应用将无法访问用户的文件、目录或操作系统。你的应用只能使用用户通过小部件（如 `st.file_uploader`）上传到你的应用的特定文件。
- 如果你的应用与任何外设（如摄像头）通信，你必须使用 Streamlit 命令或自定义组件，这些命令或组件将通过用户的浏览器访问这些设备，并在客户端（前端）和服务器（后端）之间正确通信。
- 如果你的应用打开或使用 Python 之外的任何程序或过程，它们将在服务器上运行。例如，你可能想使用 `webrowser` 为用户打开浏览器，但当你通过网络查看应用时，这不会按预期工作；它将在 Streamlit 服务器上打开浏览器，对用户不可见。
- 如果你在部署中使用负载均衡或复制，某些 Streamlit 功能在没有会话关联或粘性的情况下将无法工作。有关更多信息，请继续阅读。

## WebSocket 和会话管理

虽然大多数 Streamlit 应用开发者不需要直接与 WebSocket 交互，但理解它们的角色对于高级部署、自定义组件或大规模管理连接很重要。

Streamlit 的服务器建立在 Tornado Web 框架之上，该框架使用 WebSocket 来维持客户端和服务器之间的持久、双向通信通道。这种持久连接允许服务器将实时更新推送到客户端并为每个用户维持会话上下文。每个浏览器选项卡或窗口都创建自己的 WebSocket 连接，导致应用中的单独会话。

在大规模或生产部署中，负载均衡和服务器复制很常见。但是，Streamlit 处理会话和本地（服务器）文件的方式需要在这些环境中特别考虑。当客户端通过 HTTP 请求媒体（如图像或音频文件）时，该请求中没有附加会话上下文。在多个服务器副本或负载均衡器的部署中，媒体文件的 HTTP 请求可能被路由到与处理用户 WebSocket 连接和会话信息的服务器不同的服务器。如果媒体文件在所有副本上都不可用，你可能会遇到错误，如 `MediaFileStorageError: Bad filename`。任何允许用户上传文件的命令也可能受到影响，可能会引发 HTTP 状态代码 400。

### 会话关联或粘性

通常，你可以执行以下操作之一来解决或减少这个限制：

- 在你的代理中启用会话关联（也称为粘性）。这确保了用户会话中的所有请求都由同一服务器实例处理。
- 在将媒体传递给 Streamlit 命令之前，将媒体转换为 Base64 编码的数据 URI。这通过 WebSocket 而不是通过 HTTP 请求访问的 Streamlit 媒体存储来传递媒体数据。
- 将动态生成的文件保存到服务器副本之外的稳定位置（例如 S3 存储），并将外部 URL 传递给 Streamlit 命令。这避免了 Streamlit 的媒体存储。

启用会话关联是一个一般解决方案，可以解决媒体文件和上传文件的限制。有关配置详细信息，请咨询你的部署平台的文档。

使用 Base64 编码的数据 URI 或外部文件存储可以直接解决媒体文件的限制，但不是解决文件上传限制的完整解决方案。有关更多信息，请参阅 GitHub 问题 [#4173](https://github.com/streamlit/streamlit/issues/4173)。

---

# 缓存概述

Source: https://docs.streamlit.io/develop/concepts/architecture/caching


Streamlit 在每次用户交互或代码更改时都会从头到尾运行您的脚本。这种执行模型使得开发变得非常简单。但它带来了两个主要挑战：

1. 长时间运行的函数一遍又一遍地运行，这减慢了您的应用。
2. 对象一次又一次地重新创建，这使得在重新运行或会话之间保持它们变得困难。

但是不用担心！Streamlit 让您使用其内置的缓存机制解决这两个问题。缓存存储缓慢函数调用的结果，因此它们只需要运行一次。这使您的应用更快，并有助于在重新运行之间持久化对象。缓存值可供应用的所有用户使用。如果您需要保存只能在会话内访问的结果，请改用 [会话状态](/develop/concepts/architecture/session-state)。

<Collapse title="目录">{true}&gt;

1. [最小示例](#最小示例)
2. [基本用法](#基本用法)
3. [高级用法](#高级用法)
4. [从 st.cache 迁移](#从-stcache-迁移)

</Collapse>

## 最小示例

要在 Streamlit 中缓存函数，您必须使用两个装饰器之一（[st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 或 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)）装饰它：

```python
@st.cache_data
def long_running_function(param1, param2):
    return …
```

在此示例中，用 `@st.cache_data` 装饰 `long_running_function` 告诉 Streamlit，每当调用该函数时，它会检查两件事：

1. 输入参数的值（在此情况下为 `param1` 和 `param2`）。
2. 函数内部的代码。

如果这是 Streamlit 第一次看到这些参数值和函数代码，它会运行该函数并将返回值存储在缓存中。下次使用相同参数和代码调用该函数时（例如，当用户与应用交互时），Streamlit 将完全跳过执行该函数并返回缓存值。在开发过程中，缓存随着函数代码的变化自动更新，确保最新的更改反映在缓存中。

如前所述，有两个缓存装饰器：

- `st.cache_data` 是缓存返回数据的计算的推荐方法：从 CSV 加载 DataFrame，转换 NumPy 数组，查询 API，或任何其他返回可序列化数据对象（str、int、float、DataFrame、数组、列表等）的函数。它在每次函数调用时创建数据的新副本，使其能够防止[变异和竞态条件](#变异和并发问题)。`st.cache_data` 的行为就是您大多数情况下想要的——所以如果您不确定，请从 `st.cache_data` 开始，看看是否有效！
- `st.cache_resource` 是缓存全局资源（如 ML 模型或数据库连接）的推荐方法——不可序列化的对象，您不想多次加载。使用它，您可以在应用的所有重新运行和会话中共享这些资源，而无需复制或重复。请注意，对缓存返回值的任何更改都会直接影响缓存中的对象（详情见下文）。

<Image alt="Streamlit 的两个缓存装饰器及其用例。对任何可以存储在数据库中的内容使用 st.cache_data。对无法存储在数据库中的内容使用 st.cache_resource，比如数据库连接或机器学习模型。" caption="Streamlit 的两个缓存装饰器及其用例。" src="/images/caching-high-level-diagram.png"/>

## 基本用法

### st.cache_data

[st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 是所有返回数据的函数的首选命令——无论是 DataFrames、NumPy 数组、str、int、float 还是其他可序列化类型。几乎在所有用例中都是正确的命令！在每个用户会话中，用 `@st.cache_data` 装饰的函数返回缓存返回值的 _副本_（如果值已被缓存）。

#### 用法

<br/>

让我们来看一个使用 `st.cache_data` 的示例。假设您的应用从互联网将 [Uber 乘车共享数据集](https://github.com/plotly/datasets/blob/master/uber-rides-data1.csv) —— 一个 50MB 的 CSV 文件 —— 加载到 DataFrame 中：

```python
def load_data(url):
    df = pd.read_csv(url)  # 👈 下载数据
    return df

df = load_data("https://github.com/plotly/datasets/raw/master/uber-rides-data1.csv")
st.dataframe(df)

st.button("Rerun")
```

运行 `load_data` 函数需要 2 到 30 秒，具体取决于您的网络连接。（提示：如果您网络较慢，请改用 [这个 5MB 数据集](https://github.com/plotly/datasets/blob/master/26k-consumer-complaints.csv)）。如果不使用缓存，每次加载应用或用户交互时都会重新运行下载。自己试试点击我们添加的按钮！不太好的体验… 😕

现在让我们在 `load_data` 上添加 `@st.cache_data` 装饰器：

```
@st.cache_data  # 👈 添加缓存装饰器
def load_data(url):
    df = pd.read_csv(url)
    return df

df = load_data("https://github.com/plotly/datasets/raw/master/uber-rides-data1.csv")
st.dataframe(df)

st.button("Rerun")
```

再次运行应用。您会注意到缓慢的下载只在第一次运行时发生。每个后续重新运行应该几乎是瞬间的！ 💨

#### 行为

<br/>

这是如何工作的？让我们逐步深入了解 `st.cache_data` 的行为：

- 在第一次运行时，Streamlit 识别到它从未使用指定的参数值（CSV 文件的 URL）调用过 `load_data` 函数。所以它运行该函数并下载数据。
- 现在我们的缓存机制开始生效：返回的 DataFrame 通过 [pickle](https://docs.python.org/3/library/pickle.html) 序列化（转换为字节）并存储在缓存中（连同 `url` 参数的值）。
- 在下一次运行时，Streamlit 检查具有特定 `url` 的 `load_data` 的缓存条目。存在！所以它检索缓存的对象，反序列化为 DataFrame，并返回它而不是重新运行函数并再次下载数据。

序列化和反序列化缓存对象的这一过程创建了我们原始 DataFrame 的副本。虽然这种复制行为看起来可能是不必要的，但这正是我们在缓存数据对象时所期望的，因为它有效地防止了变异和并发问题。阅读下面的 "[变异和并发问题](#变异和并发问题)" 部分以更详细地了解这一点。

<Warning>

[st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 隐式使用 `pickle` 模块，众所周知它是不安全的。您的缓存函数返回的任何内容都被序列化并存储，然后在检索时反序列化。确保您的缓存函数返回可信的值，因为在反序列化期间可能构造恶意的 pickle 数据以执行任意代码。永远不要在不安全模式下加载可能来自不受信任来源的数据，或可能已被篡改的数据。**只加载您信任的数据**。

</Warning>

#### 示例

<br/>

**DataFrame 变换**

在上面的示例中，我们已经展示了如何缓存加载 DataFrame。缓存 DataFrame 变换（如 `df.filter`、`df.apply` 或 `df.sort_values`）也很有用。特别是对于大型 DataFrame，这些操作可能会很慢。

```python
@st.cache_data
def transform(df):
    df = df.filter(items=['one', 'three'])
    df = df.apply(np.sum, axis=0)
	return df
```

**数组计算**

同样，缓存 NumPy 数组上的计算是有意义的：

```python
@st.cache_data
def add(arr1, arr2):
	return arr1 + arr2
```

**数据库查询**

在使用数据库时，通常会对数据库进行 SQL 查询以将数据加载到您的应用中。反复运行这些查询可能很慢，花费金钱，并降低数据库的性能。我们强烈建议缓存应用中的任何数据库查询。另请参见 [我们关于将 Streamlit 连接到不同数据库的指南](/develop/tutorials/databases)，了解详细示例。

```python
connection = database.connect()

@st.cache_data
def query():
    return pd.read_sql_query("SELECT * from table", connection)
```

<Tip>

您应该设置 `ttl`（生存时间）以从数据库获取新结果。如果设置 `st.cache_data(ttl=3600)`，Streamlit 会在 1 小时（3600 秒）后使任何缓存值失效并重新运行缓存函数。详情请参见 [控制缓存大小和持续时间](#控制缓存大小和持续时间)。

</Tip>

**API 调用**

同样，缓存 API 调用是有意义的。这样做还可以避免速率限制。

```python
@st.cache_data
def api_call():
    response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
    return response.json()
```

**运行 ML 模型（推理）**

运行复杂的机器学习模型可能需要大量时间和内存。为了避免一遍又一遍地运行相同的计算，请使用缓存。

```python
@st.cache_data
def run_model(inputs):
    return model(inputs)
```

### st.cache_resource

[st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 是缓存应该在所有用户、会话和重新运行中全局可用的“资源”的正确命令。它的用例比 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 更有限，特别是用于缓存数据库连接和 ML 模型。在每个用户会话中，用 `@st.cache_resource` 装饰的函数返回返回值的缓存实例（如果值已被缓存）。因此，由 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 缓存的对象表现得像单例并可以改变。

#### 用法

作为 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 的示例，让我们看一个典型的机器学习应用。第一步，我们需要加载一个 ML 模型。我们使用 [Hugging Face 的 transformers 库](https://huggingface.co/docs/transformers/index)：

```python
from transformers import pipeline
model = pipeline("sentiment-analysis")  # 👈 加载模型
```

如果我们直接将此代码放入 Streamlit 应用中，应用将在每次重新运行或用户交互时加载模型。重复加载模型会带来两个问题：

- 加载模型需要时间并减慢应用。
- 每个会话都从头开始加载模型，这占用了大量内存。

相反，一次性加载模型并在所有用户和会话中使用同一个对象更有意义。这正是 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 的用例！让我们将其添加到我们的应用中并处理用户输入的一些文本：

```python
from transformers import pipeline

@st.cache_resource  # 👈 添加缓存装饰器
def load_model():
    return pipeline("sentiment-analysis")

model = load_model()

query = st.text_input("Your query", value="I love Streamlit! 🎈")
if query:
    result = model(query)[0]  # 👈 分类查询文本
    st.write(result)
```

如果运行此应用，您会看到应用只在一次调用 `load_model` —— 即应用启动时。后续运行将重用存储在缓存中的同一模型，节省时间和内存！

#### 行为

<br/>

使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 与使用 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 非常相似。但有一些重要的行为差异：

- [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) **不会** 创建缓存返回值的副本，而是将对象本身存储在缓存中。对该函数返回值的所有变更都会直接影响缓存中的对象，因此您必须确保多个会话的变更不会导致问题。简而言之，返回值必须是线程安全的。

    <Warning>

  对非线程安全对象使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 可能导致崩溃或损坏数据。在下方 [变异和并发问题](#变异和并发问题) 部分了解更多。
  </Warning>

- 不创建副本意味着只有一个全局缓存返回对象实例，这节省了内存，例如在使用大型 ML 模型时。在计算机科学术语中，我们创建了一个 [单例](https://en.wikipedia.org/wiki/Singleton_pattern)。
- 函数的返回值不需要是可序列化的。这种行为非常适合本质上不可序列化的类型，例如数据库连接、文件句柄或线程。使用 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 缓存这些对象是不可能的。

#### 示例

<br/>

**数据库连接**

[st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 对连接数据库很有用。通常，您正在创建一个连接对象，您希望在每个查询中全局重用它。在每次运行时创建新的连接对象效率低下，并可能导致连接错误。这正是 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 可以做到的，例如对于 Postgres 数据库：

```python
@st.cache_resource
def init_connection():
    host = "hh-pgsql-public.ebi.ac.uk"
    database = "pfmegrnargs"
    user = "reader"
    password = "NWDMCE5xdipIjRrp"
    return psycopg2.connect(host=host, database=database, user=user, password=password)

conn = init_connection()
```

当然，您也可以对任何其他数据库执行相同操作。查看 [我们关于如何将 Streamlit 连接到数据库的指南](/develop/tutorials/databases) 以获得详细的示例。

**加载 ML 模型**

您的应用应始终缓存 ML 模型，这样它们就不会在每次新会话中重新加载到内存中。有关此操作如何与 🤗 Hugging Face 模型一起工作的示例，请参见上面的[示例](#用法-1)。您可以对 PyTorch、TensorFlow 等执行相同操作。这里是 PyTorch 的示例：

```python
@st.cache_resource
def load_model():
    model = torchvision.models.resnet50(weights=ResNet50_Weights.DEFAULT)
    model.eval()
    return model

model = load_model()
```

### 决定使用哪个缓存装饰器

<br/>

上面的章节展示了每种缓存装饰器的许多常见示例。但对于边缘情况，决定使用哪种缓存装饰器并不那么简单。最终，这一切归结为"数据"和"资源"之间的区别：

- 数据是可序列化的对象（可通过 [pickle](https://docs.python.org/3/library/pickle.html) 转换为字节的对象）您可以轻松地将其保存到磁盘。想象一下您通常存储在数据库或文件系统中的所有类型——基本类型如 str、int 和 float，但也包括数组、DataFrames、图像或这些类型的组合（列表、元组、字典等）。
- 资源是不可序列化的对象，您通常不会将其保存到磁盘或数据库。它们通常是更复杂、非永久性的对象，如数据库连接、ML 模型、文件句柄、线程等。

从上面列出的类型来看，应该很明显 Python 中的大多数对象都是"数据"。这也是为什么 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 是几乎所有用例的正确命令。[st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 是一个更特殊的命令，您只应在特定情况下使用它。

或者如果您懒得思考太多，查看下表中的用例或返回类型 😉：

| 用例                                 |                                                                                                       典型返回类型 |                                                                                                                                            缓存装饰器 |
| :----------------------------------- | -------------------------------------------------------------------------------------------------------------------------: | -----------------------------------------------------------------------------------------------------------------------------------------------------------: |
| 使用 pd.read_csv 读取 CSV 文件 |                                                                                                           pandas.DataFrame |                                                                                                                                                st.cache_data |
| 读取文本文件                         |                                                                                                           str, list of str |                                                                                                                                                st.cache_data |
| 转换 pandas 数据框                 |                                                                                            pandas.DataFrame, pandas.Series |                                                                                                                                                st.cache_data |
| 使用 numpy 数组计算              |                                                                                                              numpy.ndarray |                                                                                                                                                st.cache_data |
| 使用基本类型进行简单计算             |                                                                                                         str, int, float, … |                                                                                                                                                st.cache_data |
| 查询数据库                           |                                                                                                           pandas.DataFrame |                                                                                                                                                st.cache_data |
| 查询 API                             |                                                                                                pandas.DataFrame, str, dict |                                                                                                                                                st.cache_data |
| 运行 ML 模型（推理）               |                                                                                     pandas.DataFrame, str, int, dict, list |                                                                                                                                                st.cache_data |
| 创建或处理图像                       |                                                                                             PIL.Image.Image, numpy.ndarray |                                                                                                                                                st.cache_data |
| 创建图表                             |                                                        matplotlib.figure.Figure, plotly.graph_objects.Figure, altair.Chart | st.cache_data（但有些库需要 st.cache_resource，因为图表对象不可序列化——确保不要在创建后修改图表！） |
| 惰性计算                             |                                                                                                           polars.LazyFrame |                                                                          st.cache_resource（但可能最好在收集结果上使用 st.cache_data） |
| 加载 ML 模型                         |                                                             transformers.Pipeline, torch.nn.Module, tensorflow.keras.Model |                                                                                                                                            st.cache_resource |
| 初始化数据库连接                     | pyodbc.Connection, sqlalchemy.engine.base.Engine, psycopg2.connection, mysql.connector.MySQLConnection, sqlite3.Connection |                                                                                                                                            st.cache_resource |
| 打开持久文件句柄                     |                                                                                                         \_io.TextIOWrapper |                                                                                                                                            st.cache_resource |
| 打开持久线程                         |                                                                                                           threading.thread |                                                                                                                                            st.cache_resource |

## 高级用法

### 控制缓存大小和持续时间

如果您的应用运行很长时间并不断缓存函数，您可能会遇到两个问题：

1. 应用因缓存太大而耗尽内存。
2. 缓存中的对象变得陈旧，例如，因为您缓存了来自数据库的旧数据。

您可以使用 `ttl` 和 `max_entries` 参数来解决这些问题，这些参数对于两个缓存装饰器都可用。

**`ttl`（生存时间）参数**

`ttl` 设置缓存函数的生存时间。如果时间到了并且您再次调用该函数，应用将丢弃任何旧的、缓存的值，并重新运行该函数。然后将新计算的值存储在缓存中。这种行为对于防止陈旧数据（问题 2）和缓存增长过大（问题 1）很有用。特别是从数据库或 API 拉取数据时，您应始终设置 `ttl`，以免使用旧数据。这是一个示例：

```python
@st.cache_data(ttl=3600)  # 👈 缓存数据 1 小时（=3600 秒）
def get_api_data():
    data = api.get(...)
    return data
```

<Tip>

您还可以使用 `timedelta` 设置 `ttl` 值，例如 `ttl=datetime.timedelta(hours=1)`。

</Tip>

**`max_entries` 参数**

`max_entries` 设置缓存中的最大条目数。限制缓存条目的上限对于限制内存（问题 1）很有用，特别是在缓存大对象时。当向满的缓存中添加新条目时，将删除最旧的条目。这是一个示例：

```python
@st.cache_data(max_entries=1000)  # 👈 缓存中最多 1000 个条目
def get_large_array(seed):
    np.random.seed(seed)
    arr = np.random.rand(100000)
    return arr
```

### 自定义加载动画

默认情况下，当缓存函数运行时，Streamlit 会在应用中显示一个小的加载动画。您可以使用 `show_spinner` 参数轻松修改它，该参数对于两个缓存装饰器都可用：

```python
@st.cache_data(show_spinner=False)  # 👈 禁用加载动画
def get_api_data():
    data = api.get(...)
    return data

@st.cache_data(show_spinner="从 API 获取数据...")  # 👈 使用自定义文本作为加载动画
def get_api_data():
    data = api.get(...)
    return data
```

### 排除输入参数

在缓存函数中，所有输入参数必须是可哈希的。让我们快速解释一下原因和含义。当调用函数时，Streamlit 会查看其参数值以确定之前是否已缓存。因此，它需要一种可靠的方法来比较跨函数调用的参数值。对于字符串或整数来说很简单——但对于任意对象就复杂了！Streamlit 使用 [哈希](https://en.wikipedia.org/wiki/Hash_function) 来解决这个问题。它将参数转换为稳定的键并存储该键。在下一次函数调用时，它再次对参数进行哈希处理并与存储的哈希键进行比较。

不幸的是，并非所有参数都是可哈希的！例如，您可能将不可哈希的数据库连接或 ML 模型传递给您的缓存函数。在这种情况下，您可以从缓存中排除输入参数。只需在参数名称前面加上下划线（例如，`_param1`），它就不会用于缓存。即使它改变了，如果所有其他参数匹配，Streamlit 也会返回缓存的结果。

这是一个示例：

```python
@st.cache_data
def fetch_data(_db_connection, num_rows):  # 👈 不对 _db_connection 进行哈希
    data = _db_connection.fetch(num_rows)
    return data

connection = init_connection()
fetch_data(connection, 10)
```

但是如果您想缓存一个接受不可哈希参数的函数呢？例如，您可能想缓存一个接受 ML 模型作为输入并返回该模型层名称的函数。由于模型是唯一的输入参数，您不能将其排除在缓存之外。在这种情况下，您可以使用 `hash_funcs` 参数为模型指定自定义哈希函数。

### `hash_funcs` 参数

如上所述，Streamlit 的缓存装饰器对输入参数和缓存函数的签名进行哈希处理，以确定该函数之前是否已运行并有返回值存储（"缓存命中"）或需要运行（"缓存未命中"）。Streamlit 的哈希实现无法哈希的输入参数可以通过在其名称前加下划线来忽略。但有两种罕见情况这是不可取的，即您想对 Streamlit 无法哈希的参数进行哈希：

1. 当 Streamlit 的哈希机制无法对参数进行哈希处理时，引发 `UnhashableParamError`。
2. 当您想覆盖参数的 Streamlit 默认哈希机制时。

让我们依次讨论这些情况的示例。

#### 示例 1：对自定义类进行哈希

Streamlit 不知道如何对自定义类进行哈希。如果您将自定义类传递给缓存函数，Streamlit 将引发 `UnhashableParamError`。例如，让我们定义一个自定义类 `MyCustomClass`，它接受一个初始整数分数。让我们还定义一个缓存函数 `multiply_score`，它将分数乘以倍数：

```python
import streamlit as st

class MyCustomClass:
    def __init__(self, initial_score: int):
        self.my_score = initial_score

@st.cache_data
def multiply_score(obj: MyCustomClass, multiplier: int) -&gt; int:
    return obj.my_score * multiplier

initial_score = st.number_input("输入初始分数", value=15)

score = MyCustomClass(initial_score)
multiplier = 2

st.write(multiply_score(score, multiplier))
```

如果您运行此应用，您会看到 Streamlit 引发了 `UnhashableParamError`，因为它不知道如何对 `MyCustomClass` 进行哈希：

```python
UnhashableParamError: Cannot hash argument 'obj' (of type __main__.MyCustomClass) in 'multiply_score'.
```

为了解决这个问题，我们可以使用 `hash_funcs` 参数告诉 Streamlit 如何对 `MyCustomClass` 进行哈希。我们通过将字典传递给 `hash_funcs` 来实现，该字典将参数名称映射到哈希函数。哈希函数的选择由开发人员决定。在这种情况下，让我们定义一个自定义哈希函数 `hash_func`，它将自定义类作为输入并返回分数。我们希望分数成为对象的唯一标识符，因此我们可以使用它来确定性地对对象进行哈希：

```python
import streamlit as st

class MyCustomClass:
    def __init__(self, initial_score: int):
        self.my_score = initial_score

def hash_func(obj: MyCustomClass) -&gt; int:
    return obj.my_score  # 或任何其他唯一标识对象的值

@st.cache_data(hash_funcs={MyCustomClass: hash_func})
def multiply_score(obj: MyCustomClass, multiplier: int) -&gt; int:
    return obj.my_score * multiplier

initial_score = st.number_input("输入初始分数", value=15)

score = MyCustomClass(initial_score)
multiplier = 2

st.write(multiply_score(score, multiplier))
```

现在如果您运行应用，您会看到 Streamlit 不再引发 `UnhashableParamError`，应用按预期运行。

现在让我们考虑 `multiply_score` 是 `MyCustomClass` 的属性并且我们想对整个对象进行哈希的情况：

```python
import streamlit as st

class MyCustomClass:
    def __init__(self, initial_score: int):
        self.my_score = initial_score

    @st.cache_data
    def multiply_score(self, multiplier: int) -&gt; int:
        return self.my_score * multiplier

initial_score = st.number_input("输入初始分数", value=15)

score = MyCustomClass(initial_score)
multiplier = 2

st.write(score.multiply_score(multiplier))
```

如果您运行此应用，您会看到 Streamlit 引发了 `UnhashableParamError`，因为它无法对参数 `'self' (of type __main__.MyCustomClass) in 'multiply_score'` 进行哈希。一个简单的解决方法是使用 Python 的 `hash()` 函数对对象进行哈希：

```python
import streamlit as st

class MyCustomClass:
    def __init__(self, initial_score: int):
        self.my_score = initial_score

    @st.cache_data(hash_funcs={"__main__.MyCustomClass": lambda x: hash(x.my_score)})
    def multiply_score(self, multiplier: int) -&gt; int:
        return self.my_score * multiplier

initial_score = st.number_input("输入初始分数", value=15)

score = MyCustomClass(initial_score)
multiplier = 2

st.write(score.multiply_score(multiplier))
```

以上，哈希函数定义为 `lambda x: hash(x.my_score)`。这基于 `MyCustomClass` 实例的 `my_score` 属性创建哈希。只要 `my_score` 保持不变，哈希也保持不变。因此，`multiply_score` 的结果可以从缓存中检索而无需重新计算。

作为一个敏锐的 Python 程序员，您可能曾想过使用 Python 的 `id()` 函数来对对象进行哈希，如下所示：

```python
import streamlit as st

class MyCustomClass:
    def __init__(self, initial_score: int):
        self.my_score = initial_score

    @st.cache_data(hash_funcs={"__main__.MyCustomClass": id})
    def multiply_score(self, multiplier: int) -&gt; int:
        return self.my_score * multiplier

initial_score = st.number_input("输入初始分数", value=15)

score = MyCustomClass(initial_score)
multiplier = 2

st.write(score.multiply_score(multiplier))
```

如果您运行应用，您会注意到即使 `my_score` 没有改变，Streamlit 也会每次都重新计算 `multiply_score`！困惑吗？在 Python 中，`id()` 返回对象的标识，在对象的生命周期内是唯一且不变的。这意味着即使两个 `MyCustomClass` 实例的 `my_score` 值相同，`id()` 也会为这两个实例返回不同的值，从而导致不同的哈希值。因此，Streamlit 认为这两个不同的实例需要单独的缓存值，因此即使 `my_score` 没有改变，它也会每次都重新计算 `multiply_score`。

这就是为什么我们不鼓励使用它作为哈希函数，而是鼓励返回确定性的真正哈希值的函数。也就是说，如果您知道自己在做什么，可以使用 `id()` 作为哈希函数。只需注意后果。例如，当您将 `@st.cache_resource` 函数的结果作为输入参数传递给另一个缓存函数时，`id` 通常是正确的哈希函数。有很多类型否则不可哈希的对象。

#### 示例 2：对 Pydantic 模型进行哈希

让我们考虑另一个例子，我们要对 Pydantic 模型进行哈希：

```python
import streamlit as st
from pydantic import BaseModel

class Person(BaseModel):
    name: str

@st.cache_data
def identity(person: Person):
    return person

person = identity(Person(name="Lee"))
st.write(f"这个人是 {person.name}")
```

以上，我们使用 Pydantic 的 `BaseModel` 定义了一个自定义类 `Person`，它有一个名为 name 的属性。我们还定义了一个 `identity` 函数，它接受一个 `Person` 实例作为参数并将其返回而不做修改。此函数旨在缓存结果，因此，如果多次使用相同的 `Person` 实例调用它，它不会重新计算而是返回缓存的实例。

然而，如果您运行应用，您会遇到 `UnhashableParamError: Cannot hash argument 'person' (of type __main__.Person) in 'identity'` 错误。这是因为 Streamlit 不知道如何对 `Person` 类进行哈希。为了解决这个问题，我们可以使用 `hash_funcs` 关键字参数告诉 Streamlit 如何对 `Person` 进行哈希。

在下面的版本中，我们定义了一个自定义哈希函数 `hash_func`，它将 `Person` 实例作为输入并返回 name 属性。我们希望 name 成为对象的唯一标识符，因此我们可以使用它来确定性地对对象进行哈希：

```python
import streamlit as st
from pydantic import BaseModel

class Person(BaseModel):
    name: str

@st.cache_data(hash_funcs={Person: lambda p: p.name})
def identity(person: Person):
    return person

person = identity(Person(name="Lee"))
st.write(f"这个人是 {person.name}")
```

#### 示例 3：对 ML 模型进行哈希

在某些情况下，您可能想将您最喜欢的机器学习模型传递给缓存函数。例如，假设您想基于用户在应用中选择的模型将 TensorFlow 模型传递给缓存函数。您可能尝试这样的操作：

```python
import streamlit as st
import tensorflow as tf

@st.cache_resource
def load_base_model(option):
    if option == 1:
        return tf.keras.applications.ResNet50(include_top=False, weights="imagenet")
    else:
        return tf.keras.applications.MobileNetV2(include_top=False, weights="imagenet")

@st.cache_resource
def load_layers(base_model):
    return [layer.name for layer in base_model.layers]

option = st.radio("模型 1 或 2", [1, 2])

base_model = load_base_model(option)

layers = load_layers(base_model)

st.write(layers)
```

在上述应用中，用户可以选择两个模型之一。基于选择，应用加载相应的模型并将其传递给 `load_layers`。然后此函数返回模型中的层名称。如果您运行应用，您会看到 Streamlit 引发了 `UnhashableParamError`，因为它无法对参数 `'base_model' (of type keras.engine.functional.Functional) in 'load_layers'` 进行哈希。

如果您通过在名称前加下划线来禁用对 `base_model` 的哈希，您会观察到无论选择哪个基础模型，显示的层都是一样的。这个微妙的错误是由于 `load_layers` 函数在基础模型更改时不重新运行。这是因为 Streamlit 不对 `base_model` 参数进行哈希，所以它不知道在基础模型更改时需要重新运行函数。

为了解决这个问题，我们可以使用 `hash_funcs` 关键字参数告诉 Streamlit 如何对 `base_model` 参数进行哈希。在下面的版本中，我们定义了一个自定义哈希函数 `hash_func`：`Functional: lambda x: x.name`。我们选择的哈希函数是基于我们知道 `Functional` 对象或模型的 `name` 属性唯一地标识它。只要 `name` 属性保持不变，哈希也保持不变。因此，`load_layers` 的结果可以从缓存中检索而无需重新计算。

```python
import streamlit as st
import tensorflow as tf
from keras.engine.functional import Functional

@st.cache_resource
def load_base_model(option):
    if option == 1:
        return tf.keras.applications.ResNet50(include_top=False, weights="imagenet")
    else:
        return tf.keras.applications.MobileNetV2(include_top=False, weights="imagenet")

@st.cache_resource(hash_funcs={Functional: lambda x: x.name})
def load_layers(base_model):
    return [layer.name for layer in base_model.layers]

option = st.radio("模型 1 或 2", [1, 2])

base_model = load_base_model(option)

layers = load_layers(base_model)

st.write(layers)
```

在上述情况下，我们也可以使用 `hash_funcs={Functional: id}` 作为哈希函数。这是因为当您将 `@st.cache_resource` 函数的结果作为输入参数传递给另一个缓存函数时，`id` 通常是正确的哈希函数。

#### 示例 4：覆盖 Streamlit 的默认哈希机制

让我们考虑另一个示例，我们想覆盖 Streamlit 对 pytz 本地化日期时间对象的默认哈希机制：

```python
from datetime import datetime
import pytz
import streamlit as st

tz = pytz.timezone("Europe/Berlin")

@st.cache_data
def load_data(dt):
    return dt

now = datetime.now()
st.text(load_data(dt=now))

now_tz = tz.localize(datetime.now())
st.text(load_data(dt=now_tz))
```

令人惊讶的是，尽管 `now` 和 `now_tz` 都属于 `<class>'datetime.datetime'&gt;` 类型，但 Streamlit 不知道如何对 `now_tz` 进行哈希，并引发了 `UnhashableParamError`。在这种情况下，我们可以通过将自定义哈希函数传递给 `hash_funcs` 关键字参数来覆盖 Streamlit 对 `datetime` 对象的默认哈希机制：

```python
from datetime import datetime

import pytz
import streamlit as st

tz = pytz.timezone("Europe/Berlin")

@st.cache_data(hash_funcs={datetime: lambda x: x.strftime("%a %d %b %Y, %I:%M%p")})
def load_data(dt):
    return dt

now = datetime.now()
st.text(load_data(dt=now))

now_tz = tz.localize(datetime.now())
st.text(load_data(dt=now_tz))
```

现在让我们考虑一个我们想覆盖 Streamlit 对 NumPy 数组默认哈希机制的情况。虽然 Streamlit 本地对 Pandas 和 NumPy 对象进行哈希，但在某些情况下，您可能想覆盖这些对象的 Streamlit 默认哈希机制。

例如，假设我们创建一个带缓存装饰的 `show_data` 函数，它接受一个 NumPy 数组并将其返回而不做修改。在下面的应用中，`data = df["str"].unique()`（这是一个 NumPy 数组）被传递给 `show_data` 函数。

```python
import time
import numpy as np
import pandas as pd
import streamlit as st

@st.cache_data
def get_data():
    df = pd.DataFrame({"num": [112, 112, 2, 3], "str": ["be", "a", "be", "c"]})
    return df

@st.cache_data
def show_data(data):
    time.sleep(2)  # 这使得函数运行 2 秒
    return data

df = get_data()
data = df["str"].unique()

st.dataframe(show_data(data))
st.button("Re-run")
```

由于 `data` 总是相同的，我们期望 `show_data` 函数返回缓存的值。但是，如果您运行应用并单击 `Re-run` 按钮，您会注意到 `show_data` 函数每次都重新运行。我们可以假设这种行为是 Streamlit 对 NumPy 数组的默认哈希机制的结果。

为了解决这个问题，让我们定义一个自定义哈希函数 `hash_func`，它接受一个 NumPy 数组作为输入并返回数组的字符串表示：

```python
import time
import numpy as np
import pandas as pd
import streamlit as st

@st.cache_data
def get_data():
    df = pd.DataFrame({"num": [112, 112, 2, 3], "str": ["be", "a", "be", "c"]})
    return df

@st.cache_data(hash_funcs={np.ndarray: str})
def show_data(data):
    time.sleep(2)  # 这使得函数运行 2 秒
    return data

df = get_data()
data = df["str"].unique()

st.dataframe(show_data(data))
st.button("Re-run")
```

现在如果您运行应用并单击 `Re-run` 按钮，您会注意到 `show_data` 函数不再每次都重新运行。这里需要注意的是，我们选择的哈希函数是非常简单的，不一定是最佳选择。例如，如果 NumPy 数组很大，将其转换为字符串表示可能代价高昂。在这种情况下，作为开发人员，您需要为您的用例定义一个好的哈希函数是什么。

#### 静态元素

从 1.16.0 版本开始，缓存函数可以包含 Streamlit 命令！例如，您可以这样做：

```python
@st.cache_data
def get_api_data():
    data = api.get(...)
    st.success("从 API 获取数据！")  # 👈 显示成功消息
    return data
```

正如我们所知，Streamlit 只有在之前未缓存过时才会运行此函数。在第一次运行时，`st.success` 消息将出现在应用中。但是在后续运行中会发生什么？它仍然会出现！Streamlit 意识到缓存函数内部有一个 `st.` 命令，在第一次运行时保存它，并在后续运行中重播它。静态元素重播适用于两个缓存装饰器。

您还可以使用此功能缓存整个 UI 部分：

```python
@st.cache_data
def show_data():
    st.header("数据分析")
    data = api.get(...)
    st.success("从 API 获取数据！")
    st.write("这是数据的图表：")
    st.line_chart(data)
    st.write("这是原始数据：")
    st.dataframe(data)
```

#### 输入小部件

您还可以在缓存函数中使用 [交互式输入小部件](/develop/api-reference/widgets) 如 `st.slider` 或 `st.text_input`。小部件重播目前是一个实验性功能。要启用它，您需要设置 `experimental_allow_widgets` 参数：

```python
@st.cache_data(experimental_allow_widgets=True)  # 👈 设置参数
def get_data():
    num_rows = st.slider("要获取的行数")  # 👈 添加滑块
    data = api.get(..., num_rows)
    return data
```

Streamlit 将滑块视为缓存函数的额外输入参数。如果更改滑块位置，Streamlit 将查看它是否已经为该滑块值缓存了函数。如果是，则返回缓存值。如果不是，则使用新的滑块值重新运行函数。

在缓存函数中使用小部件非常强大，因为它允许您缓存应用的整个部分。但这可能很危险！由于 Streamlit 将小部件值视为额外的输入参数，它很容易导致内存使用过多。想象一下，您的缓存函数有五个滑块并返回一个 100MB 的 DataFrame。然后对于这些五个滑块值的 _每个排列_，我们将向缓存添加 100MB——即使滑块不影响返回的数据！这些增加会使您的缓存迅速爆炸。如果您在缓存函数中使用小部件，请注意此限制。我们建议仅在 UI 的孤立部分使用此功能，其中小部件直接影响缓存的返回值。

<Warning>

对缓存函数中小部件的支持是实验性的。我们可能随时更改或删除它，恕不另行通知。请谨慎使用！
</Warning>
<Note>

目前两种小部件在缓存函数中不受支持：`st.file_uploader` 和 `st.camera_input`。我们将来可能会支持它们。如果您需要它们，请随时 [打开一个 GitHub 问题](https://github.com/streamlit/streamlit/issues)！
</Note>

### 处理大数据

如我们所解释的，您应该使用 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 缓存数据对象。但对于极其庞大的数据，例如超过一亿行的 DataFrames 或数组，这可能会很慢。这是因为 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 的[复制行为](#复制行为)：在第一次运行时，它将返回值序列化为字节，并在后续运行时反序列化。这两种操作都需要时间。

如果您正在处理极其庞大的数据，使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 可能更有意义。它不会通过序列化/反序列化创建返回值的副本，几乎是即时的。但要注意：对函数返回值的任何更改（如从 DataFrame 中删除列或在数组中设置值）都会直接操作缓存中的对象。您必须确保这不会损坏您的数据或导致崩溃。请参见下面的 [变异和并发问题](#变异和并发问题) 部分。

在对具有四列的 pandas DataFrames 上基准测试 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 时，我们发现当超过一亿行时它变得很慢。表格显示了不同行数下两种缓存装饰器的运行时间（所有都具有四列）：

|                   |                 | 10M 行 | 50M 行 | 100M 行 | 200M 行 |
| ----------------- | --------------- | :------: | :------: | :-------: | :-------: |
| st.cache_data     | 第一次运行\*     |  0.4 秒   |   3 秒    |   14 秒    |   28 秒    |
|                   | 后续运行 |  0.2 秒   |   1 秒    |    2 秒    |    7 秒    |
| st.cache_resource | 第一次运行\*     |  0.01 秒  |  0.1 秒   |   0.2 秒   |    1 秒    |
|                   | 后续运行 |   0 秒    |   0 秒    |    0 秒    |    0 秒    |

|                                                                                                                                                              |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _\*对于第一次运行，表格仅显示使用缓存装饰器的开销时间。它不包括缓存函数本身的运行时间。_ |

### 变异和并发问题

在上面的章节中，我们谈了很多关于变异缓存函数返回对象的问题。这个话题很复杂！但它对于理解 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 和 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 之间的行为差异至关重要。所以让我们更深入一点。

首先，我们应该明确定义变异和并发的含义：

- 通过 **变异**，我们指的是在调用函数 _之后_ 对缓存函数返回值所做的任何更改。例如：

  ```python
  @st.cache_data
  def create_list():
      l = [1, 2, 3]

  l = create_list()  # 👈 调用函数
  l[0] = 2  # 👈 变异其返回值
  ```

- 通过 **并发**，我们指的是多个会话可以同时引起这些变异。Streamlit 是一个 Web 框架，需要处理连接到应用的多个用户和会话。如果两个人同时查看应用，他们都会导致 Python 脚本重新运行，这可能同时操作缓存的返回对象——并发。

变异缓存的返回对象可能是危险的。它可能导致应用中的异常，甚至损坏您的数据（这可能比崩溃的应用更糟！）。下面，我们将首先解释 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 的复制行为，并展示它如何避免变异问题。然后，我们将展示并发变异如何导致数据损坏以及如何防止它。

#### 复制行为

[st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 在每次调用函数时都会创建缓存返回值的副本。这避免了大多数变异和并发问题。要详细了解，请回到上面 [st.cache_data 部分](#用法) 中的 [Uber 乘车共享示例](#用法)。我们对其进行了两项修改：

```python
@st.cache_data
def load_data(url):
    df = pd.read_csv(url)
    return df

df = load_data("...")  # 👈 df is a copy of the cached return value

# 👇 We drop the first row from the DataFrame!
first_row = df.iloc[0]
df.drop(df.index[0], inplace=True)

# The original cached object is not affected by this manipulation.
# Only the copy gets changed!
```

上面，我们操纵了从 `load_data` 返回的 DataFrame。这不会影响缓存中的原始对象，因为 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 创建了一个副本。即使我们对 `df` 进行了修改，也不会影响缓存中的原始对象。这确保了即使在多个会话中操纵数据也不会出现并发问题。我们称这种行为为"安全变异"，因为任何对返回对象的变异都不会影响缓存中的原始对象。

#### Mutations with st.cache_resource

与 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 不同，[st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) **不** 创建返回值的副本。相反，它返回原始对象本身。这意味着任何对返回值的变异都会直接影响缓存中的对象。让我们修改上面的示例以使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)：

```python
@st.cache_resource
def load_data(url):
    df = pd.read_csv(url)
    return df

df = load_data("...")  # 👈 df is the original cached object!

# 👇 We drop the first row from the DataFrame!
first_row = df.iloc[0]
df.drop(df.index[0], inplace=True)

# The original cached object IS affected by this manipulation!
# All sessions will see the modified DataFrame!
```

上面，我们操纵了从 `load_data` 返回的 DataFrame。由于我们使用了 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)，`df` 是缓存中的原始对象，而不是副本。当我们删除第一行时，我们实际上是在修改缓存中的原始对象。这会影响使用此缓存对象的所有会话！这可能会导致严重的问题，因为多个会话可能会同时修改同一个对象，从而导致数据损坏。

因此，只有在您确定变异是安全的情况下才使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)。例如，当缓存数据库连接或机器学习模型时，这些通常不会在应用代码中被修改。如果您确实需要变异使用 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 缓存的对象，请确保您的代码是线程安全的。

## 从 st.cache 迁移

在 Streamlit 1.18.0 之前，只有一个缓存命令：`st.cache`。它试图同时处理数据和资源缓存，导致行为不一致和意外问题。我们引入了 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 和 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 以明确区分这两种用例。`st.cache` 现在已弃用，将在未来版本中删除。

`st.cache` 的行为介于 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 和 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24) 之间，但偏向于 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)。因此，从 `st.cache` 迁移时：

- 如果您的缓存函数返回数据（如 DataFrame、numpy 数组、字典等），请迁移到 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)。
- 如果您的缓存函数返回资源（如数据库连接、ML 模型等），请迁移到 [st.cache_resource](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)。

<Tip>

如果您不确定要使用哪一个，请先尝试 [st.cache_data](file:///D:/github_st/docs/lib/purejs/versionHelpers.js#L3-L24)。它是最安全的选择，适用于大多数用例。

</Tip>

要自动将您的代码从 `st.cache` 迁移到新缓存命令，请使用 [我们的迁移脚本](https://gist.github.com/tvst/fe4d55c61e876905d7a84f237bfc9fec)。</class>

---

# 使用表单

Source: https://docs.streamlit.io/develop/concepts/architecture/forms


当您不希望在用户每次输入时都重新运行脚本时，[`st.form`](/develop/api-reference/execution-flow/st.form) 就派上用场了！表单可以轻松地将用户输入批量处理为单次重新运行。本使用表单指南提供了示例并解释了用户如何与表单交互。

## 示例

在以下示例中，用户可以设置多个参数以更新地图。当用户更改参数时，脚本不会重新运行，地图也不会更新。当用户点击标记为"**更新地图**"的按钮提交表单时，脚本重新运行，地图更新。

如果任何时候用户点击表单外部的"**生成新点**"，脚本将重新运行。如果用户在表单内有任何未提交的更改，这些更改将_不会_随重新运行发送。对表单的所有更改只有在表单本身提交时才会发送到 Python 后端。

<Collapse title="查看源代码">{false} &gt;

```python
import streamlit as st
import pandas as pd
import numpy as np

def get_data():
    df = pd.DataFrame({
        "lat": np.random.randn(200) / 50 + 37.76,
        "lon": np.random.randn(200) / 50 + -122.4,
        "team": ['A','B']*100
    })
    return df

if st.button('生成新点'):
    st.session_state.df = get_data()
if 'df' not in st.session_state:
    st.session_state.df = get_data()
df = st.session_state.df

with st.form("my_form"):
    header = st.columns([1,2,2])
    header[0].subheader('颜色')
    header[1].subheader('透明度')
    header[2].subheader('尺寸')

    row1 = st.columns([1,2,2])
    colorA = row1[0].color_picker('团队 A', '#0000FF')
    opacityA = row1[1].slider('A 透明度', 20, 100, 50, label_visibility='hidden')
    sizeA = row1[2].slider('A 尺寸', 50, 200, 100, step=10, label_visibility='hidden')

    row2 = st.columns([1,2,2])
    colorB = row2[0].color_picker('团队 B', '#FF0000')
    opacityB = row2[1].slider('B 透明度', 20, 100, 50, label_visibility='hidden')
    sizeB = row2[2].slider('B 尺寸', 50, 200, 100, step=10, label_visibility='hidden')

    st.form_submit_button('更新地图')

alphaA = int(opacityA*255/100)
alphaB = int(opacityB*255/100)

df['color'] = np.where(df.team=='A',colorA+f'{alphaA:02x}',colorB+f'{alphaB:02x}')
df['size'] = np.where(df.team=='A',sizeA, sizeB)

st.map(df, size='size', color='color')
```

</Collapse>
<Cloud height="800px" name="doc-forms-overview"/>

## 用户交互

如果小部件不在表单中，则当用户更改其值时，该小部件将触发脚本重新运行。对于具有键控输入的小部件（`st.number_input`、`st.text_input`、`st.text_area`），当用户点击或跳出小部件时，新值会触发重新运行。用户也可以在光标处于活动状态时按 `Enter` 来提交更改。

另一方面，如果小部件在表单内部，则当用户点击或跳出该小部件时，脚本不会重新运行。对于表单内的小部件，当提交表单时脚本将重新运行，表单内的所有小部件都将向 Python 后端发送其更新的值。

![表单](/images/forms.gif)

如果用户在接收键控输入的小部件中光标处于活动状态，用户可以使用键盘上的**Enter**键提交表单。在 `st.number_input` 和 `st.text_input` 中，用户按**Enter**键提交表单。在 `st.text_area` 中，用户按**Ctrl+Enter**/**⌘+Enter**提交表单。

![键盘提交表单](/images/form-submit-keyboard.png)

## 小部件值

在提交表单之前，表单内的所有小部件都将具有默认值，就像表单外的小部件具有默认值一样。

```python
import streamlit as st

with st.form("my_form"):
   st.write("在表单内部")
   my_number = st.slider('选择一个数字', 1, 10)
   my_color = st.selectbox('选择一个颜色', ['红色','橙色','绿色','蓝色','紫色'])
   st.form_submit_button('提交我的选择')

# 这是在表单外部
st.write(my_number)
st.write(my_color)
```

<Cloud height="450px" name="doc-forms-default"/>

## 表单是容器

当调用 `st.form` 时，前端会创建一个容器。您可以像处理其他[容器元素](/develop/api-reference/layout)一样写入该容器。也就是说，您可以使用 Python 的 `with` 语句，如上面示例所示，或者您可以将表单容器分配给一个变量并直接在其上调用方法。此外，您可以将 `st.form_submit_button` 放在表单容器中的任何位置。

```python
import streamlit as st

animal = st.form('my_animal')

# 这是直接写入主主体。由于表单容器
# 在上面定义，这将出现在表单中写入的所有内容下方。
sound = st.selectbox('声音像', ['喵','汪','吱','啾'])

# 这些方法调用在表单容器上，因此它们出现在表单内部。
submit = animal.form_submit_button(f'用{sound}说它!')
sentence = animal.text_input('您的句子:', '金枪鱼在哪？')
say_it = sentence.rstrip('.,!?') + f', {sound}!'
if submit:
    animal.subheader(say_it)
else:
    animal.subheader('')
```

<Cloud height="375px" name="doc-forms-container"/>

## 处理表单提交

表单的目的是覆盖 Streamlit 的默认行为，即用户进行更改时立即重新运行脚本。对于表单外的小部件，逻辑流程是：

1. 用户在前端更改小部件的值。
2. `st.session_state` 中小部件的值和 Python 后端（服务器）中的值被更新。
3. 脚本重新运行开始。
4. 如果小部件有回调，它作为页面重新运行的前缀执行。
5. 在重新运行期间执行更新的小部件函数时，它输出新值。

对于表单内的小部件，用户所做的任何更改（步骤1）在提交表单之前不会传递到 Python 后端（步骤2）。此外，表单内唯一可以有回调函数的小部件是 `st.form_submit_button`。如果您需要使用新提交的值执行进程，您有三种主要模式来执行。

### 在表单后执行进程

如果您需要作为表单提交的结果执行一次性进程，您可以将该进程条件设置为 `st.form_submit_button` 并在表单后执行它。如果您需要将进程结果显示在表单上方，您可以使用容器来控制表单相对于输出的位置。

```python
import streamlit as st

col1,col2 = st.columns([1,2])
col1.title('总和:')

with st.form('addition'):
    a = st.number_input('a')
    b = st.number_input('b')
    submit = st.form_submit_button('相加')

if submit:
    col2.title(f'{a+b:.2f}')
```

<Cloud height="400px" name="doc-forms-process1"/>

### 使用带有会话状态的回调

您可以使用回调在脚本重新运行前缀执行进程。

<Important>

在回调中处理新更新的值时，不要通过 `args` 或 `kwargs` 参数直接将这些值传递给回调。您需要为回调中使用的任何小部件分配一个键。如果您在回调主体中从 `st.session_state` 查找该小部件的值，您将能够访问新提交的值。请参见下面的示例。

</Important>

```python
import streamlit as st

if 'sum' not in st.session_state:
    st.session_state.sum = ''

def sum():
    result = st.session_state.a + st.session_state.b
    st.session_state.sum = result

col1,col2 = st.columns(2)
col1.title('总和:')
if isinstance(st.session_state.sum, float):
    col2.title(f'{st.session_state.sum:.2f}')

with st.form('addition'):
    st.number_input('a', key = 'a')
    st.number_input('b', key = 'b')
    st.form_submit_button('相加', on_click=sum)
```

<Cloud height="400px" name="doc-forms-process2"/>

### 使用 `st.rerun`

如果您的进程影响表单上方的内容，另一个替代方法是使用额外的重新运行。尽管如此，这可能效率较低，可能不如上述选项理想。

```python
import streamlit as st

if 'sum' not in st.session_state:
    st.session_state.sum = ''

col1,col2 = st.columns(2)
col1.title('总和:')
if isinstance(st.session_state.sum, float):
    col2.title(f'{st.session_state.sum:.2f}')

with st.form('addition'):
    a = st.number_input('a')
    b = st.number_input('b')
    submit = st.form_submit_button('相加')

# st.session_state.sum 的值在脚本重新运行结束时更新，
# 因此顶部 col2 中显示的值不会显示新的总和。在提交表单时触发
# 第二次重新运行以更新上方的值。
st.session_state.sum = a + b
if submit:
    st.rerun()
```

<Cloud height="400px" name="doc-forms-process3"/>

## 限制

- 每个表单必须包含一个 `st.form_submit_button`。
- `st.button` 和 `st.download_button` 不能添加到表单中。
- `st.form` 不能嵌套在另一个 `st.form` 中。
- 回调函数只能分配给表单内的 `st.form_submit_button`；表单中的其他小部件不能有回调。
- 表单内的相互依赖小部件不太可能特别有用。如果将 `widget1` 的值传递给 `widget2`，当它们都在表单内时，则 `widget2` 只有在提交表单时才会更新。

---

# 使用 fragments

Source: https://docs.streamlit.io/develop/concepts/architecture/fragments


重新运行是每个 Streamlit 应用的核心部分。当用户与小部件交互时，你的脚本从头到尾重新运行，你的应用的前端被更新。Streamlit 提供了几个功能来帮助你在这个执行模型中开发你的应用。Streamlit 版本 1.37.0 引入了 fragments 以允许重新运行代码的一部分而不是整个脚本。随着应用变得更大更复杂，这些 fragment 重新运行帮助你的应用高效和高性能。Fragments 给予你对应用执行流的更细致、易于理解的控制。

在阅读关于 fragments 的内容之前，我们建议对[缓存](/develop/concepts/architecture/caching)、[Session State](/concepts/architecture/session-state) 和[表单](/develop/concepts/architecture/forms)有基本的理解。

## Fragments 的用例

Fragments 是多用途的，适用于各种各样的情况。以下是一些常见的 fragments 有用的场景：

- 你的应用有多个可视化，每个都需要时间加载，但你有一个只更新其中一个的过滤输入。
- 你有一个动态表单，不需要更新应用的其余部分（直到表单完成）。
- 你想自动更新单个组件或一组组件来流式传输数据。

## 定义和调用 fragment

Streamlit 提供了一个装饰器（[`st.fragment`](/develop/api-reference/execution-flow/st.fragment)）来将任何函数转换为 fragment 函数。当你调用包含小部件函数的 fragment 函数时，用户会触发一个 _fragment 重新运行_ 而不是完整重新运行来与该 fragment 的小部件交互。在 fragment 重新运行期间，仅你的 fragment 函数被重新执行。fragment 主体内的任何内容都在前端更新，而你的应用的其余部分保持不变。我们稍后将描述跨多个容器编写的 fragments。

这是定义和调用 fragment 函数的基本示例。就像缓存一样，记住在定义函数后调用它。

```python
import streamlit as st

@st.fragment
def fragment_function():
    if st.button("Hi!"):
        st.write("Hi back!")

fragment_function()
```

如果你想让 fragment 的主体显示在侧边栏或另一个容器中，请在上下文管理器中调用你的 fragment 函数。

```python
with st.sidebar:
    fragment_function()
```

### Fragment 执行流

考虑以下代码及其下面的说明和图表。

```python
import streamlit as st

st.title("My Awesome App")

@st.fragment()
def toggle_and_text():
    cols = st.columns(2)
    cols[0].toggle("Toggle")
    cols[1].text_area("Enter text")

@st.fragment()
def filter_and_file():
    cols = st.columns(2)
    cols[0].checkbox("Filter")
    cols[1].file_uploader("Upload image")

toggle_and_text()
cols = st.columns(2)
cols[0].selectbox("Select", [1,2,3], None)
cols[1].button("Update")
filter_and_file()
```

当用户与 fragment 内的输入小部件交互时，只有 fragment 重新运行，而不是完整脚本。当用户与 fragment 外的输入小部件交互时，完整脚本如常重新运行。

如果你运行上述代码，完整脚本将在你的应用初始加载时从头到尾运行。如果你翻转运行中的应用中的切换按钮，第一个 fragment（`toggle_and_text()`）将重新运行，重新绘制切换和文本区域，同时保持其他一切不变。如果你点击复选框，第二个 fragment（`filter_and_file()`）将重新运行并相应地重新绘制复选框和文件上传器。其他一切保持不变。最后，如果你点击更新按钮，完整脚本将重新运行，Streamlit 将重新绘制所有内容。

![Fragment 执行流图表](/images/concepts/fragment_diagram.png)

## Fragment 返回值和与应用的其余部分交互

Streamlit 在 fragment 重新运行期间忽略 fragment 返回值，因此不建议为 fragment 函数定义返回值。相反，如果你的 fragment 需要与应用的其余部分共享数据，请使用 Session State。Fragments 只是你脚本中的函数，所以它们可以访问 Session State、导入的模块和其他 Streamlit 元素，如容器。如果你的 fragment 写入任何在其外创建的容器，请注意以下行为差异：

- 在你的 fragment 主体中绘制的元素在 fragment 重新运行期间被清除并在原位重新绘制。重复的 fragment 重新运行不会导致额外的元素出现。
- 绘制到 fragment 主体外的容器的元素不会在每个 fragment 重新运行时被清除。相反，Streamlit 将以累加方式绘制它们，这些元素将累积直到下一个完整脚本重新运行。
- Fragment 不能在 fragment 主体外的容器中绘制小部件。小部件只能在 fragment 的主体中。

要防止元素在外部容器中累积，请使用 [`st.empty`](/develop/api-reference/layout/st.empty) 容器。有关相关教程，请参见[跨多个容器创建 fragment](/develop/tutorials/execution-flow/create-a-multiple-container-fragment)。

如果你需要从 fragment 内部触发完整脚本重新运行，请调用 [`st.rerun`](/develop/api-reference/execution-flow/st.rerun)。有关相关教程，请参见[从 fragment 内部触发完整脚本重新运行](/develop/tutorials/execution-flow/trigger-a-full-script-rerun-from-a-fragment)。

## 自动 fragment 重新运行

`st.fragment` 包括一个方便的 `run_every` 参数，使 fragment 在指定的时间间隔自动重新运行。这些重新运行是除了任何由你的用户触发的重新运行（fragment 或完整脚本）之外。自动 fragment 重新运行将继续进行，即使你的用户没有与你的应用交互。这是显示现场数据流或运行后台作业状态的好方法，高效地更新你的渲染数据和 _仅_ 你的渲染数据。

```python
@st.fragment(run_every="10s")
def auto_function():
		# This will update every 10 seconds!
		df = get_latest_updates()
		st.line_chart(df)

auto_function()
```

有关相关教程，请参见[启动和停止流式 fragment](/develop/tutorials/execution-flow/start-and-stop-fragment-auto-reruns)。

## 将 fragments 与其他 Streamlit 功能进行比较

### Fragments vs 表单

以下是 fragments 和表单之间的比较：

- **表单** 允许用户与小部件交互而不重新运行你的应用。Streamlit 在提交表单之前不会将表单内的用户操作发送到你的应用的 Python 后端。表单内的小部件不能动态实时更新其他小部件（表单内或表单外）。
- **Fragments** 独立于代码的其余部分运行。当你的用户与 fragment 小部件交互时，他们的操作立即由你的应用的 Python 后端处理，你的 fragment 代码被重新运行。fragment 内的小部件可以动态实时更新同一 fragment 内的其他小部件。

表单批处理用户输入而小部件之间没有交互。Fragment 立即处理用户输入，但限制了重新运行的范围。

### Fragments vs 回调

以下是 fragments 和回调之间的比较：

- **回调** 允许你在脚本重新运行开始时执行一个函数。回调是你的脚本重新运行的 _单个前缀_。
- **Fragments** 允许你重新运行你的脚本的一部分。Fragment 是你的脚本的 _可重复的后缀_，每当用户与 fragment 小部件交互时，或当设置 `run_every` 时按顺序自动运行。

当回调向你的页面渲染元素时，它们在页面的其余元素之前渲染。当 fragments 向你的页面渲染元素时，它们在每个 fragment 重新运行时更新（除非它们被写入 fragment 外的容器，在这种情况下它们会在那里累积）。

### Fragments vs 自定义组件

以下是 fragments 和自定义组件之间的比较：

- **组件** 是可以与 Python 代码、本地元素和 Streamlit 应用中的小部件交互的自定义前端代码。自定义组件扩展了 Streamlit 可能实现的功能。它们遵循正常的 Streamlit 执行流。
- **Fragments** 是应用中可以独立于完整应用重新运行的部分。Fragments 可以由多个 Streamlit 元素、小部件或任何 Python 代码组成。

一个 fragment 可以包括一个或多个自定义组件。自定义组件不能轻易包括 fragment！

### Fragments vs 缓存

以下是 fragments 和缓存之间的比较：

- **缓存：** 允许你跳过一个函数并返回一个先前计算的值。当你使用缓存时，你执行除了缓存函数之外的所有内容（如果你之前已经运行过）。
- **Fragments：** 允许你冻结应用的大部分并仅执行 fragment。当你使用 fragments 时，你仅执行 fragment（当触发 fragment 重新运行时）。

缓存保存你免于不必要地运行应用的一部分，同时其余的运行。Fragments 保存你免于在你仅想运行一部分时运行整个应用。

## 限制和不支持的行为

- Fragments 无法检测输入值的变化。最好为 fragment 函数使用 Session State 进行动态输入和输出。
- 在同一函数上使用缓存和 fragments 不受支持。
- Fragments 无法在外部创建的容器中渲染小部件；小部件只能在 fragment 的主体中。

---

# 运行你的 Streamlit 应用

Source: https://docs.streamlit.io/develop/concepts/architecture/run-your-app


使用 Streamlit 很简单。首先你在普通的 Python 脚本中加入一些 Streamlit 命令，然后运行它。我们根据你的用例列出了几种运行脚本的方法。

## 使用 streamlit run

一旦你创建了脚本，比如 `your_script.py`，最简单的运行方法是使用 `streamlit run`：

```bash
streamlit run your_script.py
```

如上所示运行脚本后，本地 Streamlit 服务器将启动，你的应用将在你的默认 Web 浏览器中的新选项卡中打开。

### 将参数传递给你的脚本

当向脚本传递一些自定义参数时，必须在两个破折号之后传递它们。否则参数会被解释为 Streamlit 本身的参数：

```bash
streamlit run your_script.py [-- script args]
```

### 将 URL 传递给 streamlit run

你也可以将 URL 传递给 `streamlit run`！当你的脚本托管在远程位置（如 GitHub Gist）时，这很有用。例如：

```bash
streamlit run https://raw.githubusercontent.com/streamlit/demo-uber-nyc-pickups/master/streamlit_app.py
```

## 作为 Python 模块运行 Streamlit

运行 Streamlit 的另一种方式是将其作为 Python 模块运行。这在配置 IDE（如 PyCharm）以使用 Streamlit 时很有用：

```bash
# 运行
python -m streamlit run your_script.py
```

```bash
# 等价于：
streamlit run your_script.py
```

---

# 为应用添加状态性

Source: https://docs.streamlit.io/develop/concepts/architecture/session-state


## 什么是状态？

我们将浏览器标签页中对 Streamlit 应用的访问定义为一个**会话**。对于每个连接到 Streamlit 服务器的浏览器标签页，都会创建一个新会话。每当您与应用交互时，Streamlit 会从头到尾重新运行您的脚本。每次重新运行都在一个空白的状态下进行：运行之间不共享变量。

会话状态是一种在每次重新运行之间共享变量的方法，针对每个用户会话。除了存储和持久化状态的能力外，Streamlit 还提供了使用回调操作状态的能力。会话状态还会在[多页面应用](/develop/concepts/multipage-apps)的页面之间保持持久。

在本指南中，我们将通过构建一个有状态的计数器应用来演示**会话状态**和**回调**的使用。

有关会话状态和回调 API 的详细信息，请参阅我们的[会话状态 API 参考指南](/develop/api-reference/caching-and-state/st.session_state)。

此外，还请观看 Streamlit 开发者倡导者 Marisa Smith 博士制作的会话状态基础教程视频以开始学习：

<YouTube videoId="92jUAXBmZyU"/>

## 构建计数器

让我们将我们的脚本命名为 `counter.py`。它初始化一个 `count` 变量，并有一个按钮来增加 `count` 变量中存储的值：

```python
import streamlit as st

st.title('计数器示例')
count = 0

increment = st.button('增加')
if increment:
    count += 1

st.write('计数 = ', count)
```

无论我们在上面的应用中多少次按下**_增加_**按钮，`count` 都保持在 1。让我们了解一下原因：

- 每次我们按下**_增加_**按钮时，Streamlit 都会从头到尾重新运行 `counter.py`，而且每次运行时，`count` 都会被初始化为 `0`。
- 随后按下**_增加_**会将 1 加到 0 上，因此无论我们多少次按下**_增加_**，`count=1`。

正如我们稍后将看到的，我们可以通过将会话状态存储为会话状态变量来避免这个问题。通过这样做，我们向 Streamlit 表明应该在应用重新运行时维护会话状态变量中存储的值。

让我们进一步了解使用会话状态的 API。

### 初始化

会话状态 API 遵循基于字段的 API，这与 Python 字典非常相似：

```python
import streamlit as st

# 检查 'key' 是否已存在于 session_state 中
# 如果没有，则初始化它
if 'key' not in st.session_state:
    st.session_state['key'] = 'value'

# 会话状态也支持基于属性的语法
if 'key' not in st.session_state:
    st.session_state.key = 'value'
```

### 读取和更新

通过将项目传递给 `st.write` 来读取会话状态中的项目值：

```python
import streamlit as st

if 'key' not in st.session_state:
    st.session_state['key'] = 'value'

# 读取
st.write(st.session_state.key)

# 输出: value
```

通过为其分配一个值来更新会话状态中的项目：

```python
import streamlit as st

if 'key' not in st.session_state:
    st.session_state['key'] = 'value'

# 更新
st.session_state.key = 'value2'     # 属性 API
st.session_state['key'] = 'value2'  # 类似字典的 API
```

如果访问未初始化的变量，Streamlit 会抛出异常：

```python
import streamlit as st

st.write(st.session_state['value'])

# 抛出异常！
```

![state-uninitialized-exception](/images/state_uninitialized_exception.png)

现在让我们来看看一些示例，说明如何将会话状态添加到我们的计数器应用中。

### 示例 1: 添加会话状态

现在我们已经掌握了会话状态 API，让我们更新我们的计数器应用以使用会话状态：

```python
import streamlit as st

st.title('计数器示例')
if 'count' not in st.session_state:
    st.session_state.count = 0

increment = st.button('增加')
if increment:
    st.session_state.count += 1

st.write('计数 = ', st.session_state.count)
```

如您在上面的示例中所见，按下**_增加_**按钮每次都会更新 `count`。

### 示例 2: 会话状态和回调

现在我们已经使用会话状态构建了一个基本的计数器应用，让我们转向稍微复杂一点的内容。下一个示例将使用回调与会话状态。

**回调**: 回调是一个 Python 函数，当输入小部件发生变化时会调用该函数。回调可以与小部件一起使用，使用参数 `on_change`（或 `on_click`）、`args` 和 `kwargs`。完整的回调 API 可在我们的[会话状态 API 参考指南](/develop/api-reference/caching-and-state/st.session_state#use-callbacks-to-update-session-state)中找到。

```python
import streamlit as st

st.title('使用回调的计数器示例')
if 'count' not in st.session_state:
    st.session_state.count = 0

def increment_counter():
    st.session_state.count += 1

st.button('增加', on_click=increment_counter)

st.write('计数 = ', st.session_state.count)
```

现在，按下**_增加_**按钮通过调用 `increment_counter()` 函数每次更新计数。

### 示例 3: 在回调中使用 args 和 kwargs

回调还支持使用小部件中的 `args` 参数传递参数：

```python
import streamlit as st

st.title('使用带 args 回调的计数器示例')
if 'count' not in st.session_state:
    st.session_state.count = 0

increment_value = st.number_input('输入一个值', value=0, step=1)

def increment_counter(increment_value):
    st.session_state.count += increment_value

increment = st.button('增加', on_click=increment_counter,
    args=(increment_value, ))

st.write('计数 = ', st.session_state.count)
```

此外，我们还可以在小部件中使用 `kwargs` 参数将命名参数传递给回调函数，如下所示：

```python
import streamlit as st

st.title('使用带 kwargs 回调的计数器示例')
if 'count' not in st.session_state:
    st.session_state.count = 0

def increment_counter(increment_value=0):
    st.session_state.count += increment_value

def decrement_counter(decrement_value=0):
    st.session_state.count -= decrement_value

st.button('增加', on_click=increment_counter,
	kwargs=dict(increment_value=5))

st.button('减少', on_click=decrement_counter,
	kwargs=dict(decrement_value=1))

st.write('计数 = ', st.session_state.count)
```

### 示例 4: 表单和回调

假设我们现在不仅要增加 `count`，还要存储上次更新的时间。我们使用回调和 `st.form` 来演示如何实现：

```python
import streamlit as st
import datetime

st.title('计数器示例')
if 'count' not in st.session_state:
    st.session_state.count = 0
    st.session_state.last_updated = datetime.time(0,0)

def update_counter():
    st.session_state.count += st.session_state.increment_value
    st.session_state.last_updated = st.session_state.update_time

with st.form(key='my_form'):
    st.time_input(label='输入时间', value=datetime.datetime.now().time(), key='update_time')
    st.number_input('输入一个值', value=0, step=1, key='increment_value')
    submit = st.form_submit_button(label='更新', on_click=update_counter)

st.write('当前计数 = ', st.session_state.count)
st.write('上次更新 = ', st.session_state.last_updated)
```

## 高级概念

### 会话状态和小部件状态关联

会话状态提供了在重新运行之间存储变量的功能。小部件状态（即小部件的值）也存储在会话中。

为了简化，我们已在一处_统一_了这些信息。即会话状态。此便捷功能使您可以在应用代码中的任何地方轻松读取或写入小部件的状态。会话状态变量使用 `key` 参数镜像小部件的值。

我们用以下示例来说明这一点。假设我们有一个带有滑块的应用，表示摄氏温度。我们可以通过使用会话状态 API 来**设置**和**获取**温度小部件的值，如下所示：

```python
import streamlit as st

if "celsius" not in st.session_state:
    # 设置滑块小部件的初始默认值
    st.session_state.celsius = 50.0

st.slider(
    "摄氏温度",
    min_value=-100.0,
    max_value=100.0,
    key="celsius"
)

# 这将获取滑块小部件的值
st.write(st.session_state.celsius)
```

使用会话状态 API 设置小部件值存在局限性。

<Important>

Streamlit **不允许**通过会话状态 API 为 `st.button` 和 `st.file_uploader` 设置小部件值。

</Important>

以下示例在尝试通过会话状态 API 设置 `st.button` 的状态时将引发 `StreamlitAPIException`：

```python
import streamlit as st

if 'my_button' not in st.session_state:
    st.session_state.my_button = True
    # Streamlit 在尝试设置按钮状态时会引发异常

st.button('提交', key='my_button')
```

<Image alt="state-button-exception" src="/images/state_button_exception.png"/>

### 可序列化的会话状态

序列化是指将对象或数据结构转换为可以持久化和共享的格式的过程，让您能够恢复数据的原始结构。Python 的内置 [pickle](https://docs.python.org/3/library/pickle.html) 模块将 Python 对象序列化为字节流（"pickle化"）并将流反序列化为对象（"unpickle化"）。

默认情况下，Streamlit 的[会话状态](/develop/concepts/architecture/session-state)允许您在会话期间持久化任何 Python 对象，不管对象的 pickle 可序列化性如何。此属性允许您存储 Python 基本类型，如整数、浮点数、复数和布尔值、数据框，甚至函数返回的[lambdas](https://docs.python.org/3/reference/expressions.html#lambda)。但是，某些执行环境可能需要序列化会话状态中的所有数据，因此在开发期间检测不兼容性，或在执行环境将来停止支持时可能很有用。

为此，Streamlit 提供了一个 `runner.enforceSerializableSessionState` [配置选项](/develop/concepts/configuration)，当设置为 `true` 时，只允许在会话状态中使用可 pickle 序列化的对象。要启用此选项，可以创建一个全局或项目配置文件，其中包含以下内容，或将其用作命令行标志：

```toml
# .streamlit/config.toml
[runner]
enforceSerializableSessionState = true
```

通过"_pickle-serializable_"，我们的意思是调用 `pickle.dumps(obj)` 不应引发 [`PicklingError`](https://docs.python.org/3/library/pickle.html#pickle.PicklingError) 异常。当启用配置选项时，向会话状态添加不可序列化的数据会导致异常。例如，

```python
import streamlit as st

def unserializable_data():
	return lambda x: x

#👇 当 enforceSerializableSessionState 开启时会导致异常
st.session_state.unserializable = unserializable_data()
```

<Image alt="UnserializableSessionStateError" src="/images/unserializable-session-state-error.png"/>
<Warning>

当 `runner.enforceSerializableSessionState` 设置为 `true` 时，会话状态隐式使用 `pickle` 模块，这被认为是不安全的。确保保存和从会话状态检索的所有数据都是可信的，因为可以构造恶意的 pickle 数据，在 unpickling 期间执行任意代码。切勿在不安全模式下加载可能来自不受信任来源或可能已被篡改的数据。**仅加载您信任的数据**。

</Warning>

### 注意事项和限制

使用会话状态时需要记住一些限制：

- 会话状态在标签页打开并连接到 Streamlit 服务器期间存在。一旦您关闭标签页，存储在会话状态中的所有内容都将丢失。
- 会话状态不会持久化。如果 Streamlit 服务器崩溃，则存储在会话状态中的所有内容都会被清除
- 有关会话状态 API 的注意事项和限制，请参阅[API 限制](/develop/api-reference/caching-and-state/st.session_state#caveats-and-limitations)。

---

# 理解部件行为

Source: https://docs.streamlit.io/develop/concepts/architecture/widget-behavior


部件（如 `st.button`、`st.selectbox` 和 `st.text_input`）是 Streamlit 应用的核心。它们是 Streamlit 的交互元素，将用户信息传递到您的 Python 代码中。部件是神奇的，通常按您想要的方式工作，但在某些情况下它们可能会有令人惊讶的行为。了解部件的不同部分以及事件发生的精确顺序有助于您实现所需的结果。

本指南涵盖有关部件的高级概念。通常，它从更简单的概念开始并逐渐增加复杂性。对于大多数初学者来说，这些细节不需要马上知道。当您想要动态更改部件或在页面之间保留部件信息时，这些概念就很重要了。我们建议在阅读本指南之前先基本了解[会话状态](/develop/api-reference/caching-and-state/st.session_state)。

<Collapse title="🎈 简而言之">{false}&gt;

1. 一个用户的行为不会影响任何其他用户的部件。
2. 部件命令返回部件的当前值，这是一个简单的 Python 类型。例如，`st.button` 返回一个布尔值。
3. 部件在首次调用时返回其默认值，直到用户与其交互。
4. 部件的身份取决于传递给部件命令的参数。**如果提供了键，只有键决定部件的身份，但有一些限制，因为这仍在实施中。** 如果没有提供键，更改部件的标签、最小或最大值、默认值、占位符文本或帮助文本将导致它重置。
5. 如果您在脚本运行中不调用部件命令，Streamlit 将删除部件的信息——_包括其在会话状态中的键值对_。如果您稍后调用相同的部件命令，Streamlit 将其视为新部件。
6. 部件在页面之间不是有状态的。如果您在不同页面上有两个具有相同键的部件，它们将被视为两个不同的部件。

最后三点（部件身份和部件删除）在动态更改部件或使用多页面应用时最相关。本指南后面将详细介绍：[部件的状态性](#部件的状态性) 和 [部件生命周期](#部件生命周期)。

</Collapse>
<Important>

**部件行为的最近变化**

从 v1.46.0 到 v1.52.0，引入了部件状态性的重大变化：

- **v1.46.0**：在页面之间导航时，`st.session_state` 中的部件键在新页面脚本运行开始时而非结束时删除。
- **v1.50.0-1.52.0**：当提供键时，部件身份由键和选择参数（最小/最大值和选项）确定。这是实施期间的过渡阶段，直到部件完全转换为仅键身份。

这些变化影响部件在页面导航和参数更改时如何保持状态。要查看哪些部件已转换为基于键的身份，请参阅 [v1.50.0](https://docs.streamlit.io/release-notes/v1.50.0)、[v1.51.0](https://docs.streamlit.io/release-notes/v1.51.0) 和 [v1.52.0](https://docs.streamlit.io/release-notes/v1.52.0) 的发行说明。

截至 v1.52.0，以下部件**尚未**转换为基于键的身份：`st.data_editor` 和具有选择模式的元素，如 `st.dataframe` 和图表。

</Important>

## 部件的组成

使用部件时需要记住四个部分：

1. 用户看到的前端组件。
2. 后端（Python）内存中的值。
3. `st.session_state` 中的键值对，提供对部件值的程序访问。
4. 部件函数返回的值。

### 部件依赖于会话

部件状态依赖于特定会话（浏览器连接）。一个用户的行为不会影响任何其他用户的部件。此外，如果用户打开多个标签页访问应用，每个标签页将是唯一的会话。更改一个标签页中的部件不会影响另一个标签页中的相同部件。

### 部件返回简单的 Python 数据类型

通过 `st.session_state` 看到的部件值以及部件函数返回的值都是简单的 Python 类型。例如，`st.button` 返回一个布尔值，如果使用键，将在 `st.session_state` 中保存相同的布尔值。首次调用部件函数时（在用户与其交互之前），它将返回其默认值。例如，`st.selectbox` 默认返回第一个选项。除了 `st.button` 和 `st.file_uploader` 等少数特殊情况外，所有部件都可以配置默认值。

### 键帮助区分部件并访问其值

部件键有三个用途：

1. 区分两个其他方面相同的部件。
2. 在更改参数的同时保持部件的状态性（v1.50.0+）。
3. 创建通过 `st.session_state` 访问和操作部件值的方法。

此外，为了开发人员的便利，键在 DOM 中作为带有 Streamlit 特定前缀的 HTML 属性重复，以防止冲突。确切的前缀和属性名称不能保证在版本之间稳定。

#### 部件身份：基于键 vs 基于参数

只要可能，Streamlit 会在前端增量更新部件，而不是在每次重新运行时重建它们。这意味着 Streamlit 根据传递给部件命令的参数为每个部件分配一个部件身份。

**以前的行为（v1.50.0 之前）：** 部件身份由所有参数确定，包括标签、选项、最小/最大值、默认值、占位符文本、帮助文本和键。

**当前行为（v1.50.0+）：** 部件身份取决于是否提供了键：

- **带键：** 只有键、最小/最大值和选项参数决定部件身份。其他参数可以更改而不会重置部件。
- **无键：** 部件的参数（标签、选项、最小/最大值、默认值、占位符、帮助文本）决定部件身份。更改这些参数之一将重置部件。请注意，回调函数、回调参数和关键字参数、标签可见性以及禁用部件不会影响部件身份。

在所有情况下，部件身份和状态不会在页面之间保留。更多信息请参见下面的[部件的状态性](#部件的状态性)。

#### Streamlit 无法理解同一页面上的两个相同部件

如果在同一页面上有两个相同类型和相同参数的部件，您将收到 `DuplicateWidgetID` 错误。在这种情况下，为两个部件分配唯一键。

以下示例将导致 `DuplicateWidgetID` 错误。

```python
st.button("确定")
st.button("确定")
```

以下示例正确为两个按钮分配唯一键以避免 `DuplicateWidgetID` 错误。

```python
st.button("确定", key="privacy")
st.button("确定", key="terms")
```

## 操作顺序

当用户与部件交互时，部件被更新并按以下顺序触发重新运行：

1. `st.session_state` 中的部件值被更新。
2. 回调函数（如果有）被执行。
3. 页面重新运行，部件命令返回其新值。

如果回调函数在屏幕上显示任何内容，该内容将出现在页面上方。回调函数作为脚本运行的_前缀_运行。因此，这意味着通过回调函数编写的任何内容都会在用户执行下一个操作时消失。一般不应在回调函数中调用部件命令。

<Note>

如果回调函数传递了任何参数或关键字参数，这些参数将在部件命令调用时建立，而不是在用户与部件交互时建立。特别是，如果您想在部件自身的回调函数中使用部件的值，不能通过 `args` 参数将该值传递给回调函数；您必须为部件分配一个键，并使用 `st.session_state` 在回调函数_内_查找其值。

</Note>

### 将回调函数与表单一起使用

将回调函数与表单一起使用需要了解此操作顺序。

```python
import streamlit as st

if "attendance" not in st.session_state:
    st.session_state.attendance = set()


def take_attendance():
    if st.session_state.name in st.session_state.attendance:
        st.info(f"{st.session_state.name} 已经被记录过了。")
    else:
        st.session_state.attendance.add(st.session_state.name)


with st.form(key="my_form"):
    st.text_input("姓名", key="name")
    st.form_submit_button("我在这里！", on_click=take_attendance)
```

<Cloud height="250px" name="doc-guide-widgets-form-callbacks"/>

## 部件的状态性

只要部件身份保持相同并且该部件持续在前端渲染，它就有状态并记住用户输入。

### 更改部件的身份将重置它

如果确定部件身份的任何参数发生变化，Streamlit 将将其视为新部件并重置。使用新的基于键的身份系统，提供键可以保护部件免受其他参数更改时的重置。在这种情况下，默认值的使用尤为重要。如果您使用键并更改部件的默认值，部件状态不会有变化。如果您不使用键，更改部件的默认值将重置部件为该默认值。

在此示例中，我们有两个滑块，您可以更改最小值、最大值和默认值。尝试与每个滑块交互以更改其值，然后更改最小值或最大值设置以查看发生了什么。当您更改最小值或最大值时，两个滑块身份都将更新，它们将重置为其当前默认值。但是，如果您更改默认值，只有没有键的滑块会重置。有键的滑块将保持有状态。

```python
import streamlit as st

cols = st.columns([2, 1, 2])
minimum = cols[0].number_input("最小值", 1, 3)
maximum = cols[2].number_input("最大值", 8, 10, 10)
value = cols[1].number_input("默认值", 4, 7, 5)

st.slider("无键", minimum, maximum, value)
st.slider("带键", minimum, maximum, value, key="a")
```

<Cloud height="550px" name="doc-guide-widgets-change-parameters"/>

### 部件在不连续渲染时不保留

如果在脚本运行期间未调用特定部件实例的部件命令，则不会保留其任何部分，包括其在 `st.session_state` 中的值。如果部件有键并且您从此部件导航离开，其在 `st.session_state` 中的键和关联值将被删除。即使是临时隐藏部件也会导致它重新出现时重置；Streamlit 将将其视为新部件。要在页面之间或部件暂时隐藏时保留部件状态，请将值保存到单独的占位键中，如下所示。

#### 在会话状态中保存部件值以在页面之间保留它们

如果您想离开部件并返回它同时保持其值，请使用 `st.session_state` 中的单独键独立于部件保存信息。也建议使用此技术将部件的状态携带到另一页上的新实例。在此示例中，使用带有部件的下划线前缀的临时键。因此，`"_my_key"` 用作部件键，但数据被复制到 `"my_key"` 以在页面之间保留它。

```python
import streamlit as st

def store_value():
    # 将值复制到永久键
    st.session_state["my_key"] = st.session_state["_my_key"]

# 将保存的值复制到临时键
st.session_state["_my_key"] = st.session_state["my_key"]
st.number_input("过滤器数量", key="_my_key", on_change=store_value)
```

如果将其函数化以处理多个部件，可能看起来像这样：

```python
import streamlit as st

def store_value(key):
    st.session_state[key] = st.session_state["_"+key]
def load_value(key):
    st.session_state["_"+key] = st.session_state[key]

load_value("my_key")
st.number_input("过滤器数量", key="_my_key", on_change=store_value, args=["my_key"])
```

## 部件生命周期

当调用部件命令时，Streamlit 将检查是否已经有一个具有相同身份的部件。如果 Streamlit 认为部件已存在，它将重新连接。否则，它将创建一个新部件。

如前所述，Streamlit 根据部件是否有键以不同方式确定部件身份。页面名称也会影响部件身份，其中部件身份在页面之间不保留。另一方面，回调函数、回调参数和关键字参数、标签可见性以及禁用部件从不影响部件身份。

### 当部件尚不存在时调用部件命令

如果您的脚本重新运行调用具有更改身份的部件命令，或调用在上次脚本运行中未使用的部件命令：

1. Streamlit 将构建部件的前端和后端部分，使用其默认值。
2. 如果部件已分配键，Streamlit 将检查该键是否已存在于会话状态中。
   a. 如果键存在且**不**与具有不同身份的部件关联，Streamlit 将将该键的值分配给部件。
   b. 如果键存在且与具有不同身份的部件关联，Streamlit 将用默认值覆盖键值对。
   b. 如果键不存在，Streamlit 将使用默认值创建新的键值对。
3. 如果有回调函数的参数或关键字参数，它们将在内存中评估和保存。
4. 然后函数返回部件值。

对于第2步，v1.46.0 之前，如果值来自另一页面的部件实例，Streamlit 将忽略会话状态中的值。这是因为另一页面上的部件必然具有不同的身份。从 v1.46.0 开始，Streamlit 在新页面脚本运行开始时删除此类值。

### 当部件已存在时调用部件命令

在不更改部件身份的情况下重新运行脚本时：

1. Streamlit 将连接到现有的前端和后端部分。
2. 如果部件有从 `st.session_state` 中删除的键，则 Streamlit 将使用当前前端值重新创建键。这是因为从会话状态中删除键不会将部件恢复为默认值。
3. 部件命令将返回部件的当前值。

### 部件清理过程

Streamlit 在每次脚本运行结束时以及在新页面上脚本运行开始时清理部件数据。

当 Streamlit 到达脚本运行结束时，它将删除内存中所有未在屏幕上渲染的部件的数据。最重要的是，这意味着 Streamlit 将删除与当前不在屏幕上显示的部件相关的 `st.session_state` 中的所有键值对。当您切换页面时，Streamlit 将删除与前一页部件相关的所有数据。

### 更改部件身份时保持状态性

如果您只需要操作影响身份的参数而不在页面之间携带部件状态，可以使用回调直接维护部件状态。这是我们之前更改滑块最小值和最大值示例的解决方案。请注意，部件的初始值是通过会话状态而不是其 `value` 参数设置的。当您以编程方式更改部件时，应该只使用会话状态来维护部件状态以避免意外行为。

```python
import streamlit as st

# 设置部件的默认值
st.session_state.setdefault("a", 5)

cols = st.columns(2)
minimum = cols[0].number_input("最小值", 1, 5, key="min")
maximum = cols[1].number_input("最大值", 6, 10, 10, key="max")


def update_value():
    # 辅助函数，确保部件参数和值之间的一致性
    st.session_state.a = min(st.session_state.a, maximum)
    st.session_state.a = max(st.session_state.a, minimum)


# 渲染前验证滑块值
update_value()
st.slider("A", minimum, maximum, key="a")
```

<Cloud height="250px" name="doc-guide-widgets-change-parameters-solution"/>

`update_value()` 辅助函数确保部件参数和值之间的一致性。此外，通过写入 `st.session_state.a`，我们确保键值对可用于"新"部件。如果此脚本不写入 `st.session_state.a`，Streamlit 将解释键值对与不同部件关联并覆盖键值对。

## 最佳实践和建议

### 对于多页面应用

**主要建议：** 在入口点文件中使用通用部件和 [`st.navigation`](/develop/api-reference/navigation/st.navigation) 来完全绕过页面身份问题：

```python
# streamlit_app.py (入口点)
import streamlit as st

# 在所有页面上持续存在的通用部件
user_name = st.sidebar.text_input("姓名", key="global_name")
user_role = st.sidebar.selectbox("角色", ["用户", "管理员"], key="global_role")

# 导航
page = st.navigation([
    st.Page("page1.py", title="仪表板"),
    st.Page("page2.py", title="设置"),
])
page.run()
```

**次要建议：** 对于必须在各个页面上的部件，请使用占位键模式。更多信息请参见[在会话状态中保存部件值以在页面之间保留它们](#在会话状态中保存部件值以在页面之间保留它们)。

### 对于参数更改

- 当您需要部件在参数更改时保持状态时使用键。
- 如果您需要更改影响部件身份的参数，请使用占位键，就像对多页面应用一样，
  或使用回调直接维护部件状态。更多信息请参见[更改部件身份时保持状态性](#更改部件身份时保持状态性)。
- 要强制部件重置，请更新其键，或在不使用键的情况下更新参数。

---

# 配置和自定义你的应用

Source: https://docs.streamlit.io/develop/concepts/configuration


<TileContainer>
<RefCard href="/develop/concepts/configuration/options">
<h5>配置选项</h5>

了解通过 Streamlit 配置对你可用的选项类型。

</RefCard>
<RefCard href="/develop/concepts/configuration/https-support">
<h5>HTTPS 支持</h5>

了解如何为你的 Streamlit 应用配置 SSL 和 TLS。

</RefCard>
<RefCard href="/develop/concepts/configuration/serving-static-files">
<h5>静态文件服务</h5>

了解如何在应用旁边托管文件以通过 URL 访问。如果你想指向具有原始 HTML 的文件，请使用此功能。

</RefCard>
</TileContainer>

## 主题

<TileContainer>
<RefCard href="/develop/concepts/configuration/theming">
<h5>主题</h5>

了解如何使用主题配置选项来自定义应用的外观。

</RefCard>
<RefCard href="/develop/concepts/configuration/theming-customize-colors-and-borders">
<h5>自定义颜色和边框</h5>

了解用于自定义应用配色方案的配置选项。

</RefCard>
<RefCard href="/develop/concepts/configuration/theming-customize-fonts">
<h5>自定义字体</h5>

了解用于自定义应用字体的配置选项。

</RefCard>
</TileContainer>

---

# HTTPS 支持

Source: https://docs.streamlit.io/develop/concepts/configuration/https-support


许多应用需要使用 SSL / [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) 协议或 `https://` 访问。

我们推荐在反向代理或负载均衡器中执行 SSL 终止，用于自托管和生产用例，而不是直接在应用中。[Streamlit Community Cloud](/deploy/streamlit-community-cloud) 使用此方法，每个主要的云和应用托管平台都应该允许您配置它并提供广泛的文档。您可以在我们的[部署教程](/deploy/tutorials)中找到其中一些平台。

要在您的 Streamlit 应用中终止 SSL，您必须配置 `server.sslCertFile` 和 `server.sslKeyFile`。了解如何在[配置](/develop/concepts/configuration)中设置配置选项。

## 使用详情

- 配置值应该是证书文件和密钥文件的本地文件路径。这些必须在应用启动时可用。
- 必须指定 `server.sslCertFile` 和 `server.sslKeyFile` 两者。如果只指定一个，您的应用将以错误退出。
- 此功能在 Community Cloud 中不起作用。Community Cloud 已经使用 TLS 为您的应用提供服务。

<Warning>

在生产环境中，我们推荐由负载均衡器或反向代理执行 SSL 终止，而不是使用此选项。Streamlit 中使用此选项尚未经过广泛的安全审计或性能测试。

</Warning>

## 示例用法

```toml
# .streamlit/config.toml

[server]
sslCertFile = '/path/to/certchain.pem'
sslKeyFile = '/path/to/private.key'
```

---

# 使用配置选项

Source: https://docs.streamlit.io/develop/concepts/configuration/options


Streamlit 提供了四种不同的方式来设置配置选项。此列表按优先级逆序排列，即当多次提供相同配置选项时，命令行标志优先于环境变量。

<Note>

如果在应用运行时更改 `.streamlit/config.toml` 中的主题设置，这些更改将立即反映。如果在应用运行时更改 `.streamlit/config.toml` 中的非主题设置，则需要重启服务器才能在应用中反映更改。

</Note>

1. 在**全局配置文件**中，位于 `~/.streamlit/config.toml`（macOS/Linux）或 `%userprofile%/.streamlit/config.toml`（Windows）：

   ```toml
   [server]
   port = 80
   ```

2. 在**每个项目的配置文件**中，位于 `$CWD/.streamlit/config.toml`，
   其中 `$CWD` 是您运行 Streamlit 的文件夹。

3. 通过 `STREAMLIT_*` **环境变量**，例如：

   ```bash
   export STREAMLIT_SERVER_PORT=80
   export STREAMLIT_SERVER_COOKIE_SECRET=dontforgottochangeme
   ```

4. 在运行 `streamlit run` 时作为**命令行标志**：

   ```bash
   streamlit run your_script.py --server.port 80
   ```

## 可用选项

所有可用的配置选项都记录在 [`config.toml`](/develop/api-reference/configuration/config.toml) 中。这些选项可以在 TOML 文件中声明，作为环境变量，或作为命令行选项。

当使用环境变量覆盖 `config.toml` 时，将变量（包括其节标题）转换为大写蛇形格式并添加 `STREAMLIT_` 前缀。例如，`STREAMLIT_CLIENT_SHOW_ERROR_DETAILS` 等同于 TOML 中的以下内容：

```toml
[client]
showErrorDetails = true
```

当使用命令行选项覆盖 `config.toml` 和环境变量时，使用与 TOML 文件中相同的大小写，并将节标题作为点分隔的前缀。例如，命令行选项 `--server.enableStaticServing true` 等同于以下内容：

```toml
[server]
enableStaticServing = true
```

## 遥测

如安装过程中所述，Streamlit 收集使用统计信息。您可以通过阅读我们的[隐私声明](https://streamlit.io/privacy-policy)了解更多，但简要说明是，虽然我们收集遥测数据，但我们无法查看也不存储 Streamlit 应用中包含的信息。

如果您希望退出使用统计信息收集，请在配置文件中添加以下内容：

```toml
[browser]
gatherUsageStats = false
```

## 主题

您可以使用配置系统的 `[theme]` 部分更改应用的基本颜色。
要了解更多信息，请参见[主题](/develop/concepts/configuration/theming)。

## 查看所有配置选项

如[命令行选项](/develop/api-reference/cli)中所述，您可以使用以下命令查看所有可用的配置选项：

```bash
streamlit config show
```

---

# 静态文件服务

Source: https://docs.streamlit.io/develop/concepts/configuration/serving-static-files


Streamlit 应用可以托管和提供小型静态媒体文件，以支持无法使用普通[媒体元素](/develop/api-reference/media)的媒体嵌入用例。

要启用此功能，请在配置文件中的 `[server]` 下设置 `enableStaticServing = true`，或环境变量 `STREAMLIT_SERVER_ENABLE_STATIC_SERVING=true`。

存储在相对于运行应用文件的文件夹 `./static/` 中的媒体在路径 `app/static/[filename]` 下提供服务，例如 `http://localhost:8501/app/static/cat.png`。

## 使用详情

- 具有以下扩展名的文件将被正常提供服务：
  - 常见图像类型：`.jpg`, `.jpeg`, `.png`, `.gif`
  - 常见字体类型：`.otf`, `.ttf`, `.woff`, `.woff2`
  - 其他类型：`.pdf`, `.xml`, `.json`
    任何其他文件将以头 `Content-Type:text/plain` 发送，这将导致浏览器以纯文本渲染。
    这是出于安全考虑 - 需要渲染的其他文件类型应该在应用外部托管。
- Streamlit 还为从静态目录渲染的所有文件设置 `X-Content-Type-Options:nosniff`。
- 对于在 Streamlit Community Cloud 上运行的应用：
  - Github 仓库中可用的文件将始终被提供服务。任何在应用运行时生成的基于用户交互的文件（文件上传等）不保证在用户会话之间持久存在。
  - 存储和提供许多文件或大文件的应用可能会遇到资源限制并被关闭。

## 示例用法

- 将图像 `cat.png` 放入文件夹 `./static/`
- 在您的 `.streamlit/config.toml` 中的 `[server]` 下添加 `enableStaticServing = true`
- `./static/` 文件夹中的任何媒体都以相对 URL 提供服务，如 `app/static/cat.png`

```toml
# .streamlit/config.toml

[server]
enableStaticServing = true
```

```python
# app.py
import streamlit as st

with st.echo():
    st.title("CAT")

    st.markdown("[![Click me](app/static/cat.png)](https://streamlit.io)")

```

附加资源：

- [https://docs.streamlit.io/develop/concepts/configuration](https://docs.streamlit.io/develop/concepts/configuration)
- [https://static-file-serving.streamlit.app/](https://static-file-serving.streamlit.app/)

<Cloud height="1000px" name="static-file-serving"/>

---

# 主题概述

Source: https://docs.streamlit.io/develop/concepts/configuration/theming


在本指南中，我们将概述 Streamlit 应用的主题和视觉定制。Streamlit 主题使用配置选项定义，通常在 `.streamlit/config.toml` 文件中定义。有关设置配置选项的更多信息，请参见[使用配置选项](/develop/concepts/configuration/options)。有关配置选项和定义的完整列表，请参见 [config.toml](/develop/api-reference/configuration/config.toml#theme) 的 API 参考。

您可以为应用配置浅色和深色主题，用户可以通过设置菜单进行切换。几乎所有的主题选项中，侧边栏都可以与主应用分开配置。

以下选项可以在 `config.toml` 的 `[theme]` 表中设置，不能在侧边栏、深色主题或浅色主题表中单独设置：

- **基础配色方案**：设置自定义主题以继承 Streamlit 的浅色或深色主题，或使用外部主题 TOML 文件。
- **基础字体**：设置基础字体粗细和大小。（这可以单独配置标题和代码字体。）
- **图表颜色**：为 Plotly、Altair 和 Vega-Lite 图表设置系列颜色。
- **侧边栏边框**：设置侧边栏边框的可见性。

以下选项可以为主应用主体和侧边栏分别配置。它们也可以分别指定为深色和浅色主题（`[theme.light]`、`[theme.light.sidebar]`、`[theme.dark]`、`[theme.dark.sidebar]`）：

- **字体系列**：设置正文文本、标题和代码的字体系列。
- **字体样式**：设置标题和代码字体的粗细和大小，并设置链接下划线的可见性。
- **文字颜色**：设置正文、行内代码和链接文本的颜色。
- **主色调**：设置交互元素和高亮的颜色。
- **背景色**：设置应用、部件、代码块和数据框标题的背景色。
- **边框半径**：设置元素和部件的圆角程度。
- **边框颜色**：设置元素、部件、侧边栏和数据框边框的颜色和可见性。
- **基本调色板**：设置用于 Markdown 文本着色和火花线等的调色板（红、橙、黄、绿、蓝、紫和灰/灰色）。

## 示例主题

以下浅色主题灵感来自 [Anthropic](https://docs.anthropic.com/en/home)。
<Cloud height="500px" name="doc-theming-overview-anthropic-light-inspired"/>

以下深色主题灵感来自 [Spotify](https://open.spotify.com/)。
<Cloud height="500px" name="doc-theming-overview-spotify-inspired"/>

## 在开发过程中使用主题配置

大多数主题配置选项可以在应用运行时更新。这使得迭代自定义主题变得容易。如果您更改应用的主要颜色，保存 `config.toml` 文件并重新运行应用，您将立即看到新颜色。但是，某些配置选项（如 `[[theme.fontFace]]`）需要您重启 Streamlit 服务器才能反映更新。如有疑问，在更新应用配置时，请在终端中停止 Streamlit 服务器，并使用 `streamlit run` 命令重新启动应用。

---

# 自定义 Streamlit 应用中的颜色和边框

Source: https://docs.streamlit.io/develop/concepts/configuration/theming-customize-colors-and-borders


## 颜色值

对于所有接受颜色的配置选项，您可以使用以下字符串之一指定值：

- 一个 CSS [`<named-color>`](https://developer.mozilla.org/en-US/docs/Web/CSS/named-color) 如 `"darkBlue"` 或 `"maroon"`。
- 一个十六进制字符串如 `"#483d8b"` 或 `"#6A5ACD"`。
- 一个 RGB 字符串如 `"rgb(106, 90, 205)"` 或 `"RGB(70, 130, 180)"`。
- 一个 HSL 字符串如 `"hsl(248, 53%, 58%)"` 或 `"HSL(147, 50%, 47%)"`。

<Tip>

虽然您可以为颜色指定 alpha 值，但这对于大多数选项来说并不是必要的。Streamlit 会调整颜色的 alpha 值，以确保背景和前景之间的上下文适当着色。

</Tip>

## 默认 Streamlit 颜色

Streamlit 附带两个预配置的主题：浅色和深色。如果您不指定任何主题配置选项，Streamlit 将尝试使用最匹配每个用户浏览器设置的预配置主题。这些主题特色是红色主色调，还包括一个基本调色板（红、橙、黄、绿、蓝、紫和灰/灰色），用于着色 Markdown 文本等元素。

## 颜色和边框配置选项

大多数主题配置选项可以为整个应用设置，但您可以使用不同的值覆盖侧边栏的某些选项。例如，应用的主要颜色 (`primaryColor`) 用于突出显示交互元素和显示焦点。如果设置 `theme.primaryColor`，这将更改整个应用的主要颜色。但是，如果设置 `theme.sidebar.primaryColor`，这将在侧边栏中覆盖 `theme.primaryColor`，允许您使用两种不同的主要颜色。

以下两个配置选项只能应用于整个应用：

- `theme.base` 将应用主题的默认颜色设置为匹配 Streamlit 两个默认主题之一（`"light"` 或 `"dark"`）。如果使用了任何主题配置选项且未设置 `theme.base`，则 Streamlit 将使用 `"light"`。
- `theme.showSidebarBorder` 设置侧边栏与应用主体之间的边框可见性。
- `theme.chartCategoricalColors` 和 `theme.chartSequentialColors` 设置 Plotly、Altair 和 Vega-Lite 图表的系列颜色。

以下配置选项可以通过在 `config.toml` 中使用 `[theme.sidebar]` 表而不是 `[theme]` 表为侧边栏单独设置：

- `theme.primaryColor`
- `theme.backgroundColor`
- `theme.secondaryBackgroundColor`
- `theme.textColor`
- `theme.linkColor`
- `theme.linkUnderline`
- `theme.codeTextColor`
- `theme.codeBackgroundColor`
- `theme.baseRadius`
- `theme.buttonRadius`
- `theme.borderColor`
- `theme.dataframeBorderColor`
- `theme.dataframeHeaderBackgroundColor`
- `theme.showWidgetBorder`
- 所有调色板选项

为简洁起见，在本页其余部分，主题配置选项将不包含 `theme.` 或 `theme.sidebar.` 前缀。

### 基本调色板

Streamlit 中的各种元素使用或让您从预定义的颜色调色板中选择：红、橙、黄、绿、蓝、紫和灰/灰色。以下是使用此基本调色板的一些元素：

- Markdown 文本和背景颜色（包括 `st.badge`）。
- `st.metric` 火花线和增量。
- 数据框图表列。
- 聊天消息头像。
- 警告元素如 `st.success` 和 `st.warning`。

对于调色板中的每种颜色，您可以定义基础颜色、背景颜色和文本颜色。如果您只定义基础颜色，Streamlit 会调整亮度/暗度和不透明度以自动提供相应的背景和文本颜色。但是，您也可以手动定义每一项。以下是调色板选项：

- `redColor`, `redBackgroundColor`, `redTextColor`
- `orangeColor`, `orangeBackgroundColor`, `orangeTextColor`
- `yellowColor`, `yellowBackgroundColor`, `yellowTextColor`
- `greenColor`, `greenBackgroundColor`, `greenTextColor`
- `blueColor`, `blueBackgroundColor`, `blueTextColor`
- `violetColor`, `violetBackgroundColor`, `violetTextColor`
- `grayColor`, `grayBackgroundColor`, `grayTextColor`

### `primaryColor`

`primaryColor` 定义在整个 Streamlit 应用中最常使用的强调色。
以下功能和效果使用您的主要颜色：

- 按钮悬停效果
- 焦点中的元素
- 选中的元素

<Tip>

当您的主要颜色用作背景时，Streamlit 将文本颜色更改为白色。例如，这发生在 `type="primary"` 按钮和 `st.multiselect` 中的选中项目上。

为了可读性，请始终选择足够深的主要颜色，以便与白色文本形成良好的对比。

</Tip>

#### 示例 1：主要颜色

以下配置示例具有 `"forestGreen"` 主要颜色。在侧边栏中，配置覆盖主要颜色为 `"darkGoldenrod"`。如果您点击部件内部以使其获得焦点，Streamlit 会在部件周围显示主要颜色边框。此外，如果您悬停在次要和三级按钮上，悬停颜色与主要颜色匹配。

```toml
[theme]
base="dark"
primaryColor="forestGreen"

[theme.sidebar]
primaryColor="darkGoldrod"
```

<Cloud height="350px" name="doc-theming-color-primarycolor"/>

### `backgroundColor`, `secondaryBackgroundColor`, `codeBackgroundColor`, 和 `dataframeHeaderBackgroundColor`

- `backgroundColor` 定义应用的背景色。
- `secondaryBackgroundColor` 用于以下位置的对比：
  - 部件的输入或选择区域的背景
  - `st.help` 和 `st.dataframe` 等元素内的标题（如果未设置 `dataframeHeaderBackgroundColor`）
  - 代码块和行内代码（如果未设置 `codeBackgroundColor`）
- `codeBackgroundColor` 设置代码块和行代码的背景。如果未设置 `codeBackgroundColor`，Streamlit 将使用 `secondaryBackgroundColor`。
- `dataframeHeaderBackgroundColor` 设置数据框标题的背景（包括用于行选择和添加的单元格，如果存在的话）。

<Note>

如果您未定义侧边栏的背景色，Streamlit 将在侧边栏中交换 `backgroundColor` 和 `secondaryBackgroundColor`：

- 如果未定义 `theme.sidebar.backgroundColor`，Streamlit 使用 `theme.secondaryBackgroundColor`。
- 如果未定义 `theme.sidebar.secondaryBackgroundColor`，Streamlit 使用 `theme.backgroundColor`。

</Note>

#### 示例 2：背景色

以下配置示例具有 `"white"` 背景，以及薰衣草色调的 `"ghostWhite"` 侧边栏背景。整个应用的次要颜色是 `"lavender"`，代码背景色是 `"powderBlue"`。代码背景色在 `[theme]` 中配置一次，并在侧边栏中继承。但是，由于 Streamlit 在侧边栏继承背景色时会交换它们，因此次要背景色在 `[theme]` 和 `[theme.sidebar]` 中都设置了。要查看次要颜色用于悬停效果，请悬停在数据框单元格上或打开多选下拉菜单。

```toml
[theme]
base="light"
backgroundColor="white"
secondaryBackgroundColor="lavender"
codeBackgroundColor="powderBlue"

[theme.sidebar]
backgroundColor="ghostWhite"
secondaryBackgroundColor="lavender"
```

<Cloud height="450px" name="doc-theming-color-backgroundcolor"/>

### `textColor`, `codeTextColor`, `linkColor`, 和 `linkUnderline`

您可以配置正文、代码和链接文本的颜色。

`textColor` 设置应用中所有文本的默认文本颜色，除了代码块中的语言高亮、行内代码和链接之外。
`codeTextColor` 设置行内代码的默认文本颜色，但不影响代码块。
`linkColor` 设置应用中所有 Markdown 链接的默认字体颜色。如果 `linkUnderline` 设置为 true（默认值），则链接下划线颜色与 `linkColor` 匹配。

以下元素受 `textColor` 影响：

- Markdown 文本，链接除外
- 代码块中没有通过语言高亮着色的文本
- 应用界面和侧边栏菜单图标
- 部件标签、图标、选项文本和占位符文本
- 数据框和表格文本
- 非 Markdown 链接，如 `st.page_link`、`st.link_button` 和导航菜单

如前所述，当文本显示在您的主要颜色之上时，Streamlit 会将文本颜色更改为白色。

#### 示例 3：文本颜色

以下配置示例在 `"dark"` 基础上具有 `"darkGoldenrod"` 文本和 `"darkOrchid"` 链接。按钮（包括 `st.link_button`）使用 `"darkGoldenrod"` 文本颜色。在多选部件中，占位符文本、下拉菜单和工具提示都具有 `"darkGoldenrod"` 文本。如果您悬停在侧边栏上，滚动条和折叠图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;chevron_left</i>）都是 `"darkGoldenrod"`。

```toml
[theme]
base="dark"
textColor="darkGoldenrod"
linkColor="darkOrchid"
```

<Cloud height="400px" name="doc-theming-color-textcolor"/>

### `baseRadius` 和 `buttonRadius`

`baseRadius` 定义以下元素的边框和背景的半径：

- 部件上的按钮和输入区域
- 选中项目，包括 `st.multiselect` 和导航菜单中的项目
- 代码块和行内代码
- 数据框（外部）
- 徽章和 Markdown 文本背景
- 带边框的容器，包括扩展器、表单、对话框、弹窗和通知
- 工具提示，包括图表内的工具提示
- 状态和异常消息块
- 图像，包括显示为静态图像的 `st.graphviz` 和 `st.pyplot`

`buttonRadius` 为按钮和 `st.segmented_control` 覆盖 `baseRadius`。

有几个元素明显不完全受 `baseRadius` 影响。交互式图表和视频，由于具有更复杂的底层 HTML，将始终具有直角。这包括 `st.video`、`st.map` 和 `st.pydeck_chart`。相反，`st.chat_input` 和 `st.audio_input` 将始终完全圆角。像工具提示这样的子元素仍然受 `baseRadius` 影响。

#### 示例 4：边框半径

在以下配置示例中，应用的主体使用 `"full"`（1rem）基础半径，侧边栏使用 `"none"`（0rem）。为了更好地突出这一差异，示例包括对比鲜明的主要颜色和背景色。

```toml
[theme]
base="light"
primaryColor="slateBlue"
backgroundColor="mintCream"
secondaryBackgroundColor="darkSeaGreen"
baseRadius="full"

[theme.sidebar]
backgroundColor="aliceBlue"
secondaryBackgroundColor="skyBlue"
baseRadius="none"
```

<Cloud height="500px" name="doc-theming-color-baseradius"/>

### `borderColor`, `dataframeBorderColor`, 和 `showWidgetBorder`

Streamlit 默认不显示未聚焦部件的边框（按钮除外）。当用户聚焦于部件时，Streamlit 会在输入区域周围以您的 `primaryColor` 显示边框。当用户移除焦点时，Streamlit 会隐藏边框。

如果设置 `showWidgetBorder=true`，Streamlit 将在部件未聚焦时显示部件边框。对于这些部件，边框颜色由 `borderColor` 设置。如果未设置 `borderColor`，Streamlit 通过向您的 `textColor` 添加透明度来推断颜色。

以下元素具有您可以修改的边框：

- 带边框的容器，包括扩展器、表单、对话框、弹窗和通知
- 侧边栏，包括右边缘和导航菜单下方的边界
- 数据框和表格
- `st.tabs`（底部边框）
- 按钮，包括 `st.button`、`st.pills` 和 `st.segmented_control`
- 输入区域的边框

`dataframeBorderColor` 为数据框和表格覆盖 `borderColor`。

#### 示例 5：边框颜色和可见性

以下配置示例在整个应用中使用 `"mediumSlateBlue"` 边框颜色。在侧边栏中，显示部件边框。在应用的主体中，不显示部件边框，并且除了在聚焦状态下之外，多选、文本或聊天输入区域周围没有边框。但是，许多其他元素，如按钮和数据框，具有始终可见的边框。

```toml
[theme]
base="dark"
borderColor="mediumSlateBlue"
showWidgetBorder=false

[theme.sidebar]
showWidgetBorder=true
```

<Cloud height="420px" name="doc-theming-color-bordercolor"/></named-color>

---

# 在您的 Streamlit 应用中自定义字体

Source: https://docs.streamlit.io/develop/concepts/configuration/theming-customize-fonts


Streamlit 允许您更改和自定义应用中的字体。您可以从公共 URL 加载字体文件，或使用[静态文件服务](/develop/concepts/configuration/serving-static-files)与您的应用一起托管它们。

## 默认 Streamlit 字体

Streamlit 附带 [Source Sans](https://fonts.adobe.com/fonts/source-sans)、[Source Serif](https://fonts.adobe.com/fonts/source-serif) 和 [Source Code](https://fonts.adobe.com/fonts/source-code-pro) 字体。这些字体文件包含在 Streamlit 库中，因此客户端不会从第三方下载它们。默认情况下，Streamlit 对除行内代码和代码块之外的所有文本使用 Source Sans，而行内代码和代码块使用 Source Code。

要使用这些默认字体，您可以在 `config.toml` 中将以下配置选项设置为 `"sans-serif"`（Source Sans）、`"serif"`（Source Serif）或 `"monospace"`（Source Code）：

```toml filename=".streamlit/config.toml"
[theme]
font = "sans-serif"
headingFont = "sans-serif"
codeFont = "monospace"
[theme.sidebar]
font = "sans-serif"
headingFont = "sans-serif"
codeFont = "monospace"
```

您可以在 `config.toml` 的 `[theme]` 表中设置基础字体粗细和大小。这些不能在侧边栏中单独配置。

- `theme.baseFontSize` 设置应用的根字体大小。
- `theme.baseFontWeight` 设置应用的根字体粗细。

以下配置选项可以通过在 `config.toml` 中使用 `[theme.sidebar]` 表而不是 `[theme]` 表为侧边栏单独设置：

- `theme.font` 设置应用中所有文本的默认字体（除行内代码和代码块外）。默认为 `"sans-serif"`（Source Sans）。
- `theme.headingFont` 设置应用中所有标题的默认字体。如果未设置此项，Streamlit 将使用 `theme.font`。
- `theme.headingFontSizes` 设置 `<h1>`-`<h6>` 标题的字体大小。
- `theme.headingFontWeights` 设置 `<h1>`-`<h6>` 标题的字体粗细。
- `theme.codeFont` 设置所有行内代码和代码块的默认字体。默认为 `"monospace"`（Source Code）。
- `theme.codeFontSize` 设置代码块中、`st.json` 和 `st.help`（但不包括行内代码）的代码文本大小。
- `theme.codeFontWeight` 设置代码块中、`st.json` 和 `st.help`（但不包括行内代码）的代码文本粗细。

当未在 `[theme.sidebar]` 中声明字体时，Streamlit 将在默认为较不具体的选项之前从 `[theme]` 继承每个选项。例如，如果未设置 `theme.sidebar.headingFont`，Streamlit 将按优先顺序使用 `theme.headingFont`、`theme.sidebar.font` 或 `theme.font`。

在以下 `config.toml` 示例中，Streamlit 在应用主体中使用 Source Serif，在侧边栏中使用 Source Sans。

```toml filename=".streamlit/config.toml"
[theme]
font = "serif"
[theme.sidebar]
font = "sans-serif"
```

## 外部托管字体

如果您使用像 Google Fonts 或 Adobe Fonts 这样的字体服务，您可以通过将字体系列（名称）和 CSS URL 编码为 `{font_name}:{css_url}` 形式的单个字符串直接使用这些字体。如果您的字体系列包含空格，请在字体系列上使用内引号。在以下 `config.toml` 示例中，Streamlit 对除代码外的所有文本使用 Nunito 字体，而代码则使用 Space Mono。Space Mono 有内引号，因为它有空格。

```toml filename=".streamlit/config.toml"
[theme]
font = "Nunito:https://fonts.googleapis.com/css2?family=Nunito=swap"
codeFont = "'Space Mono':https://fonts.googleapis.com/css2?family=Space+Mono=swap"
```

<Important>

如果您将应用配置为包含任何第三方集成，包括外部托管的字体，您的应用可能会将用户数据（例如 IP 地址）传输到外部服务器。作为应用开发人员，您有责任通知用户这些第三方集成，提供相关隐私政策的访问途径，并确保遵守所有适用的数据保护法律和法规。

</Important>

## 托管替代字体

如果您有要与应用一起托管的字体文件，则必须在 `config.toml` 下的 `[[theme.fontFaces]]` 中声明字体。对于多个替代字体，在配置文件中声明多个 `[[theme.fontFaces]]` 表。您可以使用 Streamlit 静态文件服务自托管字体，或者可以指向公开托管的字体文件。

<Important>

Streamlit 支持对 OTF、TTF、WOFF 和 WOFF2 字体文件格式的自托管。其他字体文件格式必须外部托管。

</Important>

字体在其 `[[theme.fontFaces]]` 表中使用以下属性定义：

- `family`: 这是字体的名称，用于标识字体以供其他配置选项使用。
- `url`: 这是字体文件的位置。如果您与应用一起自托管字体文件，该值将类似于 `"app/static/font_file.woff"`。
- `weight`（可选）：这声明了字体文件中字体的粗细（例如 `400`、`"200 800"` 或 `"bold"`）。更多信息，请参见 [`font-weight`](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-weight) CSS `@font-face` 描述符。
- `style`（可选）：这声明了字体文件中字体的样式（例如 `"normal"`、`"italic"` 或 `"oblique"`）。更多信息，请参见 [`font-style`](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-style) CSS `@font-face` 描述符。
- `unicodeRange`（可选）：这声明了字体文件中的特定字符范围（例如 `"U+0025-00FF, U+4??"`）。更多信息，请参见 [`unicode-range`](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range) CSS `@font-face` 描述符。

<Note>

字体文件可以是静态的或可变的。静态字体文件包含单个粗细和样式。如果您使用静态字体文件，通常需要加载多个文件以在不同粗细（常规、粗体）和样式（常规、斜体）中完全支持字体。可变字体文件参数化一个或多个字体属性，这意味着单个字体文件可以支持多种粗细和样式。

</Note>

### 示例 1：使用可变字体文件定义替代字体

以下示例使用静态文件服务托管 Google 的 [Noto Sans](https://fonts.google.com/noto/specimen/Noto+Sans) 和 [Noto Sans Mono](https://fonts.google.com/noto/specimen/Noto+Sans+Mono) 字体，并配置应用使用它们。这两种字体都使用包含参数化粗细的可变字体文件定义。然而，由于字体样式没有参数化，Noto Sans 需要两个文件来分别定义常规和斜体样式。Noto Sans Mono 不包含其斜体样式的单独文件。根据 [CSS 规则](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style#italic)，如果没有显式提供斜体样式，它将通过倾斜常规样式字体来模拟。

此示例的逐行解释可在[教程](/develop/tutorials/configuration-and-theming/variable-fonts)中获得。

```toml filename=".streamlit/config.toml"
[server]
enableStaticServing = true

[[theme.fontFaces]]
family="noto-sans"
url="app/static/NotoSans-Italic-VariableFont_wdth,wght.ttf"
style="italic"
[[theme.fontFaces]]
family="noto-sans"
url="app/static/NotoSans-VariableFont_wdth,wght.ttf"
style="normal"
[[theme.fontFaces]]
family="noto-mono"
url="app/static/NotoSansMono-VariableFont_wdth,wght.ttf"

[theme]
font="noto-sans"
codeFont="noto-mono"
```

```none filename="Directory structure"
project_directory/
├── .streamlit/
│   └── config.toml
├── static/
│   ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
│   ├── NotoSans-VariableFont_wdth,wght.ttf
│   └── NotoSansMono-VariableFont_wdth,wght.ttf
└── streamlit_app.py
```

### 示例 2：使用静态字体文件定义替代字体

在此配置示例中，使用多个静态字体文件声明替代字体。要覆盖基本 Markdown 格式，每种字体至少应有四个静态文件来定义以下粗细-样式对：

- normal normal
- normal bold
- italic normal
- italic bold

如果您的应用使用没有匹配粗细-样式定义的字体，用户的浏览器将使用最接近的可用字体。`<h2>`-`<h6>` 标题的默认粗细为半粗体（600）。为了完整性，包含额外的字体文件以覆盖半粗体粗细和应用中的所有字体粗细。以下示例使用 [Tuffy](https://fonts.google.com/specimen/Tuffy) 字体。该字体有四个静态字体文件，覆盖四种粗细-样式对。

此示例的逐行解释可在[教程](/develop/tutorials/configuration-and-theming/static-fonts)中获得。

```toml filename=".streamlit/config.toml"
[server]
enableStaticServing = true

[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Regular.ttf"
style="normal"
weight=400
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Bold.ttf"
style="normal"
weight=700
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Italic.ttf"
style="italic"
weight=400
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-BoldItalic.ttf"
style="italic"
weight=700

[theme]
font="tuffy"
```

```none filename="Directory structure"
project_directory/
├── .streamlit/
│   └── config.toml
├── static/
│   ├── Tuffy-Bold.ttf
│   ├── Tuffy-BoldItalic.ttf
│   ├── Tuffy-Italic.ttf
│   └── Tuffy-Regular.ttf
└── streamlit_app.py
```

## 字体回退

如果您使用可能与所有浏览器不兼容的复杂字体，或者如果您使用外部托管字体，最佳做法是包含字体回退。

### 示例 3：定义带有回退的替代字体

在您的配置文件中，无论您在哪里声明默认字体，您都可以使用逗号分隔的字体列表代替。字体（或逗号分隔的字体列表）传递给 CSS [`font-family`](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) 属性。

您始终可以包含 Streamlit 的默认字体之一作为最终回退。以下示例使用 [Nunito](https://fonts.google.com/specimen/Nunito) 和 [Space Mono](https://fonts.google.com/specimen/Space+Mono) 字体。配置文件指向 Google 托管的字体文件，并将 Streamlit 的内置字体标识为备份。

此示例的逐行解释可在[教程](/develop/tutorials/configuration-and-theming/external-fonts)中获得。

```toml filename=".streamlit/config.toml"
[theme]
font="Nunito:https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000, sans-serif"
codeFont="'Space Mono':https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700=swap, monospace"
```

<Tip>

如果您的任何字体系列名称包含空格且您正在声明回退序列，请在名称周围使用内引号。例如，如果将字体命名为 `"Nunito Sans"`，请使用 `font="'Nunito Sans', sans-serif"`。

</Tip>

## 字体大小

您可以用像素设置应用的基础字体大小。必须将基础字体大小指定为整数。以下配置相当于 16 像素的默认基础字体大小：

```toml filename=".streamlit/config.toml"
[theme]
baseFontSize=16
```

此外，您可以设置代码块的字体大小。字体大小可以以像素或 rem 声明。以下配置相当于 0.875rem 的默认代码字体大小。

```toml filename=".streamlit/config.toml"
[theme]
codeFontSize="0.875rem"
```

<Note>

Markdown 中的行内代码不受 `theme.codeFontSize` 影响。行内代码设置为 0.75em。

</Note>

## 字体颜色

字体颜色选项在[在 Streamlit 应用中自定义颜色和边框](/develop/concepts/configuration/theming-customize-colors-and-borders#textcolor-and-linkcolor)中描述。

## 设计提示

在 Streamlit 应用中使用替代字体时，请牢记良好的设计实践。字体的可读性受其大小、与背景的对比度和形状的强烈影响。Streamlit 允许您为标题声明与其余文本不同的字体。如果您引入更精美的字体，请将其限制在标题中。由于 `theme.font` 和 `theme.sidebar.font` 用于设置部件标签、工具提示、列标题和数据框单元格中的字体，它们始终应该是高度可读的字体。

获取灵感，请参见 [Fonts in Use](https://fontsinuse.com/)。</h6></h2></h6></h1></h6></h1>

---

# 使用连接、密钥和用户认证

Source: https://docs.streamlit.io/develop/concepts/connections


<TileContainer layout="list">
<RefCard href="/develop/concepts/connections/connecting-to-data">
<h5>连接到数据</h5>

将您的应用连接到远程数据或第三方 API。

</RefCard>
<RefCard href="/develop/concepts/connections/secrets-management">
<h5>密钥管理</h5>

设置您的开发环境并设计您的应用以安全处理密钥。

</RefCard>
<RefCard href="/develop/concepts/connections/authentication">
<h5>认证和用户信息</h5>

使用 OpenID Connect 提供商认证用户并个性化您的应用。

</RefCard>
<RefCard href="/develop/concepts/connections/security-reminders">
<h5>安全提醒</h5>

查看一些遵循最佳实践并避免安全错误的提醒。

</RefCard>
</TileContainer>

---

# 用户身份验证和信息

Source: https://docs.streamlit.io/develop/concepts/connections/authentication


为您的用户个性化您的应用是让您的应用更具吸引力的好方法。

用户身份验证和个性化为开发人员解锁了大量的用例，包括管理员控制、个性化的股票行情、或具有保存历史记录的会话间聊天机器人应用。

在阅读本指南之前，您应该对[secrets 管理](/develop/concepts/connections/secrets-management)有基本了解。

## OpenID Connect

Streamlit 支持使用 OpenID Connect (OIDC) 进行用户身份验证，这是一种构建在 OAuth 2.0 之上的身份验证协议。OIDC 支持身份验证，但不支持授权：即，OIDC 连接告诉您用户是_谁_（身份验证），但不会给您_模拟_他们的权限（授权）。如果您需要连接通用 OAuth 2.0 提供商或让您的应用代表用户执行操作，请考虑使用或创建自定义组件。

一些流行的 OIDC 提供商包括：

- [Google Identity](https://developers.google.com/identity/openid-connect/openid-connect)
- [Microsoft Entra ID](https://learn.microsoft.com/en-us/power-pages/security/authentication/openid-settings)
- [Okta](https://help.okta.com/en-us/content/topics/apps/apps_app_integration_wizard_oidc.htm)
- [Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps)

## `st.login()`、`st.user` 和 `st.logout()`

用户身份验证涉及三个命令：

- [`st.login()`](/develop/api-reference/user/st.login) 将用户重定向到您的身份提供商。他们在登录后，Streamlit 会存储一个身份 Cookie，然后将他们重定向到您的应用的新会话主页。
- [`st.user`](/develop/api-reference/user/st.user) 是一个类字典对象，用于访问用户信息。它有一个持久属性 `.is_logged_in`，您可以用来检查用户的登录状态。当他们登录时，其他属性将根据您的身份提供商配置可用。
- [`st.logout()`](/develop/api-reference/user/st.logout) 从用户的浏览器中删除身份 Cookie，并将他们重定向到您的应用的新会话主页。

## 用户 Cookie 和登出

Streamlit 在每个新会话开始时检查身份 Cookie。如果用户在一个标签页中登录您的应用，然后打开新标签页，他们将自动在新标签页中登录您的应用。当您在用户会话中调用 `st.logout()` 时，Streamlit 会删除身份 Cookie 并启动新会话。这会使用户从当前会话登出。但是，如果他们已经在其他会话中登录，他们将在那些会话中保持登录状态。`st.user` 中的信息在会话开始时更新（这就是为什么 `st.login()` 和 `st.logout()` 都在保存或删除身份 Cookie 后启动新会话的原因）。

如果用户在不登出的情况下关闭您的应用，身份 Cookie 将在 30 天后过期。此过期时间不可配置，且与用户身份令牌中可能返回的任何过期时间无关。如果您需要防止在您的应用中持久身份验证，请检查 `st.user` 中身份提供商返回的过期信息，并在需要时手动调用 `st.logout()`。

Streamlit 不会修改或删除直接由您的身份提供商保存的任何 Cookie。例如，如果您使用 Google 作为身份提供商，用户使用 Google 登录您的应用，他们在使用 `st.logout()` 从您的应用登出后，仍将保持登录到他们的 Google 账户。

## 设置身份提供商

为了使用身份提供商，您必须首先通过管理员账户配置您的身份提供商。这通常涉及在身份提供商系统中设置客户端或应用程序。请遵循您身份提供商的文档。总的来说，身份提供商客户端通常执行以下操作：

- 管理您的用户列表。
- 可选：允许用户将自己添加到您的用户列表。
- 声明从每个用户账户传递到客户端的属性集（然后传递到您的 Streamlit 应用）。
- 仅允许来自您的 Streamlit 应用的身份验证请求。
- 在用户认证后将用户重定向回您的 Streamlit 应用。

要配置您的应用，您需要以下内容：

- 您的应用的 URL
  例如，对于大多数本地开发情况，使用 `http://localhost:8501`。
- 重定向 URL，这是您的应用 URL 带有路径名 `oauth2callback`
  例如，对于大多数本地开发情况，使用 `http://localhost:8501/oauth2callback`。
- Cookie 密钥，这应该是一个强随机生成的字符串

在使用此信息配置您的身份提供商客户端后，您将从身份提供商收到以下信息：

- 客户端 ID
- 客户端密钥
- 服务器元数据 URL

流行的 OIDC 提供商配置示例在 `st.login()` 的 API 参考中列出。

## 在 Streamlit 中配置您的 OIDC 连接

在配置好身份提供商客户端后，您也需要配置您的 Streamlit 应用。`st.login()` 使用您的应用的 `secrets.toml` 文件配置您的连接，类似于 `st.connection()` 的工作方式。

无论您有一个 OIDC 提供商还是多个，您都需要在 `secrets.toml` 中有一个 `[auth]` 字典。您必须在 `[auth]` 字典中声明 `redirect_uri` 和 `cookie_secret`。这两个值在您的应用中的所有 OIDC 提供商之间共享。

如果您只使用一个 OIDC 提供商，可以将剩余三个属性（`client_id`、`client_secret` 和 `server_metadata_url`）放在 `[auth]` 中。但是，如果您使用多个提供商，它们应该各自具有唯一名称，以便您可以将它们的唯一值声明在各自的字典中。例如，如果您将连接命名为 `"connection_1"` 和 `"connection_2"`，请将它们的剩余属性分别放在名为 `[auth.connection_1]` 和 `[auth.connection_2]` 的字典中。

## 简单示例

如果您使用 Google Identity 作为身份提供商，本地开发的基本配置将如下 TOML 文件所示：

`.streamlit/secrets.toml`:

```toml
[auth]
redirect_uri = "http://localhost:8501/oauth2callback"
cookie_secret = "xxx"
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://accounts.google.com/.well-known/openid-configuration"
```

确保 `redirect_uri` 中的端口与您使用的端口匹配。`cookie_secret` 应该是一个强随机生成的密钥。`redirect_uri` 和 `cookie_secret` 都应该已输入到 Google Cloud 上的客户端配置中。您必须在创建客户端后从 Google Cloud 复制 `client_id` 和 `client_secret`。对于某些身份提供商，`server_metadata_url` 可能对您的客户端是唯一的。但对于 Google Cloud，OIDC 客户端共享单个 URL。

在您的应用中，创建一个简单的登录流程：

```python
import streamlit as st

if not st.user.is_logged_in:
    if st.button("使用 Google 登录"):
        st.login()
    st.stop()

if st.button("登出"):
    st.logout()
st.markdown(f"欢迎！{st.user.name}")
```

当您使用 `st.stop()` 时，您的脚本运行在显示登录按钮时结束。这可以让您避免将整个页面嵌套在条件块中。此外，您可以使用回调进一步简化代码：

```python
import streamlit as st

if not st.user.is_logged_in:
    st.button("使用 Google 登录", on_click=st.login)
    st.stop()

st.button("登出", on_click=st.logout)
st.markdown(f"欢迎！{st.user.name}")
```

## 使用多个 OIDC 提供商

如果您使用多个 OIDC 提供商，您需要为每个提供商声明一个唯一名称。如果您想使用 Google Identity 和 Microsoft Entra ID 作为同一应用的两个提供商，本地开发的配置将如下 TOML 文件所示：

`.streamlit/secrets.toml`:

```toml
[auth]
redirect_uri = "http://localhost:8501/oauth2callback"
cookie_secret = "xxx"

[auth.google]
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://accounts.google.com/.well-known/openid-configuration"

[auth.microsoft]
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://login.microsoftonline.com/{tenant}/v2.0/.well-known/openid-configuration"
```

Microsoft 的服务器元数据 URL 根据客户端的作用域略有不同。将 `{tenant}` 替换为 Microsoft 文档中[OpenID 配置](https://learn.microsoft.com/en-us/entra/identity-platform/v2-protocols-oidc#find-your-apps-openid-configuration-document-uri)描述的适当值。

您的应用代码：

```python
import streamlit as st

if not st.user.is_logged_in:
    if st.button("使用 Google 登录"):
        st.login("google")
    if st.button("使用 Microsoft 登录"):
        st.login("microsoft")
    st.stop()

if st.button("登出"):
    st.logout()
st.markdown(f"欢迎！{st.user.name}")
```

使用回调，这看起来像：

```python
import streamlit as st

if not st.user.is_logged_in:
    st.button("使用 Google 登录", on_click=st.login, args=["google"])
    st.button("使用 Microsoft 登录", on_click=st.login, args=["microsoft"])
    st.stop()

st.button("登出", on_click=st.logout)
st.markdown(f"欢迎！{st.user.name}")
```

## 向您的身份提供商传递关键字

要自定义身份提供商的行为，您可能需要声明额外的关键字。有关 OIDC 参数的完整列表，请参见 [OpenID Connect Core](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) 和您的提供商文档。默认情况下，Streamlit 设置 `scope="openid profile email"` 和 `prompt="select_account"`。您可以通过将设置字典传递给 `client_kwargs` 来更改这些和其他 OIDC 参数。用于安全性的 `state` 和 `nonce` 会自动处理，无需指定。

例如，如果您使用 Auth0 并且需要强制用户每次都登录，请使用 Auth0 [自定义注册和登录提示](https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts)中描述的 `prompt="login"`。您的配置将如下所示：

```toml
[auth]
redirect_uri = "http://localhost:8501/oauth2callback"
cookie_secret = "xxx"

[auth.auth0]
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://{account}.{region}.auth0.com/.well-known/openid-configuration"
client_kwargs = { "prompt" = "login" }
```

<Note>
  GitHub Codespaces 等托管代码环境具有额外的安全控制措施，阻止登录重定向被正确处理。
</Note>

---

# 连接到数据

Source: https://docs.streamlit.io/develop/concepts/connections/connecting-to-data


大多数 Streamlit 应用都需要某种数据或 API 访问才有用 - 要么检索数据显示，要么保存某些用户操作的结果。这种数据或 API 通常是某种远程服务、数据库或其他数据源的一部分。

**您可以使用 Python 执行的任何操作，包括数据连接，通常都可以在 Streamlit 中工作**。Streamlit 的[教程](/develop/tutorials/databases)是许多数据源的良好起点。然而：

- 在 Python 应用程序中连接到数据通常很繁琐且烦人。
- 从 Streamlit 应用连接到数据有特定的考虑因素，例如缓存和 secrets 管理。

**Streamlit 提供了 [`st.connection()`](/develop/api-reference/connections/st.connection) 来更轻松地将 Streamlit 应用连接到数据和 API，只需几行代码**。此页面提供了使用此功能的基本示例，然后专注于高级用法。

要全面了解此功能，请查看 Streamlit 开发者体验产品经理 Joshua Carroll 的视频教程。您将通过真实示例了解此功能在创建和管理应用内数据连接方面的实用性。

<YouTube videoId="xQwDfW7UHMo"/>

## 基本用法

有关基本入门和使用示例，请阅读相关的[数据源教程](/develop/tutorials/databases)。Streamlit 有对 SQL 方言和 Snowflake 的内置连接。我们还维护可安装的[云文件存储](https://github.com/streamlit/files-connection)和[Google 表格](https://github.com/streamlit/gsheets-connection)连接。

如果您刚开始，最好的学习方法是选择您可以访问的数据源，并从上面的页面之一获取最小示例 👆。在这里，我们将提供一个使用 SQLite 数据库的超最小用法示例。之后，本页面的其余部分将专注于高级用法。

### 一个简单起点 - 使用本地 SQLite 数据库

[本地 SQLite 数据库](https://sqlite.org/index.html) 可能对您的应用的半持久数据存储有用。

<Note>

社区云应用不保证本地文件存储的持久性，因此平台可能随时删除使用此技术存储的数据。

</Note>

要查看下面运行的示例，请查看下面的交互式演示：

<Cloud height="600px" name="experimental-connection" path="SQL"/>

#### 步骤 1：安装先决条件库 - SQLAlchemy

Streamlit 中的所有 SQLConnection 都使用 SQLAlchemy。对于大多数其他 SQL 方言，您还需要安装驱动程序。但[SQLite 驱动程序随 python3 一起提供](https://docs.python.org/3/develop/sqlite3.html)，所以不需要。

```bash
pip install SQLAlchemy==1.4.0
```

#### 步骤 2：在您的 Streamlit secrets.toml 文件中设置数据库 URL

在您的应用将从中运行的同一目录中创建目录和文件 `.streamlit/secrets.toml`。将以下内容添加到文件中。

```toml
# .streamlit/secrets.toml

[connections.pets_db]
url = "sqlite:///pets.db"
```

#### 步骤 3：在您的应用中使用连接

以下应用创建到数据库的连接，使用它创建表并插入一些数据，然后查询数据并将其显示在数据框中。

```python
# streamlit_app.py

import streamlit as st

# 创建到 pets_db 的 SQL 连接，如您的 secrets 文件中指定的那样。
conn = st.connection('pets_db', type='sql')

# 使用 conn.session 插入一些数据。
with conn.session as s:
    s.execute('CREATE TABLE IF NOT EXISTS pet_owners (person TEXT, pet TEXT);')
    s.execute('DELETE FROM pet_owners;')
    pet_owners = {'jerry': 'fish', 'barbara': 'cat', 'alex': 'puppy'}
    for k in pet_owners:
        s.execute(
            'INSERT INTO pet_owners (person, pet) VALUES (:owner, :pet);',
            params=dict(owner=k, pet=pet_owners[k])
        )
    s.commit()

# 查询并显示您插入的数据
pet_owners = conn.query('select * from pet_owners')
st.dataframe(pet_owners)
```

在此示例中，我们没有在调用 [`conn.query()`](/develop/api-reference/connections/st.connections.sqlconnection#sqlconnectionquery) 时设置 `ttl=` 值，这意味着只要应用服务器运行，Streamlit 就会无限期地缓存结果。

现在，让我们讨论更多高级主题！🚀

## 高级主题

### 全局 secrets，管理多个应用和多个数据存储

Streamlit [支持在用户主目录中指定的全局 secrets 文件](/develop/concepts/connections/secrets-management)，例如 `~/.streamlit/secrets.toml`。如果您构建或管理多个应用，我们建议在跨应用的本地开发中使用全局凭证或 secrets 文件。使用这种方法，您只需要在一个地方设置和管理您的凭证，将新应用连接到现有数据源实际上就是一行代码。它还降低了意外将您的凭证签入 git 的风险，因为它们不需要存在于项目仓库中。

对于在本地开发期间连接到多个类似数据源的情况（例如本地与暂存数据库），您可以在您的 secrets 或凭证文件中为不同环境定义不同的连接部分，然后在运行时决定使用哪个。`st.connection` 支持使用 _`name=env:<MY_NAME_VARIABLE>`_ 语法来实现此功能。

例如，假设我有一个本地和一个暂存 MySQL 数据库，希望在不同时间将我的应用连接到其中一个。我可以创建一个全局 secrets 文件，如下所示：

```toml
# ~/.streamlit/secrets.toml

[connections.local]
url = "mysql://me:****@localhost:3306/local_db"

[connections.staging]
url = "mysql://jdoe:******@staging.acmecorp.com:3306/staging_db"
```

然后我可以将我的应用连接配置为从指定的环境变量获取其名称

```python
# streamlit_app.py
import streamlit as st

conn = st.connection("env:DB_CONN", "sql")
df = conn.query("select * from mytable")
# ...
```

现在我可以通过设置 `DB_CONN` 环境变量来指定在运行时连接到本地还是暂存环境。

```bash
# 连接到本地
DB_CONN=local streamlit run streamlit_app.py

# 连接到暂存环境
DB_CONN=staging streamlit run streamlit_app.py
```

### 高级 SQLConnection 配置

[SQLConnection](/develop/api-reference/connections/st.connections.sqlconnection) 配置使用 SQLAlchemy `create_engine()` 函数。它将接受单个 URL 参数或尝试使用 [`SQLAlchemy.engine.URL.create()`](https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.engine.URL.create) 从几个部分（用户名、数据库、主机等）构造 URL。

几种流行的 SQLAlchemy 方言，如 Snowflake 和 Google BigQuery，可以使用除 URL 之外的附加参数进行配置到 `create_engine()`。这些可以直接作为 `**kwargs` 传递给 [st.connection](/develop/api-reference/connections/st.connection) 调用，或在名为 `create_engine_kwargs` 的附加 secrets 部分中指定。

例如，snowflake-sqlalchemy 接受附加的 [`connect_args`](https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine.params.connect_args) 参数作为字典，用于 URL 中不支持的配置。这些可以如下指定：

```toml
# .streamlit/secrets.toml

[connections.snowflake]
url = "snowflake://<user_login_name>@<account_identifier>/"

[connections.snowflake.create_engine_kwargs.connect_args]
authenticator = "externalbrowser"
warehouse = "xxx"
role = "xxx"
```

```python
# streamlit_app.py

import streamlit as st

# 上面 secrets.toml 中的 url 和 connect_args 将被获取并使用
conn = st.connection("snowflake", "sql")
# ...
```

或者，这可以完全在 `**kwargs` 中指定。

```python
# streamlit_app.py

import streamlit as st

# 不需要 secrets.toml
conn = st.connection(
    "snowflake",
    "sql",
    url = "snowflake://<user_login_name>@<account_identifier>/",
    connect_args = dict(
        authenticator = "externalbrowser",
        warehouse = "xxx",
        role = "xxx",
    )
)
# ...
```

您也可以同时提供 kwargs 和 secrets.toml 值，它们将被合并（通常 kwargs 优先）。

### 在频繁使用或长时间运行的应用中的连接考虑

默认情况下，连接对象使用 [`st.cache_resource`](/develop/api-reference/caching-and-state/st.cache_resource) 进行缓存，没有过期时间。在大多数情况下这是期望的。如果希望连接对象在一段时间后过期，可以执行 `st.connection('myconn', type=MyConnection, ttl=<N>)`。

许多连接类型预期是长期运行的或完全无状态的，因此不需要过期。假设连接变陈旧（例如缓存的令牌过期或服务器端连接被关闭）。在这种情况下，每个连接都有一个 `reset()` 方法，它将使缓存的版本失效，并导致 Streamlit 在下次检索时重新创建连接。

像 `query()` 和 `read()` 这样的便利方法通常默认使用 [`st.cache_data`](/develop/api-reference/caching-and-state/st.cache_data) 缓存结果而不设过期时间。当应用可以运行许多具有大结果的不同读取操作时，随着时间的推移可能导致高内存使用，结果在长时间运行的应用中变陈旧，这与使用任何其他 `st.cache_data` 的情况相同。对于生产用例，我们建议在这些读取操作上设置适当的 `ttl`，例如 `conn.read('path/to/file', ttl="1d")`。请参阅[缓存](/develop/concepts/architecture/caching)以获取更多信息。

对于可能获得显著并发使用的应用，请确保您了解连接的任何线程安全含义，特别是在使用第三方构建的连接时。Streamlit 构建的连接应默认提供线程安全操作。

### 构建自己的连接

在大多数情况下，使用现有驱动程序或 SDK 构建自己的基本连接实现非常简单。但是，您可以通过进一步努力添加更复杂的功能。这种自定义实现是将支持扩展到新数据源并为 Streamlit 生态系统做贡献的好方法。

为具有频繁使用的访问模式和数据源的组织维护跨多个应用的定制内部连接实现可能是一种强大的实践。

查看下面 st.experimental 连接演示应用中的[构建您自己的连接页面](https://experimental-connection.streamlit.app/Build_your_own)以获取快速教程和工作实现。此演示在 DuckDB 之上构建了一个最小但功能非常完善的连接。

<Cloud height="600px" name="experimental-connection" path="Build_your_own"/>

典型步骤是：

1. 声明 Connection 类，扩展 [`ExperimentalBaseConnection`](/develop/api-reference/connections/st.connections.experimentalbaseconnection)，并将类型参数绑定到底层连接对象：

   ```python
   from streamlit.connections import ExperimentalBaseConnection
   import duckdb

   class DuckDBConnection(ExperimentalBaseConnection[duckdb.DuckDBPyConnection])
   ```

2. 实现 `_connect` 方法，该方法读取任何 kwargs、外部配置/凭证位置和 Streamlit secrets 以初始化底层连接：

   ```python
   def _connect(self, **kwargs) -&gt; duckdb.DuckDBPyConnection:
       if 'database' in kwargs:
           db = kwargs.pop('database')
       else:
           db = self._secrets['database']
       return duckdb.connect(database=db, **kwargs)
   ```

3. 添加对您的连接有用的辅助方法（在需要缓存的地方用 `st.cache_data` 包装）

### 连接构建最佳实践

我们建议应用以下最佳实践，使您的连接与 Streamlit 内置连接和更广泛的 Streamlit 生态系统保持一致。对于您打算公开分发的连接，这些实践尤其重要。

1. **扩展现有驱动程序或 SDK，并默认采用对现有用户有意义的语义。**

   在构建连接时，很少需要从零开始实现复杂的数据访问逻辑。尽可能使用现有的流行 Python 驱动程序和客户端。这样做使您的连接更容易维护、更安全，并使用户能够获得最新功能。例如，[SQLConnection](/develop/api-reference/connections/st.connections.sqlconnection) 扩展 SQLAlchemy，[FileConnection](https://github.com/streamlit/files-connection) 扩展 [fsspec](https://filesystem-spec.readthedocs.io/en/latest/)，[GsheetsConnection](https://github.com/streamlit/gsheets-connection) 扩展 [gspread](https://docs.gspread.org/en/latest/) 等。

   考虑使用与底层包一致的访问模式、方法/参数命名和返回值，并熟悉该包现有用户的习惯。

2. **直观、易于使用的读取方法。**

   st.connection 的大部分功能在于提供直观、易于使用的读取方法，使应用开发人员能够快速开始。大多数连接应至少公开一个读取方法，该方法：
   - 用简单动词命名，如 `read()`、`query()` 或 `get()`
   - 默认情况下由 `st.cache_data` 包装，至少支持 `ttl=` 参数
   - 如果结果是表格格式，则返回 pandas DataFrame
   - 提供常用的关键字参数（如分页或格式化）并带有合理的默认值 - 理想情况下，常见情况只需要 1-2 个参数。

3. **配置、secrets 和 `_connect` 方法中的优先级。**

   每个连接都应该支持通过 Streamlit secrets 和关键字参数提供的常用连接参数。名称应与初始化或配置底层包时使用的名称匹配。

   此外，在相关的情况下，连接应支持通过现有的标准环境变量或配置/凭证文件进行数据源特定配置。在许多情况下，底层包提供已经可以轻松处理此问题的构造函数或工厂函数。

   当您可以在多个地方指定相同的连接参数时，我们建议在可能的情况下使用以下优先级顺序（从高到低）：
   - 代码中指定的关键字参数
   - Streamlit secrets
   - 数据源特定配置（如适用）

4. **处理线程安全和陈旧连接。**

   连接应在实践中提供线程安全操作（大多数时候都是如此）并清楚地记录与此相关的任何注意事项。大多数底层驱动程序或 SDK 应提供线程安全对象或方法 - 请尽可能使用这些。

   如果底层驱动程序或 SDK 有状态连接对象变陈旧或无效的风险，请考虑在访问方法中构建低影响健康检查或重置/重试模式。内置到 Streamlit 中的 SQLConnection 有一个很好的示例，使用 [tenacity](https://tenacity.readthedocs.io/) 和内置的 [Connection.reset()](/develop/api-reference/connections/st.connections.sqlconnection#sqlconnectionreset) 方法。另一种方法是鼓励开发人员在 `st.connection()` 调用上设置适当的 TTL，以确保定期重新初始化连接对象。</N></account_identifier></user_login_name></account_identifier></user_login_name></MY_NAME_VARIABLE>

---

# Secrets 管理

Source: https://docs.streamlit.io/develop/concepts/connections/secrets-management


在 git 仓库中存储未加密的 secrets 是一种不良实践。对于需要访问敏感凭证的应用程序，推荐的解决方案是将这些凭证存储在仓库外部 - 例如使用不提交到仓库的凭证文件或将它们作为环境变量传递。

Streamlit 提供了基于文件的原生 secrets 管理，以便在您的 Streamlit 应用中轻松存储和安全访问您的 secrets。

<Note>

现有的 secrets 管理工具，例如 [dotenv 文件](https://pypi.org/project/python-dotenv/)、[AWS 凭证文件](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#configuring-credentials)、[Google Cloud Secret Manager](https://pypi.org/project/google-cloud-secret-manager/) 或 [Hashicorp Vault](https://www.vaultproject.io/use-cases/secrets-management)，在 Streamlit 中都能正常工作。我们只是在需要时添加了原生 secrets 管理。

</Note>

## 如何使用 secrets 管理

### 本地开发并设置 secrets

Streamlit 提供了两种使用 [TOML](https://toml.io/en/latest) 格式在本地设置 secrets 的方法：

1. 在**全局 secrets 文件**中，位于 `~/.streamlit/secrets.toml`（macOS/Linux）或 `%userprofile%/.streamlit/secrets.toml`（Windows）：

   ```toml
   # 此部分中的所有内容都将作为环境变量提供
   db_username = "Jane"
   db_password = "mypassword"

   # 您也可以添加其他部分（如果愿意）。
   # 如下所示的部分内容不会成为环境变量，
   # 但无论如何它们很容易从 Streamlit 内部访问，正如
   # 本文档后面所展示的那样。
   [my_other_secrets]
   things_i_like = ["Streamlit", "Python"]
   ```

   如果您使用全局 secrets 文件，当多个 Streamlit 应用共享相同 secrets 时，您不必在多个项目级文件中重复 secrets。

2. 在**每个项目的 secrets 文件**中，位于 `$CWD/.streamlit/secrets.toml`，其中 `$CWD` 是您运行 Streamlit 的文件夹。如果全局 secrets 文件和每个项目的 secrets 文件都存在，_项目级文件中的 secrets 将覆盖全局文件中定义的 secrets_。

<Important>

将此文件添加到您的 `.gitignore` 中，以免您提交 secrets！

</Important>

### 在您的应用中使用 secrets

通过查询 `st.secrets` 字典或作为环境变量访问您的 secrets。例如，如果您输入上面部分中的 secrets，以下代码展示了如何在您的 Streamlit 应用中访问它们。

```python
import streamlit as st

# 所有内容都可以通过 st.secrets 字典访问：

st.write("数据库用户名:", st.secrets["db_username"])
st.write("数据库密码:", st.secrets["db_password"])

# 根级别的 secrets 也可以作为环境变量访问：

import os

st.write(
    "环境变量是否已设置:",
    os.environ["db_username"] == st.secrets["db_username"],
)
```

<Tip>

除了键表示法（例如 `st.secrets["key"]`）外，您还可以使用属性表示法（例如 `st.secrets.key`）访问 `st.secrets` — 像 [st.session_state](/develop/api-reference/caching-and-state/st.session_state) 一样。

</Tip>

您甚至可以紧凑地使用 TOML 部分将多个 secrets 作为一个属性传递。考虑以下 secrets：

```toml
[db_credentials]
username = "my_username"
password = "my_password"
```

而不是将每个 secrets 作为函数中的属性传递，您可以更紧凑地传递部分以实现相同结果。请参见下面的概念代码，它使用了上面的 secrets：

```python
# 详细版本
my_db.connect(username=st.secrets.db_credentials.username, password=st.secrets.db_credentials.password)

# 更紧凑的版本！
my_db.connect(**st.secrets.db_credentials)
```

### 错误处理

以下是使用 secrets 管理时可能遇到的一些常见错误。

- 如果在应用运行时创建了 `.streamlit/secrets.toml`，则需要重启服务器以使更改在应用中生效。
- 如果您尝试访问一个 secret，但不存在 `secrets.toml` 文件，Streamlit 将引发 `FileNotFoundError` 异常：
  <Image alt="Secrets management FileNotFoundError" src="/images/secrets-filenotfounderror.png"/>
- 如果您尝试访问一个不存在的 secret，Streamlit 将引发 `KeyError` 异常：

  ```python
  import streamlit as st

  st.write(st.secrets["nonexistent_key"])
  ```

    <Image alt="Secrets management KeyError" src="/images/secrets-keyerror.png"/>

### 在 Streamlit Community Cloud 中使用 secrets

当您将应用部署到 [Streamlit Community Cloud](https://streamlit.io/cloud) 时，您可以使用与本地相同的 secrets 管理工作流程。但是，您还需要在 Community Cloud Secrets Management 控制台中设置您的 secrets。了解如何操作，请参阅云特定的 [Secrets 管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management) 文档。

---

# 安全提醒

Source: https://docs.streamlit.io/develop/concepts/connections/security-reminders


## 保护您的密钥

切勿直接在代码中保存用户名、密码或安全密钥，也不要将它们提交到您的仓库。

### 使用环境变量

通过使用环境变量来避免在代码中放置敏感信息。请务必查看 [`st.secrets`](/develop/concepts/connections/secrets-management)。研究您使用的任何平台，以遵循其安全最佳实践。如果您使用 Streamlit Community Cloud，[密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management) 允许您保存环境变量并在代码之外存储密钥。

### 保持 `.gitignore` 更新

如果您在开发过程中使用任何敏感或私有信息，请确保这些信息保存在与代码分离的文件中。确保 `.gitignore` 配置正确，以防止将私有信息保存到您的仓库。

## Pickle 警告

Streamlit 的 [`st.cache_data`](/develop/concepts/architecture/caching#stcache_data) 和 [`st.session_state`](/develop/concepts/architecture/session-state#serializable-session-state) 隐式使用 `pickle` 模块，该模块已知不安全。有可能构建恶意的 pickle 数据，在反序列化期间执行任意代码。切勿在不安全模式下加载可能来自不受信任来源或可能已被篡改的数据。**仅加载您信任的数据**。

- 使用 `st.cache_data` 时，函数返回的任何内容都会被 pickle 并存储，然后在检索时反序列化。确保您的缓存函数返回可信值。此警告也适用于 [`st.cache`](/develop/api-reference/caching-and-state/st.cache)（已弃用）。
- 当 `runner.enforceSerializableSessionState` [配置选项](

---

# 自定义组件

Source: https://docs.streamlit.io/develop/concepts/custom-components


组件是扩展 Streamlit 可能性的第三方 Python 模块。

## 如何使用组件

组件非常容易使用：

1. 首先找到您想要使用的组件。两个很好的资源是：
   - [组件画廊](https://streamlit.io/components)
   - [此线程](https://discuss.streamlit.io/t/streamlit-components-community-tracker/4634)，
     由我们的论坛的 Fanilo A. 提供。

2. 使用您喜欢的 Python 包管理器安装组件。此步骤以及所有后续步骤都在您的组件说明中描述。

   例如，要使用出色的 [AgGrid 组件](https://github.com/PablocFonseca/streamlit-aggrid)，您首先使用以下命令安装它：

   ```python
   pip install streamlit-aggrid
   ```

3. 在您的 Python 代码中，按照其说明导入组件。对于 AgGrid，此步骤是：

   ```python
   from st_aggrid import AgGrid
   ```

4. ...现在您准备好使用它了！对于 AgGrid，就是：

   ```python
   AgGrid(my_dataframe)
   ```

## 制作您自己的组件

如果您有兴趣制作自己的组件，请查看以下资源：

- [创建组件](/develop/concepts/custom-components/create)
- [发布组件](/develop/concepts/custom-components/publish)
- [组件 API](/develop/concepts/custom-components/intro)
- [我们推出组件时的博客文章！](https://blog.streamlit.io/introducing-streamlit-components/)

或者，如果您喜欢使用视频学习，我们的工程师 Tim Conkling 准备了一些令人惊叹的教程：

##### 视频教程，第 1 部分

<YouTube videoId="BuD3gILJW-Q"/>

##### 视频教程，第 2 部分

<YouTube videoId="QjccJl_7Jco"/>

---

# 创建组件

Source: https://docs.streamlit.io/develop/concepts/custom-components/create


<Note>

如果您只对**使用 Streamlit 组件**感兴趣，那么您可以跳过此部分并前往 [Streamlit 组件库](https://streamlit.io/components) 查找和安装社区创建的组件！

</Note>

开发人员可以编写 JavaScript 和 HTML"组件"，这些组件可以在 Streamlit 应用中渲染。Streamlit 组件可以从 Streamlit Python 脚本接收数据，也可以向其发送数据。

Streamlit 组件让您扩展基础 Streamlit 包中提供的功能。使用 Streamlit 组件为您用例所需的功能创建，然后将其包装在 Python 包中并与更广泛的 Streamlit 社区分享！

**通过 Streamlit 组件，您可以通过以下方式向应用添加新功能：**

- 创建您自己的组件，以替代现有的 Streamlit 元素和部件。
- 通过包装现有的 React.js、Vue.js 或其他 JavaScript 部件工具包创建全新的 Streamlit 元素和部件。
- 通过构建 HTML 表示并将其样式化以适应您的应用主题来渲染 Python 对象。
- 创建便捷函数来嵌入常用的网络功能，如 [GitHub gists 和 Pastebin](https://github.com/randyzwitch/streamlit-embedcode)。

查看 Streamlit 工程师 Tim Conkling 制作的这些 Streamlit 组件教程视频以开始：

## 第一部分：设置和架构

<YouTube videoId="BuD3gILJW-Q"/>

## 第二部分：制作滑块部件

<YouTube videoId="QjccJl_7Jco"/>

---

# 自定义组件简介

Source: https://docs.streamlit.io/develop/concepts/custom-components/intro


开发 Streamlit 组件的第一步是决定创建静态组件（即仅渲染一次，由 Python 控制）还是创建可以实现 Python 到 JavaScript 及返回的双向通信的组件。

## 创建静态组件

如果创建 Streamlit 组件的目标仅仅是显示 HTML 代码或从 Python 可视化库渲染图表，Streamlit 提供了两种大大简化此过程的方法：`components.html()` 和 `components.iframe()`。

如果您不确定是否需要双向通信，**请先从这里开始**！

### 渲染 HTML 字符串

虽然 [`st.text`](/develop/api-reference/text/st.text)、[`st.markdown`](/develop/api-reference/text/st.markdown) 和 [`st.write`](/develop/api-reference/write-magic/st.write) 可以轻松将文本写入 Streamlit 应用，但有时您可能更愿意实现自定义 HTML 片段。同样，虽然 Streamlit 本地支持[许多图表库](/develop/api-reference/charts#chart-elements)，但您可能希望为新的图表库实现特定的 HTML/JavaScript 模板。[`components.html`](/develop/api-reference/custom-components/st.components.v1.html) 通过为您提供在 Streamlit 应用中嵌入包含所需输出的 iframe 的能力来工作。

**示例**

```python
import streamlit as st
import streamlit.components.v1 as components

# bootstrap 4 折叠示例
components.html(
    """
    <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" rel="stylesheet">
<script crossorigin="anonymous" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" src="https://code.jquery.com/jquery-3.2.1.slim.min.js"/>
<script crossorigin="anonymous" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"/>
<div id="accordion">
<div class="card">
<div class="card-header" id="headingOne">
<h5 class="mb-0">
<button aria-controls="collapseOne" aria-expanded="true" class="btn btn-link" data-target="#collapseOne" data-toggle="collapse">
            可折叠组项目 #1
            </button>
</h5>
</div>
<div aria-labelledby="headingOne" class="collapse show" data-parent="#accordion" id="collapseOne">
<div class="card-body">
            可折叠组项目 #1 内容
          </div>
</div>
</div>
<div class="card">
<div class="card-header" id="headingTwo">
<h5 class="mb-0">
<button aria-controls="collapseTwo" aria-expanded="false" class="btn btn-link collapsed" data-target="#collapseTwo" data-toggle="collapse">
            可折叠组项目 #2
            </button>
</h5>
</div>
<div aria-labelledby="headingTwo" class="collapse" data-parent="#accordion" id="collapseTwo">
<div class="card-body">
            可折叠组项目 #2 内容
          </div>
</div>
</div>
</div>
    """,
    height=600,
)
```

### 渲染 iframe URL

[`components.iframe`](/develop/api-reference/custom-components/st.components.v1.iframe) 在功能上与 `components.html` 类似，区别在于 `components.iframe` 以 URL 作为输入。这用于您想在 Streamlit 应用中包含整个页面的情况。

**示例**

```python
import streamlit as st
import streamlit.components.v1 as components

# 在 streamlit 应用中嵌入 streamlit 文档
components.iframe("https://example.com", height=500)
```

## 创建双向组件

双向 Streamlit 组件有两个部分：

1. 一个**前端**，由 HTML 和您喜欢的任何其他网络技术（JavaScript、React、Vue 等）构建，并通过 iframe 标签在 Streamlit 应用中渲染。
2. 一个**Python API**，Streamlit 应用使用它来实例化并与前端通信

为了使创建双向 Streamlit 组件的过程更容易，我们在 [Streamlit Component-template GitHub 仓库](https://github.com/streamlit/component-template) 中创建了一个 React 模板和一个仅 TypeScript 模板。我们还在同一个仓库中提供了一些[示例组件](https://github.com/streamlit/component-template/tree/master/examples)。

### 开发环境设置

要构建 Streamlit 组件，您需要在开发环境中安装以下内容：

- Python 3.9 - Python 3.13
- Streamlit
- [nodejs](https://nodejs.org/en/)
- [npm](https://www.npmjs.com/) 或 [yarn](https://yarnpkg.com/)

克隆 [component-template GitHub 仓库](https://github.com/streamlit/component-template)，然后决定是否要使用 React.js (["template"](https://github.com/streamlit/component-template/tree/master/template)) 或纯 TypeScript (["template-reactless"](https://github.com/streamlit/component-template/tree/master/template-reactless)) 模板。

1. 从终端初始化并构建组件模板前端：

   ```bash
   # React 模板
   template/my_component/frontend
   npm install    # 初始化项目并安装 npm 依赖项
   npm run start  # 启动 Vite 开发服务器

   # 或

   # 仅 TypeScript 模板
   template-reactless/my_component/frontend
   npm install    # 初始化项目并安装 npm 依赖项
   npm run start  # 启动 Vite 开发服务器
   ```

2. _从另一个终端_，运行声明和使用组件的 Streamlit 应用（Python）：

   ```bash
   # React 模板
   cd template
   . venv/bin/activate # 或类似命令激活安装了 Streamlit 的 venv/conda 环境
   pip install -e . # 将模板安装为可编辑包
   streamlit run my_component/example.py # 运行示例

   # 或

   # 仅 TypeScript 模板
   cd template-reactless
   . venv/bin/activate # 或类似命令激活安装了 Streamlit 的 venv/conda 环境
   pip install -e . # 将模板安装为可编辑包
   streamlit run my_component/example.py # 运行示例
   ```

运行上述步骤后，您应该在浏览器中看到一个 Streamlit 应用，如下所示：

![Streamlit 组件示例应用](/images/component_demo_example.png)

模板中的示例应用展示了双向通信是如何实现的。Streamlit 组件显示一个按钮（`Python → JavaScript`），终端用户可以点击该按钮。每次点击按钮时，JavaScript 前端都会递增计数器值并将其传回 Python（`JavaScript → Python`），然后由 Streamlit 显示（`Python → JavaScript`）。

### 前端

由于每个 Streamlit 组件都是一个独立的网页，通过 `iframe` 渲染到应用中，您可以使用几乎任何网络技术来创建该网页。我们在 Streamlit [Components-template GitHub 仓库](https://github.com/streamlit/component-template/) 中提供了两个模板来开始；其中一个模板使用 [React](https://reactjs.org/)，另一个不使用。

<Note>

即使您还不熟悉 React，您可能仍想查看基于 React 的模板。它处理了从 Streamlit 发送和接收数据所需的大部分样板代码，您可以随着进展学习所需的 React 知识。

如果您不想使用 React，请无论如何阅读此部分！它解释了 Streamlit ↔ 组件通信的基础知识。
</Note>

#### React

基于 React 的模板位于 `template/my_component/frontend/src/MyComponent.tsx`。

- 当组件需要重新渲染时（就像在任何 React 应用中一样），会自动调用 `MyComponent.render()`
- 从 Python 脚本传递的参数可通过 `this.props.args` 字典获得：

```python
# 在 Python 中发送参数:
result = my_component(greeting="Hello", name="Streamlit")
```

```javascript
// 在前端接收参数:
let greeting = this.props.args["greeting"]; // greeting = "Hello"
let name = this.props.args["name"]; // name = "Streamlit"
```

- 使用 `Streamlit.setComponentValue()` 将数据从前端返回到 Python 脚本：

```javascript
// 在前端设置值:
Streamlit.setComponentValue(3.14);
```

```python
# 在 Python 中访问值:
result = my_component(greeting="Hello", name="Streamlit")
st.write("result = ", result) # result = 3.14
```

当您调用 `Streamlit.setComponentValue(new_value)` 时，该新值会被发送到 Streamlit，然后 _从头到尾重新执行 Python 脚本_。当脚本重新执行时，对 `my_component(...)` 的调用将返回新值。

从 _代码流_ 的角度来看，似乎您正在与前端同步传输数据：Python 将参数发送给 JavaScript，JavaScript 将值返回给 Python，全部在单个函数调用中！但实际上这一切都是 _异步_ 发生的，正是 Python 脚本的重新执行实现了这种巧妙的手法。

- 使用 `Streamlit.setFrameHeight()` 控制组件的高度。默认情况下，React 模板会自动调用此函数（请参见 `StreamlitComponentBase.componentDidUpdate()`）。如果您需要更多控制，可以覆盖此行为。
- 文件的最后一行有一个小技巧：`export default withStreamlitConnection(MyComponent)` - 这会与 Streamlit 进行一些握手，并建立双向数据通信机制。

#### 仅 TypeScript

仅 TypeScript 模板位于 `template-reactless/my_component/frontend/src/MyComponent.tsx`。

此模板比其 React 对应版本有更多的代码，因为握手、设置事件监听器和更新组件框架高度的所有机制都是手动完成的。React 版本的模板自动处理大部分这些细节。

- 在源文件底部附近，模板调用 `Streamlit.setComponentReady()` 告诉 Streamlit 它已准备好开始接收数据。（通常在创建和加载组件依赖的所有内容后执行此操作。）
- 它订阅 `Streamlit.RENDER_EVENT` 以获知何时重绘。（在调用 `setComponentReady` 之前不会触发此事件）
- 在其 `onRender` 事件处理程序中，它通过 `event.detail.args` 访问 Python 脚本中传递的参数
- 它以与 React 模板相同的方式将数据发送回 Python 脚本——点击"Click Me!"按钮调用 `Streamlit.setComponentValue()`
- 它通过 `Streamlit.setFrameHeight()` 通知 Streamlit 其高度可能已更改

#### 使用主题

<Note>

自定义组件主题支持需要 streamlit-component-lib 版本 1.2.0 或更高版本。

</Note>

除了向组件发送 `args` 对象外，Streamlit 还发送一个定义活动主题的 `theme` 对象，以便您的组件可以以兼容的方式调整其样式。此对象与 `args` 在同一条消息中发送，因此可通过 `this.props.theme`（使用 React 模板时）或 `event.detail.theme`（使用纯 TypeScript 模板时）访问。

`theme` 对象具有以下结构：

```json
{
  "base": "lightORdark",
  "primaryColor": "someColor1",
  "backgroundColor": "someColor2",
  "secondaryBackgroundColor": "someColor3",
  "textColor": "someColor4",
  "font": "someFont"
}
```

`base` 选项允许您指定自定义主题继承的预设 Streamlit 主题。在主题设置中未定义的任何主题配置选项的值将设置为基本主题的值。`base` 的有效值为 `"light"` 和 `"dark"`。

请注意，主题对象具有与使用命令 `streamlit config show` 打印的配置选项中"theme"部分选项同名且语义相同的字段。

使用 React 模板时，还会自动设置以下 CSS 变量。

```css
--base
--primary-color
--background-color
--secondary-background-color
--text-color
--font
```

如果您不熟悉 [CSS 变量](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties)，简单来说您可以这样使用它们：

```css
.mySelector {
  color: var(--text-color);
}
```

这些变量与上面 `theme` 对象中定义的字段匹配，是否在组件中使用 CSS 变量还是主题对象是个人偏好的问题。

#### 其他前端细节

- 由于您从开发服务器（通过 `npm run start`）托管组件，保存时所做的任何更改都应该自动反映在 Streamlit 应用中。
- 如果您想向组件添加更多包，请在组件的 `frontend/` 目录中运行 `npm add` 来添加它们。

```bash
npm add baseui
```

- 要构建组件的静态版本，请运行 `npm run export`。更多信息请参见 [准备您的组件](publish#prepare-your-component)

### Python API

`components.declare_component()` 是创建组件 Python API 所需的全部：

```python
  import streamlit.components.v1 as components
  my_component = components.declare_component(
    "my_component",
    url="http://localhost:3001"
  )
```

然后您可以使用返回的 `my_component` 函数与前端代码发送和接收数据：

```python
# 使用命名参数向前端发送数据。
return_value = my_component(name="Blackbeard", ship="Queen Anne's Revenge")

# `my_component` 的返回值是从前端返回的数据。
st.write("Value = ", return_value)
```

虽然以上是从 Python 方面定义工作组件所需的一切，但我们建议创建一个带有命名参数和默认值、输入验证等的"包装器"函数。这将使最终用户更容易理解您的函数接受哪些数据值，并允许定义有用的文档字符串。

请参见 [此示例](https://github.com/streamlit/component-template/blob/master/template/my_component/__init__.py#L41-L77) 了解从 Components-template 创建包装函数的示例。

### 数据序列化

#### Python → 前端

您通过向前端调用函数（即 `declare_component` 返回的函数）传递关键字参数将数据从 Python 发送到前端。您可以从前端发送以下类型的数据：

- 任何 JSON 可序列化数据
- `numpy.array`
- `pandas.DataFrame`

任何 JSON 可序列化数据都会序列化为 JSON 字符串，并反序列化为 JavaScript 等价物。`numpy.array` 和 `pandas.DataFrame` 使用 [Apache Arrow](https://arrow.apache.org/) 进行序列化，并反序列化为 `ArrowTable` 实例，这是一种包装 Arrow 结构并在其之上提供便捷 API 的自定义类型。

查看 [CustomDataframe](https://github.com/streamlit/component-template/tree/master/examples/CustomDataframe) 和 [SelectableDataTable](https://github.com/streamlit/component-template/tree/master/examples/SelectableDataTable) 组件示例代码，了解如何使用 `ArrowTable` 的更多上下文。

#### 前端 → Python

您通过 `Streamlit.setComponentValue()` API（这是模板代码的一部分）从前端将数据发送到 Python。与从 Python → 前端的参数传递不同，**此 API 接受单个值**。如果您想返回多个值，需要将它们包装在 `Array` 或 `Object` 中。

自定义组件可以从前端向 Python 发送 JSON 可序列化数据，以及 [Apache Arrow](http://arrow.apache.org/) `ArrowTable` 以表示数据框。</link>

---

# 自定义组件的限制

Source: https://docs.streamlit.io/develop/concepts/custom-components/limitations


## Streamlit 组件与基础 Streamlit 包提供的功能有何不同？

- Streamlit 组件被封装在一个 iframe 中，这让您可以使用任何您喜欢的网络技术在 iframe 内实现任何您想要的功能。

## 使用 Streamlit 组件无法实现哪些类型的事情？

由于每个 Streamlit 组件都被挂载到其自己的沙盒 iframe 中，这意味着组件的功能存在一些限制：

- **无法与其他组件通信**：组件不能包含（或以其他方式与）其他组件通信，因此组件不能用于构建网格布局之类的结构。
- **无法修改 CSS**：组件不能修改 Streamlit 应用其余部分使用的 CSS，因此例如，您不能创建一个使应用进入暗黑模式的功能。
- **无法添加/删除元素**：组件不能向 Streamlit 应用添加或删除其他元素，因此例如，您不能创建一个移除应用菜单的功能。

## 我的组件似乎在闪烁/卡顿……如何修复？

目前，Streamlit 内部未对组件更新执行自动去抖动。组件创建者自己可以决定对其发送回 Streamlit 的更新进行速率限制。

---

# 发布组件

Source: https://docs.streamlit.io/develop/concepts/custom-components/publish


## 发布到 PyPI

将您的 Streamlit 组件发布到 [PyPI](https://pypi.org/) 可以让全世界的 Python 用户轻松访问。这一步完全是可选的，如果您不打算公开发布组件，可以跳过此部分！

<Note>

对于[静态 Streamlit 组件](/develop/concepts/custom-components/intro#create-a-static-component)，将 Python 包发布到 PyPI 遵循与[核心 PyPI 打包说明](https://packaging.python.org/tutorials/packaging-projects/)相同的步骤。静态组件可能只包含 Python 代码，因此一旦您的[setup.py](https://packaging.python.org/tutorials/packaging-projects/#creating-setup-py) 文件正确并且[生成了分发文件](https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives)，您就可以准备[上传到 PyPI](https://packaging.python.org/tutorials/packaging-projects/#uploading-the-distribution-archives)。

[双向 Streamlit 组件](/develop/concepts/custom-components/intro#create-a-bi-directional-component) 至少包含 Python 和 JavaScript 代码，因此在可以发布到 PyPI 之前需要稍作准备。本页面的其余部分重点介绍双向组件的准备工作。

</Note>

### 准备您的组件

双向 Streamlit 组件与纯 Python 库略有不同，因为它必须包含预编译的前端代码。这也是基础 Streamlit 的工作方式；当您 `pip install streamlit` 时，您得到的是一个 Python 库，其中包含的 HTML 和前端代码已编译为静态资源。

[component-template](https://github.com/streamlit/component-template) GitHub 仓库提供了发布到 PyPI 所需的文件夹结构。但在发布之前，您需要做一些整理工作：

1. 给您的组件命名（如果尚未命名）
   - 将 `template/my_component/` 文件夹重命名为 `template/<组件名称>/`
   - 将组件名称作为第一个参数传递给 `declare_component()`
2. 编辑 `MANIFEST.in`，将 `recursive-include` 的路径从 `package/frontend/build *` 更改为 `<组件名称>/frontend/build *`
3. 编辑 `setup.py`，添加组件名称和其他相关信息
4. 创建前端代码的发布构建。这将添加一个新目录 `frontend/build/`，其中包含已编译的前端：

   ```bash
   cd frontend
   npm run build
   ```

5. 将构建文件夹的路径作为 `path` 参数传递给 `declare_component`。（如果您使用模板 Python 文件，可以在文件顶部设置 `_RELEASE = True`）：

   ```python
      import streamlit.components.v1 as components

      # 将这个:
      # component = components.declare_component("my_component", url="http://localhost:3001")

      # 改为:
      parent_dir = os.path.dirname(os.path.abspath(__file__))
      build_dir = os.path.join(parent_dir, "frontend/build")
      component = components.declare_component("new_component_name", path=build_dir)
   ```

### 构建 Python wheel

更改默认的 `my_component` 引用，编译 HTML 和 JavaScript 代码并在 `components.declare_component()` 中设置新的组件名称后，您就可以构建 Python wheel：

1. 确保您拥有最新版本的 setuptools、wheel 和 twine

2. 从源代码构建 wheel：

   ```bash
    # 从组件的顶级目录运行此命令；即，
    # 包含 `setup.py` 的目录
    python setup.py sdist bdist_wheel
   ```

### 将 wheel 上传到 PyPI

创建 wheel 后，最后一步是上传到 PyPI。此处的说明重点介绍如何上传到 [Test PyPI](https://test.pypi.org/)，以便您可以在不用担心搞砸任何东西的情况下学习此过程的机制。上传到 PyPI 遵循相同的基本过程。

1. 如果还没有，请在 [Test PyPI](https://test.pypi.org/) 上创建一个账户
   - 访问 [https://test.pypi.org/account/register/](https://test.pypi.org/account/register/) 并完成步骤

   - 访问 [https://test.pypi.org/manage/account/#api-tokens](https://test.pypi.org/manage/account/#api-tokens) 并创建一个新的 API 令牌。不要将令牌作用域限制为特定项目，因为您正在创建一个新项目。在关闭页面之前复制您的令牌，因为您将无法再次检索它。

2. 将 wheel 上传到 Test PyPI。`twine` 将提示您输入用户名和密码。对于用户名，使用 **\_\_token\_\_**。对于密码，使用您上一步的令牌值，包括 `pypi-` 前缀：

   ```bash
   python -m twine upload --repository testpypi dist/*
   ```

3. 在新 Python 项目中安装您刚刚上传的包以确保它能正常工作：

   ```bash
    python -m pip install --index-url https://test.pypi.org/simple/ --no-deps example-pkg-YOUR-USERNAME-HERE
   ```

如果一切顺利，您就可以按照 [https://packaging.python.org/tutorials/packaging-projects/#next-steps](https://packaging.python.org/tutorials/packaging-projects/#next-steps) 上的说明将您的库上传到 PyPI。

恭喜，您已经创建了一个公开可用的 Streamlit 组件！

## 推广您的组件！

我们很高兴帮助您与 Streamlit 社区分享您的组件！要分享它：

1. 如果您的代码托管在 GitHub 上，请添加 `streamlit-component` 标签，以便它被列入 [GitHub **streamlit-component** 主题](https://github.com/topics/streamlit-component) 中：

   <Image caption="将 streamlit-component 标签添加到您的 GitHub 仓库" src="/images/component-tag.gif"/>

2. 在 Streamlit 论坛的 [展示社区！](https://discuss.streamlit.io/c/streamlit-examples/9) 中发帖。使用类似"新组件：`<您的组件名称>`，一种实现 X 的新方式"的帖子标题。
3. 将您的组件添加到 [社区组件跟踪器](https://discuss.streamlit.io/t/streamlit-components-community-tracker/4634)。
4. 在 Twitter 上 @[@streamlit](https://twitter.com/streamlit) 发帖，以便我们可以转发您的公告。

我们的[组件库](https://streamlit.io/components) 大约每月更新一次。遵循以上建议以最大化您的组件进入我们组件库的可能性。我们文档中的社区组件是不定期手工策划的。受欢迎的、有很多星标和良好文档的组件更有可能被选中。</您的组件名称></组件名称></组件名称>

---

# 应用设计概念和注意事项

Source: https://docs.streamlit.io/develop/concepts/design


<TileContainer layout="list">
<RefCard href="/develop/concepts/design/animate">
<h5>动画化和更新元素</h5>

了解如何创建动态、有动画效果的内容或更新元素而无需重新运行你的应用。

</RefCard>
<RefCard href="/develop/concepts/design/buttons">
<h5>按钮行为和示例</h5>

通过解释和示例了解按钮如何工作以避免常见错误。

</RefCard>
<RefCard href="/develop/concepts/design/dataframes">
<h5>数据框</h5>

数据框是以表格格式显示和编辑数据的好方法。了解 Streamlit 中提供的 UI 和选项。

</RefCard>
<RefCard href="/develop/concepts/design/custom-classes">
<h5>在 Streamlit 应用中使用自定义 Python 类</h5>

了解在 Streamlit 重新运行模型中定义自己的 Python 类的影响。

</RefCard>
<RefCard href="/develop/concepts/design/multithreading">
<h5>多线程处理</h5>

了解如何在 Streamlit 应用中使用多线程处理。

</RefCard>
<RefCard href="/develop/concepts/design/timezone-handling">
<h5>处理时区</h5>

了解如何将时间本地化给你的用户。

</RefCard>
</TileContainer>

---

# 动画化和更新元素

Source: https://docs.streamlit.io/develop/concepts/design/animate


有时你显示一个图表或数据框并想在应用运行时实时修改它（例如，在一个循环中）。某些元素有内置方法允许你原位更新它们而不重新运行应用。

可更新的元素包括以下内容：

- `st.empty` 容器可以按顺序写入，并将始终显示写入的最后一个内容。它们也可以通过调用方法的 `.empty()` 来清除。
- `st.dataframe`、`st.table` 和许多图表元素可以使用 `.add_rows()` 方法更新，该方法附加数据。
- `st.progress` 元素可以通过额外的 `.progress()` 调用进行更新。它们也可以通过 `.empty()` 方法调用来清除。
- `st.status` 容器有一个 `.update()` 方法来改变它们的标签、展开状态和状态。
- `st.toast` 消息可以通过额外的 `.toast()` 调用原位更新。

## `st.empty` 容器

`st.empty` 可以容纳单个元素。当你向 `st.empty` 容器写入任何元素时，Streamlit 会丢弃其以前的内容并显示新元素。你也可以通过调用 `.empty()` 作为方法来清除 `st.empty` 容器。如果你想更新一组元素，请使用放在 `st.empty` 内的普通容器（`st.container()`）并向普通容器写入内容。根据需要经常重写普通容器及其内容以更新应用的显示。

## `.add_rows()` 方法

`st.dataframe`、`st.table` 和所有图表函数可以使用其输出上的 `.add_rows()` 方法进行变异。在以下示例中，我们使用 `my_data_element = st.line_chart(df)`。你可以通过简单地交换 `st.line_chart` 来尝试 `st.table`、`st.dataframe` 和大多数其他简单图表的示例。请注意，`st.dataframe` 默认只显示前十行，并为其他行启用滚动。这意味着添加行不如使用 `st.table` 或图表元素那样在视觉上明显。

```python
import streamlit as st
import pandas as pd
import numpy as np
import time

df = pd.DataFrame(np.random.randn(15, 3), columns=(["A", "B", "C"]))
my_data_element = st.line_chart(df)

for tick in range(10):
    time.sleep(.5)
    add_df = pd.DataFrame(np.random.randn(1, 3), columns=(["A", "B", "C"]))
    my_data_element.add_rows(add_df)

st.button("Regenerate")
```

---

# 按钮行为和示例

Source: https://docs.streamlit.io/develop/concepts/design/buttons


## 摘要

使用 [`st.button`](/develop/api-reference/widgets/st.button) 创建的按钮不保留状态。它们在由其点击导致的脚本重新运行时返回 `True`，并在下一个脚本重新运行时立即返回 `False`。如果显示的元素嵌套在 `if st.button('Click me'):` 内，该元素将在单击按钮时可见，并在用户采取下一步操作后立即消失。这是因为脚本重新运行，按钮返回值变为 `False`。

在本指南中，我们将说明按钮的使用并解释常见的误解。继续阅读以查看各种示例，这些示例使用 [`st.session_state`](/develop/api-reference/caching-and-state/st.session_state) 扩展 `st.button`。[反模式](#anti-patterns)包含在最后。继续并拿起你喜欢的代码编辑器，这样当你阅读时可以 `streamlit run` 示例。如果你还没有运行过自己的 Streamlit 脚本，请查看 Streamlit 的[基本概念](/get-started/fundamentals/main-concepts)。

## 何时使用 `if st.button()`

当代码以按钮的值为条件时，它将一次执行以响应按钮被单击，并且不会再次执行（直到再次单击按钮）。

适合在按钮内嵌套：

- 立即消失的临时消息。
- 每次单击一次的过程，将数据保存到会话状态、文件或数据库。

不适合在按钮内嵌套：

- 应在用户继续时保持的显示项。
- 使用时导致脚本重新运行的其他小部件。
- 既不修改会话状态也不写入文件/数据库的过程。\*

\* 当需要一次性结果时，这可能是合适的。如果你有一个"验证"按钮，它可能是直接以按钮为条件的过程。它可以用来创建一个警报来说"有效"或"无效"，无需保留该信息。

## 按钮的常见逻辑

### 使用按钮显示临时消息

如果你想给用户一个快速按钮来检查条目是否有效，但在用户继续时不保留该检查显示。

在此示例中，用户可以单击按钮来检查其 `animal` 字符串是否在 `animal_shelter` 列表中。当用户单击"**检查可用性**"时，他们将看到"我们有那个动物！"或"我们没有那个动物。"如果他们在 [`st.text_input`](/develop/api-reference/widgets/st.text_input) 中更改动物，脚本会重新运行，消息会消失，直到他们再次单击"**检查可用性**"。

```python
import streamlit as st

animal_shelter = ['cat', 'dog', 'rabbit', 'bird']

animal = st.text_input('Type an animal')

if st.button('Check availability'):
    have_it = animal.lower() in animal_shelter
    'We have that animal!' if have_it else 'We don\'t have that animal.'
```

注意：上面的示例使用[魔法](/develop/api-reference/write-magic/magic)在前端渲染消息。

### 有状态按钮

如果你希望单击的按钮继续为 `True`，请在 `st.session_state` 中创建一个值，并使用按钮通过回调将该值设置为 `True`。

```python
import streamlit as st

if 'clicked' not in st.session_state:
    st.session_state.clicked = False

def click_button():
    st.session_state.clicked = True

st.button('Click me', on_click=click_button)

if st.session_state.clicked:
    # The message and nested widget will remain on the page
    st.write('Button clicked!')
    st.slider('Select a value')
```

### 切换按钮

如果你希望按钮像切换开关一样工作，请考虑使用 [`st.checkbox`](/develop/api-reference/widgets/st.checkbox)。否则，你可以使用带有回调函数的按钮来反转保存在 `st.session_state` 中的布尔值。

在此示例中，我们使用 `st.button` 来打开和关闭另一个小部件。通过在 `st.session_state` 中的值上有条件地显示 [`st.slider`](/develop/api-reference/widgets/st.slider)，用户可以与滑块交互而不会使其消失。

```python
import streamlit as st

if 'button' not in st.session_state:
    st.session_state.button = False

def click_button():
    st.session_state.button = not st.session_state.button

st.button('Click me', on_click=click_button)

if st.session_state.button:
    # The message and nested widget will remain on the page
    st.write('Button is on!')
    st.slider('Select a value')
else:
    st.write('Button is off!')
```

或者，你可以在滑块的 `disabled` 参数上使用 `st.session_state` 中的值。

```python
import streamlit as st

if 'button' not in st.session_state:
    st.session_state.button = False

def click_button():
    st.session_state.button = not st.session_state.button

st.button('Click me', on_click=click_button)

st.slider('Select a value', disabled=st.session_state.button)
```

### 按钮用于继续或控制过程的阶段

另一种替代在按钮内嵌套内容的方法是在 `st.session_state` 中使用指定过程的"步骤"或"阶段"的值。在此示例中，我们的脚本中有四个阶段：

0. 用户开始之前。
1. 用户输入他们的名字。
2. 用户选择颜色。
3. 用户获得感谢消息。

开始处的按钮将阶段从 0 推进到 1。末尾的按钮将阶段从 3 重置为 0。阶段 1 和 2 中使用的其他小部件有回调来设置阶段。如果你有一个依赖步骤的过程，并希望保持之前的阶段可见，这样的回调会强制用户在更改早期小部件时重新追踪后续阶段。

```python
import streamlit as st

if 'stage' not in st.session_state:
    st.session_state.stage = 0

def set_state(i):
    st.session_state.stage = i

if st.session_state.stage == 0:
    st.button('Begin', on_click=set_state, args=[1])

if st.session_state.stage &gt;= 1:
    name = st.text_input('Name', on_change=set_state, args=[2])

if st.session_state.stage &gt;= 2:
    st.write(f'Hello {name}!')
    color = st.selectbox(
        'Pick a Color',
        [None, 'red', 'orange', 'green', 'blue', 'violet'],
        on_change=set_state, args=[3]
    )
    if color is None:
        set_state(2)

if st.session_state.stage &gt;= 3:
    st.write(f':{color}[Thank you!]')
    st.button('Start Over', on_click=set_state, args=[0])
```

### 按钮修改 `st.session_state`

如果你在按钮内修改 `st.session_state`，你必须考虑该按钮在脚本中的位置。

#### 一个小问题

在此示例中，我们在修改它的按钮之前和之后访问 `st.session_state.name`。单击按钮（"**Jane**"或"**John**"）时，脚本会重新运行。按钮之前显示的信息滞后于按钮之后写入的信息。按钮之前的 `st.session_state` 中的数据未更新。当脚本执行按钮函数时，这是有条件代码更新 `st.session_state` 的创建更改的时候。因此，此更改在按钮之后反映。

```python
import streamlit as st
import pandas as pd

if 'name' not in st.session_state:
    st.session_state['name'] = 'John Doe'

st.header(st.session_state['name'])

if st.button('Jane'):
    st.session_state['name'] = 'Jane Doe'

if st.button('John'):
    st.session_state['name'] = 'John Doe'

st.header(st.session_state['name'])
```

#### 回调中使用的逻辑

回调是修改 `st.session_state` 的干净方法。回调作为脚本重新运行的前缀执行，因此按钮相对于访问数据的位置并不重要。

```python
import streamlit as st
import pandas as pd

if 'name' not in st.session_state:
    st.session_state['name'] = 'John Doe'

def change_name(name):
    st.session_state['name'] = name

st.header(st.session_state['name'])

st.button('Jane', on_click=change_name, args=['Jane Doe'])
st.button('John', on_click=change_name, args=['John Doe'])

st.header(st.session_state['name'])
```

#### 按钮内嵌套的逻辑和重新运行

虽然回调通常优先于避免额外重新运行，但我们的第一个"John Doe"/"Jane Doe"示例可以通过添加 [`st.rerun`](/develop/api-reference/execution-flow/st.rerun) 来修改。如果你需要在修改它的按钮之前访问 `st.session_state` 中的数据，你可以包含 `st.rerun` 来在进行更改后重新运行脚本。这意味着单击按钮时脚本将重新运行两次。

```python
import streamlit as st
import pandas as pd

if 'name' not in st.session_state:
    st.session_state['name'] = 'John Doe'

st.header(st.session_state['name'])

if st.button('Jane'):
    st.session_state['name'] = 'Jane Doe'
    st.rerun()

if st.button('John'):
    st.session_state['name'] = 'John Doe'
    st.rerun()

st.header(st.session_state['name'])
```

### 按钮修改或重置其他小部件

当使用按钮来修改或重置另一个小部件时，它与上述修改 `st.session_state` 的示例相同。但是，存在一个额外的考虑：如果小部件的小部件已经为当前脚本运行呈现在页面上，你不能修改 `st.session_state` 中的键值对。

<Important>

不要这样做！

```python
import streamlit as st

st.text_input('Name', key='name')

# These buttons will error because their nested code changes
# a widget's state after that widget within the script.
if st.button('Clear name'):
    st.session_state.name = ''
if st.button('Streamlit!'):
    st.session_state.name = ('Streamlit')
```

</Important>

#### 选项 1：为按钮使用键并将逻辑放在小部件之前

如果你为按钮分配了一个键，你可以通过在 `st.session_state` 中使用其值来根据按钮的状态来条件化代码。这意味着取决于你的按钮的逻辑可以在你的脚本中的该按钮之前。在以下示例中，我们在 `st.session_state` 上使用 `.get()` 方法，因为按钮的键在脚本首次运行时不会存在。`.get()` 方法如果找不到密钥，将返回 `False`。否则，它将返回密钥的值。

```python
import streamlit as st

# Use the get method since the keys won't be in session_state
# on the first script run
if st.session_state.get('clear'):
    st.session_state['name'] = ''
if st.session_state.get('streamlit'):
    st.session_state['name'] = 'Streamlit'

st.text_input('Name', key='name')

st.button('Clear name', key='clear')
st.button('Streamlit!', key='streamlit')
```

#### 选项 2：使用回调

```python
import streamlit as st

st.text_input('Name', key='name')

def set_name(name):
    st.session_state.name = name

st.button('Clear name', on_click=set_name, args=[''])
st.button('Streamlit!', on_click=set_name, args=['Streamlit'])
```

#### 选项 3：使用容器

通过使用 [`st.container`](/develop/api-reference/layout/st.container)，你可以在脚本和前端视图（网页）中以不同的顺序显示小部件。

```python
import streamlit as st

begin = st.container()

if st.button('Clear name'):
    st.session_state.name = ''
if st.button('Streamlit!'):
    st.session_state.name = ('Streamlit')

# The widget is second in logic, but first in display
begin.text_input('Name', key='name')
```

### 按钮动态添加其他小部件

动态向页面添加小部件时，请确保使用索引来保持键唯一并避免 `DuplicateWidgetID` 错误。在此示例中，我们定义一个函数 `display_input_row`，它呈现一行小部件。该函数接受 `index` 作为参数。`display_input_row` 呈现的小部件在其键中使用 `index`，以便可以在单个脚本重新运行上多次执行 `display_input_row` 而不重复任何小部件键。

```python
import streamlit as st

def display_input_row(index):
    left, middle, right = st.columns(3)
    left.text_input('First', key=f'first_{index}')
    middle.text_input('Middle', key=f'middle_{index}')
    right.text_input('Last', key=f'last_{index}')

if 'rows' not in st.session_state:
    st.session_state['rows'] = 0

def increase_rows():
    st.session_state['rows'] += 1

st.button('Add person', on_click=increase_rows)

for i in range(st.session_state['rows']):
    display_input_row(i)

# Show the results
st.subheader('People')
for i in range(st.session_state['rows']):
    st.write(
        f'Person {i+1}:',
        st.session_state[f'first_{i}'],
        st.session_state[f'middle_{i}'],
        st.session_state[f'last_{i}']
    )
```

### 按钮处理昂贵或文件写入的过程

当你有昂贵的过程时，将其设置为在单击按钮时运行，并将结果保存到 `st.session_state`。这允许你继续访问过程的结果而无需不必要地重新执行它。这对于保存到磁盘或写入数据库的过程特别有帮助。在此示例中，我们有一个 `expensive_process`，取决于两个参数：`option` 和 `add`。从功能上讲，`add` 改变输出，但 `option` 不改变 — `option` 的存在是为了提供参数

```python
import streamlit as st
import pandas as pd
import time

def expensive_process(option, add):
    with st.spinner('Processing...'):
        time.sleep(5)
    df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6], 'C':[7, 8, 9]}) + add
    return (df, add)

cols = st.columns(2)
option = cols[0].selectbox('Select a number', options=['1', '2', '3'])
add = cols[1].number_input('Add a number', min_value=0, max_value=10)

if 'processed' not in st.session_state:
    st.session_state.processed = {}

# Process and save results
if st.button('Process'):
    result = expensive_process(option, add)
    st.session_state.processed[option] = result
    st.write(f'Option {option} processed with add {add}')
    result[0]
```

敏锐的观察者可能会想，"这感觉有点像缓存。"我们只保存与一个参数相关的结果，但该模式可以轻松扩展以保存与两个参数都相关的结果。从这个意义上讲，是的，它与缓存有一些相似之处，但也有一些重要的区别。当你在 `st.session_state` 中保存结果时，这些结果仅可用于其当前会话中的当前用户。如果你改为使用 [`st.cache_data`](/develop/api-reference/caching-and-state/st.cache_data)，这些结果将对所有会话中的所有用户可用。此外，如果要更新保存的结果，你必须清除该函数的所有保存结果才能这样做。

## 反模式

以下是按钮如何出错的一些简化示例。请注意这些常见错误。

### 嵌套在按钮内的按钮

```python
import streamlit as st

if st.button('Button 1'):
    st.write('Button 1 was clicked')
    if st.button('Button 2'):
        # This will never be executed.
        st.write('Button 2 was clicked')
```

### 嵌套在按钮内的其他小部件

```python
import streamlit as st

if st.button('Sign up'):
    name = st.text_input('Name')

    if name:
        # This will never be executed.
        st.success(f'Welcome {name}')
```

### 在按钮内嵌套过程而不保存到会话状态

```python
import streamlit as st
import pandas as pd

file = st.file_uploader("Upload a file", type="csv")

if st.button('Get data'):
    df = pd.read_csv(file)
    # This display will go away with the user's next action.
    st.write(df)

if st.button('Save'):
    # This will always error.
    df.to_csv('data.csv')
```

---

# 在 Streamlit 应用中使用自定义 Python 类

Source: https://docs.streamlit.io/develop/concepts/design/custom-classes


如果你正在构建一个复杂的 Streamlit 应用或使用现有代码，你可能在脚本中定义了自定义 Python 类。常见的例子包括以下内容：

- 定义 `@dataclass` 来在应用中存储相关数据。
- 定义 `Enum` 类来表示一组固定的选项或值。
- 定义自定义接口到外部服务或 [`st.connection`](/develop/api-reference/connections/st.connection) 未覆盖的数据库。

因为 Streamlit 在每次用户交互后重新运行你的脚本，自定义类可能在同一 Streamlit 会话内多次重定义。这可能导致不期望的效果，特别是在类和实例比较中。继续阅读以了解这个常见陷阱以及如何避免它。

我们首先介绍一些通用模式，你可以将其用于不同类型的自定义类，然后介绍一些更多技术细节，说明为什么这很重要。最后，我们详细介绍[使用 `Enum` 类](#using-enum-classes-in-streamlit)，并描述一个可以使其更方便的配置选项。

## 定义自定义类的模式

### 模式 1：在单独的模块中定义你的类

这是推荐的通用解决方案。如果可能，将类定义移到它们自己的模块文件中并将其导入到应用脚本中。只要你不编辑定义应用的文件，Streamlit 就不会在每次重新运行时重新导入那些类。因此，如果一个类在外部文件中定义并导入到你的脚本中，该类在会话期间不会被重定义，除非你正在主动编辑你的应用。

#### 示例：移动你的类定义

尝试运行以下 Streamlit 应用，其中 `MyClass` 在页面的脚本中定义。`isinstance()` 将在第一个脚本运行时返回 `True`，然后在之后的每次重新运行时返回 `False`。

```python
# app.py
import streamlit as st

# MyClass gets redefined every time app.py reruns
class MyClass:
    def __init__(self, var1, var2):
        self.var1 = var1
        self.var2 = var2

if "my_instance" not in st.session_state:
  st.session_state.my_instance = MyClass("foo", "bar")

# Displays True on the first run then False on every rerun
st.write(isinstance(st.session_state.my_instance, MyClass))

st.button("Rerun")
```

如果你将类定义移出 `app.py` 到另一个文件中，你可以使 `isinstance()` 一致地返回 `True`。考虑以下文件结构：

```
myproject/
├── my_class.py
└── app.py
```

```python
# my_class.py
class MyClass:
    def __init__(self, var1, var2):
        self.var1 = var1
        self.var2 = var2
```

```python
# app.py
import streamlit as st
from my_class import MyClass # MyClass doesn't get redefined with each rerun

if "my_instance" not in st.session_state:
  st.session_state.my_instance = MyClass("foo", "bar")

# Displays True on every rerun
st.write(isinstance(st.session_state.my_instance, MyClass))

st.button("Rerun")
```

Streamlit 仅在检测到代码已更改时重新加载导入模块中的代码。因此，如果你正在主动编辑应用代码，你可能需要启动新的会话或重新启动 Streamlit 服务器以避免不期望的类重定义。

### 模式 2：强制你的类比较内部值

对于存储数据的类（如[数据类](https://docs.python.org/3/library/dataclasses.html)），你可能更感兴趣的是比较内部存储的值而不是类本身。如果你定义自定义的 `__eq__` 方法，你可以强制在内部存储的值上进行比较。

#### 示例：定义 `__eq__`

尝试运行以下 Streamlit 应用，并观察比较如何在第一次运行时为 `True`，然后在之后的每次重新运行时为 `False`。

```python
import streamlit as st
from dataclasses import dataclass

@dataclass
class MyDataclass:
    var1: int
    var2: float

if "my_dataclass" not in st.session_state:
    st.session_state.my_dataclass = MyDataclass(1, 5.5)

# Displays True on the first run the False on every rerun
st.session_state.my_dataclass == MyDataclass(1, 5.5)

st.button("Rerun")
```

由于 `MyDataclass` 在每次重新运行时被重定义，存储在会话状态中的实例将不等于在稍后脚本运行中定义的任何实例。你可以通过强制比较内部值来修复此问题，如下所示：

```python
import streamlit as st
from dataclasses import dataclass

@dataclass
class MyDataclass:
    var1: int
    var2: float

    def __eq__(self, other):
        # An instance of MyDataclass is equal to another object if the object
        # contains the same fields with the same values
        return (self.var1, self.var2) == (other.var1, other.var2)

if "my_dataclass" not in st.session_state:
    st.session_state.my_dataclass = MyDataclass(1, 5.5)

# Displays True on every rerun
st.session_state.my_dataclass == MyDataclass(1, 5.5)

st.button("Rerun")
```

对于常规类或 `@dataclass` 的默认 Python `__eq__` 实现取决于类或类实例的内存中 ID。为了避免 Streamlit 中的问题，你的自定义 `__eq__` 方法不应依赖 `self` 和 `other` 的 `type()`。

### 模式 3：将你的类存储为序列化数据

存储数据的类的另一个选项是为你的类定义序列化和反序列化方法，如 `to_str` 和 `from_str`。你可以使用这些在 `st.session_state` 中存储类实例数据而不是存储类实例本身。与模式 2 相似，这是一种强制比较内部数据并绕过不断变化的内存中 ID 的方式。

#### 示例：将你的类实例保存为字符串

使用与模式 2 相同的示例，这可以按如下方式完成：

```python
import streamlit as st
from dataclasses import dataclass

@dataclass
class MyDataclass:
    var1: int
    var2: float

    def to_str(self):
        return f"{self.var1},{self.var2}"

    @classmethod
    def from_str(cls, serial_str):
        values = serial_str.split(",")
        var1 = int(values[0])
        var2 = float(values[1])
        return cls(var1, var2)

if "my_dataclass" not in st.session_state:
    st.session_state.my_dataclass = MyDataclass(1, 5.5).to_str()

# Displays True on every rerun
MyDataclass.from_str(st.session_state.my_dataclass) == MyDataclass(1, 5.5)

st.button("Rerun")
```

### 模式 4：使用缓存来保留你的类

对于用作资源的类（数据库连接、状态管理器、API），请考虑使用缓存单例模式。使用 `@st.cache_resource` 来装饰你类的 `@staticmethod` 以生成该类的单个缓存实例。例如：

```python
import streamlit as st

class MyResource:
    def __init__(self, api_url: str):
        self._url = api_url

    @st.cache_resource(ttl=300)
    @staticmethod
    def get_resource_manager(api_url: str):
        return MyResource(api_url)

# This is cached until Session State is cleared or 5 minutes has elapsed.
resource_manager = MyResource.get_resource_manager("http://example.com/api/")
```

当你在函数上使用 Streamlit 的缓存装饰器之一时，Streamlit 不使用函数对象来查找缓存的值。相反，Streamlit 的缓存装饰器使用函数的限定名称和模块来索引返回值。因此，即使 Streamlit 在每次脚本运行时都重定义了 `MyResource`，`st.cache_resource` 也不受此影响。`get_resource_manager()` 将在每次重新运行时返回其缓存值，直到该值过期。

## 理解 Python 如何定义和比较类

那么这里真正发生了什么？我们将考虑一个简单的例子来说明为什么这是一个陷阱。如果你不想处理更多细节，可以随时跳过本部分。你可以跳到前面以了解[使用 `Enum` 类](#using-enum-classes-in-streamlit)。

### 示例：定义同一个类两次时会发生什么？

暂时搁置 Streamlit，思考这个简单的 Python 脚本：

```python
from dataclasses import dataclass

@dataclass
class Student:
    student_id: int
    name: str

Marshall_A = Student(1, "Marshall")
Marshall_B = Student(1, "Marshall")

# This is True (because a dataclass will compare two of its instances by value)
Marshall_A == Marshall_B

# Redefine the class
@dataclass
class Student:
    student_id: int
    name: str

Marshall_C = Student(1, "Marshall")

# This is False
Marshall_A == Marshall_C
```

在此示例中，数据类 `Student` 定义了两次。所有三个 Marshall 都有相同的内部值。如果你比较 `Marshall_A` 和 `Marshall_B`，它们将相等，因为它们都是从 `Student` 的第一个定义创建的。但是，如果你比较 `Marshall_A` 和 `Marshall_C`，它们将不相等，因为 `Marshall_C` 是从 `Student` 的第二个定义创建的。即使两个 `Student` 数据类的定义完全相同，它们有不同的内存中 ID，因此是不同的。

### Streamlit 中发生了什么？

在 Streamlit 中，你可能在页面脚本中没有两次写同一个类。但是，Streamlit 的重新运行逻辑产生了相同的效果。让我们使用上面的示例作为类比。如果你在一个脚本运行中定义一个类并在会话状态中保存一个实例，那么稍后的重新运行将重定义该类，你最终可能会将重新运行中的 `Marshall_C` 与会话状态中的 `Marshall_A` 进行比较。由于小部件在底层依赖会话状态，这是事情变得混乱的地方。

## Streamlit 小部件如何存储选项

多个 Streamlit UI 元素，如 `st.selectbox` 或 `st.radio`，通过 `options` 参数接受多选选项。应用的用户通常可以选择其中一个或多个选项。小部件函数返回选定的值。例如：

```python
number = st.selectbox("Pick a number, any number", options=[1, 2, 3])
# number == whatever value the user has selected from the UI.
```

当你调用函数（如 `st.selectbox`）并向 `options` 传递 `Iterable` 时，`Iterable` 和当前选择被保存到[会话状态](/develop/concepts/architecture/session-state)的隐藏部分，称为小部件元数据。

当应用的用户与 `st.selectbox` 小部件交互时，浏览器将其选择的索引发送到 Streamlit 服务器。该索引用于确定从原始 `options` 列表返回到应用的值，该列表保存在上一个页面执行的小部件元数据中。

关键细节是 `st.selectbox`（或类似的小部件函数）返回的值来自在页面的先前执行期间保存在会话状态中的 `Iterable`，而不是在当前执行中传递给 `options` 的值。Streamlit 以这种方式设计的有许多架构原因，我们不会在这里讨论。但是，**这**是我们最终比较不同类的实例的方式，而我们认为我们在比较同一类的实例。

### 一个病理性示例

上面的解释可能有点令人困惑，所以这里有一个病理性的例子来说明这个想法。

```python
import streamlit as st
from dataclasses import dataclass

@dataclass
class Student:
    student_id: int
    name: str

Marshall_A = Student(1, "Marshall")
if "B" not in st.session_state:
    st.session_state.B = Student(1, "Marshall")
Marshall_B = st.session_state.B

options = [Marshall_A,Marshall_B]
selected = st.selectbox("Pick", options)

# This comparison does not return expected results:
selected == Marshall_A
# This comparison evaluates as expected:
selected == Marshall_B
```

最后的说明是，我们在这一部分的示例中使用了 `@dataclass` 来说明一点，但实际上，一般来说，可能会遇到这些相同的类问题。任何在比较运算符（如 `__eq__` 或 `__gt__`）中检查类身份的类都可以展示这些问题。

## 在 Streamlit 中使用 `Enum` 类

Python 标准库中的 [`Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) 类是定义自定义符号名称的强大方式，这些名称可以代替 `str` 值用作 `st.multiselect` 或 `st.selectbox` 的选项。

例如，你可能向 streamlit 页面添加以下内容：

```python
from enum import Enum
import streamlit as st

# class syntax
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

selected_colors = set(st.multiselect("Pick colors", options=Color))

if selected_colors == {Color.RED, Color.GREEN}:
    st.write("Hooray, you found the color YELLOW!")
```

如果你使用的是最新版本的 Streamlit，此 Streamlit 页面将按其应该的方式工作。当用户同时选择 `Color.RED` 和 `Color.GREEN` 时，他们会看到特殊消息。

但是，如果你已经读过本页的其余部分，你可能会注意到一些棘手的地方。具体来说，`Enum` 类 `Color` 在每次运行此脚本时都会被重定义。在 Python 中，如果你使用相同的类名、成员和值定义两个 `Enum` 类，这些类及其成员仍然被认为彼此是唯一的。这应该导致上面的 `if` 条件始终计算为 `False`。在任何脚本重新运行中，`st.multiselect` 返回的 `Color` 值将是与该脚本运行中定义的 `Color` 的不同类。

如果你使用 Streamlit 版本 1.28.0 或更早版本运行上面的代码片段，你将无法看到特殊消息。幸运的是，从版本 1.29.0 起，Streamlit 引入了一个配置选项来大大简化问题。这就是启用的默认 `enumCoercion` 配置选项的用武之地。

### 理解 `enumCoercion` 配置选项

启用 `enumCoercion` 后，Streamlit 会尝试识别你何时使用元素（如 `st.multiselect` 或 `st.selectbox`），且以一组 `Enum` 成员为选项。

如果 Streamlit 检测到这一点，它会将小部件的返回值转换为最新脚本运行中定义的 `Enum` 类的成员。这是我们称之为自动 `Enum` 强制转换的东西。

此行为可通过你的 Streamlit `config.toml` 文件中的 `enumCoercion` 设置进行[配置](/develop/concepts/configuration)。它默认启用，并可能被禁用或设置为一组更严格的匹配条件。

如果你发现在启用 `enumCoercion` 的情况下仍然遇到问题，请考虑使用上面描述的[自定义类模式](#patterns-to-define-your-custom-classes)，例如将你的 `Enum` 类定义移到单独的模块文件中。

---

# 数据框

Source: https://docs.streamlit.io/develop/concepts/design/dataframes


数据框是以表格格式显示和编辑数据的好方法。使用 Pandas 数据框和其他表格数据结构是数据科学工作流的关键。如果开发人员和数据科学家想在 Streamlit 中显示此数据，他们有多个选项：`st.dataframe` 和 `st.data_editor`。如果你想仅在类似表格的 UI 中显示数据，[st.dataframe](/develop/api-reference/data/st.dataframe) 是正确的方法。如果你想以交互方式编辑数据，请使用 [st.data_editor](/develop/api-reference/data/st.data_editor)。我们在以下部分中探讨每个选项的使用情况和优势。

## 使用 st.dataframe 显示数据框

Streamlit 可以通过 `st.dataframe` 在类似表格的 UI 中显示数据框：

```python
import streamlit as st
import pandas as pd

df = pd.DataFrame(
    [
        {"command": "st.selectbox", "rating": 4, "is_widget": True},
        {"command": "st.balloons", "rating": 5, "is_widget": False},
        {"command": "st.time_input", "rating": 3, "is_widget": True},
    ]
)

st.dataframe(df, use_container_width=True)
```

<Cloud height="300px" name="doc-dataframe-basic"/>

## `st.dataframe` UI 功能

`st.dataframe` 通过在底层使用 [glide-data-grid](https://github.com/glideapps/glide-data-grid) 提供额外的功能：

- **列排序**：要排序列，请选择其标题，或从标题菜单中选择"**升序排列**"或"**降序排列**"（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>）。
- **列调整大小**：要调整列的大小，请拖放列标题边框，或从标题菜单中选择"**自动调整**"。
- **列隐藏**：要隐藏列，请从标题菜单中选择"**隐藏列**"。
- **重新排序和固定列**：要重新排序列或将其固定在左侧，请拖放列标题或分别从标题菜单中选择"**固定列**"。
- **格式化数字、日期和时间**：要更改数值列的格式，请在标题菜单中的"**格式**"下选择一个选项。
- **数据框调整大小**：要调整数据框大小，请拖放右下角。
- **全屏视图**：要将数据框放大到全屏，请选择工具栏中的全屏图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;fullscreen</i>）。
- **搜索**：要搜索数据，请选择工具栏中的搜索图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;search</i>）或使用热键（`⌘+F` 或 `Ctrl+F`）。
- **下载**：要将数据下载为 CSV 文件，请选择工具栏中的下载图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;download</i>）。
- **复制到剪贴板**：要将数据复制到剪贴板，请选择一个或多个单元格，使用热键（`⌘+C` 或 `Ctrl+C`），然后将其粘贴到你喜欢的电子表格软件中。

<YouTube videoId="nauAnULRG1c">autoplay /&gt;

使用上一部分中的嵌入式应用尝试所有 UI 功能。

除了 Pandas DataFrames，`st.dataframe` 还支持其他常见的 Python 类型，例如列表、字典或 numpy 数组。它还支持 [Snowpark](https://docs.snowflake.com/en/developer-guide/snowpark/index) 和 [PySpark](https://spark.apache.org/docs/latest/api/python/) DataFrames，这些允许你懒惰地计算数据和从数据库中提取数据。这对于处理大型数据集很有用。

## 使用 st.data_editor 编辑数据

Streamlit 通过 `st.data_editor` 命令支持可编辑的数据框。在 [st.data_editor](/develop/api-reference/data/st.data_editor) 中查看其 API。它在表格中显示数据框，类似于 `st.dataframe`。但与 `st.dataframe` 不同，这个表格不是静态的！用户可以点击单元格并编辑它们。然后编辑的数据在 Python 端返回。以下是一个示例：

```python
df = pd.DataFrame(
    [
        {"command": "st.selectbox", "rating": 4, "is_widget": True},
        {"command": "st.balloons", "rating": 5, "is_widget": False},
        {"command": "st.time_input", "rating": 3, "is_widget": True},
    ]
)

edited_df = st.data_editor(df) # 👈 An editable dataframe

favorite_command = edited_df.loc[edited_df["rating"].idxmax()]["command"]
st.markdown(f"Your favorite command is **{favorite_command}** 🎈")
```

<Cloud height="300px" name="doc-data-editor"/>

尝试一下，双击任何单元格。你会注意到你可以编辑所有单元格值。尝试编辑评分列中的值并观察底部的文本输出如何变化：

## `st.data_editor` UI 功能

`st.data_editor` 还支持一些额外的功能：

- [**添加和删除行**](#add-and-delete-rows)：你可以在调用 `st.data_editor` 时设置 `num_rows="dynamic"` 来做到这一点。这将允许用户根据需要添加和删除行。
- [**复制和粘贴支持**](#copy-and-paste-support)：在 `st.data_editor` 和 Google Sheets、Excel 等电子表格软件之间进行复制和粘贴。
- [**访问编辑的数据**](#access-edited-data)：通过 Session State 仅访问单个编辑，而不是整个编辑的数据结构。
- [**批量编辑**](#bulk-edits)：类似于 Excel，只需拖动一个句柄来编辑相邻的单元格。
- [**自动输入验证**](#automatic-input-validation)：列配置提供强大的数据类型支持和其他可配置的选项。例如，无法将字母输入到数字单元格中。数字单元格可以有指定的最小值和最大值。
- [**编辑常见的数据结构**](#edit-common-data-structures)：`st.data_editor` 支持列表、字典、NumPy 数组等！

<YouTube videoId="6tah69LkfxE">autoplay /&gt;

### 添加和删除行

使用 `st.data_editor`，观看者可以通过表格 UI 添加或删除行。这个模式可以通过将 `num_rows` 参数设置为 `"dynamic"` 来激活：

```python
edited_df = st.data_editor(df, num_rows="dynamic")
```

- 要添加新行，请点击工具栏中的加号图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;add</i>）。或者，点击表格最后一行下方的带阴影的单元格。
- 要删除行，请使用左侧的复选框选择一个或多个行。点击删除图标（<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;delete</i>）或在键盘上按 `delete` 键。

<Cloud height="400px" name="doc-data-editor-clipboard"/>

### 复制和粘贴支持

数据编辑器支持从 Google Sheets、Excel、Notion 和许多其他类似工具粘贴表格数据。你也可以在 `st.data_editor` 实例之间复制粘贴数据。这个功能由 [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API) 提供支持，对于需要跨多个平台处理数据的用户来说可以是一个巨大的时间节省器。要尝试它：

1. 从 [这个 Google Sheets 文档](https://docs.google.com/spreadsheets/d/1Z0zd-5dF_HfqUaDDq4BWAOnsdlGCjkbTNwDZMBQ1dOY/edit?usp=sharing) 复制数据到你的剪贴板。
2. 在上面的应用中单击 `name` 列中的任何单元格。使用热键（`⌘+V` 或 `Ctrl+V`）粘贴它。

<Note>

粘贴的数据的每个单元格将被单独计算，如果数据与列类型兼容，则插入到单元格中。例如，将非数字文本数据粘贴到数字列中将被忽略。

</Note>
<Tip>

如果你使用 iframe 嵌入应用，你需要允许 iframe 访问剪贴板，如果你想使用复制粘贴功能。为此，请给 iframe [`clipboard-write`](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write) 和 [`clipboard-read`](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/read) 权限。例如

```javascript
<iframe allow="clipboard-write;clipboard-read;">... src="https://your-app-url"&gt;</iframe>
```

作为开发者，使用 TLS 时确保应用由有效的、受信任的证书提供。如果用户在复制和粘贴数据时遇到问题，请让他们检查他们的浏览器是否已为 Streamlit 应用激活剪贴板访问权限，无论是在提示时还是通过浏览器的网站设置。

</Tip>

### 访问编辑的数据

有时，知道哪些单元格被更改比获得整个编辑的数据框返回更方便。Streamlit 通过使用 [Session State](/develop/concepts/architecture/session-state) 使这变得容易。如果设置了 `key` 参数，Streamlit 将把对数据框所做的任何更改存储在 Session State 中。

这个代码片段展示了如何使用 Session State 访问更改的数据：

```python
st.data_editor(df, key="my_key", num_rows="dynamic") # 👈 设置一个 key
st.write("Session State 中的值是：")
st.write(st.session_state["my_key"]) # 👈 显示 Session State 中的值
```

在这个代码片段中，`key` 参数设置为 `"my_key"`。创建数据编辑器后，Session State 中与 `"my_key"` 关联的值使用 `st.write` 在应用中显示。这显示了进行的添加、编辑和删除。

当处理大数据框时，这可能很有用，你只需要知道哪些单元格已更改，而不是访问整个编辑的数据框。

<Cloud height="700px" name="doc-data-editor-changed"/>

使用我们到目前为止学到的所有内容，并将它们应用到上面的嵌入式应用中。尝试编辑单元格、添加新行和删除行。

注意表格的编辑如何反映在 Session State 中。当你进行任何编辑时，会触发重新运行，将编辑发送到后端。小部件的状态是一个包含三个属性的 JSON 对象：**edited_rows**、**added_rows** 和 **deleted_rows：**。

<Warning>

从 1.23.0 中的 `st.experimental_data_editor` 迁移到 `st.data_editor` 时，数据编辑器在 `st.session_state` 中的表示已更改。`edited_cells` 字典现在称为 `edited_rows`，并使用不同的格式（`{0: {"column name": "edited value"}}` 而不是 `{"0:1": "edited value"}`）。如果你的应用在与 `st.session_state` 结合使用 `st.experimental_data_editor` 时，你可能需要调整代码。"

</Warning>

- `edited_rows` 是包含所有编辑的字典。键是从零开始的行索引，值是将列名映射到编辑的字典（例如 `{0: {"col1": ..., "col2": ...}}`）。
- `added_rows` 是新添加的行列表。每个值都是上述格式相同的字典（例如 `[{"col1": ..., "col2": ...}]`）。
- `deleted_rows` 是已从表中删除的行号列表（例如 `[0, 2]`）。

`st.data_editor` 不支持重新排序行，所以添加的行将始终附加到数据框的末尾，任何编辑和删除都适用于原始行。

### 批量编辑

数据编辑器包括一个允许批量编辑单元格的功能。类似于 Excel，你可以跨单元格选择拖动一个句柄来批量编辑它们的值。你甚至可以在电子表格软件中应用常用的 [键盘快捷键](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md#keybindings)。当你需要对多个单元格进行相同的更改，而不是单独编辑每个单元格时，这很有用。

### 编辑常见的数据结构

编辑不仅适用于 Pandas DataFrames！你还可以编辑列表、元组、集合、字典、NumPy 数组或 Snowpark  PySpark DataFrames。大多数数据类型将以其原始格式返回。但某些类型（例如 Snowpark 和 PySpark）会转换为 Pandas DataFrames。要了解所有支持的类型，请阅读 [st.data_editor](/develop/api-reference/data/st.data_editor) API。

例如，你可以轻松让用户向列表中添加项目：

```python
edited_list = st.data_editor(["red", "green", "blue"], num_rows="dynamic")
st.write("以下是你输入的所有颜色：")
st.write(edited_list)
```

或 numpy 数组：

```python
import numpy as np

st.data_editor(np.array([
	["st.text_area", "widget", 4.92],
	["st.markdown", "element", 47.22]
]))
```

或记录列表：

```python
st.data_editor([
    {"name": "st.text_area", "type": "widget"},
    {"name": "st.markdown", "type": "element"},
])
```

或字典和许多其他类型！

```python
st.data_editor({
	"st.text_area": "widget",
	"st.markdown": "element"
})
```

### 自动输入验证

数据编辑器包括自动输入验证，以帮助防止编辑单元格时出错。例如，如果你有一列包含数值数据，输入字段将自动限制用户仅输入数值数据。这有助于防止用户意外输入非数值数据可能导致的错误。可以通过 [列配置 API](/develop/api-reference/data/st.column_config) 配置其他输入验证。继续阅读下文以获取列配置概述，包括验证选项。

## 配置列

你可以通过 [列配置 API](/develop/api-reference/data/st.column_config) 在 `st.dataframe` 和 `st.data_editor` 中配置列的显示和编辑行为。我们开发了 API 以让你在数据框和数据编辑器列中添加图像、图表和可点击的 URL。此外，你可以使单个列可编辑，将列设置为分类并指定可以取哪些选项，隐藏数据框的索引等。

列配置包括以下列类型：Text、Number、Checkbox、Selectbox、Date、Time、Datetime、List、Link、Image、Line chart、Bar chart 和 Progress。还有一个通用的 Column 选项。查看下面的嵌入式应用以查看这些不同的列类型。每个列类型都在 [列配置 API](/develop/api-reference/data/st.column_config) 文档中单独预览。

<Cloud height="480px" name="doc-column-config-overview" query="embed_options=disable_scrolling"/>

### 格式化值

`format` 参数在 [Text](/develop/api-reference/data/st.column_config/st.column_config.textcolumn)、[Date](/develop/api-reference/data/st.column_config/st.column_config.datecolumn)、[Time](/develop/api-reference/data/st.column_config/st.column_config.timecolumn) 和 [Datetime](/develop/api-reference/data/st.column_config/st.column_config.datetimecolumn) 列的列配置中可用。类似图表的列也可以被格式化。[折线图](/develop/api-reference/data/st.column_config/st.column_config.linechartcolumn) 和 [柱状图](/develop/api-reference/data/st.column_config/st.column_config.barchartcolumn) 列有 `y_min` 和 `y_max` 参数来设置垂直边界。对于 [Progress 列](/develop/api-reference/data/st.column_config/st.column_config.progresscolumn)，你可以用 `min_value` 和 `max_value` 声明水平边界。

### 验证输入

指定列配置时，你不仅可以声明列的数据类型，还可以声明值限制。所有列配置元素都允许你使用关键字参数 `required=True` 使列为必需。

对于 Text 和 Link 列，你可以使用 `max_chars` 指定最大字符数，或使用正则表达式通过 `validate` 验证条目。数值列，包括 Number、Date、Time 和 Datetime 有 `min_value` 和 `max_value` 参数。Selectbox 列有可配置的 `options` 列表。

Number 列的数据类型默认为 `float`。将类型为 `int` 的值传递给 `min_value`、`max_value`、`step` 或 `default` 中的任何一个都会将列的类型设置为 `int`。

### 配置空数据框

你可以使用 `st.data_editor` 从用户收集表格输入。从空数据框开始时，默认列类型为文本。使用列配置指定你想从用户收集的数据类型。

```python
import streamlit as st
import pandas as pd

df = pd.DataFrame(columns=['name','age','color'])
colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
config = {
    'name' : st.column_config.TextColumn('Full Name (required)', width='large', required=True),
    'age' : st.column_config.NumberColumn('Age (years)', min_value=0, max_value=122),
    'color' : st.column_config.SelectboxColumn('Favorite Color', options=colors)
}

result = st.data_editor(df, column_config = config, num_rows='dynamic')

if st.button('Get results'):
    st.write(result)
```

<Cloud height="300px" name="doc-column-config-empty"/>

## 其他格式化选项

除了列配置外，`st.dataframe` 和 `st.data_editor` 还有一些参数来自定义数据框的显示。

- `hide_index` ：设置为 `True` 以隐藏数据框的索引。
- `column_order` ：传递列标签列表以指定显示顺序。
- `disabled` ：传递列标签列表以禁用它们的编辑。这让你可以避免单独禁用它们。

## 处理大型数据集

`st.dataframe` 和 `st.data_editor` 得益于使用 glide-data-grid 库和 HTML canvas 的高性能实现，已设计为理论上处理包含数百万行的表格。但是，应用可以现实处理的最大数据量将取决于许多其他因素，包括：

1. WebSocket 消息的最大大小：Streamlit 的 WebSocket 消息可通过 `server.maxMessageSize` [配置选项](https://docs.streamlit.io/develop/concepts/configuration#view-all-configuration-options) 配置，这限制了一次可以通过 WebSocket 连接传输的数据量。
2. 服务器内存：应用可以处理的数据量也取决于服务器上可用的内存量。如果服务器的内存被超出，应用可能会变得缓慢或无响应。
3. 用户的浏览器内存：由于所有数据都需要传输到用户的浏览器以进行渲染，用户设备上可用的内存量也会影响应用的性能。如果浏览器的内存被超出，它可能会崩溃或无响应。

除了这些因素外，慢速网络连接也会显著减速处理大型数据集的应用。

处理超过 150,000 行的大型数据集时，Streamlit 应用额外的优化并禁用列排序。这可以帮助减少一次需要处理的数据量，并提高应用的性能。

## 限制

- Streamlit 在内部将所有列名转换为字符串，所以 `st.data_editor` 将返回一个所有列名都是字符串的 DataFrame。
- 数据框工具栏目前不可配置。
- 虽然 Streamlit 的数据编辑功能提供了很多功能，但编辑仅针对有限的列类型集启用（[TextColumn](/develop/api-reference/data/st.column_config/st.column_config.textcolumn)、[NumberColumn](/develop/api-reference/data/st.column_config/st.column_config.numbercolumn)、[LinkColumn](/develop/api-reference/data/st.column_config/st.column_config.linkcolumn)、[CheckboxColumn](/develop/api-reference/data/st.column_config/st.column_config.checkboxcolumn)、[SelectboxColumn](/develop/api-reference/data/st.column_config/st.column_config.selectboxcolumn)、[DateColumn](/develop/api-reference/data/st.column_config/st.column_config.datecolumn)、[TimeColumn](/develop/api-reference/data/st.column_config/st.column_config.timecolumn) 和 [DatetimeColumn](/develop/api-reference/data/st.column_config/st.column_config.datetimecolumn)）。我们正在积极开发对其他列类型（如图像、列表和图表）的编辑支持。
- 几乎所有可编辑的数据类型都支持索引编辑。但是，`pandas.CategoricalIndex` 和 `pandas.MultiIndex` 不支持编辑。
- 当 `num_rows="dynamic"` 时，`st.data_editor` 不支持排序。
- 在超过 150,000 行的大型数据集上禁用排序以优化性能。

我们不断致力于改进 Streamlit 对 DataFrame 的处理并向数据编辑添加功能，所以请关注更新。</YouTube></YouTube>

---

# Streamlit 中的多线程处理

Source: https://docs.streamlit.io/develop/concepts/design/multithreading


多线程处理是一种并发类型，可以提高计算机程序的效率。这是处理器执行多任务的一种方式。Streamlit 在其架构中使用线程，这可能使应用开发人员难以包含他们自己的多线程过程。Streamlit 不正式支持应用代码中的多线程处理，但本指南提供了有关如何实现的信息。

## 前置条件

- 你应该对 Streamlit 的[架构](/develop/concepts/architecture/architecture)有基本的理解。

## 何时使用多线程处理

多线程处理只是并发的一种类型。多处理和协程是并发的其他形式。你需要理解代码如何被限制以选择正确的并发类型。

多处理本质上是并行的，意味着资源被分割并且多个任务同时执行。因此，多处理对于计算密集型操作很有帮助。相比之下，多线程处理和协程本质上不是并行的，而是允许资源切换。这使得它们是一个不错的选择，当你的代码被困在等待某些东西时，例如 IO 操作。AsyncIO 使用协程，可能对于非常慢的 IO 操作更可取。线程处理可能对于更快的 IO 操作更可取。有关将 AsyncIO 与 Streamlit 一起使用的有用指南，请参阅[Sehmi-Conscious Thoughts 的这篇 Medium 文章](https://sehmi-conscious.medium.com/got-that-asyncio-feeling-f1a7c37cab8b)。

别忘了 Streamlit 也有[片段](/develop/concepts/architecture/fragments)和[缓存](/develop/concepts/architecture/caching)！使用缓存来避免不必要地重复计算或 IO 操作。使用片段来隔离你想从应用的其余部分单独更新的一段代码。你可以将片段设置为以指定的间隔重新运行，这样它们可以用于流式更新图表或表格。

## Streamlit 创建的线程

Streamlit creates two types of threads in Python:

- The **server thread** runs the Tornado web (HTTP + WebSocket) server.
- A **script thread** runs page code  one thread for each script run in a session.
## Streamlit 创建的线程

Streamlit 在 Python 中创建两种类型的线程：

- **服务器线程**运行 Tornado web（HTTP + WebSocket）服务器。
- **脚本线程**运行页面代码 — 每个会话中的脚本运行一个线程。

当用户连接到你的应用时，这会创建一个新的会话并运行脚本线程来为该用户初始化应用。当脚本线程运行时，它在用户的浏览器标签中呈现元素并向服务器报告状态。当用户与应用交互时，另一个脚本线程运行，重新呈现浏览器标签中的元素并更新服务器上的状态。

这是一个简化的图示，显示 Streamlit 如何工作：

![每个用户会话都使用脚本线程在用户的前端和 Streamlit 服务器之间进行通信。](/images/concepts/Streamlit-threading.svg)

## `streamlit.errors.NoSessionContext`

许多 Streamlit 命令，包括 `st.session_state`，期望从脚本线程调用。当 Streamlit 按预期运行时，此类命令使用附加到脚本线程的 `ScriptRunContext` 来确保它们在预期的会话中工作并更新正确的用户视图。当那些 Streamlit 命令找不到任何 `ScriptRunContext` 时，它们会引发 `streamlit.errors.NoSessionContext` 异常。根据你的记录器设置，你也可能看到一个控制台消息，按名称标识线程并警告"缺少 ScriptRunContext！"

## 创建自定义线程

当你使用 IO 密集操作（如远程查询或数据加载）时，你可能需要减少延迟。一般编程策略是创建线程并让它们并发工作。但是，如果你在 Streamlit 应用中执行此操作，这些自定义线程可能在与 Streamlit 服务器交互时遇到困难。

本部分介绍两种模式，让你在 Streamlit 应用中创建自定义线程。这些只是提供起点而不是完整解决方案的模式。

### 选项 1：不在自定义线程内使用 Streamlit 命令

如果你不从自定义线程调用 Streamlit 命令，你可以完全避免该问题。幸运的是，Python 线程处理提供了启动线程并从另一个线程收集其结果的方法。

在以下示例中，从脚本线程创建五个自定义线程。线程完成运行后，它们的结果显示在应用中。

```python
import streamlit as st
import time
from threading import Thread


class WorkerThread(Thread):
    def __init__(self, delay):
        super().__init__()
        self.delay = delay
        self.return_value = None

    def run(self):
        start_time = time.time()
        time.sleep(self.delay)
        end_time = time.time()
        self.return_value = f"start: {start_time}, end: {end_time}"


delays = [5, 4, 3, 2, 1]
threads = [WorkerThread(delay) for delay in delays]
for thread in threads:
    thread.start()
for thread in threads:
    thread.join()
for i, thread in enumerate(threads):
    st.header(f"Thread {i}")
    st.write(thread.return_value)

st.button("Rerun")
```

<Cloud height="700px" name="doc-multithreading-no-st-commands-batched"/>

如果你想在应用中显示结果，当各种自定义线程完成运行时，使用容器。在以下示例中，五个自定义线程的创建方式与之前的示例类似。但是，在运行自定义线程之前初始化五个容器，并使用 `while` 循环在结果可用时显示它们。由于 Streamlit `write` 命令是在自定义线程外部调用的，这不会引发异常。

```python
import streamlit as st
import time
from threading import Thread


class WorkerThread(Thread):
    def __init__(self, delay):
        super().__init__()
        self.delay = delay
        self.return_value = None

    def run(self):
        start_time = time.time()
        time.sleep(self.delay)
        end_time = time.time()
        self.return_value = f"start: {start_time}, end: {end_time}"


delays = [5, 4, 3, 2, 1]
result_containers = []
for i, delay in enumerate(delays):
    st.header(f"Thread {i}")
    result_containers.append(st.container())

threads = [WorkerThread(delay) for delay in delays]
for thread in threads:
    thread.start()
thread_lives = [True] * len(threads)

while any(thread_lives):
    for i, thread in enumerate(threads):
        if thread_lives[i] and not thread.is_alive():
            result_containers[i].write(thread.return_value)
            thread_lives[i] = False
    time.sleep(0.5)

for thread in threads:
    thread.join()

st.button("Rerun")
```

<Cloud height="700px" name="doc-multithreading-no-st-commands-iterative"/>

### 选项 2：向线程暴露 `ScriptRunContext`

如果你想从自定义线程内调用 Streamlit 命令，你必须将正确的 `ScriptRunContext` 附加到线程。

<Warning>

- 这不被正式支持，并且可能在 Streamlit 的未来版本中更改。
- 这可能不适用于所有 Streamlit 命令。
- 确保自定义线程不会超过拥有 `ScriptRunContext` 的脚本线程的生命周期。`ScriptRunContext` 的泄漏可能导致安全漏洞、致命错误或意外行为。

</Warning>

在以下示例中，附加了 `ScriptRunContext` 的自定义线程可以调用 `st.write` 而不会出现警告。

```python
import streamlit as st
from streamlit.runtime.scriptrunner import add_script_run_ctx, get_script_run_ctx
import time
from threading import Thread


class WorkerThread(Thread):
    def __init__(self, delay, target):
        super().__init__()
        self.delay = delay
        self.target = target

    def run(self):
        # 在自定义线程中运行，但可以调用 Streamlit API
        start_time = time.time()
        time.sleep(self.delay)
        end_time = time.time()
        self.target.write(f"start: {start_time}, end: {end_time}")


delays = [5, 4, 3, 2, 1]
result_containers = []
for i, delay in enumerate(delays):
    st.header(f"Thread {i}")
    result_containers.append(st.container())

threads = [
    WorkerThread(delay, container)
    for delay, container in zip(delays, result_containers)
]
for thread in threads:
    add_script_run_ctx(thread, get_script_run_ctx())
    thread.start()

for thread in threads:
    thread.join()

st.button("Rerun")
```

<Cloud height="700px" name="doc-multithreading-expose-context"/>

---

# 处理时区

Source: https://docs.streamlit.io/develop/concepts/design/timezone-handling


一般来说，处理时区可能很棘手。你的 Streamlit 应用用户不一定与运行你的应用的服务器位于同一时区。对于公开应用尤其如此，世界上任何时区的任何人都可以访问你的应用。因此，了解 Streamlit 如何处理时区至关重要，这样你可以避免在显示 `datetime` 信息时出现意外行为。

## Streamlit 如何处理时区

Streamlit 始终在前端显示 `datetime` 信息与其后端对应 `datetime` 实例相同的信息。即，日期或时间信息不会自动调整到用户的时区。我们区分以下两种情况：

### **不带时区的 `datetime` 实例（朴素）**

当你提供 _不指定时区的_ `datetime` 实例时，前端会显示没有时区信息的 `datetime` 实例。例如（这也适用于其他小部件，如 [`st.dataframe`](/develop/api-reference/data/st.dataframe)）：

```python
import streamlit as st
from datetime import datetime

st.write(datetime(2020, 1, 10, 10, 30))
# 输出: 2020-01-10 10:30:00
```

上面应用的用户始终看到输出为 `2020-01-10 10:30:00`。

### **带时区的 `datetime` 实例**

当你提供 _并指定时区的_ `datetime` 实例时，前端会显示该时区中的 `datetime` 实例。例如（这也适用于其他小部件，如 [`st.dataframe`](/develop/api-reference/data/st.dataframe)）：

```python
import streamlit as st
from datetime import datetime
import pytz

st.write(datetime(2020, 1, 10, 10, 30, tzinfo=pytz.timezone("EST")))
# 输出: 2020-01-10 10:30:00-05:00
```

上面应用的用户始终看到输出为 `2020-01-10 10:30:00-05:00`。

在这两种情况下，日期或时间信息都不会在前端自动调整到用户的时区。用户看到的与后端对应的 `datetime` 实例相同。目前不可能自动将日期或时间信息调整到查看应用的用户的时区。

<Note>

`st.dataframe` 的旧版本在时区方面有问题。我们不计划为旧版数据框推出额外的修复或增强功能。如果你需要稳定的时区支持，请考虑通过更改[配置设置](/develop/concepts/configuration)来切换到箭头序列化，_config.dataFrameSerialization = "arrow"_。

</Note>

---

# 多页应用

Source: https://docs.streamlit.io/develop/concepts/multipage-apps


<TileContainer layout="list">
<RefCard href="/develop/concepts/multipage-apps/overview">
<h5>多页应用的概述</h5>

Streamlit 提供了多种定义多页应用的方法。了解术语和方法之间的基本比较。

</RefCard>
<RefCard href="/develop/concepts/multipage-apps/page-and-navigation">
<h5>使用 <code>st.Page</code> 和 <code>st.navigation</code> 定义多页应用</h5>

了解定义多页应用的首选方法。`st.Page` 和 `st.navigation` 让您可以灵活地组织项目目录并按您的意愿标记页面。

</RefCard>
<RefCard href="/develop/concepts/multipage-apps/pages-directory">
<h5>使用 <code>pages/</code> 目录创建多页应用</h5>

通过目录结构定义您的多页应用。将额外的 Python 文件放在 `pages/` 目录中，与您的入口点文件一起，页面将自动显示在应用侧边栏中的导航部件中。

</RefCard>
<RefCard href="/develop/concepts/multipage-apps/widgets">
<h5>在多页应用中使用部件</h5>

了解部件身份如何与页面绑定。学习策略以获得您想要的部件行为。

</RefCard>
</TileContainer>

---

# 多页应用的概述

Source: https://docs.streamlit.io/develop/concepts/multipage-apps/overview


Streamlit 提供了两种内置机制来创建多页应用。最简单的方法是使用 `pages/` 目录。然而，首选且更可定制的方法是使用 `st.navigation`。

## `st.Page` 和 `st.navigation`

如果您想要在定义多页应用时获得最大灵活性，我们推荐使用 `st.Page` 和 `st.navigation`。使用 `st.Page`，您可以将任何 Python 文件或 `Callable` 声明为应用中的页面。此外，您可以在入口点文件中定义页面的公共元素（您传递给 `streamlit run` 的文件）。使用这些方法，您的入口点文件就像所有页面共享的画框一样。

您必须在入口点文件中包含 `st.navigation` 来配置应用的导航菜单。这也是您的入口点文件作为页面之间路由器的方式。

## `pages/` 目录

如果您正在寻找快速简单的解决方案，只需在入口点文件旁边放置一个 `pages/` 目录。对于 `pages/` 目录中的每个 Python 文件，Streamlit 将为您的应用创建额外的页面。Streamlit 从文件名确定页面标签和 URL，并自动在应用侧边栏顶部填充导航菜单。

```
your_working_directory/
├── pages/
│   ├── a_page.py
│   └── another_page.py
└── your_homepage.py
```

Streamlit 从文件名确定导航中的页面顺序。您可以在文件名中使用数字前缀来调整页面顺序。有关更多信息，请参见[侧边栏中的页面排序方式](/develop/concepts/multipage-apps/pages-directory#how-pages-are-sorted-in-the-sidebar)。如果您想使用此选项自定义导航菜单，您可以通过[配置](/develop/api-reference/configuration/config.toml)（`client.showSidebarNavigation = false`）停用默认导航。然后，您可以使用 `st.page_link` 手动构建自定义导航菜单。使用 `st.page_link`，您可以更改导航菜单中的页面标签和图标，但不能更改页面的 URL。

## 页面术语

页面有四个识别部分，如下所示：

- **页面源**：这是包含页面源代码的 Python 文件或可调用函数。
- **页面标签**：这是页面在导航菜单中的标识方式。请参见 <i>{{ verticalAlign: "-.25em" }} class="material-icons-sharp"&gt;looks_one</i>。
- **页面标题**：这是 HTML `<title>` 元素的内容，以及页面在浏览器标签页中的标识方式。请参见 <i>{{ verticalAlign: "-.25em" }} class="material-icons-sharp"&gt;looks_two</i>。
- **页面 URL 路径名**：这是从应用根 URL 的页面相对路径。请参见 <i>{{ verticalAlign: "-.25em" }} class="material-icons-sharp"&gt;looks_3</i>。

此外，页面可以有两个图标，如下所示：

- **页面 favicon**：这是页面标题旁边在浏览器标签页中的图标。请参见 <i>{{ verticalAlign: "-.25em" }} class="material-icons-sharp"&gt;looks_4</i>。
- **页面图标**：这是导航菜单中页面标签旁边的图标。请参见 <i>{{ verticalAlign: "-.25em" }} class="material-icons-sharp"&gt;looks_5</i>。

通常，页面图标和 favicon 是相同的，但可以使它们不同。

<div>{{ maxWidth: '564px', margin: 'auto' }}&gt;
<Image caption="1. 页面标签, 2.页面标题, 3. 页面 URL 路径名, 4.页面 favicon, 5. 页面图标" src="/images/page_parts.jpg"/>
</div>

## Automatic page labels and URLs

If you use `st.Page` without declaring the page title or URL pathname, Streamlit falls back on automatically determining the page label, title, and URL pathname in the same manner as when you use a `pages/` directory with the default navigation menu. This section describes this naming convention which is shared between the two approaches to multipage apps.

### Parts of filenames and callables

Filenames are composed of four different parts as follows (in order):

1. `number`: A non-negative integer.
2. `separator`: Any combination of underscore (`"_"`), dash (`"-"`), and space (`" "`).
3. `identifier`: Everything up to, but not including, `".py"`.
4. `".py"`

For callables, the function name is the `identifier`, including any leading or trailing underscores.

### How Streamlit converts filenames into labels and titles

Within the navigation menu, Streamlit displays page labels and titles as follows:

1. If your page has an `identifier`, Streamlit displays the `identifier`. Any underscores within the page's `identifier` are treated as spaces. Therefore, leading and trailing underscores are not shown. Sequential underscores appear as a single space.
2. Otherwise, if your page has a `number` but does not have an `identifier`, Streamlit displays the `number`, unmodified. Leading zeros are included, if present.
3. Otherwise, if your page only has a `separator` with no `number` and no `identifier`, Streamlit will not display the page in the sidebar navigation.

The following filenames and callables would all display as "Awesome page" in the sidebar navigation.

- `"Awesome page.py"`
- `"Awesome_page.py"`
- `"02Awesome_page.py"`
- `"--Awesome_page.py"`
- `"1_Awesome_page.py"`
- `"33 - Awesome page.py"`
- `Awesome_page()`
- `_Awesome_page()`
- `__Awesome_page__()`

### How Streamlit converts filenames into URL pathnames

Your app's homepage is associated to the root URL of app. For all other pages, their `identifier` or `number` becomes their URL pathname as follows:

- If your page has an `identifier` that came from a filename, Streamlit uses the `identifier` with one modification. Streamlit condenses each consecutive grouping of spaces (`" "`) and underscores (`"_"`) to a single underscore.
- Otherwise, if your page has an `identifier` that came from the name of a callable, Streamlit uses the `identifier` unmodified.
- Otherwise, if your page has a `number` but does not have an `identifier`, Streamlit uses the `number`. Leading zeros are included, if present.

For each filename in the list above, the URL pathname would be "Awesome_page" relative to the root URL of the app. For example, if your app was running on `localhost` port `8501`, the full URL would be `localhost:8501/awesome_page`. For the last two callables, however, the pathname would include the leading and trailing underscores to match the callable name exactly.

## Navigating between pages

The primary way users navigate between pages is through the navigation widget. Both methods for defining multipage apps include a default navigation menu that appears in the sidebar. When a user clicks this navigation widget, the app reruns and loads the selected page. Optionally, you can hide the default navigation UI and build your own with [`st.page_link`](/develop/api-reference/widgets/st.page_link). For more information, see [Build a custom navigation menu with `st.page_link`](/develop/tutorials/multipage/st.page_link-nav).

If you need to programmatically switch pages, use [`st.switch_page`](/develop/api-reference/navigation/st.switch_page).

Users can also navigate between pages using URLs as noted above. When multiple files have the same URL pathname, Streamlit picks the first one (based on the ordering in the navigation menu. Users can view a specific page by visiting the page's URL.

<Important>
    Navigating between pages by URL creates a new browser session. In particular, clicking markdown links to other pages resets ``st.session_state``. In order to retain values in ``st.session_state``, handle page switching through Streamlit navigation commands and widgets, like ``st.navigation``, ``st.switch_page``, ``st.page_link``, and the built-in navigation menu.
</Important>

If a user tries to access a URL for a page that does not exist, they will see a modal like the one below, saying "Page not found."

<div>{{ maxWidth: '75%', margin: 'auto' }}&gt;
<Image alt="Page not found" src="/images/mpa-page-not-found.png"/>
</div></title>

---

# 使用 `st.Page` 和 `st.navigation` 定义多页应用

Source: https://docs.streamlit.io/develop/concepts/multipage-apps/page-and-navigation


`st.Page` 和 `st.navigation` 是定义多页应用的首选命令。使用这些命令，您可以灵活地组织项目文件并自定义导航菜单。只需使用 `st.Page` 初始化 `StreamlitPage` 对象，然后在入口点文件中（即您传递给 `streamlit run` 的文件）将这些 `StreamlitPage` 对象传递给 `st.navigation`。

此页面假设您了解概述中介绍的[页面术语](/develop/concepts/multipage-apps/overview#page-terminology)。

## 应用结构

使用 `st.navigation` 时，您的入口点文件充当页面路由器。每个页面都是从入口点文件执行的脚本。您可以从 Python 文件或函数定义页面。如果您在入口点文件中包含元素或部件，它们将成为页面之间的公共元素。在这种情况下，您可以将入口点文件想象成每个页面的画框。

您每个应用运行只能调用一次 `st.navigation`，并且必须从入口点文件调用。当用户在导航中选择页面（或通过像 `st.switch_page` 这样的命令路由）时，`st.navigation` 返回选定的页面。您必须使用 `.run()` 方法手动执行该页面。以下示例是一个两页应用，其中每个页面由 Python 文件定义。

**目录结构：**

```
your-repository/
├── page_1.py
├── page_2.py
└── streamlit_app.py
```

**`streamlit_app.py`：**

```python
import streamlit as st

pg = st.navigation([st.Page("page_1.py"), st.Page("page_2.py")])
pg.run()
```

## 定义页面

`st.Page` 让您定义页面。第一个也是唯一必需的参数定义您的页面源，它可以是 Python 文件或函数。使用 Python 文件时，您的页面可以在子目录（或上级目录）中。页面文件的路径必须始终相对于入口点文件。一旦创建页面对象，将它们传递给 `st.navigation` 以将它们注册为应用中的页面。

如果您不定义页面标题或 URL 路径名，Streamlit 将从文件或函数名推断它们，如多页应用[概述](/develop/concepts/multipage-apps/overview#automatic-page-labels-and-urls)中所述。但是，`st.Page` 让您手动配置它们。在 `st.Page` 中，Streamlit 使用 `title` 设置页面标签和标题。此外，Streamlit 使用 `icon` 设置页面图标和 favicon。如果您想要不同的页面标题和标签，或不同的页面图标和 favicon，您可以使用 `st.set_page_config` 更改页面标题和/或 favicon。只需在入口点文件或页面脚本中调用 `st.set_page_config`。您可以多次调用 `st.set_page_config` 来累加配置页面。在入口点文件中使用 `st.set_page_config` 来声明默认配置，并在页面脚本中调用它来覆盖该默认值。

以下示例使用 `st.set_page_config` 在页面间一致地设置页面标题和 favicon。每个页面将在导航菜单中拥有自己的标签和图标，但浏览器标签页将在所有页面上显示一致的标题和 favicon。

**目录结构：**

```
your-repository/
├── create.py
├── delete.py
└── streamlit_app.py
```

**`streamlit_app.py`：**

```python
import streamlit as st

create_page = st.Page("create.py", title="Create entry", icon=":material/add_circle:")
delete_page = st.Page("delete.py", title="Delete entry", icon=":material/delete:")

pg = st.navigation([create_page, delete_page])
st.set_page_config(page_title="Data manager", page_icon=":material/edit:")
pg.run()
```

<div>{{ maxWidth: '564px', margin: 'auto' }}&gt;
<Image src="/images/mpa-v2-use-set-page-config.jpg"/>
</div>

## 自定义导航

您可以使用 `st.navigation` 中的 `position` 参数在侧边栏或应用顶部显示导航菜单。如果您想将页面分组到部分中，`st.navigation` 让您在侧边栏导航中插入标题，或在顶部导航中插入下拉组。或者，您可以禁用默认导航部件并使用 `st.page_link` 构建自定义导航菜单。

此外，您可以动态更改传递给 `st.navigation` 的页面。但是，只有 `st.navigation` 返回的页面接受 `.run()` 方法。如果用户输入带有路径名的 URL，而该路径名未关联到 `st.navigation` 中的页面（首次运行），Streamlit 将抛出"页面未找到"错误并将他们重定向到默认页面。

### 添加部分标题

自定义导航菜单的最简单方法是在 `st.navigation` 中组织页面。您可以排序或分组页面，以及删除您不想让用户访问的任何页面。这是处理用户权限的便捷方式。但是，您不能在导航中隐藏页面同时保持通过直接 URL 访问。如果您需要隐藏页面同时保持可访问性，您需要隐藏默认导航菜单并使用像 `st.page_link` 这样的命令构建导航菜单。

以下示例创建两个菜单状态。当用户开始新会话时，他们未登录。在这种情况下，唯一可用的页面是登录页面。如果用户尝试通过 URL 访问另一个页面，它将创建新会话，Streamlit 将不识别页面。用户将被转移到登录页面。但是，用户登录后，他们将看到带有三个部分的导航菜单，并被定向到仪表板作为应用的默认页面（即主页）。

**目录结构：**

```
your-repository/
├── reports
│   ├── alerts.py
│   ├── bugs.py
│   └── dashboard.py
├── tools
│   ├── history.py
│   └── search.py
└── streamlit_app.py
```

**`streamlit_app.py`：**

```python
import streamlit as st

if "logged_in" not in st.session_state:
    st.session_state.logged_in = False

def login():
    if st.button("Log in"):
        st.session_state.logged_in = True
        st.rerun()

def logout():
    if st.button("Log out"):
        st.session_state.logged_in = False
        st.rerun()

login_page = st.Page(login, title="Log in", icon=":material/login:")
logout_page = st.Page(logout, title="Log out", icon=":material/logout:")

dashboard = st.Page(
    "reports/dashboard.py", title="Dashboard", icon=":material/dashboard:", default=True
)
bugs = st.Page("reports/bugs.py", title="Bug reports", icon=":material/bug_report:")
alerts = st.Page(
    "reports/alerts.py", title="System alerts", icon=":material/notification_important:"
)

search = st.Page("tools/search.py", title="Search", icon=":material/search:")
history = st.Page("tools/history.py", title="History", icon=":material/history:")

if st.session_state.logged_in:
    pg = st.navigation(
        {
            "Account": [logout_page],
            "Reports": [dashboard, bugs, alerts],
            "Tools": [search, history],
        }
    )
else:
    pg = st.navigation([login_page])

pg.run()
```

<div>{{ maxWidth: '564px', margin: 'auto' }}&gt;
<Image src="/images/mpa-v2-page-sections.jpg"/>
</div>

### 动态更改可用页面

您可以通过更新 `st.navigation` 中的页面列表来更改用户可用的页面。这是处理基于角色或基于用户的某些页面访问的便捷方式。有关更多信息，请查看我们的教程，[创建动态导航菜单](/develop/tutorials/multipage/dynamic-navigation)。

### 构建自定义导航菜单

如果您想要对导航菜单进行更多控制，您可以隐藏默认导航并构建自己的导航。您可以通过在 `st.navigation` 命令中包含 `position="hidden"` 来隐藏默认导航。如果您希望页面对用户可用而不显示在导航菜单中，您必须使用此方法。如果页面未包含在 `st.navigation` 中，用户无法路由到该页面。这适用于通过 URL 的导航以及像 `st.switch_page` 和 `st.page_link` 这样的命令。

---

# 使用 `pages/` 目录创建多页应用

Source: https://docs.streamlit.io/develop/concepts/multipage-apps/pages-directory


声明多页应用的最可定制方法是使用[页面和导航](/develop/concepts/multipage-apps/page-and-navigation)。但是，Streamlit 还提供了一种无摩擦的方式来创建多页应用，其中页面会自动识别并显示在应用侧边栏中的导航部件中。此方法使用 `pages/` 目录。

此页面假设您了解概述中介绍的[页面术语](/develop/concepts/multipage-apps/overview#page-terminology)。

## 应用结构

当您使用 `pages/` 目录时，Streamlit 通过目录结构和文件名识别多页应用中的页面。您的入口点文件（传递给 `streamlit run` 的文件）是应用的主页。当您在入口点文件旁边有 `pages/` 目录时，Streamlit 将识别其中的每个 Python 文件作为页面。以下示例有三个页面。`your_homepage.py` 是入口点文件和主页。

```
your_working_directory/
├── pages/
│   ├── a_page.py
│   └── another_page.py
└── your_homepage.py
```

像运行单页应用一样运行您的多页应用。将您的入口点文件传递给 `streamlit run`。

```
streamlit run your_homepage.py
```

只有 `pages/` 目录中的 `.py` 文件将被识别为页面。Streamlit 忽略 `pages/` 目录及其子目录中的所有其他文件。Streamlit 还忽略 `pages/` 子目录中的 Python 文件。

<Important>

如果您在应用中（在任何会话中）调用 `st.navigation`，Streamlit 将切换到使用较新的页面和导航多页结构。在这种情况下，`pages/` 目录将在所有会话中被忽略。除非您重启应用，否则您无法回退到 `pages/` 目录。

</Important>

### 侧边栏中的页面排序方式

请参见概述以了解 Streamlit 如何根据构成文件名的 `number`、`separator`、`identifier` 和 `".py"` 扩展名分配[自动页面标签和 URL](/develop/concepts/multipage-apps/overview#automatic-page-labels-and-urls)。

入口点文件始终首先显示。其余页面按以下方式排序：

- 具有 `number` 的文件出现在没有 `number` 的文件之前。
- 文件根据 `number`（如果有），然后是 `label`（如果有）进行排序。
- 对文件进行排序时，Streamlit 将 `number` 视为实际数字而不是字符串。所以 `03` 与 `3` 相同。

此表显示了文件名示例及其对应的标签，按它们在侧边栏中出现的顺序排序。

**示例**：

| **文件名**              | **渲染标签** |
| :------------------------ | :----------------- |
| `1 - first page.py`       | first page         |
| `12 monkeys.py`           | monkeys            |
| `123.py`                  | 123                |
| `123_hello_dear_world.py` | hello dear world   |
| `_12 monkeys.py`          | 12 monkeys         |

<Tip>

表情符号可以用来让您的页面名称更有趣！例如，名为 `🏠_Home.py` 的文件将在侧边栏中创建一个标题为"🏠 Home"的页面。在文件名中添加表情符号时，最佳实践是包含编号前缀以使终端中的自动完成功能更容易。终端自动完成可能会被 unicode（表情符号的表示方式）混淆。

</Tip>

## 注意事项和限制

- 页面支持保存时运行。
  - 当您在应用运行时更新页面时，这会导致当前查看该确切页面的用户重新运行。
  - 当您在应用运行时更新页面时，应用不会为当前查看不同页面的用户自动重新运行。
- 当您的应用运行时，添加或删除页面会立即更新侧边栏导航。
- [`st.set_page_config`](/develop/api-reference/configuration/st.set_page_config) 在页面级别工作。
  - 当您使用 `st.set_page_config` 设置 `title` 或 `favicon` 时，这仅适用于当前页面。
  - 当您使用 `st.set_page_config` 设置 `layout` 时，该设置将在会话中保持直到被另一个 `st.set_page_config` 调用更改。如果您使用 `st.set_page_config` 设置 `layout`，建议在_所有_页面上调用它。
- 页面全局共享相同的 Python 模块：

  ```python
  # page1.py
  import foo
  foo.hello = 123

  # page2.py
  import foo
  st.write(foo.hello)  # 如果 page1 已经执行，这将写入 123
  ```

- 页面共享相同的 [st.session_state](/develop/concepts/architecture/session-state)：

  ```python
  # page1.py
  import streamlit as st
  if "shared" not in st.session_state:
     st.session_state["shared"] = True

  # page2.py
  import streamlit as st
  st.write(st.session_state["shared"]) # 如果 page1 已经执行，这将写入 True
  ```

您现在对多页应用有了扎实的理解。您已经学习了如何构建应用、定义页面以及在用户界面中导航页面。现在是时候[创建您的第一个多页应用](/get-started/tutorials/create-a-multipage-app)了！🥳

---

# 在多页应用中使用部件

Source: https://docs.streamlit.io/develop/concepts/multipage-apps/widgets


当您在 Streamlit 应用中创建一个部件时，Streamlit 会生成一个部件 ID 并使用它使您的部件有状态。随着用户交互，您的应用重新运行，Streamlit 通过将其值关联到其 ID 来跟踪部件的值。特别是，部件的 ID 取决于创建它的页面。如果您在两个不同页面上定义相同的部件，那么当您切换页面时，部件将重置为其默认值。

本指南解释了三种策略来处理此行为，如果您希望部件在所有页面上保持有状态。如果您不希望部件出现在所有页面上，但希望在离开其页面（然后返回）时保持有状态，则可以使用选项 2 和 3。有关这些策略的详细信息，请参见[了解部件行为](/develop/concepts/architecture/widget-behavior)。

## 选项 1（首选）：在您的入口点文件中执行您的部件命令

当您使用 `st.Page` 和 `st.navigation` 定义多页应用时，您的入口点文件成为页面周围公共元素的框架。当您在入口点文件中执行部件命令时，Streamlit 将部件关联到您的入口点文件而不是特定页面。由于您的入口点文件在每次应用重新运行时都会执行，入口点文件中的任何部件将在用户在页面间切换时保持有状态。

如果您使用 `pages/` 目录定义应用，此方法不起作用。

以下示例在侧边栏中包含一个选择框和滑块，它们在所有页面上渲染并保持有状态。每个部件都有一个分配的键，以便您可以通过会话状态在页面内访问它们的值。

**目录结构：**

```
your-repository/
├── page_1.py
├── page_2.py
└── streamlit_app.py
```

**`streamlit_app.py`：**

```python
import streamlit as st

pg = st.navigation([st.Page("page_1.py"), st.Page("page_2.py")])

st.sidebar.selectbox("Group", ["A","B","C"], key="group")
st.sidebar.slider("Size", 1, 5, key="size")

pg.run()
```

## 选项 2：在会话状态中将您的部件值保存到虚拟键中

如果您希望离开部件并返回到它同时保持其值，或者如果您希望在多个页面上使用相同的部件，请使用 `st.session_state` 中的单独键来独立于部件保存值。在此示例中，临时键与部件一起使用。临时键使用下划线前缀。因此，`"_my_key"` 用作部件键，但数据被复制到 `"my_key"` 以在页面间保留它。

```python
import streamlit as st

def store_value():
    # 将值复制到永久键
    st.session_state["my_key"] = st.session_state["_my_key"]

# 将保存的值复制到临时键
st.session_state["_my_key"] = st.session_state["my_key"]
st.number_input("Number of filters", key="_my_key", on_change=store_value)
```

如果这被功能化以与多个部件一起工作，它可能看起来像这样：

```python
import streamlit as st

def store_value(key):
    st.session_state[key] = st.session_state["_"+key]
def load_value(key):
    st.session_state["_"+key] = st.session_state[key]

load_value("my_key")
st.number_input("Number of filters", key="_my_key", on_change=store_value, args=["my_key"])
```

## 选项 3：中断部件清理过程

当 Streamlit 到达应用运行结束时，它将删除任何未渲染部件的数据。这包括任何未关联到当前页面的部件的数据。但是，如果您在应用运行中重新保存键值对，Streamlit 将不会将键值对关联到任何部件，直到您再次使用该键执行部件命令。

因此，如果您在每个页面顶部有以下代码，具有键 `"my_key"` 的任何部件将在其渲染（或不渲染）的地方保留其值。或者，如果您使用 `st.navigation` 和 `st.Page`，您可以在执行页面之前在入口点文件中包含此内容一次。

```python
if "my_key" in st.session_state:
    st.session_state.my_key = st.session_state.my_key
```

---

# Quick reference

Source: https://docs.streamlit.io/develop/quick-reference


<TileContainer layout="list">
<RefCard href="/develop/quick-reference/cheat-sheet">
<h5>Cheatsheet</h5>

A dense list of Streamlit commands with example syntax.

</RefCard>
<RefCard href="/develop/quick-reference/release-notes">
<h5>Release notes</h5>

See how Streamlit has changed with each new version.

</RefCard>
<RefCard href="/develop/quick-reference/prerelease">
<h5>Pre-release features</h5>

Understand how we introduce new features and how you can get your hands on them sooner!

</RefCard>
<RefCard href="https://roadmap.streamlit.app/">
<h5>Roadmap</h5>

Get a sneak peek at what we have scheduled for the next year.

</RefCard>
</TileContainer>

---

# Streamlit API cheat sheet

Source: https://docs.streamlit.io/develop/quick-reference/cheat-sheet


This is a summary of the docs for the latest version of Streamlit, [v1.52.0](https://pypi.org/project/streamlit/1.52.0/).

<Masonry>
<CodeTile>

#### Install  Import

```python
pip install streamlit

streamlit run first_app.py

# Import convention
&gt;&gt;&gt; import streamlit as st
```

</CodeTile>
<CodeTile>

#### Pre-release features

```python
pip uninstall streamlit
pip install streamlit-nightly --upgrade
```

Learn more about [experimental features](advanced-features/prerelease#experimental-features)

</CodeTile>
<CodeTile>

#### Command line

```python
streamlit cache clear
streamlit config show
streamlit docs
streamlit hello
streamlit help
streamlit init
streamlit run streamlit_app.py
streamlit version
```

</CodeTile>
</Masonry>
<Masonry>
<CodeTile>

#### Magic commands

```python
# Magic commands implicitly
# call st.write().
"_This_ is some **Markdown**"
my_variable
"dataframe:", my_data_frame

```

</CodeTile>
<CodeTile>

#### Display text

```python
st.write("Most objects") # df, err, func, keras!
st.write(["st", "is </CodeTile></Masonry>

---

# Pre-release features

Source: https://docs.streamlit.io/develop/quick-reference/prerelease


At Streamlit, we like to move quick while keeping things stable. In our latest effort to move even faster without sacrificing stability, we're offering our bold and fearless users two ways to try out Streamlit's bleeding-edge features:

1. [Experimental features](#experimental-features)
2. [Nightly releases](#nightly-releases)

## Experimental Features

Less stable Streamlit features have one naming convention: `st.experimental_`. This distinction is a prefix we attach to our command names to make sure their status is clear to everyone.

Here's a quick rundown of what you get from each naming convention:

- **st**: this is where our core features like `st.write` and `st.dataframe` live. If we ever make backward-incompatible changes to these, they will take place gradually and with months of announcements and warnings.
- **experimental**: this is where we'll put all new features that may or may not ever make it into Streamlit core. This gives you a chance to try the next big thing we're cooking up weeks or months before we're ready to stabilize its API. We don't know whether these features have a future, but we want you to have access to everything we're trying, and work with us to figure them out.

Features with the `experimental_` naming convention are things that we're still working on or trying
to understand. If these features are successful, at some point they'll become part of Streamlit
core. If unsuccessful, these features are removed without much notice. While in experimental, a feature's API and behaviors may not be stable, and it's possible they could change in ways that aren't backward-compatible.

<Warning>

Experimental features and their APIs may change or be removed at any time.

</Warning>

### The lifecycle of an experimental feature

1. A feature is added with the `experimental_` prefix.
2. The feature is potentially tweaked over time, with possible API/behavior breakages.
3. If successful, we promote the feature to Streamlit core and remove it from `experimental_`:
   - a\. The feature's API stabilizes and the feature is _cloned_ without the `experimental_` prefix, so it exists as both `st` and `experimental_`. At this point, users will see a warning when using the version of the feature with the `experimental_` prefix -- but the feature will still work.
   - b\. At some point, the code of the `experimental_`-prefixed feature is _removed_, but there will still be a stub of the function prefixed with `experimental_` that shows an error with appropriate instructions.
   - c\. Finally, at a later date the `experimental_` version is removed.
4. If unsuccessful, the feature is removed without much notice and we leave a stub in `experimental_` that shows an error with instructions.

## Nightly releases

In addition to experimental features, we offer another way to try out Streamlit's newest features: nightly releases.

At the end of each day (at night 🌛), our bots run automated tests against the latest Streamlit code and, if everything looks good, it publishes them as the `streamlit-nightly` package. This means the nightly build includes all our latest features, bug fixes, and other enhancements on the same day they land on our codebase.

**How does this differ from official releases?**

Official Streamlit releases go not only through both automated tests but also rigorous manual testing, while nightly releases only have automated tests. It's important to keep in mind that new features introduced in nightly releases often lack polish. In our official releases, we always make double-sure all new features are ready for prime time.

**How do I use the nightly release?**

All you need to do is install the `streamlit-nightly` package:

```bash
pip uninstall streamlit
pip install streamlit-nightly --upgrade
```

<Warning>

You should never have both `streamlit` and `streamlit-nightly` installed in the same environment!

</Warning>

**Why should I use the nightly release?**

Because you can't wait for official releases, and you want to help us find bugs early!

**Why shouldn't I use the nightly release?**

While our automated tests have high coverage, there's still a significant likelihood that there will be some bugs in the nightly code.

**Can I choose which nightly release I want to install?**

If you'd like to use a specific version, you can find the version number in our [Release history](https://pypi.org/project/streamlit-nightly/#history). Specify the desired version using `pip` as usual: `pip install streamlit-nightly==x.yy.zz-123456`.

**Can I compare changes between releases?**

If you'd like to review the changes for a nightly release, you can use the [comparison tool on GitHub](https://github.com/streamlit/streamlit/compare/0.57.3...0.57.4.dev20200412).

---

# Release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes


This page lists highlights, bug fixes, and known issues for the latest release of Streamlit. If you're looking for information about nightly releases or experimental features, see [Pre-release features](/develop/quick-reference/prerelease).

## Upgrade Streamlit

<Tip>

To upgrade to the latest version of Streamlit, run:

```bash
pip install --upgrade streamlit
```

</Tip>

## **Version 1.52.0 (latest)**

_Release date: December 3, 2025_

**Highlights**

- 📅 Introducing [`st.datetime_input`](/develop/api-reference/widgets/st.datetime_input) to set date and time in a single widget.
- 📩 To avoid blocking your script, you can pass a callable to [`st.download_button`](/develop/api-reference/widgets/st.download_button) for on-demand download generation ([#12942](https://github.com/streamlit/streamlit/pull/12942), [#5053](https://github.com/streamlit/streamlit/issues/5053)).
- 🎤 [`st.chat_input`](/develop/api-reference/chat/st.chat_input) can optionally accept audio input ([#12836](https://github.com/streamlit/streamlit/pull/12836), [#13054](https://github.com/streamlit/streamlit/pull/13054)).

**Notable Changes**

- 🎹 You can configure keyboard shortcuts for [buttons](/develop/api-reference/widgets/st.button) ([#12975](https://github.com/streamlit/streamlit/pull/12975), [#1291](https://github.com/streamlit/streamlit/issues/1291)).
- ❓ You can now pass query parameters to [`st.switch_page`](/develop/api-reference/navigation/st.switch_page) and [`st.page_link`](/develop/api-reference/widgets/st.page_link) ([#13027](https://github.com/streamlit/streamlit/pull/13027), [#8102](https://github.com/streamlit/streamlit/issues/8102), [#8112](https://github.com/streamlit/streamlit/issues/8112), [#13093](https://github.com/streamlit/streamlit/pull/13093)).
- 〰️ [`st.html`](/develop/api-reference/text/st.html) has a new `unsafe_allow_javascript` parameter to execute JavaScript ([#12918](https://github.com/streamlit/streamlit/pull/12918)).
- ⬆️ [`st.metric`](/develop/api-reference/data/st.metric) has a new `delta_arrow` parameter to configure the visibility and orientation of the delta arrow ([#12982](https://github.com/streamlit/streamlit/pull/12982), [#4775](https://github.com/streamlit/streamlit/issues/4775)).
- ⌨️ You can configure the horizontal alignment of [`st.markdown`](/develop/api-reference/text/st.markdown), `st.caption`, `st.title`, `st.header`, `st.subheader`, and `st.text` with a new `text_alignment` parameter ([#13032](https://github.com/streamlit/streamlit/pull/13032), [#4109](https://github.com/streamlit/streamlit/issues/4109), [#13034](https://github.com/streamlit/streamlit/pull/13034), [#13036](https://github.com/streamlit/streamlit/pull/13036)).
- 🌀 You can use a spinner everywhere you can set an `icon` and in the `avatar` parameter of [`st.chat_message`](/develop/api-reference/chat/st.chat_message). The spinner can't be used as a page favicon ([#13045](https://github.com/streamlit/streamlit/pull/13045), [#6415](https://github.com/streamlit/streamlit/issues/6415)).
- 🛠️ You can now add tooltips to [`st.badge`](/develop/api-reference/text/st.badge) ([#12897](https://github.com/streamlit/streamlit/pull/12897), [#12878](https://github.com/streamlit/streamlit/issues/12878)). Thanks, [marcolanfranchi](https://github.com/marcolanfranchi)!
- 🕳️ You can configure placeholder text for null values in [`st.dataframe`](/develop/api-reference/data/st.dataframe) and [`st.data_editor`](/develop/api-reference/data/st.data_editor) with a new `placeholder` parameter ([#12968](https://github.com/streamlit/streamlit/pull/12968), [#7360](https://github.com/streamlit/streamlit/issues/7360)).
- 🔑 To prevent widgets from resetting when you change a parameter, widgets are transitioning to an identity based only on their keys (if provided). The following widgets use only their key for their identity:
  - `st.file_uploader`
  - `st.camera_input`
- ↕️ `st.plotly_chart` has a height parameter to use with flex containers ([#12593](https://github.com/streamlit/streamlit/pull/12593)).
- ↔️ `st.container`, `st.dataframe`, and `st.data_editor` support `width="content"` ([#12848](https://github.com/streamlit/streamlit/pull/12848), [#12875](https://github.com/streamlit/streamlit/pull/12875), [#12391](https://github.com/streamlit/streamlit/issues/12391)).
- 🐍 Streamlit supports Python 3.14 and Vega-Altair 6!
- 👻 `st.bokeh_chart` has been removed. Use the `streamlit-bokeh` custom component instead.
- ☠️ `**kwargs` is deprecated in `st.vega_lite_chart` ([#13141](https://github.com/streamlit/streamlit/pull/13141)).
- 💩 The `.add_rows()` method is under consideration for removal. Please leave feedback ([#13063](https://github.com/streamlit/streamlit/issues/13063)).
- 👥 We're improving community contributions by using a public workflow for discussing feature specs ([#12248](https://github.com/streamlit/streamlit/pull/12248)).

**Other Changes**

- 🪥 For better performance, Streamlit uses `uvloop` if it's installed ([#13047](https://github.com/streamlit/streamlit/pull/13047)).
- 🧼 For improved performance, Markdown plugins are lazy loaded ([#13152](https://github.com/streamlit/streamlit/pull/13152)).
- 🧽 To improve load times, we reduced the bundle size ([#13071](https://github.com/streamlit/streamlit/pull/13071), [#13077](https://github.com/streamlit/streamlit/pull/13077), [#13099](https://github.com/streamlit/streamlit/pull/13099), [#13115](https://github.com/streamlit/streamlit/pull/13115), [#13128](https://github.com/streamlit/streamlit/pull/13128)).
- 🛁 To improve performance, we've refactored session context data ([#12788](https://github.com/streamlit/streamlit/pull/12788), [#12789](https://github.com/streamlit/streamlit/pull/12789), [#12790](https://github.com/streamlit/streamlit/pull/12790), [#12791](https://github.com/streamlit/streamlit/pull/12791)).
- 🚿 The hovering performance of `st.line_chart` was improved ([#13156](https://github.com/streamlit/streamlit/pull/13156), [#13154](https://github.com/streamlit/streamlit/issues/13154)).
- 🧹 `st.metric` was optimized to prevent poor hovering performance with large data sets ([#12983](https://github.com/streamlit/streamlit/pull/12983)).
- 👽 The `packaging` Python dependency is no longer version-capped ([#13073](https://github.com/streamlit/streamlit/pull/13073)).
- 🫥 For clarity, Streamlit logs a warning if you try to hide a non-range index when using `st.data_editor` with `num_rows="dynamic"`. A non-range index must be editable to add rows ([#12978](https://github.com/streamlit/streamlit/pull/12978), [#8263](https://github.com/streamlit/streamlit/issues/8263)).
- 🦋 Bug fix: Streamlit auth raises a warning instead of an error when browser back navigation revisits a consumed OAuth callback ([#13127](https://github.com/streamlit/streamlit/pull/13127), [#13101](https://github.com/streamlit/streamlit/issues/13101)).
- 🦀 Bug fix: The WebSocket timeout was increased on Android to improve `st.file_uploader` performance ([#13132](https://github.com/streamlit/streamlit/pull/13132), [#11419](https://github.com/streamlit/streamlit/issues/11419)).
- 🦎 Bug fix: Query parameters are preserved when using browser back and forward navigation ([#13129](https://github.com/streamlit/streamlit/pull/13129), [#9279](https://github.com/streamlit/streamlit/issues/9279)).
- 🐌 Bug fix: For custom components v2, the frontend key is correctly computed to be stable if it has a key in Python and otherwise change when its parameters change ([#12950](https://github.com/streamlit/streamlit/pull/12950)).
- 🕸️ Bug fix: Empty code blocks in Markdown don't display "undefined" ([#13074](https://github.com/streamlit/streamlit/pull/13074), [#12986](https://github.com/streamlit/streamlit/issues/12986)). Thanks, [ashm-dev](https://github.com/ashm-dev)!
- 🦗 Bug fix: `st.feedback` is prevented from wrapping ([#12970](https://github.com/streamlit/streamlit/pull/12970), [#12068](https://github.com/streamlit/streamlit/issues/12068)).
- 🦂 Bug fix: Custom components v2 don't raise a warning when placeholders are replaced as a result of the initial manifest scan ([#13043](https://github.com/streamlit/streamlit/pull/13043), [#13042](https://github.com/streamlit/streamlit/issues/13042)).
- 🦟 Bug fix: `st.audio_input` has the correct padding for its waveform ([#13010](https://github.com/streamlit/streamlit/pull/13010)).
- 🦠 Bug fix: The date and time icons in `st.data_editor` are visible in dark mode ([#12994](https://github.com/streamlit/streamlit/pull/12994), [#12852](https://github.com/streamlit/streamlit/issues/12852)). Thanks, [aritradhabal](https://github.com/aritradhabal)!
- 🪰 Bug fix: `st.pills` and `st.segmented_control` wrap correctly when `width="content"` ([#12969](https://github.com/streamlit/streamlit/pull/12969), [#12067](https://github.com/streamlit/streamlit/issues/12067), [#12879](https://github.com/streamlit/streamlit/pull/12879), [#12857](https://github.com/streamlit/streamlit/issues/12857)).
- 🪳 Bug fix: `st.color_picker` has a minimum width to prevent a pixel width below its intrinsic size ([#12962](https://github.com/streamlit/streamlit/pull/12962), [#12872](https://github.com/streamlit/streamlit/issues/12872)).
- 🕷️ Bug fix: Disabled widgets hide their borders ([#12949](https://github.com/streamlit/streamlit/pull/12949)).
- 🐞 `st.audio_input` and `st.chat_input` show a clearer message when microphone permissions are insufficient ([#12914](https://github.com/streamlit/streamlit/pull/12914)).
- 🐝 Bug fix: `st.navigation` uses the sidebar font and Streamlit falls back to its built-in fonts if a font can't be found ([#12948](https://github.com/streamlit/streamlit/pull/12948)).
- 🐜 Bug fix: `MultiselectColumn` doesn't raise a `ValueError` when adding new rows in `st.data_editor` ([#12860](https://github.com/streamlit/streamlit/pull/12860), [#12936](https://github.com/streamlit/streamlit/pull/12936), [#12815](https://github.com/streamlit/streamlit/issues/12815)). Thanks, [kkchemboli](https://github.com/kkchemboli)!
- 🪲 Bug fix: `MultiselectColumn` works correctly when the underlying dataframe has an empty column ([#12935](https://github.com/streamlit/streamlit/pull/12935), [#12842](https://github.com/streamlit/streamlit/issues/12842)).
- 🐛 Bug fix: `st.text_area` avoids negative height calculations that produce invalid CSS ([#12891](https://github.com/streamlit/streamlit/pull/12891), [#12867](https://github.com/streamlit/streamlit/issues/12867)).

## Older versions of Streamlit

- [2025 release notes](/develop/quick-reference/release-notes/2025)
- [2024 release notes](/develop/quick-reference/release-notes/2024)
- [2023 release notes](/develop/quick-reference/release-notes/2023)
- [2022 release notes](/develop/quick-reference/release-notes/2022)
- [2021 release notes](/develop/quick-reference/release-notes/2021)
- [2020 release notes](/develop/quick-reference/release-notes/2020)
- [2019 release notes](/develop/quick-reference/release-notes/2019)

---

# 2019 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2019


This page contains release notes for Streamlit versions released in 2019. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## Version 0.52.0

_Release date: December 20, 2019_

**Highlights:**

- 📤 Preview release of the file uploader widget. To try it out just call
  [`st.file_uploader`](https://docs.streamlit.io/en/latest/api.html#streamlit.file_uploader)!

  _Note that as a **preview release** things may change in the near future.
  Looking forward to hearing input from the community before we stabilize the
  API!_

- 👋 Support for [emoji codes](https://www.webfx.com/tools/emoji-cheat-sheet/) in
  `st.write` and `st.markdown`! Try it out with `st.write("Hello :wave:")`.

**Breaking changes:**

- 🧹 `st.pyplot` now clears figures by default, since that's what you want 99% of
  the time. This allows you to create two or more Matplotlib charts without
  having to call
  [`pyplot.clf`](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.clf.html)
  every time. If you want to turn this behavior off, use
  [`st.pyplot(clear_figure=False)`](https://docs.streamlit.io/en/latest/api.html#streamlit.pyplot)
- 📣 `st.cache` no longer checks for input mutations. This is the first change
  of our ongoing effort to simplify the caching system and prepare Streamlit
  for the launch of other caching primitives like Session State!

## Version 0.51.0

_Release date: November 30, 2019_

**Highlights:**

- 🐕 You can now tweak the behavior of the file watcher with the config option `server.fileWatcherType`. Use it to switch between:
  - `auto` (default) : Streamlit will attempt to use the watchdog module, and
    falls back to polling if watchdog is not available.
  - `watchdog` : Force Streamlit to use the watchdog module.
  - `poll` : Force Streamlit to always use polling.
  - `none` : Streamlit will not watch files.

**Notable bug fixes:**

- Fix the "keyPrefix" option in static report sharing [#724](https://github.com/streamlit/streamlit/pull/724)
- Add support for getColorX and getTargetColorX to DeckGL Chart [#718](https://github.com/streamlit/streamlit/pull/718)
- Fixing Tornado on Windows + Python 3.8 [#682](https://github.com/streamlit/streamlit/pull/682)
- Fall back on webbrowser if xdg-open is not installed on Linux [#701](https://github.com/streamlit/streamlit/pull/701)
- Fixing number input spin buttons for Firefox [#683](https://github.com/streamlit/streamlit/pull/683)
- Fixing CTRL+ENTER on Windows [#699](https://github.com/streamlit/streamlit/pull/699)
- Do not automatically create credential file when in headless mode [#467](https://github.com/streamlit/streamlit/pull/467)

## Version 0.50.1

_Release date: November 10, 2019_

**Highlights:**

- 👩‍🎓 SymPy support and ability to draw mathematical expressions using LaTeX! See
  [`st.latex`](/develop/api-reference/text/st.latex),
  [`st.markdown`](/develop/api-reference/text/st.markdown),
  and
  [`st.write`](/develop/api-reference/write-magic/st.write).
- 🌄 You can now set config options using environment variables. For example,
  `export STREAMLIT_SERVER_PORT=9876`.
- 🐱 Ability to call `streamlit run` directly with Github and Gist URLs. No
  need to grab the "raw" URL first!
- 📃 Cleaner exception stack traces. We now remove all Streamlit-specific code
  from stack traces originating from the user's app.

## Version 0.49.0

_Release date: October 23, 2019_

**Highlights:**

- 💯 New input widget for entering numbers with the keyboard: `st.number_input()`
- 📺 Audio/video improvements: ability to load from a URL, to embed YouTube
  videos, and to set the start position.
- 🤝 You can now (once again) share static snapshots of your apps to S3! See
  the S3 section of `streamlit config show` to set it up. Then share from
  top-right menu.
- ⚙️ Use `server.baseUrlPath` config option to set Streamlit's URL to something
  like `http://domain.com/customPath`.

**Notable bug fixes:**

- Fixes numerous Windows bugs, including [Issues
  #339](https://github.com/streamlit/streamlit/issues/399) and
  [#401](https://github.com/streamlit/streamlit/issues/301).

## Version 0.48.0

_Release date: October 12, 2019_

**Highlights:**

- 🔧 Ability to set config options as command line flags or in a local config file.
- ↕️ You can now maximize charts and images!
- ⚡ Streamlit is now much faster when writing data in quick succession to your app.
- ✳️ Ability to blacklist folder globs from "run on save" and `@st.cache` hashing.
- 🎛️ Improved handling of widget state when Python file is modified.
- 🙈 Improved HTML support in `st.write` and `st.markdown`. HTML is still unsafe, though!

**Notable bug fixes:**

- Fixes `@st.cache` bug related to having your Python environment on current
  working directory. [Issue #242](https://github.com/streamlit/streamlit/issues/242)
- Fixes loading of root url `/` on Windows. [Issue #244](https://github.com/streamlit/streamlit/issues/244)

## Version 0.47.0

_Release date: October 1, 2019_

**Highlights:**

- 🌄 New hello.py showing off 4 glorious Streamlit apps. Try it out!
- 🔄 Streamlit now automatically selects an unused port when 8501 is already in use.
- 🎁 Sidebar support is now out of beta! Just start any command with `st.sidebar.` instead of `st.`
- ⚡ Performance improvements: we added a cache to our websocket layer so we no longer re-send data to the browser when it hasn't changed between runs
- 📈 Our "native" charts `st.line_chart`, `st.area_chart` and `st.bar_chart` now use Altair behind the scenes
- 🔫 Improved widgets: custom st.slider labels; default values in multiselect
- 🕵️‍♀️ The filesystem watcher now ignores hidden folders and virtual environments
- 💅 Plus lots of polish around caching and widget state management

**Breaking change:**

- 🛡️ We have temporarily disabled support for sharing static "snapshots" of Streamlit apps. Now that we're no longer in a limited-access beta, we need to make sure sharing is well thought through and abides by laws like the DMCA. But we're working on a solution!

## Version 0.46.0

_Release date: September 19, 2019_

**Highlights:**

- ✨ Magic commands! Use `st.write` without typing `st.write`. See
  [https://docs.streamlit.io/en/latest/api.html#magic-commands](https://docs.streamlit.io/en/latest/api.html#magic-commands)
- 🎛️ New `st.multiselect` widget.
- 🐍 Fixed numerous install issues so now you can use `pip install streamlit`
  even in Conda! We've therefore deactivated our Conda repo.
- 🐞 Multiple bug fixes and additional polish in preparation for our launch!

**Breaking change:**

- 🛡️ HTML tags are now blacklisted in `st.write`/`st.markdown` by default. More
  information and a temporary work-around at:
  [https://github.com/streamlit/streamlit/issues/152](https://github.com/streamlit/streamlit/issues/152)

## Version 0.45.0

_Release date: August 28, 2019_

**Highlights:**

- 😱 Experimental support for _sidebar_! Let us know if you want to be a beta
  tester.
- 🎁 Completely redesigned `st.cache`! Much more performant, has a cleaner API,
  support for caching functions called by `@st.cached` functions,
  user-friendly error messages, and much more!
- 🖼️ Lightning fast `st.image`, ability to choose between JPEG and PNG
  compression, and between RGB and BGR (for OpenCV).
- 💡 Smarter API for `st.slider`, `st.selectbox`, and `st.radio`.
- 🤖 Automatically fixes the Matplotlib backend -- no need to edit .matplotlibrc

## Version 0.44.0

_Release date: July 28, 2019_

**Highlights:**

- ⚡ Lightning-fast reconnect when you do a ctrl-c/rerun on your Streamlit code
- 📣 Useful error messages when the connection fails
- 💎 Fixed multiple bugs and improved polish of our newly-released interactive widgets

## Version 0.43.0

_Release date: July 9, 2019_

**Highlights:**

- ⚡ Support for interactive widgets! 🎈🎉

## Version 0.42.0

_Release date: July 1, 2019_

**Highlights:**

- 💾 Ability to save Vega-Lite and Altair charts to SVG or PNG
- 🐇 We now cache JS files in your browser for faster loading
- ⛔ Improvements to error-handling inside Streamlit apps

## Version 0.41.0

_Release date: June 24, 2019_

**Highlights:**

- 📈 Greatly improved our support for named datasets in Vega-Lite and Altair
- 🙄 Added ability to ignore certain folders when watching for file changes. See the `server.folderWatchBlacklist` config option.
- ☔ More robust against syntax errors on the user's script and imported modules

## Version 0.40.0

_Release date: June 10, 2019_

**Highlights:**

- Streamlit is more than 10x faster. Just save and watch your analyses update instantly.
- We changed how you run Streamlit apps:
  `$ streamlit run your_script.py [script args]`
- Unlike the previous versions of Streamlit, `streamlit run [script] [script args]` creates a server (now you don't need to worry if the proxy is up). To kill the server, all you need to do is hit **Ctrl+c**.

**Why is this so much faster?**

Now, Streamlit keeps a single Python session running until you kill the server. This means that Streamlit can re-run your code without kicking off a new process; imported libraries are cached to memory. An added bonus is that `st.cache` now caches to memory instead of to disk.

**What happens if I run Streamlit the old way?**

If you run `$ python your_script.py` the script will execute from top to bottom, but won't produce a Streamlit app.

**What are the limitations of the new architecture?**

- To switch Streamlit apps, first you have to kill the Streamlit server with **Ctrl-c**. Then, you can use `streamlit run` to generate the next app.
- Streamlit only works when used inside Python files, not interactively from the Python REPL.

**What else do I need to know?**

- The strings we print to the command line when **liveSave** is on have been cleaned up. You may need to adjust any RegEx that depends on those.
- A number of config options have been renamed:

  | Old config                 | New config            |
  | -------------------------- | --------------------- |
  | proxy.isRemote             | server.headless       |
  | proxy.liveSave             | server.liveSave       |
  | proxy.runOnSave            | server.runOnSave      |
  | proxy.watchFileSystem      | server.runOnSave      |
  | proxy.enableCORS           | server.enableCORS     |
  | proxy.port                 | server.port           |
  | browser.proxyAddress       | browser.serverAddress |
  | browser.proxyPort          | browser.serverPort    |
  | client.waitForProxySecs    | _n/a_                 |
  | client.throttleSecs        | _n/a_                 |
  | client.tryToOutliveProxy   | _n/a_                 |
  | client.proxyAddress        | _n/a_                 |
  | client.proxyPort           | _n/a_                 |
  | proxy.autoCloseDelaySecs   | _n/a_                 |
  | proxy.reportExpirationSecs | _n/a_                 |

**What if something breaks?**

If the new Streamlit isn't working, please let us know by Slack or email. You can downgrade at any time with these commands:

```bash
pip install --upgrade streamlit==0.37
```

```bash
conda install streamlit=0.37
```

**What's next?**

Thank you for staying with us on this journey! This version of Streamlit lays the foundation for interactive widgets, a new feature of Streamlit we're really excited to share with you in the next few months.

## Version 0.36.0

_Release date: May 03, 2019_

**Highlights**

- 🚣‍♀️ `st.progress()` now also accepts floats from 0.0–1.0
- 🤯 Improved rendering of long headers in DataFrames
- 🔐 Shared apps now default to HTTPS

## Version 0.35.0

_Release date: April 26, 2019_

**Highlights**

- 📷 Bokeh support! Check out docs for `st.bokeh_chart`
- ⚡️ Improved the size and load time of saved apps
- ⚾️ Implemented better error-catching throughout the codebase

---

# 2020 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2020


This page contains release notes for Streamlit versions released in 2020. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## Version 0.73.0

_Release date: December 17, 2020_

**Notable Changes**

- 🐍 Streamlit can now be installed on Python 3.9. Streamlit components are not
  yet compatible with Python 3.9 and must use version 3.8 or earlier.
- 🧱 Streamlit Components now allows same origin, enabling features provided by
  the browser such as a webcam component.
- 🐙 Fix Streamlit sharing deploy experience for users running on Git versions
  2.7.0 or earlier.
- 🧰 Handle unexpected closing of uploaded files for [`st.file_uploader`](https://docs.streamlit.io/en/0.72.0/api.html#streamlit.file_uploader).

## Version 0.72.0

_Release date: December 2, 2020_

**Notable Changes**

- 🌈 Establish a framework for theming and migrate existing components.
- 📱 Improve the sidebar experience for mobile devices.
- 🧰 Update [`st.file_uploader`](https://docs.streamlit.io/en/0.71.0/api.html#streamlit.file_uploader) to reduce reruns.

## Version 0.71.0

_Release date: November 11, 2020_

**Notable Changes**

- 📁 Updated [`st.file_uploader`](https://docs.streamlit.io/en/0.71.0/api.html#streamlit.file_uploader)
  to automatically reset buffer on app reruns.
- 📊 Optimize the default rendering of charts and reduce issues with the initial render.

## Version 0.70.0

_Release date: October 28, 2020_

**Notable Changes**

- 🧪 [`st.set_page_config`](https://docs.streamlit.io/en/0.70.0/api.html#streamlit.set_page_config) and [`st.color_picker`](https://docs.streamlit.io/en/0.70.0/api.html#streamlit.color_picker) have now been moved into the
  Streamlit namespace. These will be removed from beta January 28th, 2021. Learn
  more about our beta process [here](https://docs.streamlit.io/en/0.70.0/api.html#beta-and-experimental-features).
- 📊 Improve display of bar charts for discrete values.

## Version 0.69.0

_Release date: October 15, 2020_

**Highlights:**

- 🎁 Introducing Streamlit sharing, the best way to deploy, manage, and share your public Streamlit apps—for free. Read more about it on our [blog post](http://blog.streamlit.io/introducing-streamlit-sharing/) or sign up [here](https://streamlit.io/sharing)!
- Added `st.experimental_rerun` to programatically re-run your app. Thanks [SimonBiggs](https://github.com/SimonBiggs)!

**Notable Changes**

- 📹 Better support across browsers for start and stop times for st.video.
- 🖼 Bug fix for intermittently failing media files
- 📦 Bug fix for custom components compatibility with Safari. Make sure to upgrade to the latest [streamlit-component-lib](https://www.npmjs.com/package/streamlit-component-lib).

## Version 0.68.0

_Release date: October 8, 2020_

**Highlights:**

- ⌗ Introducing new layout options for Streamlit! Move aside, vertical layout.
  Make a little space for... horizontal layout! Check out our
  [blog post](https://blog.streamlit.io/introducing-new-layout-options-for-streamlit/).
- 💾 File uploader redesigned with new functionality for multiple files uploads
  and better support for working with uploaded files. This may cause breaking
  changes. Please see the new api in our
  [documentation](https://docs.streamlit.io/en/0.68.0/api.html#streamlit.file_uploader)

**Notable Changes**

- 🎈 `st.balloon` has gotten a facelift with nicer balloons and smoother animations.
- 🚨 Breaking Change: Following the deprecation of `st.deck_gl_chart` in
  January 2020, we have now removed the API completely. Please use
  `st.pydeck_chart` instead.
- 🚨 Breaking Change: Following the deprecation of `width` and `height` for
  `st.altair_chart`, `st.graphviz_chart`, `st.plotly_chart`, and
  `st.vega_lite_chart` in January 2020, we have now removed the args completely.
  Please set the width and height in the respective charting library.

## Version 0.67.0

_Release date: September 16, 2020_

**Highlights:**

- 🦷 Streamlit Components can now return bytes to your Streamlit App. To create a
  component that returns bytes, make sure to upgrade to the latest
  [streamlit-component-lib](https://www.npmjs.com/package/streamlit-component-lib).

**Notable Changes**

- 📈 Deprecation warning: Beginning December 1st, 2020 `st.pyplot()` will require a figure to
  be provided. To disable the deprecation warning, please set `deprecation.showPyplotGlobalUse`
  to `False`
- 🎚 `st.multiselect` and `st.select` are now lightning fast when working with large datasets. Thanks [masa3141](https://github.com/masa3141)!

## Version 0.66.0

_Release date: September 1, 2020_

**Highlights:**

- ✏️ `st.write` is now available for use in the sidebar!
- 🎚 A slider for distinct or non-numerical values is now available with `st.select_slider`.
- ⌗ Streamlit Components can now return dataframes to your Streamlit App. Check out our [SelectableDataTable example](https://github.com/streamlit/component-template/tree/master/examples/SelectableDataTable).
- 📦 The Streamlit Components library used in our Streamlit Component template is
  now available as a npm package ([streamlit-component-lib](https://www.npmjs.com/package/streamlit-component-lib)) to simplify future upgrades to the latest version.
  Existing components do not need to migrate.

**Notable Changes**

- 🐼 Support StringDtype from pandas version 1.0.0
- 🧦 Support for running Streamlit on Unix sockets

## Version 0.65.0

_Release date: August 12, 2020_

**Highlights:**

- ⚙️ Ability to set page title, favicon, sidebar state, and wide mode via st.beta_set_page_config(). See our [documentation](https://docs.streamlit.io/en/0.65.0/api.html#streamlit.set_page_config) for details.
- 📝 Add stateful behaviors through the use of query parameters with st.experimental_set_query_params and st.experimental_get_query_params. Thanks [@zhaoooyue](https://github.com/zhaoooyue)!
- 🐼 Improved pandas dataframe support for st.radio, st.selectbox, and st.multiselect.
- 🛑 Break out of your Streamlit app with st.stop.
- 🖼 Inline SVG support for st.image.

**Callouts:**

- 🚨Deprecation Warning: The st.image parameter format has been renamed to output_format.

## Version 0.64.0

_Release date: July 23, 2020_

**Highlights:**

- 📊 Default matplotlib to display charts with a tight layout. To disable this,
  set `bbox_inches` to `None`, inches as a string, or a `Bbox`
- 🗃 Deprecation warning for automatic encoding on `st.file_uploader`
- 🙈 If `gatherUserStats` is `False`, do not even load the Segment library.
  Thanks [@tanmaylaud](https://github.com/tanmaylaud)!

## Version 0.63.0

_Release date: July 13, 2020_

**Highlights:**

- 🧩 **Support for Streamlit Components!!!** See
  [documentation](https://docs.streamlit.io/en/latest/streamlit_components.html) for more info.
- 🕗 Support for datetimes in
  [`st.slider`](https://docs.streamlit.io/en/latest/api.html#streamlit.slider). And, of course, just
  like any other value you use in `st.slider`, you can also pass in two-element lists to get a
  datetime range slider.

## Version 0.62.0

_Release date: June 21, 2020_

**Highlights:**

- 📨 Ability to turn websocket compression on/off via the config option
  `server.enableWebsocketCompression`. This is useful if your server strips HTTP headers and you do
  not have access to change that behavior.
- 🗝️ Out-of-the-box support for CSRF protection using the
  [Cookie-to-header token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token)
  technique. This means that if you're serving your Streamlit app from multiple replicas you'll need
  to configure them to to use the same cookie secret with the `server.cookieSecret` config option.
  To turn XSRF protection off, set `server.enableXsrfProtection=false`.

**Notable bug fixes:**

- 🖼️ Added a grace period to the image cache expiration logic in order to fix multiple related bugs
  where images sent with `st.image` or `st.pyplot` were sometimes missing.

## Version 0.61.0

_Release date: June 2, 2020_

**Highlights:**

- 📅 Support for date ranges in `st.date_picker`. See
  [docs](https://docs.streamlit.io/en/latest/api.html#streamlit.date_picker)
  for more info, but the TLDR is: just pass a list/tuple as the default date and it will be
  interpreted as a range.
- 🗣️ You can now choose whether `st.echo` prints the code above or below the output of the echoed
  block. To learn more, refer to the `code_location` argument in the
  [docs](https://docs.streamlit.io/en/latest/api.html#streamlit.echo).
- 📦 Improved `@st.cache` support for Keras models and Tensorflow `saved_models`.

## Version 0.60.0

_Release date: May 18, 2020_

**Highlights:**

- ↕️ Ability to set the height of an `st.text_area` with the `height` argument
  (expressed in pixels). See
  [docs](https://docs.streamlit.io/en/latest/api.html#streamlit.text_area) for more.
- 🔡 Ability to set the maximimum number of characters allowed in `st.text_area`
  or `st.text_input`. Check out the `max_chars` argument in the
  [docs](https://docs.streamlit.io/en/latest/api.html#streamlit.text_area).
- 🗺️ Better DeckGL support for the [H3](https://h3geo.org/) geospatial indexing
  system. So now you can use things like `H3HexagonLayer` in
  [`st.pydeck_chart`](https://docs.streamlit.io/en/latest/api.html#streamlit.pydeck_chart).
- 📦 Improved `@st.cache` support for PyTorch TensorBase and Model.

## Version 0.59.0

_Release date: May 05, 2020_

**Highlights:**

- 🎨 New color-picker widget! Use it with
  [`st.beta_color_picker()`](https://docs.streamlit.io/en/0.69.0/api.html#streamlit.beta_color_picker)
- 🧪 Introducing `st.beta_*` and `st.experimental_*` function prefixes, for faster
  Streamlit feature releases. See
  [docs](https://docs.streamlit.io/en/latest/api.html#pre-release-features) for more info.
- 📦 Improved `@st.cache` support for SQL Alchemy objects, CompiledFFI, PyTorch
  Tensors, and `builtins.mappingproxy`.

## Version 0.58.0

_Release date: April 22, 2020_

**Highlights:**

- 💼 Made `st.selectbox` filtering case-insensitive.
- ㈬ Better support for Tensorflow sessions in `@st.cache`.
- 📊 Changed behavior of `st.pyplot` to auto-clear the figure only when using
  the global Matplotlib figure (i.e. only when calling `st.pyplot()` rather
  than `st.pyplot(fig)`).

## Version 0.57.0

_Release date: March 26, 2020_

**Highlights:**

- ⏲️ Ability to set expiration options for `@st.cache`'ed functions by setting
  the `max_entries` and `ttl` arguments. See
  [docs](https://docs.streamlit.io/en/latest/api.html#streamlit.cache).
- 🆙 Improved the machinery behind `st.file_uploader`, so it's much more
  performant now! Also increased the default upload limit to 200MB
  (configurable via `server.max_upload_size`).
- 🔒 The `server.address` config option now _binds_ the server to that address
  for added security.
- 📄 Even more details added to error messages for `@st.cache` for easier
  debugging.

## Version 0.56.0

_Release date: February 15, 2020_

**Highlights:**

- 📄 Improved error messages for st.cache. The errors now also point to the new
  caching docs we just released. Read more
  [here](https://discuss.streamlit.io/t/help-us-stress-test-streamlit-s-latest-caching-update/1944)!

**Breaking changes:**

- 🐍 As [announced last month](https://discuss.streamlit.io/t/streamlit-will-deprecate-python-2-in-february/1656),
  **Streamlit no longer supports Python 2.** To use Streamlit you'll need
  Python 3.5 or above.

## Version 0.55.0

_Release date: February 4, 2020_

**Highlights:**

- 📺 **Ability to record screencasts directly from Streamlit!** This allows
  you to easily record and share explanations about your models, analyses,
  data, etc. Just click ☰ then "Record a screencast". Give it a try!

## Version 0.54.0

_Release date: January 29, 2020_

**Highlights:**

- ⌨️ Support for password fields! Just pass `type="password"` to
  `st.text_input()`.

**Notable fixes:**

- ✳️ Numerous st.cache improvements, including better support for complex objects.
- 🗣️ Fixed cross-talk in sidebar between multiple users.

**Breaking changes:**

- If you're using the SessionState <del>hack</del> Gist, you should re-download it!
  Depending on which hack you're using, here are some links to save you some
  time:
  - [SessionState.py](https://gist.github.com/tvst/036da038ab3e999a64497f42de966a92)
  - [st_state_patch.py](https://gist.github.com/tvst/0899a5cdc9f0467f7622750896e6bd7f)

## Version 0.53.0

_Release date: January 14, 2020_

**Highlights:**

- 🗺️ Support for all DeckGL features! Just use
  [Pydeck](https://deckgl.readthedocs.io/en/latest/) instead of
  [`st.deck_gl_chart`](https://docs.streamlit.io/en/latest/api.html#streamlit.pydeck_chart).
  To do that, simply pass a PyDeck object to
  [`st.pydeck_chart`](https://docs.streamlit.io/en/latest/api.html#streamlit.pydeck_chart),
  [`st.write`](https://docs.streamlit.io/en/latest/api.html#streamlit.write),
  or [magic](https://docs.streamlit.io/en/latest/api.html#magic).

  _Note that as a **preview release** things may change in the near future.
  Looking forward to hearing input from the community before we stabilize the
  API!_

  **The goals is for this to replace `st.deck_gl_chart`,** since it
  is does everything the old API did _and much more!_

- 🆕 Better handling of Streamlit upgrades while developing. We now auto-reload
  the browser tab if the app it is displaying uses a newer version of Streamlit
  than the one the tab is running.

- 👑 New favicon, with our new logo!

**Notable fixes:**

- Magic now works correctly in Python 3.8. It no longer causes
  docstrings to render in your app.

**Breaking changes:**

- Updated how we calculate the default width and height of all chart types.
  We now leave chart sizing up to your charting library itself, so please refer
  to the library's documentation.

  As a result, the `width` and `height` arguments have been deprecated
  from most chart commands, and `use_container_width` has been introduced
  everywhere to allow you to make charts fill as much horizontal space as
  possible (this used to be the default).

---

# 2021 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2021


This page contains release notes for Streamlit versions released in 2021. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## Version 1.3.0

_Release date: Dec 16, 2021_

**Notable Changes**

- 💯 Support for NumPy values in `st.metric`.
- 🌐 Support for Mesh Layers in PyDeck.
- 📊 Updated Plotly chart version to support the latest features.
- 🏀 `st.spinner` element has visual animated spinner.
- 🍰 `st.caption` supports HTML in text with `unsafe_allow_html` parameter.

**Other Changes**

- 🪲 Bug fix: Allow `st.session_state` to be used to set number_input values with no warning ([#4047](https://github.com/streamlit/streamlit/pull/4047)).
- 🪲 Bug fix: Fix footer alignment in wide mode ([#4035](https://github.com/streamlit/streamlit/pull/4035)).
- 🐞 Bug fix: Better support for Graphviz and Bokeh charts in containers (columns, expanders, etc.) ([#4039](https://github.com/streamlit/streamlit/pull/4039)).
- 🐞 Bug fix: Support inline data values in Vega-Lite ([#4070](https://github.com/streamlit/streamlit/pull/4070)).
- ✍️ Types: Updated type annotations for experimental memo and singleton decorators.
- ✍️ Types: Improved type annotations for `st.selectbox`, `st.select_slider`, `st.radio`, `st.number_input`, and `st.multiselect`.

## Version 1.2.0

_Release date: Nov 11, 2021_

**Notable Changes**

- ✏️ `st.text_input` and `st.text_area` now have a `placeholder` parameter to display text when the field is empty.
- 📏 Viewers can now resize the input box in `st.text_area`.
- 📁 Streamlit can auto-reload when files in sub-directories change.
- 🌈 We've upgraded Bokeh support to 2.4.1! We recommend updating your Bokeh library to 2.4.1 to maintain functionality. Going forward, we'll let you know if there's a mismatch in your Bokeh version via an error prompt.
- 🔒 Developers can access secrets via attribute notation (e.g. `st.secrets.key` vs `st.secrets["key"]`) just like session state.
- ✍️ Publish type annotations according to [PEP 561](https://mypy.readthedocs.io/en/stable/installed_packages.html). Users now get type annotations for Streamlit when running mypy ([#4025](https://github.com/streamlit/streamlit/pull/4025)).

**Other Changes**

- 👀 Visual fixes ([#3863](https://github.com/streamlit/streamlit/pull/3863), [#3995](https://github.com/streamlit/streamlit/pull/3995), [#3926](https://github.com/streamlit/streamlit/pull/3926), [#3975](https://github.com/streamlit/streamlit/pull/3975)).
- 🍔 Fixes to the hamburger menu ([#3968](https://github.com/streamlit/streamlit/pull/3968)).
- 🖨️ Ability to print session state ([#3970](https://github.com/streamlit/streamlit/pull/3970)).

## Version 1.1.0

_Release date: Oct 21, 2021_

**Highlights**

- 🧠 Memory improvements: Streamlit apps allocate way less memory over time now.

**Notable Changes**

- ♻️ Apps automatically rerun now when the content of `secrets.toml` changes (before this you had to refresh the page manually).

**Other Changes**

- 🔗 Redirected some links to our [brand-new docs site](https://docs.streamlit.io/), e.g. in exceptions.
- 🪲 Bug fix: Allow initialization of range slider with session state ([#3586](https://github.com/streamlit/streamlit/issues/3586)).
- 🐞 Bug fix: Refresh chart when using `add_rows` with `datetime` index ([#3653](https://github.com/streamlit/streamlit/issues/3653)).
- ✍️ Added some more type annotation in our codebase ([#3908](https://github.com/streamlit/streamlit/issues/3908)).

## Version 1.0.0

_Release date: Oct 5, 2021_

**Highlights**

- 🎈Announcing Streamlit 1.0! To read more about check out our [1.0 blog post](https://blog.streamlit.io/announcing-streamlit-1-0/).

**Other Changes**

- 🐞 Fixed an issue where using `df.dtypes` to show datatypes for a DF fails while using Arrow ([#3709](https://github.com/streamlit/streamlit/issues/3709)), Image captions stay within image width and are readable ([#3530](https://github.com/streamlit/streamlit/issues/3530)).

## Version 0.89.0

_Release date: Sep 22, 2021_

**Highlights**

- 💰 Introducing `st.experimental_memo` and `experimental_singleton`, a new primitive for caching! See [our blog post](https://blog.streamlit.io/new-experimental-primitives-for-caching/).
- 🍔 Streamlit allows developers to configure their hamburger menu to be more user-centric.

**Notable Changes**

- 💅 We updated our UI to a more polished look with a new font.
- 🎨 We now support `theme.base` in the theme object when it's sent to custom components.
- 🧠 We've modified session state to reset widgets if any of their arguments changed even if they provide a key.
  - Some widget behavior may have changed, but we believe this change makes the most sense. We have added a section to [our documentation](/develop/concepts/widget-semantics) describing how they behave.

**Other Changes**

- 🐞 Bug fixes: Support svgs from a URL ([#3809](https://github.com/streamlit/streamlit/pull/3809)) and that do not start with `<svg>` tag ([#3789](https://github.com/streamlit/streamlit/pull/3789)).

## Version 0.88.0

_Release date: Sep 2, 2021_

**Highlights**

- ⬇️ Introducing `st.download_button`, a new button widget for easily downloading files.

**Notable Changes**

- 🛑 We made changes to improve the redacted exception experience on Streamlit Community Cloud. When `client.showErrorDetails=true` exceptions display the Error Type and the Traceback, but redact the actual error text to prevent data leaks.

## Version 0.87.0

_Release date: Aug 19, 2021_

**Highlights**

- 🔢 Introducing `st.metric`, an API for displaying KPIs. Check out the [demo app](https://streamlit-release-demos-0-87streamlit-app-0-87-rfzphf.streamlit.app/) showcasing the functionality.

**Other Changes**

- 🐞 **Bug Fixes**: File uploader retains state upon expander closing ([#3557](https://github.com/streamlit/streamlit/issues/3557)), setIn Error with `st.empty` ([#3659](https://github.com/streamlit/streamlit/issues/3659)), Missing IFrame embeds in docs ([#3706](https://github.com/streamlit/streamlit/issues/3706)), Fix error writing certain PNG files ([#3597](https://github.com/streamlit/streamlit/issues/3597)).

## Version 0.86.0

_Release date: Aug 5, 2021_

**Highlights**

- 🎓 Our layout primitives are graduating from beta! You can now use `st.columns`, `st.container` and `st.expander` without the `beta_` prefix.

**Notable Changes**

- 📱 When using `st.columns`, columns will stack vertically when viewport size \</svg>

---

# 2022 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2022


This page contains release notes for Streamlit versions released in 2022. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## **Version 1.16.0**

_Release date: December 14, 2022_

**Highlights**

- 👩‍🎨 Introducing a new Streamlit theme for Altair, Plotly, and Vega-Lite charts! Check out our [blog post](https://blog.streamlit.io/a-new-streamlit-theme-for-altair-and-plotly/) for more information.
- 🎨 Streamlit now supports colored text in all commands that accept Markdown, including `st.markdown`, `st.header`, and more. Learn more in our [documentation](/develop/api-reference/text/st.markdown).

**Notable Changes**

- 🔁 Functions cached with `st.experimental_memo` or `st.experimental_singleton` can contain Streamlit media elements and forms.
- ⛄ All Streamlit commands that accept pandas DataFrames as input also support Snowpark and PySpark DataFrames.
- 🏷 [st.checkbox](/develop/api-reference/widgets/st.checkbox) and [st.metric](/develop/api-reference/data/st.metric) can customize how to hide their labels with the `label_visibility` parameter.

**Other Changes**

- 🗺️ `st.map` improvements: support for upper case columns and better exception messages ([#5679](https://github.com/streamlit/streamlit/pull/5679), [#5792](https://github.com/streamlit/streamlit/pull/5792)).
- 🐞 Bug fix: `st.plotly_chart` respects the figure's height attribute and the `use_container_width` parameter ([#5779](https://github.com/streamlit/streamlit/pull/5779)).
- 🪲 Bug fix: all commands with the `icon` parameter such as [st.error](/develop/api-reference/status/st.error), [st.warning](/develop/api-reference/status/st.warning), etc, can contain emojis with variant selectors ([#5583](https://github.com/streamlit/streamlit/pull/5583)).
- 🐝 Bug fix: prevent `st.camera_input` from jittering when resizing the browser window ([#5661](https://github.com/streamlit/streamlit/pull/5711)).
- 🐜 Bug fix: update exception layout to avoid overflow of stack traces ([#5700](https://github.com/streamlit/streamlit/pull/5700)).

## **Version 1.15.0**

_Release date: November 17, 2022_

**Notable Changes**

- 💅 Widget labels can contain inline Markdown. See our [docs](/develop/api-reference/widgets) and demo [app](https://markdown-labels.streamlit.app/) for more info.
- 🎵 [`st.audio`](/develop/api-reference/media/st.audio) now supports playing audio data passed in as NumPy arrays with the keyword-only `sample_rate` parameter.
- 🔁 Functions cached with `st.experimental_memo` or `st.experimental_singleton` can contain Streamlit widgets using the `experimental_allow_widgets` parameter. This allows caching checkboxes, sliders, radio buttons, and more!

**Other Changes**

- 👩‍🎨 Design tweak to prevent jittering in sliders ([#5612](https://github.com/streamlit/streamlit/pull/5612)).
- 🐛 Bug fix: links in headers are red, not blue ([#5609](https://github.com/streamlit/streamlit/pull/5609)).
- 🐞 Bug fix: properly resize Plotly charts when exiting fullscreen ([#5645](https://github.com/streamlit/streamlit/pull/5645)).
- 🐝: Bug fix: don't accidentally trigger `st.balloons` and `st.snow` ([#5401](https://github.com/streamlit/streamlit/pull/5401)).

## **Version 1.14.0**

_Release date: October 27, 2022_

**Highlights**

- 🎨 `st.button` and `st.form_submit_button` support designating buttons as "primary" (for additional emphasis) or "secondary" (for normal buttons) with the `type` keyword-only parameter.

**Notable Changes**

- 🤏 `st.multiselect` has a keyword-only `max_selections` parameter to limit the number of options that can be selected at a time.
- 📄 `st.form_submit_button` now has the `disabled` parameter that removes interactivity.

**Other Changes**

- 🏓 `st.dataframe` and `st.table` accept categorical intervals as input ([#5395](https://github.com/streamlit/streamlit/pull/5395)).
- ⚡ Performance improvements to Plotly charts ([#5542](https://github.com/streamlit/streamlit/pull/5542)).
- 🪲 Bug fix: `st.download_button` supports non-latin1 characters in filenames ([#5465](https://github.com/streamlit/streamlit/pull/5465)).
- 🐞 Bug fix: Allow `st.image` to render a local GIF as a GIF, not as a static PNG ([#5438](https://github.com/streamlit/streamlit/pull/5438)).
- 📱 Design tweaks to the sidebar in multipage apps ([#5538](https://github.com/streamlit/streamlit/pull/5538), [#5445](https://github.com/streamlit/streamlit/pull/5445), [#5559](https://github.com/streamlit/streamlit/pull/5559)).
- 📊 Improvements to the axis configuration for built-in charts ([#5412](https://github.com/streamlit/streamlit/pull/5412)).
- 🔧 Memo and singleton improvements: support text values for `show_spinner`, use `datetime.timedelta` objects as `ttl` parameter value, properly hash PIL images and `Enum` classes, show better error messages when returning unevaluated dataframes ([#5447](https://github.com/streamlit/streamlit/pull/5447), [#5413](https://github.com/streamlit/streamlit/pull/5413), [#5504](https://github.com/streamlit/streamlit/pull/5504), [#5426](https://github.com/streamlit/streamlit/pull/5426), [#5515](https://github.com/streamlit/streamlit/pull/5515)).
- 🔍 Zoom buttons in maps created with `st.map` and `st.pydeck_chart` use light or dark style based on the app's theme ([#5479](https://github.com/streamlit/streamlit/pull/5479)).
- 🗜 Websocket headers from the current session's incoming WebSocket request can be obtained from a new "internal" (i.e.: subject to change without deprecation) API ([#5457](https://github.com/streamlit/streamlit/pull/5457)).
- 📝 Improve the text that gets printed when you first install and use Streamlit ([#5473](https://github.com/streamlit/streamlit/pull/5473)).

## **Version 1.13.0**

_Release date: September 22, 2022_

**Notable Changes**

- 🏷 Widgets can customize how to hide their labels with the `label_visibility` parameter.
- 🔍 `st.map` adds zoom buttons to the map by default.
- ↔️ `st.dataframe` supports the `use_container_width` parameter to stretch across the full container width.
- 🪄 Improvements to `st.dataframe` sizing: Column width calculation respects column headers, supports double click between column headers to autosize, better fullscreen support, and fixes the issue with the `width` parameter.

**Other Changes**

- ⌨️ `st.time_input` allows for keyboard-only input ([#5194](https://github.com/streamlit/streamlit/pull/5194)).
- 💿 `st.memo` will warn the user when using `ttl` and `persist` keyword argument together ([#5032](https://github.com/streamlit/streamlit/pull/5032)).
- 🔢 `st.number_input` returns consistent type after rerun ([#5359](https://github.com/streamlit/streamlit/pull/5359)).
- 🚒 `st.sidebar` UI fixes including a fix for scrollbars in Firefox browsers ([#5157](https://github.com/streamlit/streamlit/pull/5157), [#5324](https://github.com/streamlit/streamlit/pull/5324)).
- 👩‍💻 Improvements to usage metrics to guide API development.
- ✍️ More type hints! ([#5191](https://github.com/streamlit/streamlit/pull/5191), [#5192](https://github.com/streamlit/streamlit/pull/5192), [#5242](https://github.com/streamlit/streamlit/pull/5242), [#5243](https://github.com/streamlit/streamlit/pull/5243), [#5244](https://github.com/streamlit/streamlit/pull/5244), [#5245](https://github.com/streamlit/streamlit/pull/5245), [#5246](https://github.com/streamlit/streamlit/pull/5246)) Thanks [harahu](https://github.com/harahu)!

## **Version 1.12.0**

_Release date: August 11, 2022_

**Highlights**

- 📊 Built-in charts (e.g. `st.line_chart`) get a brand-new look and parameters `x` and `y`! Check out our [blog post](https://blog.streamlit.io/built-in-charts-get-a-new-look-and-parameters/) for more information.

**Notable Changes**

- ⏯ Functions cached with `st.experimental_memo` or `st.experimental_singleton` can now contain static `st` commands. This allows caching text, charts, dataframes, and more!
- ↔️ The sidebar is now resizable via drag and drop.
- ☎️ `st.info`, `st.success`, `st.error`, and `st.warning` got a redesign and have a new keyword-only parameter: `icon`.

**Other Changes**

- 🎚️ `st.select_slider` correctly handles all floats now ([#4973](https://github.com/streamlit/streamlit/pull/4973), [#4978](https://github.com/streamlit/streamlit/pull/4978)).
- 🔢 `st.multi_select` can take values from enums ([#4987](https://github.com/streamlit/streamlit/pull/4987)).
- 🍊 `st.slider` range values can now be set through `st.session_state` ([#5007](https://github.com/streamlit/streamlit/pull/5007)).
- 🎨 `st.progress` got a redesign ([#5011](https://github.com/streamlit/streamlit/pull/5011), [#5086](https://github.com/streamlit/streamlit/pull/5086)).
- 🔘 `st.radio` better deals with list-like dataframes ([#5021](https://github.com/streamlit/streamlit/pull/5021)).
- 🧞‍♂️ `st.cache` properly handles JSON files now ([#5023](https://github.com/streamlit/streamlit/pull/5023)).
- ⚓️ Headers render markdown now when the `anchor` parameter is set ([#5038](https://github.com/streamlit/streamlit/pull/5038)).
- 🗻 `st.image` can now load SVGs from Inkscape ([#5040](https://github.com/streamlit/streamlit/pull/5040)).
- 🗺️ `st.map` and `st.pydeck_chart` use light or dark style based on the app's theme ([#5074](https://github.com/streamlit/streamlit/pull/5074), [#5108](https://github.com/streamlit/streamlit/pull/5108)).
- 🎈 Clicks on elements below `st.balloons` and `st.snow` don't get blocked anymore ([#5098](https://github.com/streamlit/streamlit/pull/5098)).
- 🔝 Embedded apps have lower top padding ([#5111](https://github.com/streamlit/streamlit/pull/5111)).
- 💅 Adjusted padding and alignment for widgets, charts, and dataframes ([#4995](https://github.com/streamlit/streamlit/pull/4995), [#5061](https://github.com/streamlit/streamlit/pull/5061), [#5081](https://github.com/streamlit/streamlit/pull/5081)).
- ✍️ More type hints! ([#4926](https://github.com/streamlit/streamlit/pull/4926), [#4932](https://github.com/streamlit/streamlit/pull/4932), [#4933](https://github.com/streamlit/streamlit/pull/4933))

## **Version 1.11.0**

_Release date: July 14, 2022_

**Highlights**

- 🗂 Introducing `st.tabs` to have tab containers in your app. See our [documentation](/develop/api-reference/layout/st.tabs) on how to use this feature.

**Notable Changes**

- ℹ️ `st.metric` supports tooltips with the `help` keyword parameter.
- 🚇 `st.columns` supports setting the gap size between columns with the `gap` keyword parameter.

**Other Changes**

- 💅 Design tweaks to `st.selectbox`, `st.expander`, `st.spinner` ([#4801](https://github.com/streamlit/streamlit/pull/4801)).
- 📱 The sidebar will close when users select a page from the navigation menu on mobile devices ([#4851](https://github.com/streamlit/streamlit/pull/4841)).
- 🧠 `st.memo` supports dataclasses! ([#4850](https://github.com/streamlit/streamlit/pull/4850))
- 🏎 Bug fix for a race condition that destroyed widget state with rapid interaction ([#4882](https://github.com/streamlit/streamlit/pull/4882)).
- 🏓 `st.table` presents overflowing content to be scrollable when placed inside columns and expanders ([#4934](https://github.com/streamlit/streamlit/pull/4934)).
- 🐍 Types: More updated type annotations across Streamlit! ([#4808](https://github.com/streamlit/streamlit/pull/4808), [#4809](https://github.com/streamlit/streamlit/pull/4809), [#4856](https://github.com/streamlit/streamlit/pull/4856))

## **Version 1.10.0**

_Release date: June 2, 2022_

**Highlights**

- 📖 Introducing native support for multipage apps! Check out our [blog post](https://blog.streamlit.io/introducing-multipage-apps) and try out our new `streamlit hello`.

**Notable Changes**

- ✨ `st.dataframe` has been redesigned.
- 🔘 `st.radio` has a `horizontal` keyword-only parameter to display options horizontally.
- ⚠️ Streamlit Community Cloud will support richer exception formatting.
- 🏂 Get user information on private apps using `st.experimental_user`.

**Other Changes**

- 📊 Upgraded Vega-Lite library to support even more interactive charting improvements. See their [release notes](https://github.com/vega/vega-lite/releases) to find out more. ([#4751](https://github.com/streamlit/streamlit/pull/4751)).
- 📈 `st.vega_lite_chart` will respond to updates, particularly in response to input widgets ([#4736](https://github.com/streamlit/streamlit/pull/4736)).
- 💬 `st.markdown` with long text will always wrap ([#4696](https://github.com/streamlit/streamlit/pull/4696)).
- 📦 Support for [PDM](https://pdm.fming.dev/) ([#4724](https://github.com/streamlit/streamlit/pull/4724)).
- ✍️ Types: Updated type annotations across Streamlit! ([#4679](https://github.com/streamlit/streamlit/pull/4679), [#4680](https://github.com/streamlit/streamlit/pull/4680), [#4681](https://github.com/streamlit/streamlit/pull/4681), [#4682](https://github.com/streamlit/streamlit/pull/4682), [#4683](https://github.com/streamlit/streamlit/pull/4683), [#4684](https://github.com/streamlit/streamlit/pull/4684), [#4685](https://github.com/streamlit/streamlit/pull/4685), [#4686](https://github.com/streamlit/streamlit/pull/4686), [#4687](https://github.com/streamlit/streamlit/pull/4687), [#4688](https://github.com/streamlit/streamlit/pull/4688), [#4690](https://github.com/streamlit/streamlit/pull/4690), [#4703](https://github.com/streamlit/streamlit/pull/4703), [#4704](https://github.com/streamlit/streamlit/pull/4704), [#4705](https://github.com/streamlit/streamlit/pull/4705), [#4706](https://github.com/streamlit/streamlit/pull/4706), [#4707](https://github.com/streamlit/streamlit/pull/4707), [#4708](https://github.com/streamlit/streamlit/pull/4708), [#4710](https://github.com/streamlit/streamlit/pull/4710), [#4723](https://github.com/streamlit/streamlit/pull/4723), [#4733](https://github.com/streamlit/streamlit/pull/4733)).

## **Version 1.9.0**

_Release date: May 4, 2022_

**Notable Changes**

- 🪗 `st.json` now supports a keyword-only argument, `expanded` on whether the JSON should be expanded by default (defaults to `True`).
- 🏃‍♀️ More performance improvements from reducing redundant work each script run.

**Other Changes**

- 🏇 Widgets when `disabled` is set/unset will maintain its value ([#4527](https://github.com/streamlit/streamlit/pull/4527)).
- 🧪 Experimental feature to increase the speed of reruns using configuration `runner.fastReruns`. See [#4628](https://github.com/streamlit/streamlit/pull/4628) for the known issues in enabling this feature.
- 🗺️ DataFrame timestamps support UTC offset (in addition to time zone notation) ([#4669](https://github.com/streamlit/streamlit/pull/4669)).

## **Version 1.8.0**

_Release date: March 24, 2022_

**Notable Changes**

- 🏃‍♀️ Dataframes should see performance improvements ([#4463](https://github.com/streamlit/streamlit/pull/4463)).

**Other Changes**

- 🕰 `st.slider` handles timezones better by removing timezone conversions on the backend ([#4348](https://github.com/streamlit/streamlit/pull/4358)).
- 👩‍🎨 Design improvements to our header ([#4496](https://github.com/streamlit/streamlit/pull/4496)).

## **Version 1.7.0**

_Release date: March 3, 2022_

**Highlights**

- Introducing `st.snow`, celebrating our acquisition by Snowflake! See more information in [our blog post](https://blog.streamlit.io/snowflake-to-acquire-streamlit/).

## **Version 1.6.0**

_Release date: Feb 24, 2022_

**Other Changes**

- 🗜 WebSocket compression is now disabled by default, which will improve CPU and latency performance for large dataframes. You can use the `server.enableWebsocketCompression` configuration option to re-enable it if you find the increased network traffic more impactful.
- ☑️ 🔘 Radio and checkboxes improve focus on Keyboard navigation ([#4308](https://github.com/streamlit/streamlit/pull/4308)).

## **Version 1.5.0**

_Release date: Jan 27, 2022_

**Notable Changes**

- 🌟 Favicon defaults to a PNG to allow for transparency ([#4272](https://github.com/streamlit/streamlit/pull/4272)).
- 🚦 Select Slider Widget now has the `disabled` parameter that removes interactivity (completing all of our widgets) ([#4314](https://github.com/streamlit/streamlit/pull/4314)).

**Other Changes**

- 🔤 Improvements to our markdown library to provide better support for HTML (specifically nested HTML) ([#4221](https://github.com/streamlit/streamlit/pull/4221)).
- 📖 Expanders maintain their expanded state better when multiple expanders are present ([#4290](https://github.com/streamlit/streamlit/pull/4290)).
- 🗳 Improved file uploader and camera input to call its `on_change` handler only when necessary ([#4270](https://github.com/streamlit/streamlit/pull/4270)).

## **Version 1.4.0**

_Release date: Jan 13, 2022_

**Highlights**

- 📸 Introducing `st.camera_input` for uploading images straight from your camera.

**Notable Changes**

- 🚦 Widgets now have the `disabled` parameter that removes interactivity.
- 🚮 Clear `st.experimental_memo` and `st.experimental_singleton` programmatically by using the `clear()` method on a cached function.
- 📨 Developers can now configure the maximum size of a message to accommodate larger messages within the Streamlit application. See `server.maxMessageSize`.
- 🐍 We formally added support for Python 3.10.

**Other Changes**

- 😵‍💫 Calling `str` or `repr` on `threading.current_thread()` does not cause a RecursionError ([#4172](https://github.com/streamlit/streamlit/issues/4172)).
- 📹 Gracefully stop screencast recording when user removes permission to record ([#4180](https://github.com/streamlit/streamlit/pull/4180)).
- 🌇 Better scale images by using a higher-quality image bilinear resampling algorithm ([#4159](https://github.com/streamlit/streamlit/pull/4159)).

---

# 2023 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2023


This page contains release notes for Streamlit versions released in 2023. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## **Version 1.29.0**

_Release date: November 30, 2023_

**Highlights**

- 🔲 [`st.container`](/develop/api-reference/layout/st.container) and [`st.form`](/develop/api-reference/execution-flow/st.form) now have a `border` parameter to show or hide a border.
- 🐍 Streamlit supports Python 3.12!

**Notable Changes**

- ⌛ `st.dataframe`, `st.data_editor`, and `st.table` support `datetime.timedelta` values ([#7689](https://github.com/streamlit/streamlit/pull/7689), [#4489](https://github.com/streamlit/streamlit/issues/4489)).
- 💀 Streamlit apps preload skeleton elements for a smoother appearance when initializing ([#7598](https://github.com/streamlit/streamlit/pull/7598)).
- 🏃 Reduced the overhead of running `AppTest`-simulated apps, especially for fast-running apps ([#7691](https://github.com/streamlit/streamlit/pull/7691)).
- 🛁 String representations of `AppTest` data are improved for a better testing and debugging experience ([#7658](https://github.com/streamlit/streamlit/pull/7658)).
- 🔢 Apps can be configured to identify `Enum` classes as the same if they have matching member names ([#7408](https://github.com/streamlit/streamlit/pull/7408), [#4909](https://github.com/streamlit/streamlit/issues/4909)). Thanks, [Asaurus1](https://github.com/Asaurus1)!
- ❌ The "Made with Streamlit" footer no longer appears at the bottom of apps ([#7583](https://github.com/streamlit/streamlit/pull/7583)).
- 🧹 Unused config options have been deprecated ([#7584](https://github.com/streamlit/streamlit/pull/7584)).
- 🕳️ Query parameters can be empty ([#7601](https://github.com/streamlit/streamlit/pull/7601), [#7416](https://github.com/streamlit/streamlit/issues/7416)).
- 💅 Visual tweaks ([#7592](https://github.com/streamlit/streamlit/pull/7592), [#7630](https://github.com/streamlit/streamlit/pull/7630)).

**Other Changes**

- 🦗 Bug fix: Convert floats to bytes instead of hashing to avoid hashing instability ([#7754](https://github.com/streamlit/streamlit/pull/7754)). Thanks, [BlackHC](https://github.com/BlackHC)!
- 🦎 Bug fix: Corrected broken URLs and typos in error messages ([#7746](https://github.com/streamlit/streamlit/pull/7746), [#7764](https://github.com/streamlit/streamlit/pull/7764), [#7770](https://github.com/streamlit/streamlit/pull/7770)). Thanks, [ObservedObserver](https://github.com/ObservedObserver)!
- 🐌 Bug fix: `st.connection` correctly caches results when using two connections of the same type ([#7730](https://github.com/streamlit/streamlit/pull/7730), [#7709](https://github.com/streamlit/streamlit/issues/7709)).
- 🕸️ Bug fix: Using context managers with multithreading now displays content in the expected order ([#7715](https://github.com/streamlit/streamlit/pull/7715), [#7668](https://github.com/streamlit/streamlit/issues/7668)). Thanks, [eric-skydio](https://github.com/eric-skydio)!
- 🦂 Bug fix: Added https fallback when obtaining the host machine's address ([#7712](https://github.com/streamlit/streamlit/pull/7712), [#7703](https://github.com/streamlit/streamlit/issues/7703)). Thanks, [LarsHill](https://github.com/LarsHill)!
- 🛡️ Bug fix: Added security patch for `pyarrow` vulnerability. Custom components using `pyarrow` table deserialization should require `pyarrow&gt;=14.0.1` ([#7695](https://github.com/streamlit/streamlit/pull/7695), [#7700](https://github.com/streamlit/streamlit/issues/7700)).
- 🦟 Bug fix: Improved typing for `st.connection` ([#7671](https://github.com/streamlit/streamlit/pull/7671)). Thanks, [thezanke](https://github.com/thezanke)!
- 🪰 Bug fix: Retries of `SnowflakeConnection` methods are narrowed to only occur with transient errors to avoid unnecessary repeated errors ([#7645](https://github.com/streamlit/streamlit/pull/7645), [#7637](https://github.com/streamlit/streamlit/issues/7637)).
- 🏗️ Removed the v0 testing framework which was undocumented ([#7657](https://github.com/streamlit/streamlit/pull/7657)).
- 🪳 Bug fix: The navigation expander arrow no longer disappears ([#7634](https://github.com/streamlit/streamlit/pull/7634), [#7547](https://github.com/streamlit/streamlit/issues/7547)).
- ❄️ Improved the error message for `SnowflakeConnection` when a configuration is not found ([#7652](https://github.com/streamlit/streamlit/pull/7652)).
- 🕷️ Bug fix: `st.rerun` no longer causes a `RecursionError` when used with `st.chat_input` ([#7643](https://github.com/streamlit/streamlit/pull/7643), [#7629](https://github.com/streamlit/streamlit/issues/7629)).
- 🐞 Bug fix: `st.file_uploader` no longer causes an extra rerun and therefore doesn't conflict with `st.chat_input` ([#7641](https://github.com/streamlit/streamlit/pull/7641), [#7556](https://github.com/streamlit/streamlit/issues/7556)).
- 🐝 Bug fix: `AppTest` no longer raises an error when encountering `st.container` ([#7644](https://github.com/streamlit/streamlit/pull/7644), [#7636](https://github.com/streamlit/streamlit/issues/7636)).
- 🪲 Bug fix: Graphviz charts scale correctly when exiting fullscreen view ([#7398](https://github.com/streamlit/streamlit/pull/7398), [#7527](https://github.com/streamlit/streamlit/issues/6527)).
- 🎥 Bug fix: "Record a screencast" is hidden when known to be unsupported in a browser ([#7604](https://github.com/streamlit/streamlit/pull/7604)).
- 🐛 Bug fix: Increased the top padding of embedded apps to better display the dataframe toolbar ([#7681](https://github.com/streamlit/streamlit/pull/7681), [#7609](https://github.com/streamlit/streamlit/pull/7609), [#7607](https://github.com/streamlit/streamlit/issues/7607)).
- 🐜 Bug fix: `st.rerun` uses `NoReturn` for improved type checking ([#7422](https://github.com/streamlit/streamlit/pull/7422)) Thanks, [kongzii](https://github.com/kongzii).

## **Version 1.28.0**

_Release date: October 26, 2023_

**Release videos**

- [Introducing `AppTest`](https://www.youtube.com/watch?v=99OEoP5sy0U)

**Highlights**

- 🧪 Introducing a new testing framework for Streamlit apps! Check out our [documentation](/develop/api-reference/app-testing) to learn how to build automated tests for your apps.
- 💻 Announcing the general availability of `st.connection`, a command to conveniently manage connections in Streamlit apps. Check out the [docs](/develop/api-reference/connections/st.connection) to learn more.
- ❄️ `SnowparkConnection` has been upgraded to the new and improved `SnowflakeConnection` — the same, great functionality _plus more_! Check out our [built-in connections](/develop/api-reference/connections#built-in-connections).
- 🛠️ `st.dataframe` and `st.data_editor` have a new toolbar! Users can search and download data in addition to enjoying improved UI for row additions and deletions. See our updated guide on [Dataframes](/develop/concepts/design/dataframes).

**Notable Changes**

- 🌀 When using a spinner with cached functions, the spinner will be overlaid instead of pushing content down ([#7488](https://github.com/streamlit/streamlit/pull/7488)).
- 📅 `st.data_editor` now supports datetime index editing ([#7483](https://github.com/streamlit/streamlit/pull/7483)).
- 🔢 Improved support for `decimal.Decimal` in `st.dataframe` and `st.data_editor` ([#7475](https://github.com/streamlit/streamlit/pull/7475)).
- 🥸 Global kwargs were added for `hashlib` ([#7527](https://github.com/streamlit/streamlit/pull/7527), [#7526](https://github.com/streamlit/streamlit/issues/7526)). Thanks, [DueViktor](https://github.com/DueViktor)!
- 📋 `st.components.v1.iframe` now permits writing to clipboard ([#7487](https://github.com/streamlit/streamlit/pull/7487)). Thanks, [dilipthakkar](https://github.com/dilipthakkar)!
- 📝 `SafeSessionState` disconnect was replaced with script runner yield points for improved efficiency and clarity ([#7373](https://github.com/streamlit/streamlit/pull/7373)).
- 🤖 The Langchain callback handler will show the full input string inside the body of a `st.status` when the input string is too long to show as a label ([#7478](https://github.com/streamlit/streamlit/pull/7478)). Thanks, [pokidyshev](https://github.com/pokidyshev)!
- 📈 `st.graphviz_chart` now supports using different Graphviz layout engines ([#7505](https://github.com/streamlit/streamlit/pull/7505), [#4089](https://github.com/streamlit/streamlit/issues/4089)).
- 🦋 Assorted visual tweaks ([#7486](https://github.com/streamlit/streamlit/pull/7486), [#7592](https://github.com/streamlit/streamlit/pull/7592)).
- 📊 `plotly.js` was upgraded to version 2.26.1 ([#7449](https://github.com/streamlit/streamlit/pull/7449), [#7476](https://github.com/streamlit/streamlit/issues/7476), [#7045](https://github.com/streamlit/streamlit/issues/7045)).
- 💽 Legacy serialization for DataFrames was removed. All DataFrames will be serialized by Apache Arrow ([#7429](https://github.com/streamlit/streamlit/pull/7429)).
- 🖼️ Compatibility for Pillow 10.x was added ([#7442](https://github.com/streamlit/streamlit/pull/7442)).
- 📬 Migrated `_stcore/allowed-message-origins` endpoint to `_stcore/host-config` ([#7342](https://github.com/streamlit/streamlit/pull/7342)).
- 💬 Added `post_parent_message` platform command to send custom messages from a Streamlit app to its parent window ([#7522](https://github.com/streamlit/streamlit/pull/7522)).

**Other Changes**

- ⌨️ Improved string dtype handling for DataFrames ([#7479](https://github.com/streamlit/streamlit/pull/7479)).
- ✒️ `st.write` will avoid using `unsafe_allow_html=True` if possible ([#7432](https://github.com/streamlit/streamlit/pull/7432)).
- 🐛 Bug fix: Implementation of `st.expander` was simplified for improved behavior and consistency ([#7247](https://github.com/streamlit/streamlit/pull/7247), [#2839](https://github.com/streamlit/streamlit/issues/2839), [#4111](https://github.com/streamlit/streamlit/issues/4111), [#4651](https://github.com/streamlit/streamlit/issues/4651), [#5604](https://github.com/streamlit/streamlit/issues/5604)).
- 🪲 Bug fix: Multipage links in the sidebar are now aligned with other sidebar elements ([#7531](https://github.com/streamlit/streamlit/pull/7531)).
- 🐜 Bug fix: `st.chat_input` won't incorrectly prompt for `label` parameter in IDEs ([#7560](https://github.com/streamlit/streamlit/pull/7560)).
- 🐝 Bug fix: Scroll bars correctly overlay `st.dataframe` and `st.data_editor` without adding empty space ([#7090](https://github.com/streamlit/streamlit/pull/7090), [#6888](https://github.com/streamlit/streamlit/issues/6888)).
- 🐞 Bug fix: `st.chat_message` behaves correctly with the removal of AutoSizer ([#7504](https://github.com/streamlit/streamlit/pull/7504), [#7473](https://github.com/streamlit/streamlit/issues/7473)).
- 🕷️ Bug fix: Anchor links are reliably produced for non-English headers ([#7454](https://github.com/streamlit/streamlit/pull/7454), [#5291](https://github.com/streamlit/streamlit/issues/5291)).
- ☃️ Bug fix: `st.connections.SnowparkConnection` more accurately detects when it's running within Streamlit in Snowflake ([#7502](https://github.com/streamlit/streamlit/pull/7502)).
- 🪳 Bug fix: A user-friendly warning is shown when exceeding the size limitations of a pandas `Styler` object ([#7497](https://github.com/streamlit/streamlit/pull/7497), [#5953](https://github.com/streamlit/streamlit/issues/5953)).
- 🪰 Bug fix: `st.data_editor` automatically converts non-string column names to strings ([#7485](https://github.com/streamlit/streamlit/pull/7485), [#6950](https://github.com/streamlit/streamlit/issues/6950)).
- 🦠 Bug fix: `st.data_editor` correctly identifies non-range indices as a required column ([#7481](https://github.com/streamlit/streamlit/pull/7481), [#6995](https://github.com/streamlit/streamlit/issues/6995)).
- 🦟 Bug fix: `st.file_uploader` displays compound file extensions like `csv.gz` correctly ([#7362](https://github.com/streamlit/streamlit/pull/7362)). Thanks, [mo42](https://github.com/mo42)!
- 🦂 Bug fix: Column Configuration no longer uses deprecated type checks ([#7496](https://github.com/streamlit/streamlit/pull/7496), [#7477](https://github.com/streamlit/streamlit/pull/7477), [#7550](https://github.com/streamlit/streamlit/issues/7550)). Thanks, [c-bik](https://github.com/c-bik)!
- 🦗 Bug fix: Additional toolbar items no longer stack vertically ([#7470](https://github.com/streamlit/streamlit/pull/7470), [#7471](https://github.com/streamlit/streamlit/issues/7471)).
- 🕸️ Bug fix: Column Configuration no longer causes a type warning in Mypy ([#7457](https://github.com/streamlit/streamlit/pull/7457)). Thanks, [kopp](https://github.com/kopp)!
- 🐌 Bug fix: Bokeh Sliders no longer cause JavaScript errors ([#7441](https://github.com/streamlit/streamlit/pull/7441), [#7171](https://github.com/streamlit/streamlit/issues/7171)).
- 🦎 Bug fix: Caching now recognizes DataFrames with the same values but different column names as different ([#7331](https://github.com/streamlit/streamlit/pull/7331), [#7086](https://github.com/streamlit/streamlit/issues/7086)).

## **Version 1.27.0**

_Release date: September 21, 2023_

**Highlights**

- ✨ Introducing `st.scatter_chart` — a new, simple chart element to build scatter charts Streamlit-y fast and easy! See our [documentation](/develop/api-reference/charts/st.scatter_chart).
- 🔗 Introducing `st.link_button`! Want to open an external link in a new tab with a bit more pizazz than a plain-text link? Check out our [documentation](/develop/api-reference/widgets/st.link_button) to see how.
- 🏃 Announcing the general availability of [`st.rerun`](/develop/api-reference/execution-flow/st.rerun), a command to interrupt your script and trigger an immediate rerun.

**Notable Changes**

- 👻 You can initialize widgets with an empty state by setting `None` as an initial value for [`st.number_input`](/develop/api-reference/widgets/st.number_input), [`st.selectbox`](/develop/api-reference/widgets/st.selectbox), [`st.date_input`](/develop/api-reference/widgets/st.date_input), [`st.time_input`](/develop/api-reference/widgets/st.time_input), [`st.radio`](/develop/api-reference/widgets/st.radio), [`st.text_input`](/develop/api-reference/widgets/st.text_input), and [`st.text_area`](/develop/api-reference/widgets/st.text_area)!
- 📤 [`st.download_button`](/develop/api-reference/widgets/st.download_button) now uses `target="_self"` instead of opening a new tab ([#7151](https://github.com/streamlit/streamlit/pull/7151), [#7132](https://github.com/streamlit/streamlit/issues/7132)).
- 🧟 Removed unmaintained `pympler` dependency ([#7193](https://github.com/streamlit/streamlit/pull/7193), [#7131](https://github.com/streamlit/streamlit/issues/7131)). Thanks, [rudyardrichter](https://github.com/rudyardrichter)!

**Other Changes**

- 🐛 Bug fix: `st.multiselect` now shows a correct message when no result matches a user's search ([#7205](https://github.com/streamlit/streamlit/pull/7205), [#7116](https://github.com/streamlit/streamlit/issues/7116)).
- 🪲 Bug fix: `st.experimental_user` now defaults to `test@example.com` ([#7219](https://github.com/streamlit/streamlit/pull/7219), [#7215](https://github.com/streamlit/streamlit/issues/7215)).
- 🐜 Bug fix: `st.slider` labels don't overlap when small ranges are selected ([#7221](https://github.com/streamlit/streamlit/pull/7221), [#3385](https://github.com/streamlit/streamlit/issues/3385)).
- 🐝 Bug fix: Type-checking correctly identifies all string types to avoid hashing errors ([#7255](https://github.com/streamlit/streamlit/pull/7255), [#6455](https://github.com/streamlit/streamlit/issues/6455)).
- 🐞 Bug fix: JSON is parsed with JSON5 to avoid errors from null values when using `st.pydeck_chart` ([#7256](https://github.com/streamlit/streamlit/pull/7256), [#5799](https://github.com/streamlit/streamlit/issues/5799)).
- 🕷️ Bug fix: Identical widgets on different pages are correctly interpreted by Streamlit as distinct ([#7264](https://github.com/streamlit/streamlit/pull/7264), [#6146](https://github.com/streamlit/streamlit/issues/6146)).
- 🦋 Bug fix: Visual tweaks to widgets for responsive behavior ([#7145](https://github.com/streamlit/streamlit/pull/7145)).
- 🪳 Bug fix: SVGs are accurately displayed ([#7183](https://github.com/streamlit/streamlit/pull/7183), [#3882](https://github.com/streamlit/streamlit/issues/3882)).
- 🪰 Bug fix: `st.video` correctly updates with changes to `start_time` ([#7257](https://github.com/streamlit/streamlit/pull/7257), [#7126](https://github.com/streamlit/streamlit/issues/7126)).
- 🦠 Bug fix: Additional error handling was added to `st.session_state` ([#7280](https://github.com/streamlit/streamlit/pull/7280), [#7206](https://github.com/streamlit/streamlit/issues/7206)).
- 🦟 Bug fix: `st.map` correctly refreshes with new data ([#7307](https://github.com/streamlit/streamlit/pull/7307), [#7294](https://github.com/streamlit/streamlit/issues/7294)).
- 🦂 Bug fix: The decorative app header line is no longer covered by the sidebar ([#7297](https://github.com/streamlit/streamlit/pull/7297), [#6264](https://github.com/streamlit/streamlit/issues/6264)).
- 🦗 Bug fix: `st.code` no longer triggers a `CachedStFunctionWarning` ([#7306](https://github.com/streamlit/streamlit/pull/7306), [#7055](https://github.com/streamlit/streamlit/issues/7055)).
- 🕸️ Bug fix: `st.download_button` no longer resets with different `data` ([#7316](https://github.com/streamlit/streamlit/pull/7316), [#7308](https://github.com/streamlit/streamlit/issues/7308)).
- 🐌 Bug fix: Widgets consistently recognize user interaction while a page is still running, with or without `fastRerun` enabled ([#7283](https://github.com/streamlit/streamlit/pull/7283), [#6643](https://github.com/streamlit/streamlit/issues/6643)).
- 🦎 Bug fix: `st.tabs` was improved to better handle and render conditionally appearing tabs ([#7287](https://github.com/streamlit/streamlit/pull/7287), [#7310](https://github.com/streamlit/streamlit/pull/7310), [#5454](https://github.com/streamlit/streamlit/issues/5454), [#7040](https://github.com/streamlit/streamlit/issues/7040)).

## **Version 1.26.0**

_Release date: August 24, 2023_

**Highlights**

- 🤖 Introducing `st.status` to display output from long-running processes and external API calls ([#7140](https://github.com/streamlit/streamlit/pull/7140)). Works great with `st.chat_message`! See our [documentation](/develop/api-reference/status/st.status) for how to use this feature.
- 🚥 Introducing [`st.toggle`](/develop/api-reference/widgets/st.toggle) — an alternative to `st.checkbox` when you need an on/off switch.

**Notable Changes**

- 🎨 Simple [chart elements](/develop/api-reference/charts) have a `color` parameter to set the color of your data points or series ([#7022](https://github.com/streamlit/streamlit/pull/7022)).
- 🌈 [Markdown](/develop/api-reference/text/st.markdown) supports rainbow and gray colors ([#7106](https://github.com/streamlit/streamlit/pull/7106), [#7179](https://github.com/streamlit/streamlit/pull/7179)).
- 📏 [`st.header`](/develop/api-reference/text/st.header) and [`st.subheader`](/develop/api-reference/text/st.subheader) have optional, colored dividers ([#7133](https://github.com/streamlit/streamlit/pull/7133)).
- 🚀 Deploying to Community Cloud is even easier—locally running apps have a [deploy button](/develop/concepts/architecture/app-chrome#deploy-this-app) in their toolbars ([#7085](https://github.com/streamlit/streamlit/pull/7085), [#6935](https://github.com/streamlit/streamlit/issues/6935)).
- 🖌️ [`st.download_button`](/develop/api-reference/widgets/st.download_button) has a new parameter `type` for theming ([#7056](https://github.com/streamlit/streamlit/pull/7056), [#7038](https://github.com/streamlit/streamlit/issues/7038)).
- 🤖 [`st.chat_message`](/develop/api-reference/chat/st.chat_message) has ai and human presets for messages ([#7094](https://github.com/streamlit/streamlit/pull/7094)).
- 💅 [`st.radio`](/develop/api-reference/widgets/st.radio) options support markdown and have captions ([#7018](https://github.com/streamlit/streamlit/pull/7018), [#7105](https://github.com/streamlit/streamlit/pull/7105), [#6085](https://github.com/streamlit/streamlit/issues/6085)).
- 🧼 Assorted visual tweaks ([#7050](https://github.com/streamlit/streamlit/pull/7050), [#894](https://github.com/streamlit/streamlit/issues/894)).
- 🛏️ Replaced deprecated `imghdr` dependency with `pillow` ([#7081](https://github.com/streamlit/streamlit/pull/7081), [#7027](https://github.com/streamlit/streamlit/issues/7027)).
- 🔢 [`st.number_input`](/develop/api-reference/widgets/st.number_input)'s step buttons (+/-) are ignored during tabbing navigation ([#7154](https://github.com/streamlit/streamlit/pull/7154)). Thanks [@denck007](https://github.com/denck007)!

**Other Changes**

- 🍞 Bug fix: Toast messages are no longer blocked by `st.chat_input` ([#7204](https://github.com/streamlit/streamlit/pull/7204), [#7115](https://github.com/streamlit/streamlit/issues/7115)).
- 🕸️ Bug fix: Widget IDs are now stable to prevent inconsistent statefulness ([#7003](https://github.com/streamlit/streamlit/pull/7003)).
- 🦟 Bug fix: Browser autofill is correctly recognized within forms now ([#7150](https://github.com/streamlit/streamlit/pull/7150), [#7101](https://github.com/streamlit/streamlit/issues/7101), [#7084](https://github.com/streamlit/streamlit/issues/7084)).
- 🪱 Bug fix: `st.file_uploader` no longer causes session state to reset when a websocket connection is dropped and reconnected ([#7149](https://github.com/streamlit/streamlit/pull/7149), [#7025](https://github.com/streamlit/streamlit/pull/7025)).
- 🏎️ Bug fix: Pydeck JSON data is cached for improved performance ([#7113](https://github.com/streamlit/streamlit/pull/7113), [#5532](https://github.com/streamlit/streamlit/issues/5532)).
- 🦋 Bug fix: `st.chat_input` no longer submits prematurely while typing with an input method editor ([#6993](https://github.com/streamlit/streamlit/pull/6993)).
- 🐞 Bug fix: Label backgrounds for `st.tabs` are now transparent ([#7070](https://github.com/streamlit/streamlit/pull/7070), [#5707](https://github.com/streamlit/streamlit/issues/5707)).
- 🐝 Bug fix: Page width is no longer ignored when using the `help` parameter in `st.button` ([#7033](https://github.com/streamlit/streamlit/pull/7033), [#6161](https://github.com/streamlit/streamlit/issues/6161)).
- 🐜 Bug fix: Tweaked Altair color specification for improved visibility in dark mode ([#7061](https://github.com/streamlit/streamlit/pull/7061), [#3343](https://github.com/streamlit/streamlit/issues/3343)).
- 🪲 Bug fix: `st.chat_message` can correctly use local images as avatars ([#7130](https://github.com/streamlit/streamlit/pull/7130)).
- 🐛 Bug fix: Specified that MD5 is not used for security ([#7122](https://github.com/streamlit/streamlit/pull/7122), [#7120](https://github.com/streamlit/streamlit/issues/7120)).
- 🪄 Bug fix: Async function docstrings are ignored by [Streamlit magic](/develop/api-reference/write-magic/magic) ([#7143](https://github.com/streamlit/streamlit/pull/7143), [#7137](https://github.com/streamlit/streamlit/issues/7137)).

## **Version 1.25.0**

_Release date: July 20, 2023_

**Highlights**

- 🍞 Introducing `st.toast` — a command to briefly show toast messages to users in the bottom-right corner of apps. See [our documentation](/develop/api-reference/status/st.toast) on how to use this feature.

**Notable Changes**

- 🗺️ [`st.map`](/develop/api-reference/charts/st.map) now has parameters for `latitude`, `longitude`, `color`, and `size` to customize data points ([#6896](https://github.com/streamlit/streamlit/pull/6896)).
- 🚩 [`st.multiselect`](/develop/api-reference/widgets/st.multiselect) supports setting placeholders and specifying the maximum number of selections via the `placeholder` and `max_selections` keyword-only arguments, respectively ([#6901](https://github.com/streamlit/streamlit/pull/6901), [#4750](https://github.com/streamlit/streamlit/issues/4750)). Thanks, [@fhiroki](https://github.com/fhiroki)!
- 📅 Customize the date format for `st.date_input` with the `format` parameter ([#6974](https://github.com/streamlit/streamlit/pull/6974), [#5234](https://github.com/streamlit/streamlit/issues/5234)).
- ↩️ [Forms](/develop/api-reference/execution-flow/st.form) can now be submitted with Enter/Return while inside [`st.text_input`](/develop/api-reference/widgets/st.text_input), [`st.number_input`](/develop/api-reference/widgets/st.number_input), or [`st.text_area`](/develop/api-reference/widgets/st.text_area) ([#6911](https://github.com/streamlit/streamlit/pull/6911), [#3790](https://github.com/streamlit/streamlit/issues/3790)).
- 🍢 The app menu icon in the upper-right corner of apps has been changed from "**☰**" to "**⋮**" ([#6947](https://github.com/streamlit/streamlit/pull/6947)).

**Other Changes**

- ⛓️ Minimum required versions increased for multiple Python dependencies, including `numpy&gt;=1.19.3` and `pandas&gt;=1.3.0` ([#6802](https://github.com/streamlit/streamlit/pull/6802)).
- 🛡️ `protobufjs` was bumped from 7.2.1 to 7.2.4 ([#6959](https://github.com/streamlit/streamlit/pull/6959)).
- ✨ Visual design tweaks to Streamlit's input widgets ([#6944](https://github.com/streamlit/streamlit/pull/6944)).
- 🦋 Bug Fix: `st.slider` now accepts general number types like `numpy.int64` instead of just `int` and `float` ([#6816](https://github.com/streamlit/streamlit/pull/6816), [#6815](https://github.com/streamlit/streamlit/issues/6815)). Thanks, [@milliams](https://github.com/milliams)!
- 🐜 Bug Fix: Data labels for `st.slider` and `st.select_slider` no longer overflow when inside `st.expander` ([#6828](https://github.com/streamlit/streamlit/pull/6828), [#6297](https://github.com/streamlit/streamlit/issues/6297)).
- 🐛 Bug Fix: Elements no longer re-render from scratch with each rerun ([#6923](https://github.com/streamlit/streamlit/pull/6923), [#6920](https://github.com/streamlit/streamlit/issues/6920)).
- 🐞 Bug Fix: `st.data_editor` hashes styler objects correctly for stability across reruns ([#6815](https://github.com/streamlit/streamlit/pull/6915), [#6898](https://github.com/streamlit/streamlit/issues/6898)).
- 🐝 Bug Fix: Fixed the padding for embedded apps using `st.chat_input` to prevent messages being cutoff ([#6979](https://github.com/streamlit/streamlit/pull/6979)).

## **Version 1.24.0**

_Release date: June 27, 2023_

**Highlights**

- 💬 Introducing `st.chat_message` and `st.chat_input` — two new [chat elements](/develop/api-reference/chat) that let you build conversational apps. Learn how to use these features in your LLM-powered chat apps in our [tutorial](/develop/tutorials/llms/build-conversational-apps).
- 💾 Streamlit's caching decorators now allow you to customize Streamlit's hashing of input parameters with the keyword-only argument [`hash_funcs`](/develop/concepts/architecture/caching#the-hash_funcs-parameter).

**Notable Changes**

- 🐍 We've deprecated support for Python 3.7 in the core library and Streamlit Community Cloud ([#6868](https://github.com/streamlit/streamlit/pull/6868)).
- 📅 `st.cache_data` and `st.cache_resource` can hash timezone-aware `datetime` objects ([#6812](https://github.com/streamlit/streamlit/pull/6812), [#6690](https://github.com/streamlit/streamlit/issues/6690), [#5110](https://github.com/streamlit/streamlit/issues/5110)).

**Other Changes**

- ✨ Visual design tweaks to Streamlit's input widgets ([#6817](https://github.com/streamlit/streamlit/pull/6817)).
- 🐛 Bug fix: `st.write` pretty-prints dataclasses using `st.help` ([#6750](https://github.com/streamlit/streamlit/pull/6750)).
- 🪲 Bug fix: `st.button`'s height is consistent with that of other widgets ([#6738](https://github.com/streamlit/streamlit/pull/6738)).
- 🐜 Bug fix: Upgraded the `react-range` frontend dependency to fix the memory usage of sliders ([#6764](https://github.com/streamlit/streamlit/pull/6764), [#5436](https://github.com/streamlit/streamlit/issues/5436)). Thanks [@wolfd](https://github.com/wolfd)!
- 🐝 Bug fix: Pydantic validators no longer result in exceptions on app reruns ([#6664](https://github.com/streamlit/streamlit/pull/6664), [#3218](https://github.com/streamlit/streamlit/issues/3218)).
- 🐞 Bug fix: `streamlit config show` honors newlines ([#6758](https://github.com/streamlit/streamlit/pull/6758), [#2868](https://github.com/streamlit/streamlit/issues/2868)).
- 🪰 Bug fix: Fixed a race condition to ensure Streamlit reruns the latest code when the file changes ([#6884](https://github.com/streamlit/streamlit/pull/6884)).
- 🦋 Bug fix: Apps no longer rerun when users click anchor links ([#6834](https://github.com/streamlit/streamlit/pull/6834), [#6500](https://github.com/streamlit/streamlit/issues/6500)).
- 🕸️ Bug fix: Added robust out-of-bounds checks for `min_value` and `max_value` in `st.number_input` ([#6847](https://github.com/streamlit/streamlit/pull/6847), [#6797](https://github.com/streamlit/streamlit/issues/6797)).

## **Version 1.23.0**

_Release date: June 1, 2023_

**Highlights**

- ✂️ Announcing the general availability of [st.data_editor](/develop/api-reference/data/st.data_editor), a widget that allows you to edit DataFrames and many other data structures in a table-like UI. **Breaking change:** the data editor's representation used in `st.session_state` was altered. Find out more about the new format in [Access edited data](/develop/concepts/design/dataframes#access-edited-data).
- ⚙️ Introducing the [Column configuration API](/develop/api-reference/data/st.column_config) with a suite of methods to configure the display and editing behavior of `st.dataframe` and `st.data_editor` columns (e.g. their title, visibility, type, or format). Keep an eye out for a detailed [blog post](https://blog.streamlit.io/) and in-depth [documentation](/develop/concepts/design/dataframes#configuring-columns) upcoming in the next two weeks.
- 🔌 Learn to use `st.experimental_connection` to create and manage data connections in your apps with the new [Connecting to data](/develop/concepts/connections/connecting-to-data) docs and [video tutorial](https://www.youtube.com/watch?v=xQwDfW7UHMo).

**Notable Changes**

- 📊 Streamlit now supports Protobuf 4 and Altair 5 ([#6215](https://github.com/streamlit/streamlit/issues/6215), [#6618](https://github.com/streamlit/streamlit/pull/6618), [#5626](https://github.com/streamlit/streamlit/issues/5626), [#6622](https://github.com/streamlit/streamlit/pull/6622)).
- ☎️ st.dataframe and st.data_editor can hide index columns with `hide_index`, specify the display order of columns with `column_order`, and disable editing for individual columns with the `disabled` parameter.
- ⏱️ The `ttl` parameter in [st.cache_data](/develop/api-reference/caching-and-state/st.cache_data) and [st.cache_resource](/develop/api-reference/caching-and-state/st.cache_resource) accepts formatted strings, so you can simply say `ttl="30d"`, `ttl="1h30m"` and any other combination of `w`, `d`, `h`, `m`, `s` supported by [Pandas's Timedelta constructor](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.html) ([#6560](https://github.com/streamlit/streamlit/pull/6560)).
- 📂 `st.file_uploader` now interprets the `type` parameter more accurately. For example, "jpg" or ".jpg" now accept both "jpg" and "jpeg" extensions. This functionality has also been extended to "mpeg/mpg", "tiff/tif", "html/htm", and "mpeg4/mp4".
- 🤫 The new `global.disableWidgetStateDuplicationWarning` configuration option allows the silencing of warnings triggered by setting widget default values and keyed session state values concurrently ([#3605](https://github.com/streamlit/streamlit/issues/3605), [#6640](https://github.com/streamlit/streamlit/pull/6640)). Thanks, [@antonAce](https://github.com/antonAce)!

**Other Changes**

- 🏃‍♀️Improved startup time by lazy loading some dependencies ([#6531](https://github.com/streamlit/streamlit/pull/6531)).
- 👋 Removed `st.beta_*` and `st.experimental_show` due to deprecation and low-use ([#6558](https://github.com/streamlit/streamlit/pull/6558))
- 🚀 Further improvements to st.dataframe and st.data_editor:
  - Improved editing on mobile devices for the data editor ([#6548](https://github.com/streamlit/streamlit/pull/6548)).
  - All editable columns have an icon in their column header and support tooltips ([#6550](https://github.com/streamlit/streamlit/pull/6550), [#6561](https://github.com/streamlit/streamlit/pull/6561)).
  - Enable editing for columns containing datetime, date, or time values ([#6025](https://github.com/streamlit/streamlit/pull/6025)).
  - New input validation options for columns in the data editor, such as `max_chars` and `validate` for text columns, and `min_value`, `max_value` and `step` for number columns ([#6563](https://github.com/streamlit/streamlit/pull/6563)).
  - Improved type parsing capabilities in the data editor ([#6551](https://github.com/streamlit/streamlit/pull/6551)).
  - Unified missing values to `None` in returned data structures ([#6544](https://github.com/streamlit/streamlit/pull/6544)).
  - A warning is shown in cells when integers exceed the maximum safe value of `(2^53) -1` ([#6311](https://github.com/streamlit/streamlit/issues/6311), [#6549](https://github.com/streamlit/streamlit/pull/6549)).
  - Prevented editing the sessions state by showing a warning ([#6634](https://github.com/streamlit/streamlit/pull/6634)).
  - Fixed issues with list columns sometimes breaking the frontend ([#6644](https://github.com/streamlit/streamlit/pull/6644)).
  - Fixed a display issue with index columns using category dtype ([#6680](https://github.com/streamlit/streamlit/issues/6680), [#6598](https://github.com/streamlit/streamlit/pull/6598)).
  - Fixed an issue that prevented a rerun when adding empty rows ([#6598](https://github.com/streamlit/streamlit/pull/6598)).
  - Unified the behavior between `st.data_editor` and `st.dataframe` related to auto-hiding the index column(s) based on the input data ([#6659](https://github.com/streamlit/streamlit/issues/6659), [#6598](https://github.com/streamlit/streamlit/pull/6598))
- 🛡️ Streamlit's [Security Policy](https://github.com/streamlit/streamlit/blob/develop/SECURITY.md) can be found in its GitHub repository ([#6666](https://github.com/streamlit/streamlit/pull/6666)).
- 🤏 Documented the integer size limit for `st.number_input` and `st.slider` ([#6724](https://github.com/streamlit/streamlit/pull/6724)).
- 🐍 The majority of Streamlit's Python dependencies have set a maximum allowable version, with the standard upper limit set to the next major version, but not inclusive of it ([#6691](https://github.com/streamlit/streamlit/pull/6691)).
- 💅 UI design improvements to in-app modals ([#6688](https://github.com/streamlit/streamlit/pull/6688)).
- 🐞 Bug fix: `st.date_input`'s date selector is equally visible in dark mode ([#6072](https://github.com/streamlit/streamlit/issues/6072), [#6630](https://github.com/streamlit/streamlit/pull/6630)).
- 🐜 Bug fix: the sidebar navigation expansion indicator in multipage apps is restored ([#6731](https://github.com/streamlit/streamlit/pull/6731)).
- 🐛 Bug fix: The docstring and exception message for `st.set_page_config` have been updated to clarify that this command can be invoked once for each page within a multipage app, rather than once per entire app ([#6594](https://github.com/streamlit/streamlit/pull/6594)).
- 🐝 Bug fix: `st.json` no longer collapses multiple spaces in both keys and values with single space when rendered ([#6657](https://github.com/streamlit/streamlit/issues/6657), [#6663](https://github.com/streamlit/streamlit/pull/6663)).

## **Version 1.22.0**

_Release date: April 27, 2023_

**Highlights**

- 🔌 Introducing `st.experimental_connection`: Easily connect your app to data sources and APIs using our new connection feature. Find more details in the [API reference](/develop/api-reference/connections), and stay tuned for an upcoming blog post and in-depth documentation! In the meantime, explore our updated [MySQL](/develop/tutorials/databases/mysql) and [Snowflake](/develop/tutorials/databases/snowflake) connection tutorials for examples of this feature.

**Notable Changes**

- 🐼 Streamlit now supports Pandas 2.0 ([#6413](https://github.com/streamlit/streamlit/issues/6413), [#6378](https://github.com/streamlit/streamlit/pull/6378), [#6507](https://github.com/streamlit/streamlit/pull/6507)). Thanks, [connortann](https://github.com/connortann)!
- 🍔 Customize the visibility of items in the toolbar, options menu, and the settings dialog using the `client.toolbarMode` [config option](https://docs.streamlit.io/develop/concepts/configuration#view-all-configuration-options) ([#6174](https://github.com/streamlit/streamlit/pull/6174)).
- 🪵 Streamlit logs now reside in the "streamlit" namespace instead of the root logger, enabling app developers to better manage log handling ([#3978](https://github.com/streamlit/streamlit/issues/3978), [#6377](https://github.com/streamlit/streamlit/pull/6377)).

**Other Changes**

- 🔏 CLI parameters can no longer be used to set sensitive configuration values ([#6376](https://github.com/streamlit/streamlit/pull/6376)).
- 🤖 Improved the debugging experience by reducing log noise ([#6391](https://github.com/streamlit/streamlit/pull/6391)).
- 🐞 Bug fix: `@st.cache_data` decorated functions support UUID objects as parameters ([#6440](https://github.com/streamlit/streamlit/issues/6440), [#6459](https://github.com/streamlit/streamlit/pull/6459)).
- 🐛 Bug fix: Tabbing through buttons and other elements now displays a red border only when focused, not when clicked ([#6373](https://github.com/streamlit/streamlit/pull/6373)).
- 🪲 Bug fix: `st.multiselect`'s clear icon is larger and includes a hover effect ([#6471](https://github.com/streamlit/streamlit/pull/6471)).
- 🐜 Bug fix: Custom theme font settings no longer apply to code blocks ([#6484](https://github.com/streamlit/streamlit/issues/6484), [#6535](https://github.com/streamlit/streamlit/pull/6535)).
- ©️ Bug fix: `st.code`'s copy-to-clipboard button appears when you hover on code blocks ([#6490](https://github.com/streamlit/streamlit/issues/6490), [#6498](https://github.com/streamlit/streamlit/pull/6498)).

## **Version 1.21.0**

_Release date: April 6, 2023_

**Highlights**

- 📏 Introducing `st.divider` — a command that displays a horizontal line in your app. Learn how to use this command in its [API reference](/develop/api-reference/text/st.divider).
- 🔏 Streamlit now supports the use of a global `secrets.toml` file, in addition to a project-level file, to easily store and securely access your secrets. Learn more in [Secrets management](/develop/concepts/connections/secrets-management).
- 🚀 [st.help](/develop/api-reference/utilities/st.help) has been revamped to show more information about object methods, attributes, classes, and more, which is great for debugging ([#5857](https://github.com/streamlit/streamlit/pull/5857), [#6382](https://github.com/streamlit/streamlit/pull/6382))!

**Notable Changes**

- 🪜 [st.time_input](/develop/api-reference/widgets/st.time_input) supports adding a stepping interval with the keyword-only `step` parameter ([#6071](https://github.com/streamlit/streamlit/pull/6071)).
- ❓ Most [text elements](/develop/api-reference/text) can include tooltips with the `help` parameter ([#6043](https://github.com/streamlit/streamlit/pull/6043)).
- ↔️ [st.pyplot](/develop/api-reference/charts/st.pyplot) has a `use_container_width` parameter to set the chart to the container width (now all [chart elements](/develop/api-reference/charts) support this parameter) ([#6067](https://github.com/streamlit/streamlit/pull/6067)).
- 👩‍💻 [st.code](/develop/api-reference/text/st.code) supports optionally displaying line numbers to the code block's left with the boolean `line_numbers` parameter ([#5756](https://github.com/streamlit/streamlit/issues/5756), [#6042](https://github.com/streamlit/streamlit/pull/6042)).
- ⚓ Anchors in header elements can be turned off by setting `anchor=False` ([#6158](https://github.com/streamlit/streamlit/pull/6158)).

**Other Changes**

- 🐼 [st.table](/develop/api-reference/data/st.table) and [st.dataframe](/develop/api-reference/data/st.dataframe) support `pandas.Period`, and number and boolean types in categorical columns ([#2547](https://github.com/streamlit/streamlit/issues/2547), [#5429](https://github.com/streamlit/streamlit/pull/5429), [#5329](https://github.com/streamlit/streamlit/issues/5392), [#6248](https://github.com/streamlit/streamlit/pull/6248)).
- 🕸️ Added `.webp` to the list of allowed static file extensions ([#6331](https://github.com/streamlit/streamlit/pull/6331))
- 🐞 Bug fix: stop script execution on websocket close to immediately clear session information ([#6166](https://github.com/streamlit/streamlit/issues/6166), [#6204](https://github.com/streamlit/streamlit/pull/6204)).
- 🐜 Bug fixes: updated allowed/disallowed label markdown behavior such that unsupported elements are unwrapped and only their children (text contents) render ([#5872](https://github.com/streamlit/streamlit/issues/5872), [#6036](https://github.com/streamlit/streamlit/issues/6036), [#6054](https://github.com/streamlit/streamlit/issues/6054), [#6163](https://github.com/streamlit/streamlit/pull/6163)).
- 🪲 Bug fixes: don't push browser history states on rerun, use HTTPS to load external resources in `streamlit hello`, and make the browser back button work for multipage apps ([#5292](https://github.com/streamlit/streamlit/issues/5292), [#6266](https://github.com/streamlit/streamlit/pull/6266), [#6232](https://github.com/streamlit/streamlit/pull/6232)). Thanks, [whitphx](https://github.com/whitphx)!
- 🐝 Bug fix: avoid showing emoji on non-UTF-8 terminals. ([#2284](https://github.com/streamlit/streamlit/issues/2284), [#6088](https://github.com/streamlit/streamlit/pull/6088)). Thanks, [kcarnold](https://github.com/kcarnold)!
- 📁 Bug fix: override default use of [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API) for `react-dropzone` so that `st.file_uploader`'s File Selection Dialog only shows file types corresponding to those included in the `type` parameter ([#6176](https://github.com/streamlit/streamlit/issues/6176), [#6315](https://github.com/streamlit/streamlit/pull/6315)).
- 💾 Bug fix: make the `.clear()` method on cache-decorated functions work ([#6310](https://github.com/streamlit/streamlit/issues/6310), [#6321](https://github.com/streamlit/streamlit/pull/6321)).
- 🏃 Bug fix: `st.experimental_get_query_params` doesn't need reruns to work ([#6347](https://github.com/streamlit/streamlit/issues/6347), [#6348](https://github.com/streamlit/streamlit/pull/6348)). Thanks, [PaleNeutron](https://github.com/PaleNeutron)!
- 🐛 Bug fix: `CachedStFunctionWarning` mentions `experimental_allow_widgets` instead of the deprecated `suppress_st_warning` ([#6216](https://github.com/streamlit/streamlit/issues/6216), [#6217](https://github.com/streamlit/streamlit/pull/6217)).

## **Version 1.20.0**

_Release date: March 09, 2023_

**Notable Changes**

- 🔐 Added support for configuring SSL to [serve apps directly over HTTPS](/develop/concepts/configuration/https-support) ([#5969](https://github.com/streamlit/streamlit/pull/5969)).
- 🖼️ Granular control over app embedding behavior with the `/?embed` and `/?embed_options` query parameters. Learn how to use this feature in our [docs](/deploy/streamlit-community-cloud/share-your-app/embed-your-app) ([#6011](https://github.com/streamlit/streamlit/pull/6011), [#6019](https://github.com/streamlit/streamlit/pull/6019)).
- ⚡ Enabled the `runner.fastReruns` [configuration option](/develop/concepts/configuration#view-all-configuration-options) by default to make apps much more responsive to user interaction ([#6200](https://github.com/streamlit/streamlit/pull/6200)).

**Other Changes**

- 🍔 Cleaned up the hamburger menu by removing the least used options ([#6080](https://github.com/streamlit/streamlit/pull/6080)).
- 🖨️ Design changes to ensure apps being printed or saved as a PDF look good ([#6180](https://github.com/streamlit/streamlit/pull/6180)).
- 🐞 Bug fix: improved `dtypes` checking in `st.experimental_data_editor` ([#6185](https://github.com/streamlit/streamlit/issues/6185), [#6188](https://github.com/streamlit/streamlit/pull/6188)).
- 🐛 Bug fix: properly position `st.metric`'s `help` tooltip when not inside columns ([#6168](https://github.com/streamlit/streamlit/pull/6168)).
- 🪲 Bug fix: regression in retrieving messages from the server's `ForwardMsgCache` ([#6210](https://github.com/streamlit/streamlit/pull/6210)).
- 🌀 Bug fix: `st.cache_data` docstring for the `show_spinner` param now lists `str` as a supported type ([#6207](https://github.com/streamlit/streamlit/issues/6207), [#6213](https://github.com/streamlit/streamlit/pull/6213)).
- ⏱️ Made ping and websocket timeouts far more forgiving ([#6212](https://github.com/streamlit/streamlit/pull/6212)).
- 🗺️ `st.map` and `st.pydeck_chart` docs state that Streamlit's Mapbox token will not work indefinitely ([#6143](https://github.com/streamlit/streamlit/pull/6143)).

## **Version 1.19.0**

_Release date: February 23, 2023_

**Highlights**

- ✂️ Introducing `st.experimental_data_editor`, a widget that allows you to edit DataFrames and many other data structures in a table-like UI. Read more in our [documentation](/develop/concepts/design/dataframes) and [blog post](https://blog.streamlit.io/editable-dataframes-are-here/).

**Other Changes**

- ✨ Streamlit's GitHub README got a new look ([#6016](https://github.com/streamlit/streamlit/pull/6016)).
- 🌚 Improved readability of styled dataframe cells in dark mode ([#6060](https://github.com/streamlit/streamlit/issues/6060), [#6098](https://github.com/streamlit/streamlit/pull/6098)).
- 🐛 Bug fix: make apps work again in the latest versions of Safari, and in Chrome with third-party cookies blocked ([#6092](https://github.com/streamlit/streamlit/issues/6092), [#6094](https://github.com/streamlit/streamlit/pull/6094), [#6087](https://github.com/streamlit/streamlit/issues/6087), [#6100](https://github.com/streamlit/streamlit/pull/6100)).
- 🐞 Bug fix: refer to new cache primitives in the "Clear cache" dialog and error messages ([#6082](https://github.com/streamlit/streamlit/pull/6082), [#6128](https://github.com/streamlit/streamlit/pull/6128)).
- 🐝 Bug fix: properly cache class member functions and instance methods ([#6109](https://github.com/streamlit/streamlit/issues/6109), [#6114](https://github.com/streamlit/streamlit/pull/6114)).
- 🐜 Bug fix: regression in `st.metric` tooltip position ([#6093](https://github.com/streamlit/streamlit/issues/6093), [#6129](https://github.com/streamlit/streamlit/pull/6129)).
- 🪲 Bug fix: allow fullscreen button to show for dataframes, charts, etc, in expander ([#6083](https://github.com/streamlit/streamlit/pull/6083), [#6148](https://github.com/streamlit/streamlit/pull/6148)).

## **Version 1.18.0**

_Release date: February 09, 2023_

**Highlights**

- 🎊 Introducing `@st.cache_data` and `@st.cache_resource` — two new caching commands to replace `st.cache`! Check out our [blog post](https://blog.streamlit.io/p/c0a90231-9848-47ec-a40c-ad4a344e4de1/) and [documentation](/develop/concepts/architecture/caching) for more information.

**Notable Changes**

- 🪆 `st.columns` supports up to one level of column nesting (i.e., columns inside columns) in the main area of the app.
- ⏳ `st.progress` supports adding a message to display above the progress bar with the `text` keyword parameter.
- ↔️ `st.button` has an optional `use_container_width` parameter to allow you to stretch buttons across the full container width.
- 🐍 We formally added support for Python 3.11.
- 🖨️ Save your app as a PDF via the "Print" option in your app's hamburger menu.
- 🛎️ Apps can serve small, static media files via the `enableStaticServing` config option. See our [documentation](/develop/concepts/configuration/serving-static-files) on how to use this feature and our demo [app](https://static-file-serving.streamlit.app/) for an example.

**Other Changes**

- 🏁 All Streamlit endpoints (including `/healthz`) have been renamed to have a consistent pattern and avoid any clashes with reserved endpoints of GCP (notably Cloud Run and App Engine) ([#5534](https://github.com/streamlit/streamlit/pull/5534)).
- ⚡ Improved caching performance when multiple sessions access an uncomputed cached value simultaneously ([#6017](https://github.com/streamlit/streamlit/pull/6017)).
- 🚧 Streamlit only displays deprecation warnings in the browser when the `client.showErrorDetails` config option is set to `True`. Deprecation warnings always get logged to the console, regardless of whether they're displayed in-browser ([#5945](https://github.com/streamlit/streamlit/pull/5945)).
- 🏓 Refactored the `st.dataframe` internals to improve dataframe handling and conversion, such as detecting more types, converting key-value dicts to dataframes, and more ([#6026](https://github.com/streamlit/streamlit/pull/6026), [#6023](https://github.com/streamlit/streamlit/pull/6023)).
- 💽 The behavior of widget labels when they are passed unsupported Markdown elements is documented ([#5978](https://github.com/streamlit/streamlit/pull/5978)).
- 📊 Bug fix: Plotly improvements — upgraded multiple frontend dependencies, including Plotly, to the latest version to properly redraw cached charts, make Plotly mapbox animations work, and allow users to update the figure layout when using the Streamlit theme ([#5885](https://github.com/streamlit/streamlit/pull/5885), [#5967](https://github.com/streamlit/streamlit/pull/5967), [#6055](https://github.com/streamlit/streamlit/pull/6055)).
- 📶 Bug fix: allow browser tabs that transiently disconnect (due to a network blip, load balancer timeout, etc.) to avoid losing all of their state ([#5856](https://github.com/streamlit/streamlit/pull/5856)).
- 📱 Bug fix: the keyboard is hidden on mobile when `st.selectbox` and `st.multiselect` have less than 10 options ([#5979](https://github.com/streamlit/streamlit/pull/5979)).
- 🐝 Bug fix: design tweaks to `st.metric`, `st.multiselect`, `st.tabs` , and menu items to prevent label overflow and scrolling issues, especially with small viewport sizes ([#5933](https://github.com/streamlit/streamlit/pull/5933), [#6034](https://github.com/streamlit/streamlit/pull/6034)).
- 🐞 Bug fix: switched to a functioning Twemoji URL from which page favicons are loaded in `st.set_page_config` ([#5943](https://github.com/streamlit/streamlit/pull/5943)).
- ✍️ More type hints ([#5986](https://github.com/streamlit/streamlit/pull/5986)). Thanks, [harahu](https://github.com/harahu)!

## **Version 1.17.0**

_Release date: January 12, 2023_

**Notable Changes**

- 🪄 [`@st.experimental_singleton`](/develop/api-reference/caching-and-state/st.experimental_singleton#validating-the-cache) supports an optional `validate` parameter that accepts a validation function for cached data and is called each time the cached value is accessed.
- 💾  [`@st.experimental_memo`](/develop/api-reference/caching-and-state/st.experimental_memo)'s `persist` parameter can also accept booleans.

**Other Changes**

- 📟 Multipage apps exclude `__init__.py` from the page selector ([#5890](https://github.com/streamlit/streamlit/pull/5890)).
- 📐 The iframes of embedded apps have the ability to dynamically resize their height ([#5894](https://github.com/streamlit/streamlit/pull/5894)).
- 🐞 Bug fix: thumb values of range sliders respect the container width ([#5913](https://github.com/streamlit/streamlit/pull/5913)).
- 🪲 Bug fix: all examples in docstrings of Streamlit commands contain relevant imports to make them reproducible ([#5877](https://github.com/streamlit/streamlit/pull/5877)).

---

# 2024 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2024


This page contains release notes for Streamlit versions released in 2024. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## **Version 1.41.0**

_Release date: December 10, 2024_

**Notable Changes**

- 🔲 [`st.metric`](/develop/api-reference/data/st.metric) and [`st.columns`](/develop/api-reference/layout/st.columns) have a parameter to show an optional border ([#9927](https://github.com/streamlit/streamlit/pull/9927), [#9928](https://github.com/streamlit/streamlit/pull/9928)).
- 🎨 Text and background color in [Markdown](/develop/api-reference/text/st.markdown) can use the "primary" color from the `theme.primaryColor` configuration option ([#9676](https://github.com/streamlit/streamlit/pull/9676)).
- 🥶 You can freeze columns with [column configuration](/develop/api-reference/data/st.column_config) to make them always visible when scrolling horizontally ([#9535](https://github.com/streamlit/streamlit/pull/9535), [#7078](https://github.com/streamlit/streamlit/issues/7078)).
- 3️⃣ The `type` parameter for [buttons](/develop/api-reference/widgets/st.button) accepts a new option, `"tertiary"` ([#9923](https://github.com/streamlit/streamlit/pull/9923)).
- 🚶‍♂️ Streamlit supports `pathlib.Path` objects everywhere you can use a string path ([#9711](https://github.com/streamlit/streamlit/pull/9711), [#9783](https://github.com/streamlit/streamlit/pull/9783)).
- ⏱️ [`st.date_input`](/develop/api-reference/widgets/st.date_input) and [`st.time_input`](/develop/api-reference/widgets/st.time_input) accept ISO formatted strings for initial values ([#9753](https://github.com/streamlit/streamlit/pull/9753)).
- 💬 [`st.write_stream`](/develop/api-reference/write-magic/st.write_stream) accepts async generators, which it converts internally to sync generators ([#8724](https://github.com/streamlit/streamlit/pull/8724), [#8161](https://github.com/streamlit/streamlit/issues/8161)).
- 🪵 The [`client.showErrorDetails`](/develop/api-reference/configuration/config.toml#client) configuration option has additional values to show or hide more information ([#9909](https://github.com/streamlit/streamlit/pull/9909)).
- 🔎 When Streamlit shows stack traces in the app for uncaught exceptions, internal code is omitted or reduced for easier debugging ([#9913](https://github.com/streamlit/streamlit/pull/9913)).
- 📈 [`st.line_chart`](/develop/api-reference/charts/st.line_chart) shows tooltips for the nearest point on hover ([#9674](https://github.com/streamlit/streamlit/pull/9674)).
- 🌐 [`st.html`](/develop/api-reference/utilities/st.html) will attempt to convert non-string objects with `._repr_html_()` before falling back to `str()` ([#9877](https://github.com/streamlit/streamlit/pull/9877)).
- 🐍 Streamlit supports Python 3.13 and no longer supports Python 3.8 ([#9635](https://github.com/streamlit/streamlit/pull/9635)).

**Other Changes**

- 🔣 Material Symbols have been updated with the latest icons ([#9813](https://github.com/streamlit/streamlit/pull/9813), [#9810](https://github.com/streamlit/streamlit/issues/9810)).
- 👽 Streamlit supports Watchdog version 6 ([#9785](https://github.com/streamlit/streamlit/pull/9785)). Thanks, [RubenVanEldik](https://github.com/RubenVanEldik).
- 🌀 Bug fix: Streamlit only shows cached function spinners on cache misses and doesn't show spinners for nested cached functions ([#9956](https://github.com/streamlit/streamlit/pull/9956), [#9951](https://github.com/streamlit/streamlit/issues/9951)).
- 🔈 Bug fix: Streamlit's audio buffer handles channels better to correctly play audio recordings in Firefox ([#9885](https://github.com/streamlit/streamlit/pull/9885), [#9799](https://github.com/streamlit/streamlit/issues/9799)).
- 🦊 Bug fix: URL patterns are matched correctly to allow Community Cloud developer tools to display correctly in Firefox ([#9849](https://github.com/streamlit/streamlit/pull/9849), [#9848](https://github.com/streamlit/streamlit/issues/9848)).
- ☠️ Bug fix: Corrected a performance and alignment problem with containers ([#9901](https://github.com/streamlit/streamlit/pull/9901), [#9456](https://github.com/streamlit/streamlit/issues/9456), [#9560](https://github.com/streamlit/streamlit/issues/9560)).
- 👻 Bug fix: `st.rerun` will raise an error if an invalid `scope` is passed to it ([#9911](https://github.com/streamlit/streamlit/pull/9911), [#9908](https://github.com/streamlit/streamlit/issues/9908)).
- 🦋 Bug fix: Dataframe toolbars show correctly in dialogs ([#9897](https://github.com/streamlit/streamlit/pull/9897), [#9461](https://github.com/streamlit/streamlit/issues/9461)).
- 🦀 Bug fix: `LinkColumn` regex for `display_text` uses the correct URI decoding ([#9895](https://github.com/streamlit/streamlit/pull/9895), [#9893](https://github.com/streamlit/streamlit/issues/9893)).
- 🦎 Bug fix: `st.dataframe` has correct type hinting when `on_selection="ignore"` ([#9898](https://github.com/streamlit/streamlit/pull/9898), [#9669](https://github.com/streamlit/streamlit/issues/9669)).
- 🐌 Bug fix: Padding is applied consistently for wide and centered layout mode ([#9882](https://github.com/streamlit/streamlit/pull/9882), [#9707](https://github.com/streamlit/streamlit/issues/9707)).
- 🕸️ Bug fix: `st.graphviz_chart` is displayed correctly when `use_container_width=True` ([#9867](https://github.com/streamlit/streamlit/pull/9867), [#9866](https://github.com/streamlit/streamlit/issues/9866)).
- 🦗 Bug fix: The overloaded definitions of `st.pills` and `st.segmented_control` use the correct selection-mode default ([#9801](https://github.com/streamlit/streamlit/pull/9801)). Thanks, [RubenVanEldik](https://github.com/RubenVanEldik)!
- 🦂 Bug fix: `st.text_area` (and other widgets) are correctly submitted in a form when using `Ctrl+Enter` ([#9847](https://github.com/streamlit/streamlit/pull/9847), [#9841](https://github.com/streamlit/streamlit/issues/9841)).
- 🦟 Bug Fix: `st.write` renders `DeltaGenerator` objects with [`st.help`](http://st.help) ([#9828](https://github.com/streamlit/streamlit/pull/9828), [#9827](https://github.com/streamlit/streamlit/issues/9827)).
- 🦠 Bug fix: `st.text_area` correctly matches the value in Session State when used with a key ([#9829](https://github.com/streamlit/streamlit/pull/9829), [#9825](https://github.com/streamlit/streamlit/issues/9825)).
- 🪰 Bug fix: `st.text_input` does not trigger a rerun when a user submits an unchanged value ([#9826](https://github.com/streamlit/streamlit/pull/9826)).
- 🪳 Bug fix: Improved styling for `st.exception` to fix overflow and incorrect padding ([#9818](https://github.com/streamlit/streamlit/pull/9818), [#9817](https://github.com/streamlit/streamlit/issues/9817), [#9816](https://github.com/streamlit/streamlit/issues/9816)).
- 🕷️ Bug fix: Large dataframe don't overflow and cover the dataframe toolbar in fullscreen mode ([#9803](https://github.com/streamlit/streamlit/pull/9803), [#9798](https://github.com/streamlit/streamlit/issues/9798)).
- 🐞 Bug fix: `st.audio_input` shows the correct time on recording in time zones with a half-hour offset ([#9791](https://github.com/streamlit/streamlit/pull/9791), [#9631](https://github.com/streamlit/streamlit/issues/9631)).
- 🐝 Bug fix: In iOS, `st.number_input` shows a number pad instead of a keyboard when in focus ([#9766](https://github.com/streamlit/streamlit/pull/9766), [#9763](https://github.com/streamlit/streamlit/issues/9763)).
- 🐜 Bug fix: Widget keys containing hyphens are correctly added to HTML classes in the DOM with an `st-key-` prefix ([#9793](https://github.com/streamlit/streamlit/pull/9793)).
- 🪲 Bug fix: Audio files created by `st.audio_input` include a timestamp to ensure unique file names ([#9768](https://github.com/streamlit/streamlit/pull/9768)).
- 🐛 Bug fix: Double slash URL pathnames do not create a 301 redirect ([#9754](https://github.com/streamlit/streamlit/pull/9754), [#9690](https://github.com/streamlit/streamlit/issues/9690)).

## **Version 1.40.0**

_Release date: November 6, 2024_

**Highlights**

- 💊 Introducing [`st.pills`](/develop/api-reference/widgets/st.pills) to create a single- or multi-select group of pill-buttons.
- 🎛️ Introducing [`st.segmented_control`](/develop/api-reference/widgets/st.segmented_control) to create a segmented button or button group.
- 🎤 Announcing the general availability of [`st.audio_input`](), a widget to let users record sound with their microphones.

**Notable Changes**

- ➡️ Markdown renders a limited set of typographical symbols (arrows and comparators).
- <img src="/logo.svg">{{ display: "inline-block", width: "1em" }} /&gt; You can use `:streamlit:` to render the Streamlit logo in [Markdown](/develop/api-reference/text/st.markdown).
- 🐍 [`st.text`](/develop/api-reference/text/st.text) wraps text and no longer uses monospace font.
- 🪣 You can set `use_container_width` for [`st.image`](/develop/api-reference/media/st.image). `use_column_width` is deprecated.
- 📅 [`st.date_input`](/develop/api-reference/widgets/st.date_input) infers the first day of the week from the user’s locale ([#9706](https://github.com/streamlit/streamlit/pull/9706), [#5215](https://github.com/streamlit/streamlit/issues/5215)).

**Other Changes**

- 🎶 Streamlit’s CLI tool accepts array values for configuration options ([#9577](https://github.com/streamlit/streamlit/pull/9577)).
- ⛓️ Static file serving supports symlinks ([#9147](https://github.com/streamlit/streamlit/pull/9147), [#9146](https://github.com/streamlit/streamlit/issues/9146)). Thanks, [link89](https://github.com/link89)!
- 🚀 Streamlit provides helpful links for deployment when an app is running locally ([#9681](https://github.com/streamlit/streamlit/pull/9681)).
- ↕️ The fullscreen button for charts matches with the dataframe toolbar ([#9721](https://github.com/streamlit/streamlit/pull/9721)).
- 🏃 The running-man icon has a brief delay before rendering to avoid an unnecessary flicker for fast running apps ([#9732](https://github.com/streamlit/streamlit/pull/9732)).
- 🖇️ The `ComponentRequestHandler` allows symlinks ([#9588](https://github.com/streamlit/streamlit/pull/9588)).
- 👆 Streamlit works with `pillow` version 11 ([#9742](https://github.com/streamlit/streamlit/pull/9742)). Thanks, [hauntsaninja](https://github.com/hauntsaninja)!
- 🗺️ Deck.gl was upgraded to version 9.0.33 ([#9636](https://github.com/streamlit/streamlit/pull/9636)).
- 🦠 Bug fix: `st.latex` stays center-aligned when using the `help` keyword argument ([#9698](https://github.com/streamlit/streamlit/pull/9698), [#9682](https://github.com/streamlit/streamlit/issues/9682)). Thanks, [emmagarr](https://github.com/emmagarr)!
- 🪰 Bug fix: Apps correctly access local storage on Android ([#9744](https://github.com/streamlit/streamlit/pull/9744), [#9740](https://github.com/streamlit/streamlit/issues/9740)).
- 🕷️ Bug fix: Cached class methods can be cleared ([#9642](https://github.com/streamlit/streamlit/pull/9642), [#9633](https://github.com/streamlit/streamlit/issues/9633)).
- 🐞 Bug fix: Streamlit clears fragment auto-reruns when a user changes pages. This prevents an invalid index ([#9617](https://github.com/streamlit/streamlit/pull/9617)).
- 🐝 Bug fix: `st.page_link` margins are correct ([#9625](https://github.com/streamlit/streamlit/pull/9625)).
- 🐜 Bug fix: Form widgets show submission instructions when in focus ([#9576](https://github.com/streamlit/streamlit/pull/9576), [#7079](https://github.com/streamlit/streamlit/issues/7079)).
- 🪲 Bug fix: `st.navigation` correctly reconciles `client.showSidebarNavigation` ([#9589](https://github.com/streamlit/streamlit/pull/9589), [#9581](https://github.com/streamlit/streamlit/issues/9581)).
- 🐛 Bug fix: `st.text_area` requires a minimum height of 68px which fits two lines ([#9561](https://github.com/streamlit/streamlit/pull/9561), [#9217](https://github.com/streamlit/streamlit/issues/9217)).
- 💅 Bug fix: Various styling fixes ([#9529](https://github.com/streamlit/streamlit/pull/9529), [#8131](https://github.com/streamlit/streamlit/issues/8131), [#9555](https://github.com/streamlit/streamlit/pull/9555), [#9496](https://github.com/streamlit/streamlit/issues/9496), [#9554](https://github.com/streamlit/streamlit/pull/9554), [#9349](https://github.com/streamlit/streamlit/issues/9349), [#7739](https://github.com/streamlit/streamlit/issues/7739)).

## **Version 1.39.0**

_Release date: October 1, 2024_

**Highlights**

- 🎤 Introducing [`st.experimental_audio_input`](/develop/api-reference/widgets/st.audio_input) to let users record with their microphones!
- 📍 [`st.pydeck_chart`](/develop/api-reference/charts/st.pydeck_chart#chart-selections) can return selection events!

**Notable Changes**

- 😃 [`st.button`](/develop/api-reference/widgets/st.button), [`st.download_button`](/develop/api-reference/widgets/st.download_button), [`st.form_submit_button`](/develop/api-reference/execution-flow/st.form_submit_button), [`st.link_button`](/develop/api-reference/widgets/st.link_button), and [`st.popover`](/develop/api-reference/layout/st.popover) each have a new parameter to add an icon.
- 🏢 [`st.logo`](/develop/api-reference/media/st.logo) has a new parameter to adjust the size of your logo.
- 🧭 [`st.navigation`](/develop/api-reference/navigation/st.navigation) lets you display an always-expanded or collapsible menu using a new `expanded` parameter.
- ↕️ You can set `height` and `width` for [`st.map`](/develop/api-reference/charts/st.map) and [`st.pydeck_chart`](/develop/api-reference/charts/st.pydeck_chart).
- ↩️ Form submission behavior can be configured with a new `enter_to_submit` parameter ([#9480](https://github.com/streamlit/streamlit/pull/9480), [#7538](https://github.com/streamlit/streamlit/issues/7538), [#9406](https://github.com/streamlit/streamlit/pull/9406), [#8042](https://github.com/streamlit/streamlit/issues/8042)).
- ⏱️ A new config option, `server.disconnectedSessionTTL`, lets you set a minimum time before a disconnected session is cleaned up ([#9179](https://github.com/streamlit/streamlit/pull/9179)).
- 🤹 Dataframes support multi-index headers ([#9483](https://github.com/streamlit/streamlit/pull/9483), [#6319](https://github.com/streamlit/streamlit/issues/6319)).

**Other Changes**

- 🔑 Widget keys appear as HTML classes in the DOM with an `st-key-` prefix ([#9295](https://github.com/streamlit/streamlit/pull/9295), [#5437](https://github.com/streamlit/streamlit/issues/5437), [#3888](https://github.com/streamlit/streamlit/issues/3888)).
- 🔍 The `StreamlitAPIException` class has been extended into more specific exceptions for some of the most common errors ([#9318](https://github.com/streamlit/streamlit/pull/9318)).
- 🗺️ `st.map` and `st.pydeck_chart` have a full-screen toggle that matches the dataframe toolbar.
- ⬆️ Frontend dependencies for Vega have been upgraded ([#9443](https://github.com/streamlit/streamlit/pull/9443), [#9438](https://github.com/streamlit/streamlit/issues/9438)).
- 🕵️ Streamlit is compatible with Watchdog version 5 ([#9354](https://github.com/streamlit/streamlit/pull/9354)). Thanks, [RubenVanEldik](https://github.com/RubenVanEldik)!
- 🔁 Streamlit is compatible with Tenacity version 9 ([#9348](https://github.com/streamlit/streamlit/pull/9348)).
- 🔢 Bug fix: Column configuration will override any text or number format from `pandas.Styler` ([#9538](https://github.com/streamlit/streamlit/pull/9538), [#7329](https://github.com/streamlit/streamlit/issues/7329), [#7977](https://github.com/streamlit/streamlit/issues/7977)).
- 🦋 Bug fix: Deck GL zoom button has the correct border radius ([#9536](https://github.com/streamlit/streamlit/pull/9536)).
- 🦐 Bug fix: Embedded apps have the correct padding to avoid hiding elements ([#9524](https://github.com/streamlit/streamlit/pull/9524), [#9341](https://github.com/streamlit/streamlit/issues/9341)).
- 🎨 Bug fix: The `st.multiselect` placeholder text has the correct color ([#9523](https://github.com/streamlit/streamlit/pull/9523), [#9514](https://github.com/streamlit/streamlit/issues/9514)).
- 🧹 Bug fix: `st.json` scrolls horizontally instead of overflowing its container ([#9521](https://github.com/streamlit/streamlit/pull/9521), [#9520](https://github.com/streamlit/streamlit/issues/9520)).
- 🌬️ Bug fix: Bokeh charts (temporarily) don't have a fullscreen button to prevent horizontal scrolling ([#9528](https://github.com/streamlit/streamlit/pull/9528), [#2358](https://github.com/streamlit/streamlit/issues/2358)).
- 🐡 Bug fix: Users are correctly redirected if they add a trailing slash to a page URL ([#9500](https://github.com/streamlit/streamlit/pull/9500), [#9127](https://github.com/streamlit/streamlit/issues/9127)).
- 📁 Bug fix: `st.Page` warns developers against using subdirectories in `url_path`, which is not supported ([#9499](https://github.com/streamlit/streamlit/pull/9499)).
- 💩 Bug fix: Streamlit correctly calculates dataframe widths to prevent Minified React error #185: Maximum update depth exceeded ([#9490](https://github.com/streamlit/streamlit/pull/9490), [#7949](https://github.com/streamlit/streamlit/issues/7949)).
- ☠️ Bug fix: ScriptRunContext handles the active script hash to avoid a race condition where widgets lose state in a multipage app ([#9441](https://github.com/streamlit/streamlit/pull/9441), [#9100](https://github.com/streamlit/streamlit/issues/9100)).
- 🪱 Bug fix: PDFs don't appear as plain text when hosted through static file serving in Streamlit ([#9439](https://github.com/streamlit/streamlit/pull/9439), [#9425](https://github.com/streamlit/streamlit/issues/9425)).
- 👻 Bug fix: Fragment elements don't disappear when used with custom components and callbacks ([#9381](https://github.com/streamlit/streamlit/pull/9381), [#9389](https://github.com/streamlit/streamlit/pull/9389), [#9372](https://github.com/streamlit/streamlit/issues/9372)).
- 👽 Bug fix: Streamlit watches the correct directory for file changes ([#9453](https://github.com/streamlit/streamlit/pull/9453), [#7467](https://github.com/streamlit/streamlit/issues/7467)).
- 🦀 Bug fix: The sidebar navigation uses page count to determine when to display a "show more" button for more consistent behavior ([#9394](https://github.com/streamlit/streamlit/pull/9394)).
- 🦎 Bug fix: The internal script hash is updated at the beginning of a script run instead of the end for correct page routing when a script run is interrupted ([#9408](https://github.com/streamlit/streamlit/pull/9408), [#8975](https://github.com/streamlit/streamlit/issues/8975)).
- 🐌 Bug fix: Bold formatting in headers is ignored ([#9395](https://github.com/streamlit/streamlit/pull/9395), [#4248](https://github.com/streamlit/streamlit/issues/4428)).
- 🕸️ Bug fix: Streamlit correctly identifies the MIME type of more files to prevent custom components from not rendering ([#9390](https://github.com/streamlit/streamlit/pull/9390), [#9365](https://github.com/streamlit/streamlit/issues/9365)). Thanks, [t0mdavid-m](https://github.com/t0mdavid-m)!
- 🦗 Bug fix: The `client.showSidebarNavigation` configuration option works correctly with `st.navigation` ([#9379](https://github.com/streamlit/streamlit/pull/9379)).
- 🦂 Bug fix: Streamlit uses `example.com` instead of `test.com` in a health check to avoid unnecessary warnings ([#9371](https://github.com/streamlit/streamlit/pull/9371)). Thanks, [wyattscarpenter](https://github.com/wyattscarpenter)!
- 🦟 Bug fix: `st.Page` will raise an error if it tries to initialize a page with an empty path ([#9374](https://github.com/streamlit/streamlit/pull/9374), [#8892](https://github.com/streamlit/streamlit/issues/8892)).
- 🦠 Bug fix: An unchanged `st.dialog` can be programmatically reopened after a user has dismissed it ([#9333](https://github.com/streamlit/streamlit/pull/9333), [#9323](https://github.com/streamlit/streamlit/issues/9323)).
- 🪰 Bug fix: Streamlit will not remove underscores from declared page titles in `st.Page` ([#9375](https://github.com/streamlit/streamlit/pull/9375), [#8890](https://github.com/streamlit/streamlit/issues/8890)).
- 🪳 Bug fix: `st.logo` does not flicker when switching pages ([#9361](https://github.com/streamlit/streamlit/pull/9361), [#8815](https://github.com/streamlit/streamlit/issues/8815)).
- 🕷️ Bug fix: `st.data_editor` allows users to re-add a row with the same index after deleting it ([#8864](https://github.com/streamlit/streamlit/pull/8864), [#8854](https://github.com/streamlit/streamlit/issues/8854)).
- 🐞 Bug fix: `st.logo` maintains its aspect ratio when resized to fit within the sidebar width ([#9368](https://github.com/streamlit/streamlit/pull/9368)).
- 🐝 Bug fix: Streamlit correctly removes `st.logo` if not called during a rerun ([#9337](https://github.com/streamlit/streamlit/pull/9337), [#9336](https://github.com/streamlit/streamlit/issues/9336)).
- 🐜 Bug fix: `st.logo` does not flicker when the sidebar changes its state ([#9338](https://github.com/streamlit/streamlit/pull/9338)).
- 🪲 Bug fix: Streamlit renders `st.balloons` and `st.snow` in a React Portal for improved rendering and compatibility with `st.dialog` ([#9335](https://github.com/streamlit/streamlit/pull/9335), [#9236](https://github.com/streamlit/streamlit/issues/9236)).
- 🐛 Bug fix: Option labels are cleanly truncated when `st.multiselect` is displayed in a narrow container ([#9334](https://github.com/streamlit/streamlit/pull/9334), [#8213](https://github.com/streamlit/streamlit/issues/8213)).

## **Version 1.38.0**

_Release date: August 27, 2024_

**Highlights**

- 📈 Streamlit natively supports more dataframe formats! Use dataframe and series objects from popular libraries like Dask, Modin, Numpy, pandas, Polars, PyArrow, Snowpark, Xarray, and more. Use database cursors compliant with the Python Database API Specification 2.0. Use anything that supports the Python dataframe interchange protocol. See the [docs](/develop/api-reference/data/st.dataframe).

**Notable Changes**

- ↔️ You can control the initial expansion state of [`st.json`](/develop/api-reference/data/st.json) elements.
- 🧑‍💻 You can choose to wrap lines in [`st.code`](/develop/api-reference/text/st.code).
- 🕵️ Streamlit supports Kubernetes style secrets so you can use Snowflake Snowpark Container Services secret format ([#9078](https://github.com/streamlit/streamlit/pull/9078)).
- ⤴️ Breaking change: We removed a patch that allows custom validators in `pydantic</img>

---

# 2025 release notes

Source: https://docs.streamlit.io/develop/quick-reference/release-notes/2025


This page contains release notes for Streamlit versions released in 2025. For the latest version of Streamlit, see [Release notes](/develop/quick-reference/release-notes).

## **Version 1.52.0**

_Release date: December 3, 2025_

**Highlights**

- 📅 Introducing [`st.datetime_input`](/develop/api-reference/widgets/st.datetime_input) to set date and time in a single widget.
- 📩 To avoid blocking your script, you can pass a callable to [`st.download_button`](/develop/api-reference/widgets/st.download_button) for on-demand download generation ([#12942](https://github.com/streamlit/streamlit/pull/12942), [#5053](https://github.com/streamlit/streamlit/issues/5053)).
- 🎤 [`st.chat_input`](/develop/api-reference/chat/st.chat_input) can optionally accept audio input ([#12836](https://github.com/streamlit/streamlit/pull/12836), [#13054](https://github.com/streamlit/streamlit/pull/13054)).

**Notable Changes**

- 🎹 You can configure keyboard shortcuts for [buttons](/develop/api-reference/widgets/st.button) ([#12975](https://github.com/streamlit/streamlit/pull/12975), [#1291](https://github.com/streamlit/streamlit/issues/1291)).
- ❓ You can now pass query parameters to [`st.switch_page`](/develop/api-reference/navigation/st.switch_page) and [`st.page_link`](/develop/api-reference/widgets/st.page_link) ([#13027](https://github.com/streamlit/streamlit/pull/13027), [#8102](https://github.com/streamlit/streamlit/issues/8102), [#8112](https://github.com/streamlit/streamlit/issues/8112), [#13093](https://github.com/streamlit/streamlit/pull/13093)).
- 〰️ [`st.html`](/develop/api-reference/text/st.html) has a new `unsafe_allow_javascript` parameter to execute JavaScript ([#12918](https://github.com/streamlit/streamlit/pull/12918)).
- ⬆️ [`st.metric`](/develop/api-reference/data/st.metric) has a new `delta_arrow` parameter to configure the visibility and orientation of the delta arrow ([#12982](https://github.com/streamlit/streamlit/pull/12982), [#4775](https://github.com/streamlit/streamlit/issues/4775)).
- ⌨️ You can configure the horizontal alignment of [`st.markdown`](/develop/api-reference/text/st.markdown), `st.caption`, `st.title`, `st.header`, `st.subheader`, and `st.text` with a new `text_alignment` parameter ([#13032](https://github.com/streamlit/streamlit/pull/13032), [#4109](https://github.com/streamlit/streamlit/issues/4109), [#13034](https://github.com/streamlit/streamlit/pull/13034), [#13036](https://github.com/streamlit/streamlit/pull/13036)).
- 🌀 You can use a spinner everywhere you can set an `icon` and in the `avatar` parameter of [`st.chat_message`](/develop/api-reference/chat/st.chat_message). The spinner can't be used as a page favicon ([#13045](https://github.com/streamlit/streamlit/pull/13045), [#6415](https://github.com/streamlit/streamlit/issues/6415)).
- 🛠️ You can now add tooltips to [`st.badge`](/develop/api-reference/text/st.badge) ([#12897](https://github.com/streamlit/streamlit/pull/12897), [#12878](https://github.com/streamlit/streamlit/issues/12878)). Thanks, [marcolanfranchi](https://github.com/marcolanfranchi)!
- 🕳️ You can configure placeholder text for null values in [`st.dataframe`](/develop/api-reference/data/st.dataframe) and [`st.data_editor`](/develop/api-reference/data/st.data_editor) with a new `placeholder` parameter ([#12968](https://github.com/streamlit/streamlit/pull/12968), [#7360](https://github.com/streamlit/streamlit/issues/7360)).
- 🔑 To prevent widgets from resetting when you change a parameter, widgets are transitioning to an identity based only on their keys (if provided). The following widgets use only their key for their identity:
  - `st.file_uploader`
  - `st.camera_input`
- ↕️ `st.plotly_chart` has a height parameter to use with flex containers ([#12593](https://github.com/streamlit/streamlit/pull/12593)).
- ↔️ `st.container`, `st.dataframe`, and `st.data_editor` support `width="content"` ([#12848](https://github.com/streamlit/streamlit/pull/12848), [#12875](https://github.com/streamlit/streamlit/pull/12875), [#12391](https://github.com/streamlit/streamlit/issues/12391)).
- 🐍 Streamlit supports Python 3.14 and Vega-Altair 6!
- 👻 `st.bokeh_chart` has been removed. Use the `streamlit-bokeh` custom component instead.
- ☠️ `**kwargs` is deprecated in `st.vega_lite_chart` ([#13141](https://github.com/streamlit/streamlit/pull/13141)).
- 💩 The `.add_rows()` method is under consideration for removal. Please leave feedback ([#13063](https://github.com/streamlit/streamlit/issues/13063)).
- 👥 We're improving community contributions by using a public workflow for discussing feature specs ([#12248](https://github.com/streamlit/streamlit/pull/12248)).

**Other Changes**

- 🪥 For better performance, Streamlit uses `uvloop` if it's installed ([#13047](https://github.com/streamlit/streamlit/pull/13047)).
- 🧼 For improved performance, Markdown plugins are lazy loaded ([#13152](https://github.com/streamlit/streamlit/pull/13152)).
- 🧽 To improve load times, we reduced the bundle size ([#13071](https://github.com/streamlit/streamlit/pull/13071), [#13077](https://github.com/streamlit/streamlit/pull/13077), [#13099](https://github.com/streamlit/streamlit/pull/13099), [#13115](https://github.com/streamlit/streamlit/pull/13115), [#13128](https://github.com/streamlit/streamlit/pull/13128)).
- 🛁 To improve performance, we've refactored session context data ([#12788](https://github.com/streamlit/streamlit/pull/12788), [#12789](https://github.com/streamlit/streamlit/pull/12789), [#12790](https://github.com/streamlit/streamlit/pull/12790), [#12791](https://github.com/streamlit/streamlit/pull/12791)).
- 🚿 The hovering performance of `st.line_chart` was improved ([#13156](https://github.com/streamlit/streamlit/pull/13156), [#13154](https://github.com/streamlit/streamlit/issues/13154)).
- 🧹 `st.metric` was optimized to prevent poor hovering performance with large data sets ([#12983](https://github.com/streamlit/streamlit/pull/12983)).
- 👽 The `packaging` Python dependency is no longer version-capped ([#13073](https://github.com/streamlit/streamlit/pull/13073)).
- 🫥 For clarity, Streamlit logs a warning if you try to hide a non-range index when using `st.data_editor` with `num_rows="dynamic"`. A non-range index must be editable to add rows ([#12978](https://github.com/streamlit/streamlit/pull/12978), [#8263](https://github.com/streamlit/streamlit/issues/8263)).
- 🦋 Bug fix: Streamlit auth raises a warning instead of an error when browser back navigation revisits a consumed OAuth callback ([#13127](https://github.com/streamlit/streamlit/pull/13127), [#13101](https://github.com/streamlit/streamlit/issues/13101)).
- 🦀 Bug fix: The WebSocket timeout was increased on Android to improve `st.file_uploader` performance ([#13132](https://github.com/streamlit/streamlit/pull/13132), [#11419](https://github.com/streamlit/streamlit/issues/11419)).
- 🦎 Bug fix: Query parameters are preserved when using browser back and forward navigation ([#13129](https://github.com/streamlit/streamlit/pull/13129), [#9279](https://github.com/streamlit/streamlit/issues/9279)).
- 🐌 Bug fix: For custom components v2, the frontend key is correctly computed to be stable if it has a key in Python and otherwise change when its parameters change ([#12950](https://github.com/streamlit/streamlit/pull/12950)).
- 🕸️ Bug fix: Empty code blocks in Markdown don't display "undefined" ([#13074](https://github.com/streamlit/streamlit/pull/13074), [#12986](https://github.com/streamlit/streamlit/issues/12986)). Thanks, [ashm-dev](https://github.com/ashm-dev)!
- 🦗 Bug fix: `st.feedback` is prevented from wrapping ([#12970](https://github.com/streamlit/streamlit/pull/12970), [#12068](https://github.com/streamlit/streamlit/issues/12068)).
- 🦂 Bug fix: Custom components v2 don't raise a warning when placeholders are replaced as a result of the initial manifest scan ([#13043](https://github.com/streamlit/streamlit/pull/13043), [#13042](https://github.com/streamlit/streamlit/issues/13042)).
- 🦟 Bug fix: `st.audio_input` has the correct padding for its waveform ([#13010](https://github.com/streamlit/streamlit/pull/13010)).
- 🦠 Bug fix: The date and time icons in `st.data_editor` are visible in dark mode ([#12994](https://github.com/streamlit/streamlit/pull/12994), [#12852](https://github.com/streamlit/streamlit/issues/12852)). Thanks, [aritradhabal](https://github.com/aritradhabal)!
- 🪰 Bug fix: `st.pills` and `st.segmented_control` wrap correctly when `width="content"` ([#12969](https://github.com/streamlit/streamlit/pull/12969), [#12067](https://github.com/streamlit/streamlit/issues/12067), [#12879](https://github.com/streamlit/streamlit/pull/12879), [#12857](https://github.com/streamlit/streamlit/issues/12857)).
- 🪳 Bug fix: `st.color_picker` has a minimum width to prevent a pixel width below its intrinsic size ([#12962](https://github.com/streamlit/streamlit/pull/12962), [#12872](https://github.com/streamlit/streamlit/issues/12872)).
- 🕷️ Bug fix: Disabled widgets hide their borders ([#12949](https://github.com/streamlit/streamlit/pull/12949)).
- 🐞 `st.audio_input` and `st.chat_input` show a clearer message when microphone permissions are insufficient ([#12914](https://github.com/streamlit/streamlit/pull/12914)).
- 🐝 Bug fix: `st.navigation` uses the sidebar font and Streamlit falls back to its built-in fonts if a font can't be found ([#12948](https://github.com/streamlit/streamlit/pull/12948)).
- 🐜 Bug fix: `MultiselectColumn` doesn't raise a `ValueError` when adding new rows in `st.data_editor` ([#12860](https://github.com/streamlit/streamlit/pull/12860), [#12936](https://github.com/streamlit/streamlit/pull/12936), [#12815](https://github.com/streamlit/streamlit/issues/12815)). Thanks, [kkchemboli](https://github.com/kkchemboli)!
- 🪲 Bug fix: `MultiselectColumn` works correctly when the underlying dataframe has an empty column ([#12935](https://github.com/streamlit/streamlit/pull/12935), [#12842](https://github.com/streamlit/streamlit/issues/12842)).
- 🐛 Bug fix: `st.text_area` avoids negative height calculations that produce invalid CSS ([#12891](https://github.com/streamlit/streamlit/pull/12891), [#12867](https://github.com/streamlit/streamlit/issues/12867)).

## **Version 1.51.0**

_Release date: October 29, 2025_

**Highlights**

- 🧩 Announcing [custom components](/develop/api-reference/custom-components/st.components.v2.component), version 2! Easily create frameless custom UI with bidirectional data flow.
- 🌗 Introducing custom [light and dark theme](/develop/concepts/configuration/theming) configuration! You can simultaneously define custom light and dark themes in your app.
- 🎨 Announcing [reusable themes](/develop/api-reference/configuration/config.toml#theme)! You can define a theme in a sharable file and use it as a base in other themes.
- 💫 Introducing [`st.space`](/develop/api-reference/layout/st.space) for adding vertical and horizontal spaces in your app.

**Notable Changes**

- 🔗 New configuration options, `theme.codeTextColor` and `theme.linkColor`, let you configure the color of code and link text.
- 📊 [`ProgressColumn`](/develop/api-reference/data/st.column_config/st.column_config.progresscolumn) has a new `color` parameter.
- 🌈 You can set `color="auto"` in [`MultiselectColumn`](/develop/api-reference/data/st.column_config/st.column_config.multiselectcolumn) to inherit colors from `theme.chartCategoricalColors`.
- 📌 `MultiselectColumn` has a `pinned` parameter to match other column types.
- ⭐ You can set a `default` value for [`st.feedback`](/develop/api-reference/widgets/st.feedback) ([#12578](https://github.com/streamlit/streamlit/pull/12578), [#9469](https://github.com/streamlit/streamlit/issues/9469)). Thanks, [andreasntr](https://github.com/andreasntr)!
- 👆 [`st.write_stream`](/develop/api-reference/write-magic/st.write_stream) has a `cursor` parameter to set a custom cursor for the typewriter effect.
- 🍿 [`st.popover`](/develop/api-reference/layout/st.popover) has a `type` parameter to match `st.button` styling options.
- 🔑 To prevent widgets from resetting when you change a parameter, widgets are transitioning to an identity based only on their keys (if provided). The following widgets use only their key for their identity:
  - `st.color_picker`
  - `st.segmented_control`
  - `st.radio`
  - `st.audio_input`
  - `st.slider`
  - `st.select_slider`
  - `st.chat_input`
  - `st.feedback`
  - `st.pills`
- ↕️ `st.dataframe`, `st.data_editor`, `st.altair_chart`, `st.pydeck_chart`, and all simple charts have height parameters to use with flex containers.
- ↔️ `st.plotly_chart`, `st.vega_lite_chart`, `st.altair_chart`, `st.pydeck_chart`, and all simple charts have width parameters to use with flex containers.
- 🐍 Due to end of life, Python 3.9 is no longer supported.

**Other Changes**

- ⚡ If you don't pass a file to `streamlit run`, it will try `streamlit_app.py` by default ([#12599](https://github.com/streamlit/streamlit/pull/12599)).
- 🥷 `st.dataframe` hides its index column by default when row selections are enabled ([#12448](https://github.com/streamlit/streamlit/pull/12448), [#12237](https://github.com/streamlit/streamlit/issues/12237)). Thanks, [plumol](https://github.com/plumol)!
- 👩‍🎨 For compatibility with new theming options, the app settings menu no longer supports theme editing ([#12648](https://github.com/streamlit/streamlit/pull/12648)).
- 👋 The Streamlit hello app preloads its Python packages on its home page for a faster user experience ([#12617](https://github.com/streamlit/streamlit/pull/12617)).
- 👍 Slider thumbs don't extend beyond the edge of their track ([#12549](https://github.com/streamlit/streamlit/pull/12549), [#4284](https://github.com/streamlit/streamlit/issues/4284)).
- ℹ️ Material icons and emojis were updated ([#12669](https://github.com/streamlit/streamlit/pull/12669)).
- 🦠 Bug fix: Pyplot charts render correctly in fragments, containers, and expanders ([#12807](https://github.com/streamlit/streamlit/pull/12807), [#12678](https://github.com/streamlit/streamlit/issues/12678), [#12763](https://github.com/streamlit/streamlit/issues/12763)).
- 🪰 Bug fix: Dataframes correctly resize and align when using `width="content"` ([#12682](https://github.com/streamlit/streamlit/pull/12682)).
- 🪳 Bug fix: Fuzzy search in select boxes is case insensitive ([#12849](https://github.com/streamlit/streamlit/pull/12849), [#11724](https://github.com/streamlit/streamlit/issues/11724)).
- 🕷️ Bug fix: 500 errors display correctly ([#12845](https://github.com/streamlit/streamlit/pull/12845)).
- 🐞 Bug fix: Deprecation warnings respect `client.showErrorDetails` ([#12794](https://github.com/streamlit/streamlit/pull/12794), [#12743](https://github.com/streamlit/streamlit/issues/12743)).
- 🐝 Bug fix: Path handling in the file watcher was improved to prevent a `ValueError` in Windows environments ([#12741](https://github.com/streamlit/streamlit/pull/12741), [#12731](https://github.com/streamlit/streamlit/issues/12731)).
- 🐜 Bug fix: `st.pills` shows its value when disabled ([#12555](https://github.com/streamlit/streamlit/pull/12555), [#12388](https://github.com/streamlit/streamlit/issues/12388)). Thanks, [davidsjoberg1](https://github.com/davidsjoberg1)!
- 🪲 Bug fix: Plotly charts hide overflow to prevent flickering behavior from scrollbars [(#12594](https://github.com/streamlit/streamlit/pull/12594)).
- 🐛 Bug fix: Streamlit's handling of Altair charts was improved for thread safety and prevention of an "Unrecognized data set" race condition ([#12673](https://github.com/streamlit/streamlit/pull/12673), [#11911](https://github.com/streamlit/streamlit/pull/11911), [#11342](https://github.com/streamlit/streamlit/issues/11342), [#11906](https://github.com/streamlit/streamlit/issues/11906)).

## **Version 1.50.0**

_Release date: September 23, 2025_

**Highlights**

- 🤹 Introducing [`MultiselectColumn`](/develop/api-reference/data/st.column_config/st.column_config.multiselectcolumn) to configure colorful, editable lists in your dataframes.
- 🎨 Announcing [color palette](/develop/concepts/configuration/theming-customize-colors-and-borders#basic-color-palette) configuration options to set the exact shade of red, orange, yellow, green, blue, violet, and grey to use in Markdown, status elements, sparklines, `st.metric`, and `st.badge`.
- 📊 [`st.bar_chart`](/develop/api-reference/charts/st.bar_chart) has a new `sort` parameter for conveniently sorting your bars.

**Notable Changes**

- 🔑 To prevent widgets from resetting when you change a parameter, widgets are transitioning to an identity based only on their keys (if provided). The following widgets use only their key for their identity:
  - `st.button`
  - `st.download_button`
  - `st.form_submit_button`
  - `st.checkbox`
  - `st.toggle`
  - `st.text_area`
  - `st.text_input`
  - `st.number_input`
  - `st.time_input`
  - `st.date_input`
  - `st.selectbox`
  - `st.multiselect`
  - Custom components
- 🖌️ You can configure the color of [chart columns](/develop/api-reference/data/st.column_config/st.column_config.areachartcolumn).
- 🔢 [`st.metric`](/develop/api-reference/data/st.metric) supports `decimal.Decimal` types ([#12377](https://github.com/streamlit/streamlit/pull/12377), [#12308](https://github.com/streamlit/streamlit/issues/12308)). Thanks, [aebrahim](https://github.com/aebrahim)!
- 🎤 You can specify the sample rate for [`st.audio_input`](/develop/api-reference/widgets/st.audio_input), and the default sample rate has been reduced to 16000 Hz.
- ⚙️ For clarity, in [`st.plotly_chart`](/develop/api-reference/charts/st.plotly_chart), `**kwargs` is deprecated and replaced by `config` ([#12291](https://github.com/streamlit/streamlit/pull/12291), [#12280](https://github.com/streamlit/streamlit/issues/12280)). Thanks, [zyfy29](https://github.com/zyfy29)!
- 📈 [`st.line_chart`](/develop/api-reference/charts/st.line_chart) and [`st.graphviz_chart`](/develop/api-reference/charts/st.graphviz_chart) have `width` parameters to use with flex containers.
- 🔲 You can configure [`st.table`](/develop/api-reference/data/st.table) borders to show all, only horizontal, or no lines.
- 📂 You can specify a default tab in [`st.tabs`](/develop/api-reference/layout/st.tabs).
- 🌐 To use hosted fonts from providers like Google and Adobe, you can declare externally hosted fonts with a URL to their CSS file in `theme.font`, `theme.headingFont`, and `theme.codeFont`.

**Other Changes**

- 🧹 `**kwargs` has been removed from `st.write` ([#12375](https://github.com/streamlit/streamlit/pull/12375), [#12374](https://github.com/streamlit/streamlit/issues/12374)).
- ⏱️ To prevent browser defaults from invalidating caches too soon, cache headers include the `max-age` and `immutable` directives ([#12420](https://github.com/streamlit/streamlit/pull/12420)).
- 👽 Material icons were updated ([#12473](https://github.com/streamlit/streamlit/pull/12473), [#12535](https://github.com/streamlit/streamlit/pull/12535)).
- 🦋 Visual tweaks ([#12348](https://github.com/streamlit/streamlit/pull/12348), [#12367](https://github.com/streamlit/streamlit/pull/12367)).
- 👻 Bug fix: To correct a sequential navigation regression for `st.number_input`, some internal refactoring was reverted ([#12547](https://github.com/streamlit/streamlit/pull/12547), [#12526](https://github.com/streamlit/streamlit/issues/12526)).
- 🦀 Bug fix: Custom components respect zero-size dimensions ([#12479](https://github.com/streamlit/streamlit/pull/12479), [#12454](https://github.com/streamlit/streamlit/issues/12454)).
- 🦎 Bug fix: Images respect center alignment in containers ([#12495](https://github.com/streamlit/streamlit/pull/12495), [#12435](https://github.com/streamlit/streamlit/issues/12435)).
- 🐌 Bug fix: If you use an empty string as a section label in top navigation, those pages will display individually before the collapsible sections ([#12247](https://github.com/streamlit/streamlit/pull/12247), [#12243](https://github.com/streamlit/streamlit/issues/12243)).
- 🕸️ Bug fix: To fix a performance regression, dataframes use `.iat[]` instead of `.iloc[]` internally ([#12422](https://github.com/streamlit/streamlit/pull/12422), [#10952](https://github.com/streamlit/streamlit/issues/10952)).
- 🦗 Bug fix: `st.data_editor` accepts Shift+Enter for multiline entry in a cell ([#12401](https://github.com/streamlit/streamlit/pull/12401), [#12386](https://github.com/streamlit/streamlit/issues/12386)).
- 🦂 Bug fix: To make `st.pdf` more compatible on Windows, MIME types were updated ([#12399](https://github.com/streamlit/streamlit/pull/12399), [#12387](https://github.com/streamlit/streamlit/issues/12387)). Thanks, [geoextra](https://github.com/geoextra)!
- 🦟 Bug fix: To prevent long-word overflow, words are forced to break if they exceed their container's width ([#12370](https://github.com/streamlit/streamlit/pull/12370), [#12366](https://github.com/streamlit/streamlit/issues/12366)).
- 🦠 Bug fix: Hiding all dataframe columns won't raise a TypeError ([#12361](https://github.com/streamlit/streamlit/pull/12361), [#12227](https://github.com/streamlit/streamlit/issues/12227)).
- 🪰 Bug fix: `st.logo` doesn't dislocate the sidebar collapse button ([#12329](https://github.com/streamlit/streamlit/pull/12329), [#12326](https://github.com/streamlit/streamlit/issues/12326)).
- 🪳 Bug fix: When using `accept_new_options=True` with `st.multiselect`, mobile users can access their keyboards ([#12330](https://github.com/streamlit/streamlit/pull/12330)).
- 🕷️ Bug fix: `st.components.v1.html` ignores fractional pixels in `width` ([#12354](https://github.com/streamlit/streamlit/pull/12354), [#12340](https://github.com/streamlit/streamlit/issues/12340)).
- 🐞 Bug fix: `st.number_input` correctly accepts keyed entries ([#12351](https://github.com/streamlit/streamlit/pull/12351), [#12349](https://github.com/streamlit/streamlit/issues/12349)).
- 🐝 Bug fix: Markdown images maintain their aspect ratio when constrained ([#12343](https://github.com/streamlit/streamlit/pull/12343)).
- 🐜 Bug fix: `st.date_input` is inclusive of min and max values ([#12295](https://github.com/streamlit/streamlit/pull/12295), [#12293](https://github.com/streamlit/streamlit/issues/12293)).
- 🪲 Bug fix: Maintain image proportions in fullscreen mode for all width settings ([#12235](https://github.com/streamlit/streamlit/pull/12235)).
- 🐛 Bug fix: Markdown code blocks don't overflow when used in labels ([#12175](https://github.com/streamlit/streamlit/pull/12175), [#12149](https://github.com/streamlit/streamlit/issues/12149)).

## **Version 1.49.0**

_Release date: August 26, 2025_

**Highlights**

- 📄 Introducing [`st.pdf`](/develop/api-reference/media/st.pdf) to beautifully render PDF documents in your app!
- ⛏️ Dataframes support [cell selections](/develop/api-reference/data/st.dataframe#dataframeselectionstate)!
- ✨ You can add sparklines to [`st.metric`](/develop/api-reference/data/st.metric)!
- ✏️ [`ListColumn`](/develop/api-reference/data/st.column_config/st.column_config.listcolumn) is now editable!
- 📂 Users can upload a directory of files with [`st.file_uploader`](/develop/api-reference/widgets/st.file_uploader) or [`st.chat_input`](/develop/api-reference/chat/st.chat_input).

**Notable Changes**

- 🏷️ You can configure the labels of options in [`SelectboxColumn`](/develop/api-reference/data/st.column_config/st.column_config.selectboxcolumn) with a new `format_func` parameter ([#12232](https://github.com/streamlit/streamlit/pull/12232), [#6795](https://github.com/streamlit/streamlit/issues/6795)).
- 🍞 You can configure the duration of [`st.toast`](/develop/api-reference/status/st.toast) messages ([#11872](https://github.com/streamlit/streamlit/pull/11872), [#7047](https://github.com/streamlit/streamlit/issues/7047)).
- 🔑 [`st.form_submit_button`](/develop/api-reference/execution-flow/st.form_submit_button) has a `key` parameter ([#12190](https://github.com/streamlit/streamlit/pull/12190), [#12121](https://github.com/streamlit/streamlit/issues/12121)).
- 🌻 [Markdown](/develop/api-reference/text/st.markdown) and heading dividers can be yellow ([#12201](https://github.com/streamlit/streamlit/pull/12201)).
- 💬 [`st.dialog`](/develop/api-reference/execution-flow/st.dialog) widths have a larger option ([#12040](https://github.com/streamlit/streamlit/pull/12040), [#8904](https://github.com/streamlit/streamlit/issues/8904)).
- 💻 `st.dataframe` and `st.data_editor` have `width` and `height` to use with flex layouts ([#11930](https://github.com/streamlit/streamlit/pull/11930)).
- 🖼️ `st.image`, `st.pyplot`, and `st.graphviz_chart` have a `width` parameter to use them with flex layouts ([#11952](https://github.com/streamlit/streamlit/pull/11952), [#12212](https://github.com/streamlit/streamlit/pull/12212)).
- 📈 Users can access the underlying data of a Vega chart through the toolbar. This includes all data passed to the chart, even if it's not displayed ([#10311](https://github.com/streamlit/streamlit/pull/10311)).
- ☠️ `st.bokeh_chart` is deprecated. Use the [`streamlit-bokeh`](https://github.com/streamlit/streamlit-bokeh) custom component instead.
- 🧹 We removed deprecated commands and parameters: `st.experimental_dialog`, `st.experimental_fragment`, and caching's `experimental_allow_widgets` ([#12167](https://github.com/streamlit/streamlit/pull/12167)).

**Other Changes**

- 🏃‍♂️ For better performance, `st.slider` will not rerun the app until the user releases the slider thumb ([#11879](https://github.com/streamlit/streamlit/pull/11879), [#4541](https://github.com/streamlit/streamlit/issues/4541)).
- 💅 For improved custom theming, single mark charts use the first categorical chart color ([#12162](https://github.com/streamlit/streamlit/pull/12162)).
- 🌐 For `st.logo`, the `crossorigin` property can be configured by hosts ([#12226](https://github.com/streamlit/streamlit/pull/12226)).
- 🎨 The colored decoration line at the top of Streamlit apps was removed ([#12155](https://github.com/streamlit/streamlit/pull/12155)).
- 👻 The copy-to-clipboard function of multiple elements gives a checkmark feedback to users when they copy something ([#12141](https://github.com/streamlit/streamlit/pull/12141), [#12172](https://github.com/streamlit/streamlit/pull/12172)).
- 🫥 Users can quickly hide or unhide all columns in a dataframe ([#12164](https://github.com/streamlit/streamlit/pull/12164), [#12082](https://github.com/streamlit/streamlit/issues/12082)). Thanks, [plumol](https://github.com/plumol)!
- ℹ️ Material icons were updated ([#12264](https://github.com/streamlit/streamlit/pull/12264)).
- 👽 Bug fix: `CheckboxColumn` uses the radii from the theming configuration options ([#12263](https://github.com/streamlit/streamlit/pull/12263)).
- 🦀 Bug fix: A column's menu is not accessible when the column is hidden ([#12233](https://github.com/streamlit/streamlit/pull/12233), [#12230](https://github.com/streamlit/streamlit/issues/12230)). Thanks, [plumol](https://github.com/plumol)!
- 🦋 Bug fix: Streamlit correctly caches Pydantic models ([#12137](https://github.com/streamlit/streamlit/pull/12137), [#10348](https://github.com/streamlit/streamlit/issues/10348)).
- 🦎 Bug fix: `st.plotly_chart` correctly handles null selections ([#12222](https://github.com/streamlit/streamlit/pull/12222), [#12191](https://github.com/streamlit/streamlit/issues/12191)).
- 🐌 Bug fix: When using `accept_new_options=True` with `st.selectbox`, mobile users can access their keyboards ([#12219](https://github.com/streamlit/streamlit/pull/12219), [#12205](https://github.com/streamlit/streamlit/issues/12205)).
- 🕸️ Bug fix: Streamlit does not raise an error when the user's email is empty and `server.showEmailPrompt` is false ([#12202](https://github.com/streamlit/streamlit/pull/12202), [#12166](https://github.com/streamlit/streamlit/issues/12166)). Thanks, [wyattscarpenter](https://github.com/wyattscarpenter)!
- 🦗 Bug fix: The drop area of `st.file_uploader` correctly truncates a long list of file types ([#12192](https://github.com/streamlit/streamlit/pull/12192), [#12189](https://github.com/streamlit/streamlit/issues/12189)).
- 🦂 Bug fix: The corner radius of `st.page_link` matches the navigation widget instead of the border radius configured for buttons ([#12181](https://github.com/streamlit/streamlit/pull/12181)).
- 🦟 Bug fix: Cached replay correctly handles element height and width for flex layouts ([#12183](https://github.com/streamlit/streamlit/pull/12183)).
- 🦠 Bug fix: When a client disconnects from a Streamlit server and the user dismisses the warning, the client will re-raise the warning while the app remains disconnected ([#12178](https://github.com/streamlit/streamlit/pull/12178), [#12113](https://github.com/streamlit/streamlit/issues/12113)).
- 🪰 Bug fix: Identity provider logout was reverted to prevent redirect failures in `st.logout()` ([#12179](https://github.com/streamlit/streamlit/pull/12179)).
- 🪳 Bug fix: Currency symbols in column configuration are narrowly formatted ([#11895](https://github.com/streamlit/streamlit/pull/11895)).
- 🕷️ Bug fix: Users can't remove files from `st.file_uploader` while the widget is disabled ([#12180](https://github.com/streamlit/streamlit/pull/12180), [#12146](https://github.com/streamlit/streamlit/issues/12146)).
- 🐞 Bug fix: `pip install` works correctly in Windows ([#8952](https://github.com/streamlit/streamlit/pull/8952)). Thanks, [Dev-iL](https://github.com/Dev-iL)!
- 🐝 Bug fix: The drop-down menu for `st.time_input` uses theme colors consistently with other elements ([#12157](https://github.com/streamlit/streamlit/pull/12157)).
- 🐜 Bug fix: `st.toast` uses custom theme colors ([#12160](https://github.com/streamlit/streamlit/pull/12160), [#11951](https://github.com/streamlit/streamlit/issues/11951)).
- 🪲 Bug fix: The width handling of custom components was updated to work with horizontal containers ([#12148](https://github.com/streamlit/streamlit/pull/12148)).
- 🐛 Bug fix: `st.chat_input` correctly resizes itself after the user submits a long message ([#12132](https://github.com/streamlit/streamlit/pull/12132), [#12079](https://github.com/streamlit/streamlit/issues/12079)).

## **Version 1.48.0**

_Release date: August 5, 2025_

**Highlights**

- 💪 Announcing horizontal flex [containers](/develop/api-reference/layout/st.container)! Configure the alignment, direction, and gap of containers to create dynamic layouts.

**Notable Changes**

- 🪵 [`st.logout`](/develop/api-reference/user/st.logout) will log the user out of their identity provider if the server metadata includes `end_session_endpoint` ([#11901](https://github.com/streamlit/streamlit/pull/11901), [#11900](https://github.com/streamlit/streamlit/issues/11900)). Thanks, [velochy](https://github.com/velochy)!
- 💬 You can configure the dismissibility of [`st.dialog`](/develop/api-reference/execution-flow/st.dialog) and set callback functions ([#9504](https://github.com/streamlit/streamlit/pull/9504), [#12034](https://github.com/streamlit/streamlit/pull/12034)). Thanks, [souvikmaji](https://github.com/souvikmaji)!
- ↔️ You can set a `width` parameter for [buttons](/develop/api-reference/widgets/st.button) and [popovers](/develop/api-reference/layout/st.popover).
- 🧑‍💻 [`codeFontWeight`](/develop/api-reference/configuration/config.toml#sidebar-theme) can be configured separately in the sidebar.
- 📶 You can configure the WebSocket ping interval with the [`server.websocketPingInterval`](/develop/api-reference/configuration/config.toml#server) configuration option ([#12117](https://github.com/streamlit/streamlit/pull/12117), [#12108](https://github.com/streamlit/streamlit/issues/12108)).

**Other Changes**

- 🌀 The spinner design was unified across Streamlit commands ([#12031](https://github.com/streamlit/streamlit/pull/12031)).
- 💅 Design and style tweaks ([#12032](https://github.com/streamlit/streamlit/pull/12032), [#11989](https://github.com/streamlit/streamlit/pull/11989), [#11986](https://github.com/streamlit/streamlit/pull/11986), [#11999](https://github.com/streamlit/streamlit/pull/11999), [#12015](https://github.com/streamlit/streamlit/pull/12015), [#11995](https://github.com/streamlit/streamlit/pull/11995), [#11981](https://github.com/streamlit/streamlit/pull/11981), [#11964](https://github.com/streamlit/streamlit/pull/11964)).
- 🔄 Error logic and logging was improved to reduce confusion from `asyncio` runtime errors when unrelated errors are raised ([#12008](https://github.com/streamlit/streamlit/pull/12008)).
- 🪧 Dataframe column menus include an icon to show the column type and a button to copy the column name ([#11303](https://github.com/streamlit/streamlit/pull/11303)).
- 💽 For convenience, there are additional "extras" installation options ([#11760](https://github.com/streamlit/streamlit/pull/11760), [#8233](https://github.com/streamlit/streamlit/issues/8233)).
- 📁 Additional checks are performed to validate the extension of uploaded files, but app developers are still responsible for checking and handling the security of uploaded files ([#11884](https://github.com/streamlit/streamlit/pull/11884), [#11883](https://github.com/streamlit/streamlit/issues/11883)).
- 🔘 Button group widgets are identified by their command name in error messages ([#11769](https://github.com/streamlit/streamlit/pull/11769), [#11753](https://github.com/streamlit/streamlit/issues/11753)). Thanks, [bajajku](https://github.com/bajajku)!
- ⚔️ For `st.snow`, `st.balloons`, chat avatars, and media elements, the `crossorigin` property can be configured by hosts ([#12087](https://github.com/streamlit/streamlit/pull/12087), [#11948](https://github.com/streamlit/streamlit/pull/11948)).
- 🦗 Bug fix: Ctrl+C will stop a Streamlit server in Windows, even if there is no active session ([#12049](https://github.com/streamlit/streamlit/pull/12049), [#6855](https://github.com/streamlit/streamlit/issues/6855)).
- 🦂 Bug fix: `st.line_chart` uses the column order in the chart data instead of reordering them alphabetically ([#12092](https://github.com/streamlit/streamlit/pull/12092), [#12071](https://github.com/streamlit/streamlit/issues/12071)).
- 🦟 Bug fix: Menu items set in `st.set_page_config` are not hidden when `client.toolbarMode` is set to `"minimal"` ([#12091](https://github.com/streamlit/streamlit/pull/12091), [#12083](https://github.com/streamlit/streamlit/issues/12083)).
- 🦠 Bug fix: `theme.codeFontWeight` does not interfere with bold inline code ([#12074](https://github.com/streamlit/streamlit/pull/12074), [#11976](https://github.com/streamlit/streamlit/issues/11976)).
- 🪰 Bug fix: To allow fractional pixel values, heading font sizes in theming configuration aren't rounded ([#12077](https://github.com/streamlit/streamlit/pull/12077), [#11963](https://github.com/streamlit/streamlit/issues/11963)).
- 🪳 Bug fix: Altair 5.4.0 and 5.4.1 have been excluded to prevent an upstream bug with reading dataframes ([#12066](https://github.com/streamlit/streamlit/pull/12066), [#12064](https://github.com/streamlit/streamlit/issues/12064)).
- 🕷️ Bug fix: Dataframe scrollbars have been tweaked to avoid sizing problems ([#11936](https://github.com/streamlit/streamlit/pull/11936), [#11921](https://github.com/streamlit/streamlit/issues/11921), [#12053](https://github.com/streamlit/streamlit/issues/12053), [#11985](https://github.com/streamlit/streamlit/issues/11985)).
- 🐞 Bug fix: Linting accepts lists in addition to tuples for callback arguments in widgets ([#12039](https://github.com/streamlit/streamlit/pull/12039)).
- 🐝 Bug fix: To fix a deprecation warning, Altair theme syntax was updated ([#12050](https://github.com/streamlit/streamlit/pull/12050)).
- 🐜 Bug fix: `st.navigation` does not hide the menu when a single section is used with `position="top"` ([#12025](https://github.com/streamlit/streamlit/pull/12025), [#12029](https://github.com/streamlit/streamlit/issues/12029)).
- 🪲 Bug fix: The sidebar state does not reset when the window is resized ([#12024](https://github.com/streamlit/streamlit/pull/12024), [#12016](https://github.com/streamlit/streamlit/issues/12016)).
- 🐛 Bug fix: `st.pills` and `st.segmented_control` don't raise unintended `StreamlitDuplicateElementId` errors ([#11982](https://github.com/streamlit/streamlit/pull/11982), [#11975](https://github.com/streamlit/streamlit/issues/11975)).

## **Version 1.47.0**

_Release date: July 16, 2025_

**Highlights**

- 🎨 Streamlit has additional [theming configuration](/develop/api-reference/configuration/config.toml#theme) options!
  - `theme.baseFontWeight`: Set the root font weight of text in the app.
  - `theme.chartCategoricalColors`: Configure default categorical colors for Plotly, Altair, and Vega-Lite charts.
  - `theme.chartSequentialColors`: Configure default sequential colors for Plotly, Altair, and Vega-Lite charts.
  - `theme.codeFontWeight`: Set the font weight of code text.
  - `theme.dataframeHeaderBackgroundColor`: Set the background color of dataframe headers.
  - `theme.headingFontSizes`: Set the font sizes of headings.
  - `theme.headingFontWeights`: Set the font weights of headings.
  - `theme.linkUnderline`: Configure whether to underline links.

**Notable Changes**

- 💬 You can set the unsubmitted value of [`st.chat_input`](/develop/api-reference/chat/st.chat_input) through Session State ([#10175](https://github.com/streamlit/streamlit/pull/10175), [#7166](https://github.com/streamlit/streamlit/issues/7166)).
- ↔️ You can set a `width` parameter for [`st.html`](/develop/api-reference/text/st.html), [`st.feedback`](/develop/api-reference/widgets/st.feedback), [`st.pills`](/develop/api-reference/widgets/st.pills), [`st.segmented_control`](/develop/api-reference/widgets/st.segmented_control), and [`st.multiselect`](/develop/api-reference/widgets/st.multiselect).
- ↕️ You can set a `height` parameter for [`st.metric`](/develop/api-reference/data/st.metric) and [`st.text_area`](/develop/api-reference/widgets/st.text_area).
- 👩‍💻 [`st.code`](/develop/api-reference/text/st.code) and [`st.form`](/develop/api-reference/execution-flow/st.form) can have `height="stretch"`.
- 🧑‍💻 [`st.code`](/develop/api-reference/text/st.code) can have `width="content"`.
- ⏱️ You can show the elapsed time with the spinner for cached functions using the `show_time` parameter ([#11469](https://github.com/streamlit/streamlit/pull/11469), [#10647](https://github.com/streamlit/streamlit/issues/10647)). Thanks, [Darkace01](https://github.com/Darkace01)!
- `server.showEmailPrompt` lets you configure whether to show the email prompt (for locally running apps).
- 💾 [`NumberColumn`](/develop/api-reference/data/st.column_config/st.column_config.numbercolumn) and [`ProgressColumn`](/develop/api-reference/data/st.column_config/st.column_config.progresscolumn) support `"bytes"` as a predefined format ([#11288](https://github.com/streamlit/streamlit/pull/11288), [#11287](https://github.com/streamlit/streamlit/issues/11287)). Thanks, [cgivre](https://github.com/cgivre)!
- ⚙️ Column configuration accepts pixel widths for columns ([#11838](https://github.com/streamlit/streamlit/pull/11838)).
- ℹ️ The `display_text` parameter of [`LinkColumn`](/develop/api-reference/data/st.column_config/st.column_config.linkcolumn) accepts a Material icon ([#11690](https://github.com/streamlit/streamlit/pull/11690), [#7004](https://github.com/streamlit/streamlit/issues/7004)).
- 🖊️ The `title` parameter of [`st.dialog`](/develop/api-reference/execution-flow/st.dialog) accepts Markdown ([#11763](https://github.com/streamlit/streamlit/pull/11763), [#11755](https://github.com/streamlit/streamlit/issues/11755)).
- 🧩 To support proxying requests for custom components, in [`declare_component`](/develop/api-reference/custom-components/st.components.v1.declare_component), you can set both `url` and `path` ([#11698](https://github.com/streamlit/streamlit/pull/11698)).

**Other Changes**

- 🧭 Section labels in the sidebar navigation widget are collapsible ([#11863](https://github.com/streamlit/streamlit/pull/11863)).
- 📂 The "Deploy" button is hidden when the "File change" notification is visible in the app chrome ([#11834](https://github.com/streamlit/streamlit/pull/11834)).
- 🔝 When using top navigation in an app, the header has more padding ([#11836](https://github.com/streamlit/streamlit/pull/11836)).
- 🪜 In `NumberColumn`, the precision from `step` will override the display precision from `format`, unless `format` is a printf string ([#11835](https://github.com/streamlit/streamlit/pull/11835)).
- 📅 When `st.date_input` accepts a date range, the widget displays a quick-select option below the calendar for common date ranges ([#10166](https://github.com/streamlit/streamlit/pull/10166), [#11108](https://github.com/streamlit/streamlit/issues/11108)).
- 🏋️ Dataframes support font weight defined in `pandas` `Styler` objects ([#11705](https://github.com/streamlit/streamlit/pull/11705), [#6461](https://github.com/streamlit/streamlit/issues/6461)).
- 🫥 The about dialog does not show by default in the app menu. The current Streamlit version is displayed in the settings dialog ([#10091](https://github.com/streamlit/streamlit/pull/10091)).
- 💅 `st.metric` uses a background color for the delta value, like `st.badge` ([#11678](https://github.com/streamlit/streamlit/pull/11678)).
- 💻 IDEs can give type hints for `.clear()` on cached functions ([#11793](https://github.com/streamlit/streamlit/pull/11793), [#11821](https://github.com/streamlit/streamlit/pull/11821)). Thanks, [whitphx](https://github.com/whitphx)!
- 🔄 Bug swap: To prevent a multipage app regression, `st.context.theme` does not automatically rerun the app on first load. In some cases, `st.context.theme` may not be correct until the first rerun ([#11870](https://github.com/streamlit/streamlit/pull/11870), [#11797](https://github.com/streamlit/streamlit/issues/11797)).
- 🧹 Bug fix: `st.chat_input` displays correctly at the bottom of the screen in mobile view ([#11896](https://github.com/streamlit/streamlit/pull/11896), [#11722](https://github.com/streamlit/streamlit/issues/11722), [#11891](https://github.com/streamlit/streamlit/issues/11891)).
- ⏳ Bug fix: When a WebSocket reconnects, the app will fully rerun to prevent missing fragments ([#11890](https://github.com/streamlit/streamlit/pull/11890), [#11660](https://github.com/streamlit/streamlit/issues/11660)).
- 🪱 Bug fix: To reduce `No such file or directory` errors, the file watcher has more robust exception handling and clearer logging ([#11871](https://github.com/streamlit/streamlit/pull/11871), [#11841](https://github.com/streamlit/streamlit/pull/11841), [#11809](https://github.com/streamlit/streamlit/issues/11809), [#11728](https://github.com/streamlit/streamlit/issues/11728)).
- 💩 Bug fix: Vega-Lite facet charts do not flicker ([#11833](https://github.com/streamlit/streamlit/pull/11833)).
- ☠️ Bug fix: When the initial sidebar state is set to `"collapsed"`, the sidebar correctly loads in a collapsed state without flickering open ([#11861](https://github.com/streamlit/streamlit/pull/11861), [#11848](https://github.com/streamlit/streamlit/issues/11848)).
- 👽 Bug fix: To prevent apps from being out of sync with their current code at a later time, Streamlit clears the script cache when all file watchers disconnect ([#11876](https://github.com/streamlit/streamlit/pull/11876), [#11739](https://github.com/streamlit/streamlit/pull/11739)). Thanks, [diwu-sf](https://github.com/diwu-sf)!
- 👻 Bug fix: Inline code in tooltips has the same relative size as inline code in other Markdown text ([#11877](https://github.com/streamlit/streamlit/pull/11877)).
- 🦀 Bug fix: `st.multiselect` and `st.selectbox` display the correct placeholder text when `accept_new_options=True` ([#11623](https://github.com/streamlit/streamlit/pull/11623), [#11609](https://github.com/streamlit/streamlit/issues/11609)).
- 🦋 Bug fix: The column visibility menu can be closed by toggling the toolbar icon ([#11857](https://github.com/streamlit/streamlit/pull/11857), [#11801](https://github.com/streamlit/streamlit/issues/11801)).
- 🦎 Bug fix: Progress bar columns in dataframes have the correct padding between the bar and its label ([#11685](https://github.com/streamlit/streamlit/pull/11685)).
- 🐌 Bug fix: The warning indicator in a dataframe cell adapts to theme configuration ([#11682](https://github.com/streamlit/streamlit/pull/11682)).
- 🕸️ Bug fix: To fix multiple visual and UX bugs in dataframe, `glide-data-grid` was updated ([#11677](https://github.com/streamlit/streamlit/pull/11677), [#8310](https://github.com/streamlit/streamlit/issues/8310), [#9498](https://github.com/streamlit/streamlit/issues/9498), [#9471](https://github.com/streamlit/streamlit/issues/9471)).
- 🦗 Bug fix: In the sidebar navigation widget, font spacing and weight were adjust for visual clarity ([#11814](https://github.com/streamlit/streamlit/pull/11814)).
- 🦂 Bug fix: Altair charts correctly resize in width to match their container ([#11807](https://github.com/streamlit/streamlit/pull/11807), [#11802](https://github.com/streamlit/streamlit/issues/11802)).
- 🦟 Bug fix: The running-man icon matches the theme configuration ([#11461](https://github.com/streamlit/streamlit/pull/11461), [#11371](https://github.com/streamlit/streamlit/issues/11371)). Thanks, [TreavVasu](https://github.com/TreavVasu)!
- 🦠 Bug fix: The top header background is correctly opaque when it contains elements ([#11787](https://github.com/streamlit/streamlit/pull/11787), [#11785](https://github.com/streamlit/streamlit/issues/11785)).
- 🪰 Bug fix: Extra top padding is removed when printing ([#11798](https://github.com/streamlit/streamlit/pull/11798)).
- 🪳 Bug fix: Markdown inline code displays correctly when `unsafe_allow_html=True` ([#11817](https://github.com/streamlit/streamlit/pull/11817), [#11800](https://github.com/streamlit/streamlit/issues/11800)). Thanks, [bajajku](https://github.com/bajajku)!
- 🕷️ Bug fix: The WebSocket ping interval does not exceed the timeout interval ([#11693](https://github.com/streamlit/streamlit/pull/11693), [#11670](https://github.com/streamlit/streamlit/issues/11670)).
- 🐞 Bug fix: The sidebar state initialized correctly on Community Cloud and page content slides and resizes correctly in response to the sidebar ([#11732](https://github.com/streamlit/streamlit/pull/11732), [#11702](https://github.com/streamlit/streamlit/issues/11702), [#11710](https://github.com/streamlit/streamlit/issues/11710)).
- 🐝 Bug fix: The timer in `st.spinner` uses system time to prevent pausing when the user focuses on another browser tab ([#11756](https://github.com/streamlit/streamlit/pull/11756), [#11720](https://github.com/streamlit/streamlit/issues/11720)).
- 🐜 Bug fix: Empty containers with borders and empty expanders are visible before elements are added to them ([#11669](https://github.com/streamlit/streamlit/pull/11669)).
- 🪲 Bug fix: `st.audio_input` and `st.camera_input` have consistent appearances ([#11699](https://github.com/streamlit/streamlit/pull/11699), [#11700](https://github.com/streamlit/streamlit/issues/11700)).
- 🐛 Bug fix: To prevent a race condition, the file watcher correctly applies a lock to watched paths ([#11692](https://github.com/streamlit/streamlit/pull/11692), [#11691](https://github.com/streamlit/streamlit/issues/11691)).

## **Version 1.46.0**

_Release date: June 18, 2025_

**Highlights**

- 🧭 Introducing top navigation! Use [`st.navigation`](https://docs.streamlit.io/develop/api-reference/navigation/st.navigation) with `position="top"` to create a navigation menu across the top of your app.
- 🔆 You can detect if the viewer is in light mode or dark mode at runtime with [`st.context.theme`](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.context#contexttheme).

**Notable Changes**

- 🪺 Streamlit no longer restricts the nesting of columns, expanders, popovers, and chat message containers, but beware of bad design! Always be mindful of different screen sizes and orientations, and don't overuse nested layouts.
- ↔️ You can set the width of most Streamlit elements.
- ⬆️ [`st.form`](https://docs.streamlit.io/develop/api-reference/execution-flow/st.form) has a new parameter to configure its `height`.
- 🛠️ [`st.columns`](https://docs.streamlit.io/develop/api-reference/layout/st.columns) supports `gap=None` for no gap between columns.
- 🏋️ Font face declarations in [`config.toml`](https://docs.streamlit.io/develop/api-reference/configuration/config.toml#theme) support weight and unicode ranges ([#11248](https://github.com/streamlit/streamlit/pull/11248), [#11163](https://github.com/streamlit/streamlit/issues/11163), [#11247](https://github.com/streamlit/streamlit/issues/11247)).
- 😃 Font face declarations are supported in the window variable ([#11628](https://github.com/streamlit/streamlit/pull/11628), [#11568](https://github.com/streamlit/streamlit/issues/11568)).
- 🔎 Streamlit searches for secrets and configuration options relative to the entrypoint file in addition to the working directory and user root ([#10173](https://github.com/streamlit/streamlit/pull/10173), [#8195](https://github.com/streamlit/streamlit/issues/8195)).
- 🎨 A new configuration option, `theme.dataframeBorderColor`, lets you set the border color for dataframes and tables separately from other border colors ([#11475](https://github.com/streamlit/streamlit/pull/11475)).
- 🌯 A new configuration option, `theme.buttonRadius`, lets you set the radius of buttons separately from other elements ([#11464](https://github.com/streamlit/streamlit/pull/11464)).
- 🖥️ A new configuration option, `theme.codeFontSize`, lets you set the size of code in `st.code`, `st.json`, and `st.help` ([#11508](https://github.com/streamlit/streamlit/pull/11508)).
- 🔒 You can configure a list of allowed origins when CORS protection is enabled ([#11377](https://github.com/streamlit/streamlit/pull/11377)).
- 📄 `st.set_page_config` can be called multiple times in a single script run ([#11286](https://github.com/streamlit/streamlit/pull/11286), [#4483](https://github.com/streamlit/streamlit/issues/4483), [#2216](https://github.com/streamlit/streamlit/issues/2216), [#9797](https://github.com/streamlit/streamlit/issues/9797), [#9038](https://github.com/streamlit/streamlit/issues/9038)).
- 🗺️ `st.pydeck_chart` and [`st.map`](http://st.map) now use Carto by default to provide map tiles ([#11231](https://github.com/streamlit/streamlit/pull/11231)).
- 👀 You can configure Streamlit to watch additional directories for changes with the new configuration option, `server.folderWatchList` ([#9656](https://github.com/streamlit/streamlit/pull/9656), [#9655](https://github.com/streamlit/streamlit/issues/9655)). Thanks, [akramsystems](https://github.com/akramsystems)!

**Other Changes**

- 🔘 Exception messages include a copy button to conveniently copy the message to your clipboard ([#11250](https://github.com/streamlit/streamlit/pull/11250), [#11083](https://github.com/streamlit/streamlit/issues/11083)). Thanks, [snakeM](https://github.com/snakeM)!
- ⚓ Streamlit apps can be served from port 3000 ([#11525](https://github.com/streamlit/streamlit/pull/11525), [#8149](https://github.com/streamlit/streamlit/issues/8149)).
- 👟 Markdown dependencies were upgraded for improved performance ([#11553](https://github.com/streamlit/streamlit/pull/11553), [#11550](https://github.com/streamlit/streamlit/issues/11550)).
- ↔️ The sidebar is narrower by default and consistently handles the scrollbar spacing ([#11412](https://github.com/streamlit/streamlit/pull/11412)).
- 👋 We gave Streamlit hello a couple small tweaks ([#11442](https://github.com/streamlit/streamlit/pull/11442)).
- 🧑‍💻 Base URL window variables are consistently namespaced in `__streamlit` ([#11481](https://github.com/streamlit/streamlit/pull/11481)).
- 🌐 Streamlit apps now serve a `manifest.json` file ([#11462](https://github.com/streamlit/streamlit/pull/11462)).
- 🖌️ `st.dataframe` shows row selection boxes always instead of just on hover ([#11411](https://github.com/streamlit/streamlit/pull/11411), [#11410](https://github.com/streamlit/streamlit/issues/11410)).
- 🦋 `ListColumn` and `LinkColumn` can inherit coloring from `pandas` `Styler` ([#11612](https://github.com/streamlit/streamlit/pull/11612), [#8254](https://github.com/streamlit/streamlit/issues/8254)).
- 💹 `NumberColumn` and `ProgressColumn` support a Japanese yen number format ([#11588](https://github.com/streamlit/streamlit/pull/11588)). Thanks, [alexmalins](https://github.com/alexmalins)!
- 🔗 `st.page_link` can inherit an icon when passed a `StreamlitPage` ([#10694](https://github.com/streamlit/streamlit/pull/10694), [#9743](https://github.com/streamlit/streamlit/issues/9743)). Thanks, [abokey1](https://github.com/abokey1)!
- 🎫 A button's placement in the sidebar or main body of an app is included in its widget identity ([#10881](https://github.com/streamlit/streamlit/pull/10881), [#10598](https://github.com/streamlit/streamlit/issues/10598)). Thanks, [joaooliveira-11](https://github.com/joaooliveira-11)!
- 🕷️ Built-in Streamlit fonts now use variable font files ([#11646](https://github.com/streamlit/streamlit/pull/11646), [#11600](https://github.com/streamlit/streamlit/pull/11600), [#11534](https://github.com/streamlit/streamlit/pull/11534)).
- 🤹 Bug fix: Streamlit Markdown correctly formats task lists and block quotes (#11237).
- 🐞 Bug fix: Horizontal scroll bars are sized correctly in Safari ([#11625](https://github.com/streamlit/streamlit/pull/11625)).
- 🐝 Bug fix: Unnecessary media caching was reduced to improve efficiency and avoid video player crashes ([#11635](https://github.com/streamlit/streamlit/pull/11635), [#9688](https://github.com/streamlit/streamlit/issues/9688)).
- 🐜 Bug fix: `st.text` uses the `break-word` CSS property to wrap long lines without whitespace ([#10969](https://github.com/streamlit/streamlit/pull/10969), [#10824](https://github.com/streamlit/streamlit/issues/10824)). Thanks, [matilde2004](https://github.com/matilde2004)!
- 🪲 Bug fix: Material icons display correctly in `st.markdown` when `unsafe_allow_html=True` ([#11633](https://github.com/streamlit/streamlit/pull/11633), [#9945](https://github.com/streamlit/streamlit/issues/9945)).
- 🐛 Bug fix: Multi-index column names preserve brackets ([#11617](https://github.com/streamlit/streamlit/pull/11617), [#10415](https://github.com/streamlit/streamlit/issues/10415)).
- 💅 Bug fix: Various CSS tweaks ([#11631](https://github.com/streamlit/streamlit/pull/11631), [#11632](https://github.com/streamlit/streamlit/pull/11632), [#11630](https://github.com/streamlit/streamlit/pull/11630), [#11611](https://github.com/streamlit/streamlit/issues/11611), [#11577](https://github.com/streamlit/streamlit/pull/11577), [#9085](https://github.com/streamlit/streamlit/issues/9085), [#8671](https://github.com/streamlit/streamlit/issues/8671), [#11576](https://github.com/streamlit/streamlit/pull/11576), [#11569](https://github.com/streamlit/streamlit/issues/11569)).
- ⛏️ Bug fix: `st.dataframe` clears filter options when applying sort to prevent incorrect highlights ([#11587](https://github.com/streamlit/streamlit/pull/11587), [#11575](https://github.com/streamlit/streamlit/issues/11575)).
- 📊 Bug fix: Altair charts have the correct width and don't overflow with long titles ([#11585](https://github.com/streamlit/streamlit/pull/11585), [#9984](https://github.com/streamlit/streamlit/issues/9984)).
- 🍞 Bug fix: `st.toast` messages appear above `st.dialog` containers ([#11578](https://github.com/streamlit/streamlit/pull/11578), [#10383](https://github.com/streamlit/streamlit/issues/10383)).
- 🪱 Bug fix: Streamlit apps correctly scroll to anchor links ([#11552](https://github.com/streamlit/streamlit/pull/11552), [#11551](https://github.com/streamlit/streamlit/issues/11551)).
- ✍️ Bug fix: `st.context` does not lose state in an app being edited ([#11506](https://github.com/streamlit/streamlit/pull/11506), [#11330](https://github.com/streamlit/streamlit/issues/11330)).
- ⬜ Bug fix: `st.code` preserves leading white space ([#10065](https://github.com/streamlit/streamlit/pull/10065), [#6302](https://github.com/streamlit/streamlit/issues/6302)). Thanks, [XuehaiPan](https://github.com/XuehaiPan)!
- 📅 Bug fix: `st.date_input` shows the correct hover effect when using date ranges ([#11223](https://github.com/streamlit/streamlit/pull/11223), [#10929](https://github.com/streamlit/streamlit/issues/10929)). Thanks, [Bernardo1008](https://github.com/Bernardo1008)!
- 💩 Bug fix: Dataframes using `pandas` `Styler` correctly display `Enum` values ([#11049](https://github.com/streamlit/streamlit/pull/11049), [#10637](https://github.com/streamlit/streamlit/issues/10637)). Thanks, [BigBird404](https://github.com/BigBird404)!
- ☠️ Bug fix: `st.context` does not lose state when `st.switch_page` is called ([#11521](https://github.com/streamlit/streamlit/pull/11521), [#11507](https://github.com/streamlit/streamlit/issues/11507)).
- 👽 Bug fix: File watcher correctly handles custom metaclasses ([#10388](https://github.com/streamlit/streamlit/pull/10388), [#10992](https://github.com/streamlit/streamlit/issues/10992)). Thanks, [HomenShum](https://github.com/HomenShum)!
- 👻 Bug fix: [`st.map`](http://st.map) uses a private Mapbox token when configured ([#11511](https://github.com/streamlit/streamlit/pull/11511), [#11399](https://github.com/streamlit/streamlit/issues/11399)).
- 🦀 Bug fix: `vega-interpreter` was updated to prevent unintentional blank axes ([#11514](https://github.com/streamlit/streamlit/pull/11514), [#5733](https://github.com/streamlit/streamlit/issues/5733)).
- 🦎 Bug fix: Truncated values in `NumberColumn` are rounded correctly ([#11520](https://github.com/streamlit/streamlit/pull/11520), [#11519](https://github.com/streamlit/streamlit/issues/11519)).
- 🐌 Bug fix: Highlighted in text in Markdown has the correct padding on wrapped lines ([#11530](https://github.com/streamlit/streamlit/pull/11530)).
- 🕸️ Bug fix: For a Plotly chart, reset axes works correctly after using fullscreen ([#11498](https://github.com/streamlit/streamlit/pull/11498), [#11327](https://github.com/streamlit/streamlit/issues/11327)).
- 🦗 Bug fix: Altair chart are not cropped on the left on first load ([#10939](https://github.com/streamlit/streamlit/pull/10939), [#9339](https://github.com/streamlit/streamlit/issues/9339)). Thanks, [goncalossmartins](https://github.com/goncalossmartins)!
- 📈 Bug fix: Chart columns correctly show negative values ([#11048](https://github.com/streamlit/streamlit/pull/11048), [#10411](https://github.com/streamlit/streamlit/issues/10411)). Thanks, [tiagorb1](https://github.com/tiagorb1)!
- 🦂 Bug fix: Streamlit doesn't crash when editing indices in `st.data_editor` ([#11448](https://github.com/streamlit/streamlit/pull/11448), [#11434](https://github.com/streamlit/streamlit/issues/11434)).
- 🦟 Bug fix: Color and style is preserved in charts when using `.add_rows()` ([#11414](https://github.com/streamlit/streamlit/pull/11414), [#11312](https://github.com/streamlit/streamlit/issues/11312)).
- 🌪️ Bug fix: Tornado 6.5.0 is excluded to prevent file uploading errors related to unicode filenames ([#11440](https://github.com/streamlit/streamlit/pull/11440), [#11396](https://github.com/streamlit/streamlit/issues/11396), [#11436](https://github.com/streamlit/streamlit/issues/11436)).
- 🦠 Bug fix: Selected rows are cleared when a column in `st.dataframe` is sorted ([#11363](https://github.com/streamlit/streamlit/pull/11363), [#11345](https://github.com/streamlit/streamlit/issues/11345)).
- 📶 Bug fix: Streamlit shows a clearer message when it can't connect to the server and automatically dismisses the message if a connection is successful ([#11366](https://github.com/streamlit/streamlit/pull/11366)).
- 🪰 Bug fix: Localized number and date formats correctly interpret locales with commas ([#11297](https://github.com/streamlit/streamlit/pull/11297), [#11291](https://github.com/streamlit/streamlit/issues/11291)).
- 🧹 Bug fix: Streamlit cleans up the forward message cache to prevent WebSocket message errors ([#11302](https://github.com/streamlit/streamlit/pull/11302), [#11299](https://github.com/streamlit/streamlit/issues/11299), [#11300](https://github.com/streamlit/streamlit/issues/11300)).
- 📜 Bug fix: `st.latex` scrolls horizontally when its content is wider than the app ([#10071](https://github.com/streamlit/streamlit/pull/10071), [#4304](https://github.com/streamlit/streamlit/issues/4304)).
- 🪳 Bug fix: `st.multiselect` has a more stable sort when filtering options ([#11309](https://github.com/streamlit/streamlit/pull/11309), [#11218](https://github.com/streamlit/streamlit/issues/11218)).
- 🕷️ Bug fix: `st.multiselect` options are case sensitive and don't overlap in the drop down menu ([#11307](https://github.com/streamlit/streamlit/pull/11307), [#11217](https://github.com/streamlit/streamlit/issues/11217), [#11306](https://github.com/streamlit/streamlit/pull/11306), [#11215](https://github.com/streamlit/streamlit/issues/11215)).
- 🍪 Bug fix: Streamlit logs an error if the cookie returned by `st.login` is too large ([#11290](https://github.com/streamlit/streamlit/pull/11290), [#11168](https://github.com/streamlit/streamlit/issues/11168)).
- 🪲 Bug fix: Displaying elements within a fragment's callback logs a clear warning that it's not supported ([#10942](https://github.com/streamlit/streamlit/pull/10942), [#10475](https://github.com/streamlit/streamlit/issues/10475)). Thanks, [Zane-dev16](https://github.com/Zane-dev16)!
- 🐞 Bug fix: `st.file_uploader` is case insensitive when validating allowed file extensions ([#11261](https://github.com/streamlit/streamlit/pull/11261), [#11259](https://github.com/streamlit/streamlit/issues/11259)).
- 🐝 Bug fix: Page runs end correctly to prevent invalid widget states ([#11258](https://github.com/streamlit/streamlit/pull/11258), [#11202](https://github.com/streamlit/streamlit/issues/11202)).
- 👤 Bug fix: Error messages correctly refer to `st.user` instead of `st.experimental_user` ([#11198](https://github.com/streamlit/streamlit/pull/11198)).
- 🏷️ Bug fix: The missing label warning for widgets includes a stack trace ([#11187](https://github.com/streamlit/streamlit/pull/11187), [#8908](https://github.com/streamlit/streamlit/issues/8908)).
- 🐛 Bug fix: `st.data_editor` returns the correct result when some rows are deleted and others are added ([#11183](https://github.com/streamlit/streamlit/pull/11183), [#11180](https://github.com/streamlit/streamlit/issues/11180)).

## **Version 1.45.0**

_Release date: April 29, 2025_

**Highlights**

- 🧑 Announcing the general availability of [`st.user`](https://docs.streamlit.io/develop/api-reference/user/st.user), a dict-like object to access information about the current user.

**Notable Changes**

- ➕ [`st.multiselect`](https://docs.streamlit.io/develop/api-reference/widgets/st.multiselect) and [`st.selectbox`](https://docs.streamlit.io/develop/api-reference/widgets/st.selectbox) have a new parameter to let users add new options.
- 🥸 [`st.context`](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.context) has new attributes: `url`, `ip_address`, and `is_embedded`.
- ⚠️ Text [alerts](https://docs.streamlit.io/develop/api-reference/status/st.success) and [exceptions](https://docs.streamlit.io/develop/api-reference/status/st.exception) have a new `width` parameter ([#11142](https://github.com/streamlit/streamlit/pull/11142)).
- ⌨️ You can set the tab index for [`st.components.v1.html`](https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v1.html) and [`st.components.v1.iframe`](https://docs.streamlit.io/develop/api-reference/custom-components/st.components.v1.iframe) ([#11065](https://github.com/streamlit/streamlit/pull/11065), [#7969](https://github.com/streamlit/streamlit/issues/7969)).
- 🌐 When you pass a CSS file's path to [`st.html`](https://docs.streamlit.io/develop/api-reference/text/st.html), Streamlit will automatically insert `<style>` tags and avoid creating extra space in the app ([#10979](https://github.com/streamlit/streamlit/pull/10979), [#9388](https://github.com/streamlit/streamlit/issues/9388), [#10027](https://github.com/streamlit/streamlit/issues/10027)).
- 😃 You can add an icon to the left of the value in [`st.text_input`](https://docs.streamlit.io/develop/api-reference/widgets/st.text_input) and [`st.number_input`](https://docs.streamlit.io/develop/api-reference/widgets/st.number_input).

**Other Changes**

- 🗑️ Per the scheduled deprecation, `st.experimental_audio_input` has been removed. Use `st.audio_input` instead.
- 💅 Various elements received styling tweaks for consistency and compatibility with advanced theming ([#10916](https://github.com/streamlit/streamlit/pull/10916), [#10930](https://github.com/streamlit/streamlit/pull/10930), [#10915](https://github.com/streamlit/streamlit/pull/10915), [#10944](https://github.com/streamlit/streamlit/pull/10944), [#10990](https://github.com/streamlit/streamlit/pull/10990), [#11033](https://github.com/streamlit/streamlit/pull/11033), [#11034](https://github.com/streamlit/streamlit/pull/11034)).
- ⚒️ The element toolbar sizing and spacing was adjusted for improved UX ([#11135](https://github.com/streamlit/streamlit/pull/11135), [#11155](https://github.com/streamlit/streamlit/pull/11155)).
- 🫥 Bug fix: Streamlit does not display a frontend error when displaying an empty dataframe ([#11100](https://github.com/streamlit/streamlit/pull/11100), [#11064](https://github.com/streamlit/streamlit/issues/11064)).
- 🔁 Bug fix: `st.context` retains its information when calling `st.rerun` ([#11113](https://github.com/streamlit/streamlit/pull/11113), [#11111](https://github.com/streamlit/streamlit/issues/11111)).
- 💩 Bug fix: `st.camera_input` has the correct color and hover effect when disabled ([#11116](https://github.com/streamlit/streamlit/pull/11116)).
- 🎤 Bug fix: `st.audio_input` has consistent color and hover effects with other widgets ([#11118](https://github.com/streamlit/streamlit/pull/11118)).
- ↔️ Bug fix: `st.logo` displays correctly when the sidebar is resized ([#11063](https://github.com/streamlit/streamlit/pull/11063), [#11062](https://github.com/streamlit/streamlit/issues/11062)).
- 📂 Bug fix: `st.file_uploader` can handle multi-part file extensions in its `type` parameter ([#11043](https://github.com/streamlit/streamlit/pull/11043), [#11041](https://github.com/streamlit/streamlit/issues/11041)). Thanks, [moutayam](https://github.com/moutayam)!
- 💈 Bug fix: `theme.fontFaces` correctly supports font style ([#11098](https://github.com/streamlit/streamlit/pull/11098), [#11097](https://github.com/streamlit/streamlit/issues/11097)).
- 🧹 Bug fix: `streamlit init` specifies file encoding to avoid errors in systems where UTF-8 is not the default ([#11090](https://github.com/streamlit/streamlit/pull/11090), [#11086](https://github.com/streamlit/streamlit/issues/11086)). Thanks, [ashm-dev](https://github.com/ashm-dev)!
- 📜 Bug fix: In the sidebar, space is reserved for the scrollbar to prevent flickering from resizing ([#10733](https://github.com/streamlit/streamlit/pull/10733), [#10310](https://github.com/streamlit/streamlit/issues/10310)).
- 🪱 Bug fix: `st.logo` supports SVGs defined with a `viewBox` ([#11038](https://github.com/streamlit/streamlit/pull/11038), [#10904](https://github.com/streamlit/streamlit/issues/10904)).
- ☠️ Bug fix: `st.date_input` raises an error in the UI if a user enters a date outside of the specified allowed range ([#10764](https://github.com/streamlit/streamlit/pull/10764), [#8475](https://github.com/streamlit/streamlit/issues/8475)).
- 👽 Bug fix: `st.snow` and `st.balloons` don't incorrectly rerun during a fragment rerun ([#11015](https://github.com/streamlit/streamlit/pull/11015), [#10961](https://github.com/streamlit/streamlit/issues/10961)).
- 👻 Bug fix: When updating `config.toml`during development, Streamlit will elegantly handle invalid TOML formatting and reload the configuration file on the next save ([#10857](https://github.com/streamlit/streamlit/pull/10857), [#1256](https://github.com/streamlit/streamlit/issues/1256), [#8320](https://github.com/streamlit/streamlit/issues/8320)).
- 🦋 Bug fix: Streamlit applies the correct hover effect when colored text is used in button labels ([#10996](https://github.com/streamlit/streamlit/pull/10996), [#8767](https://github.com/streamlit/streamlit/issues/8767)).
- 🦀 Bug fix: Streamlit ignores `__init__.py` and dotfiles in the `/pages` directory when automatically declaring pages in a multipage app ([#11009](https://github.com/streamlit/streamlit/pull/11009), [#11006](https://github.com/streamlit/streamlit/issues/11006)).
- ⏩ `st.write` received an optimization tweak for rendering strings ([#10985](https://github.com/streamlit/streamlit/pull/10985)).
- 🦎 Bug fix: `st.html` renders at 100% width for correct sizing ([#10976](https://github.com/streamlit/streamlit/pull/10976), [#10964](https://github.com/streamlit/streamlit/issues/10964)).
- 🐌 Bug fix: Page links become disabled if a client disconnects from the Streamlit server ([#10946](https://github.com/streamlit/streamlit/pull/10946), [#9198](https://github.com/streamlit/streamlit/issues/9198)).
- 🕸️ Bug fix: Streamlit supports newer emojis in page icons ([#10912](https://github.com/streamlit/streamlit/pull/10912), [#11154](https://github.com/streamlit/streamlit/pull/11154)).
- 🦗 Bug fix: `st.exception` only shows links to Google and ChatGPT when the app is being accessed through [`localhost`](http://localhost) ([#10971](https://github.com/streamlit/streamlit/pull/10971), [#10924](https://github.com/streamlit/streamlit/issues/10924)).
- 🦂 Bug fix: `st.chat_input` will expand to show multi-line placeholder text in most browsers. Firefox does not support this fix ([#10931](https://github.com/streamlit/streamlit/pull/10931), [#10611](https://github.com/streamlit/streamlit/issues/10611)).
- 🦟 Bug fix: Streamlit elegantly catches a `TypeError` when concurrent changes to rows and columns cause a failure in serialization ([#10954](https://github.com/streamlit/streamlit/pull/10954), [#10937](https://github.com/streamlit/streamlit/issues/10937)).
- 🦠 Bug fix: Streamlit cleanly handles non-ASCII characters in anchor links, which may change some anchors in existing apps ([#10929](https://github.com/streamlit/streamlit/pull/10925), [#8114](https://github.com/streamlit/streamlit/issues/8114)).
- 🪰 Bug fix: To prevent a race condition, session information is not immediately cleared unless a new session message is received ([#9886](https://github.com/streamlit/streamlit/pull/9886), [#9767](https://github.com/streamlit/streamlit/issues/9767)).
- 🪳 Bug fix: `streamlit config show` correctly displays `client.showErrorDetails` as a string instead of a list ([#10921](https://github.com/streamlit/streamlit/pull/10921), [#10913](https://github.com/streamlit/streamlit/issues/10913)).
- 🕷️ Bug fix: `st.selectbox` does not lose its value if a partial edit is abandoned ([#10891](https://github.com/streamlit/streamlit/pull/10891)).
- 🐞 Bug fix: `st.badge` doesn't falsely show `rainbow` as a color option ([#10896](https://github.com/streamlit/streamlit/pull/10896)).
- 🐝 Bug fix: To avoid a file lock conflict the occurs with some IDEs, Streamlit's file watcher utilities retries reading files when blocked ([#10868](https://github.com/streamlit/streamlit/pull/10868), [#4486](https://github.com/streamlit/streamlit/issues/4486)). Thanks, [Morridin](https://github.com/Morridin)!
- 🐜 Bug fix: `st.selectbox` and `st.multiselect` have consistent color and spacing for placeholder text ([#10865](https://github.com/streamlit/streamlit/pull/10865)).
- 🪲 Bug fix: Context managers correctly handle form elements ([#10752](https://github.com/streamlit/streamlit/pull/10752), [#8761](https://github.com/streamlit/streamlit/issues/8761)). Thanks, [SrGesus](https://github.com/SrGesus)!
- 🐛 Bug fix: `st.link_button` and `st.tabs` remain active when a client disconnects from a Streamlit server ([#10861](https://github.com/streamlit/streamlit/pull/10861)).

## **Version 1.44.0**

_Release date: March 25, 2025_

**Highlights**

- 💈 Introducing [advanced theming options](/develop/api-reference/configuration/config.toml#theme)! Use an assortment of configuration options to customize the appearance of your app. Change the fonts, colors, and roundness of your app without CSS.
- 👮 Introducing [`st.badge`](/develop/api-reference/text/st.badge) to insert a colored badge element. You can also include badges in Markdown using a new directive.
- 🏗️ Use [`streamlit init`](/develop/api-reference/cli/init) in your terminal to create all the local files you need for a new Streamlit app.

**Notable Changes**

- 🤖 [`st.exception`](/develop/api-reference/status/st.exception) includes links to open Google or ChatGPT with the contents of the exception. This includes uncaught exceptions displayed in the app.
- 🗺️ You can access the user's locale through [`st.context`](/develop/api-reference/caching-and-state/st.context#contextlocale) ([#10563](https://github.com/streamlit/streamlit/pull/10563)).

**Other Changes**

- 📄 When using a `pages/` directory to automatically generate a multipage app, no pages (including the entrypoint file) can have the same inferred URL pathname ([#10276](https://github.com/streamlit/streamlit/pull/10276)).
- 🏎️ To improve performance, Streamlit uses the React 18 `createRoot` API for its frontend ([#10453](https://github.com/streamlit/streamlit/pull/10453)).
- 📝 To improve compatibility with AI tools, script compilation errors are logged when `logger.level="error"` and not just when `logger.level="debug"` ([#10826](https://github.com/streamlit/streamlit/pull/10826)).
- 🪵 Streamlit automatically enables more detailed logging if `rich` is installed ([#10650](https://github.com/streamlit/streamlit/pull/10650)).
- 🔢 `st.slider` and `st.number_input` raise an error when assigned a value in excess of a declared minimum or maximum ([#9964](https://github.com/streamlit/streamlit/pull/9964), [#9342](https://github.com/streamlit/streamlit/issues/9342)).
- 🛠️ `st.table` support pandas `Styler.set_tooltips()` ([#10561](https://github.com/streamlit/streamlit/pull/10561), [#10553](https://github.com/streamlit/streamlit/issues/10553)).
- ℹ️ Material symbols have been updated to the latest icon set ([#10813](https://github.com/streamlit/streamlit/pull/10813), [#10717](https://github.com/streamlit/streamlit/pull/10717)).
- 🦋 Visual tweaks to headers ([#10599](https://github.com/streamlit/streamlit/pull/10599)).
- 🦀 Bug fix: `st.html` displays correctly when used inside `st.tabs` ([#10825](https://github.com/streamlit/streamlit/pull/10825), [#10815](https://github.com/streamlit/streamlit/issues/10815)).
- 🦎 Bug fix: For backwards compatibility, `theme.font="sans serfi"` is internally converted to the new `theme.font="sans-serif"` ([#10789](https://github.com/streamlit/streamlit/pull/10789), [#10786](https://github.com/streamlit/streamlit/issues/10786)).
- 🐌 Bug fix: When using `st.secrets`, if Streamlit can't find the `secrets.toml` file, it will raise a `FileNotFoundError` ([#10508](https://github.com/streamlit/streamlit/pull/10508), [#8559](https://github.com/streamlit/streamlit/issues/8559)).
- 🕸️ Bug fix: `st.secrets` raises a clear `TypeError` if you try to assign a value to an attribute ([#10698](https://github.com/streamlit/streamlit/pull/10698), [#10107](https://github.com/streamlit/streamlit/issues/10107)).
- 🦗 Bug fix: In single-page apps, `st.page_link` does not highlight external links as if they are the current page ([#10690](https://github.com/streamlit/streamlit/pull/10690), [#10689](https://github.com/streamlit/streamlit/issues/10689)).
- 🦂 Bug fix: `st.poppover` displays at the correct width when using the `help` parameter ([#10709](https://github.com/streamlit/streamlit/pull/10709), [#10693](https://github.com/streamlit/streamlit/issues/10693)).
- 🦟 Bug fix: All components (and custom components) that read their width from the DOM initially load with a width of -1 px to prevent flickering ([#10712](https://github.com/streamlit/streamlit/pull/10712), [#10672](https://github.com/streamlit/streamlit/pull/10672), [#10663](https://github.com/streamlit/streamlit/pull/10663), [#10644](https://github.com/streamlit/streamlit/issues/10644)).
- 🦠 Bug fix: When `st.number_input` is configured to use integers, the default minimum and maximum values will prevent integer overflow ([#10655](https://github.com/streamlit/streamlit/pull/10655), [#6740](https://github.com/streamlit/streamlit/issues/6740)).
- 🪰 Bug fix: `st.navigation` uses immutable types to prevent mypy errors ([#10670](https://github.com/streamlit/streamlit/pull/10670)).
- 🪳 Bug fix: Custom components correctly inherit font from theme configuration ([#10661](https://github.com/streamlit/streamlit/pull/10661), [#10660](https://github.com/streamlit/streamlit/issues/10660)).
- 🕷️ Bug fix: Dataframes correctly support Dask data objects ([#10662](https://github.com/streamlit/streamlit/pull/10662)).
- 🐞 Bug fix: Button widths are correct when using the `help` parameter ([#10658](https://github.com/streamlit/streamlit/pull/10658), [#10648](https://github.com/streamlit/streamlit/issues/10648), [#10656](https://github.com/streamlit/streamlit/issues/10656)).
- 🐝 Bug fix: Scrolling is disabled when hovering over `st.number_input` to prevent accidental value changes ([#10642](https://github.com/streamlit/streamlit/pull/10642), [#8867](https://github.com/streamlit/streamlit/issues/8867)).
- 🐜 Bug fix: `st.chat_input` gives a clear error in the UI when the file size limit is exceeded ([#10530](https://github.com/streamlit/streamlit/pull/10530)).
- 🪲 Bug fix: The favicon and Markdown emojis use the same SVG emoji source for consistency ([#10539](https://github.com/streamlit/streamlit/pull/10539), [#6822](https://github.com/streamlit/streamlit/issues/6822)).
- 🐛 Bug fix: The dataframe search bar is more responsive to width ([#10534](https://github.com/streamlit/streamlit/pull/10534), [#10532](https://github.com/streamlit/streamlit/issues/10532)).

## **Version 1.43.0**

_Release date: March 4, 2025_

**Highlights**

- 📁 Announcing the option to accept files with [`st.chat_input`](/develop/api-reference/chat/st.chat_input)!
- 📒 Introducing a new column type for column configuration! Use [`JsonColumn`](/develop/api-reference/data/st.column_config/st.column_config.jsoncolumn) to show JSON-compatible objects.

**Notable Changes**

- 🏃 You can prevent [`st.download_button`](/develop/api-reference/widgets/st.download_button) from triggering a rerun by setting `on_click="ignore"` ([#10296](https://github.com/streamlit/streamlit/pull/10296), [#4382](https://github.com/streamlit/streamlit/issues/4382)).
- 🕑 You can access a user's timezone and timezone offset through [`st.context`](/develop/api-reference/caching-and-state/st.context) ([#10336](https://github.com/streamlit/streamlit/pull/10336)).
- ↕️ You can configure the row height in [`st.dataframe`](/develop/api-reference/data/st.dataframe) and [`st.data_editor`](/develop/api-reference/data/st.data_editor) with a new parameter ([#9549](https://github.com/streamlit/streamlit/pull/9549), [#7266](https://github.com/streamlit/streamlit/issues/7266), [#8632](https://github.com/streamlit/streamlit/issues/8632), [#5386](https://github.com/streamlit/streamlit/issues/5386)).
- 💅 `st.dataframe` and `st.data_editor` use `use_container_width=True` by default ([#10434](https://github.com/streamlit/streamlit/pull/10434)).
- 🤏 [Markdown](/develop/api-reference/text/st.markdown) has a small text directive ([#10487](https://github.com/streamlit/streamlit/pull/10487), [#10486](https://github.com/streamlit/streamlit/issues/10486)).
- 🧵 You can pass strings, paths, and callables to [`st.navigation`](/develop/api-reference/navigation/st.navigation) in place of `StreamlitPage` objects for convenience ([#10358](https://github.com/streamlit/streamlit/pull/10358), [#10069](https://github.com/streamlit/streamlit/issues/10069)). Thanks, [ashm-dev](https://github.com/ashm-dev)!
- 📈 Streamlit has a new custom component, [`streamlit-bokeh`](https://github.com/streamlit/streamlit-bokeh), to support the latest version of Bokeh ([#10374](https://github.com/streamlit/streamlit/pull/10374), [#5858](https://github.com/streamlit/streamlit/issues/5858)).
- 🔣 [`NumberColumn`](/develop/api-reference/data/st.column_config/st.column_config.numbercolumn), [`ProgressColumn`](/develop/api-reference/data/st.column_config/st.column_config.progresscolumn), [`DatetimeColumn`](/develop/api-reference/data/st.column_config/st.column_config.datetimecolumn), [`DateColumn`](/develop/api-reference/data/st.column_config/st.column_config.datecolumn), and [`TimeColumn`](/develop/api-reference/data/st.column_config/st.column_config.timecolumn) have preconfigured format options for ease of use ([#10179](https://github.com/streamlit/streamlit/pull/10179), [#8788](https://github.com/streamlit/streamlit/issues/8788), [#7702](https://github.com/streamlit/streamlit/issues/7702)).
- 🛎️ [Static file serving](/develop/concepts/configuration/serving-static-files) supports files with JSON, XML, and common font file extensions. ([#10417](https://github.com/streamlit/streamlit/pull/10417), [#10335](https://github.com/streamlit/streamlit/pull/10335), [#10337](https://github.com/streamlit/streamlit/pull/10337), [#10302](https://github.com/streamlit/streamlit/issues/10302)).

**Other Changes**

- 🥷 Users can hide dataframe columns ([#10264](https://github.com/streamlit/streamlit/pull/10264), [#6870](https://github.com/streamlit/streamlit/issues/6870)).
- 📅 Users can change the format of numbers, dates, and times in dataframes ([#10420](https://github.com/streamlit/streamlit/pull/10420)).
- ↔️ Users can auto-size column widths ([#10476](https://github.com/streamlit/streamlit/pull/10476)).
- 🐻‍❄️ Streamlit supports Polars dataframe and series hashing ([#10408](https://github.com/streamlit/streamlit/pull/10408), [#10347](https://github.com/streamlit/streamlit/issues/10347)).
- ☠️ `rich` is no longer a required dependency for Streamlit ([#10320](https://github.com/streamlit/streamlit/pull/10320)).
- 🦋 `st.file_uploader` has a better display format in narrow containers ([#10272](https://github.com/streamlit/streamlit/pull/10272)).
- 🦎 Bug fix: Tabs are prevented from having a width of zero to prevent flickering ([#10533](https://github.com/streamlit/streamlit/pull/10533)).
- 🐌 Bug fix: Column order is correctly displayed when set in column configuration ([#10445](https://github.com/streamlit/streamlit/pull/10445), [#10442](https://github.com/streamlit/streamlit/issues/10442)).
- 🕸️ Bug fix: We updated dataframe null handling to prevent deprecation warnings ([#10484](https://github.com/streamlit/streamlit/pull/10484)).
- 🦗 Bug fix: Elapsed time doesn't overflow for `st.audio_input` ([#10410](https://github.com/streamlit/streamlit/pull/10410), [#10373](https://github.com/streamlit/streamlit/issues/10373)). Thanks, [ashm-dev](https://github.com/ashm-dev)!
- 🦂 Bug fix: `st.altair_chart` does not show an incorrect "true" tooltip when the user makes a selection ([#10456](https://github.com/streamlit/streamlit/pull/10456), [#10448](https://github.com/streamlit/streamlit/issues/10448)).
- 🦟 Bug fix: Streamlit does not raise a RuntimeError when an `asyncio` event loop is not already running ([#10455](https://github.com/streamlit/streamlit/pull/10455), [#10452](https://github.com/streamlit/streamlit/issues/10452)).
- 🦠 Bug fix: The key for an internal MIME type is set correctly to avoid a browser warning ([#10404](https://github.com/streamlit/streamlit/pull/10404)).
- 🪰 Bug fix: `st.data_editor` automatically scrolls to the bottom when a user adds a row ([#10405](https://github.com/streamlit/streamlit/pull/10405), [#10351](https://github.com/streamlit/streamlit/issues/10351)).
- 🪳 Bug fix: Tooltips are suppressed on user-added rows in `st.data_editor` to prevent erroneous warnings ([#10398](https://github.com/streamlit/streamlit/pull/10398)).
- 🕷️ Bug fix: `st.logo` displays consistently when used with fragments and dialogs ([#10377](https://github.com/streamlit/streamlit/pull/10377), [#10350](https://github.com/streamlit/streamlit/issues/10350), [#10382](https://github.com/streamlit/streamlit/issues/10382)).
- 🐞 Bug fix: `st.graphviz_chart` has rounded corners for consistent style ([#10224](https://github.com/streamlit/streamlit/pull/10224)).
- 🐝 Bug fix: Streamlit raises a clear exception when an underscore is used in `provider` for `st.login` ([#10360](https://github.com/streamlit/streamlit/pull/10360), [#10356](https://github.com/streamlit/streamlit/issues/10356)).
- 🐜 Bug fix: The dataframe column menu displays correctly inside dialogs ([#10359](https://github.com/streamlit/streamlit/pull/10359), [#10357](https://github.com/streamlit/streamlit/issues/10357)).
- 🪲 Bug fix: Exception handling was adjusted for improved compatibility with Cython ([#10354](https://github.com/streamlit/streamlit/pull/10354), [#10353](https://github.com/streamlit/streamlit/issues/10353)). Thanks, [tutu-sol](https://github.com/tutu-sol)!
- 🐛 Bug fix: `st.pills` and `st.segmented_control` have consistent font sizes across browsers ([#10349](https://github.com/streamlit/streamlit/pull/10349)).

## **Version 1.42.0**

_Release date: February 4, 2025_

**Highlights**

- 👩‍💻 Introducing [`st.login()`](/develop/api-reference/user/st.login) and [`st.logout()`](/develop/api-reference/user/st.logout) to authenticate users with any OpenID Connect provider.

**Notable Changes**

- ❣️ [`st.table`](/develop/api-reference/data/st.table) supports Markdown ([#8785](https://github.com/streamlit/streamlit/issues/8785), [#10088](https://github.com/streamlit/streamlit/pull/10088)).
- ⏲️ [`st.spinner`](/develop/api-reference/status/st.spinner) can show elapsed time with `show_time=True` ([#6805](https://github.com/streamlit/streamlit/issues/6805), [#10072](https://github.com/streamlit/streamlit/pull/10072)).
- 💈 [`st.image`](/develop/api-reference/media/st.image) supports Markdown in the `caption` parameter ([#6808](https://github.com/streamlit/streamlit/issues/6808), [#10075](https://github.com/streamlit/streamlit/pull/10075)).
- ↕️ [`st.code`](/develop/api-reference/text/st.code) has a `height` parameter ([#7418](https://github.com/streamlit/streamlit/issues/7418), [#10080](https://github.com/streamlit/streamlit/pull/10080)).
- ↔️ Most charts default to using `use_container_width=True` ([#10064](https://github.com/streamlit/streamlit/pull/10064)).
- ❄️ [`SnowflakeConnection`](/develop/api-reference/connections/st.connections.snowflakeconnection) was updated to match the current Snowflake API, which changes its handling of keyword arguments in some cases ([#10122](https://github.com/streamlit/streamlit/pull/10122)).
- 🐁 Users can drag and drop dataframe columns to rearrange them ([#8796](https://github.com/streamlit/streamlit/issues/8796), [#10099](https://github.com/streamlit/streamlit/pull/10099)).

**Other Changes**

- 📌 Dataframes have column menus for users to sort and pin columns ([#10206](https://github.com/streamlit/streamlit/pull/10206)).
- 🚦 Dataframes support categorical indices ([#9647](https://github.com/streamlit/streamlit/issues/9647), [#10195](https://github.com/streamlit/streamlit/pull/10195)).
- 🛸 Dataframes show a hover highlight on rows ([#8096](https://github.com/streamlit/streamlit/issues/8096), [#10104](https://github.com/streamlit/streamlit/pull/10104)).
- ⚠️ When dataframes have cell values that are inconsistent with their configured type, Streamlit shows a tooltip describing the error ([#8253](https://github.com/streamlit/streamlit/issues/8253), [#9899](https://github.com/streamlit/streamlit/pull/9899)).
- ➰ If there is an existing asyncio event loop when a Streamlit app starts, the app will reuse it instead of creating a new one ([#10164](https://github.com/streamlit/streamlit/pull/10164)). Thanks, [DeltaGa](https://github.com/DeltaGa)!
- 🖼️ Streamlit recognizes `pyspark.sql.connect.dataframe.DataFrame` objects as dataframes ([#9953](https://github.com/streamlit/streamlit/issues/9953), [#9954](https://github.com/streamlit/streamlit/pull/9954)). Thanks, [OSalama](https://github.com/OSalama)!
- 😃 We've updated emoji validation for new emojis ([#10149](https://github.com/streamlit/streamlit/pull/10149)).
- 🔣 Material Symbols have been updated with the latest icons ([#10247](https://github.com/streamlit/streamlit/pull/10247)).
- 💅 Visual tweaks and improvements ([#8705](https://github.com/streamlit/streamlit/issues/8705), [#9823](https://github.com/streamlit/streamlit/pull/9823), [#10047](https://github.com/streamlit/streamlit/pull/10047), [#10048](https://github.com/streamlit/streamlit/pull/10048), [#10083](https://github.com/streamlit/streamlit/pull/10083), [#10087](https://github.com/streamlit/streamlit/pull/10087), [#10225](https://github.com/streamlit/streamlit/pull/10225)).
- ⭕ `st.image` displays rounded corners for consistent design ([#9999](https://github.com/streamlit/streamlit/pull/9999)).
- 🎩 Bug fix: Top margin is applied correctly in `st.columns` ([#10265](https://github.com/streamlit/streamlit/issues/10265), [#10268](https://github.com/streamlit/streamlit/pull/10268)).
- 💩 Bug fix: `react-syntax-highlighter` is aliased to prevent rendering errors in `st.code` ([#10231](https://github.com/streamlit/streamlit/issues/10231), [#10244](https://github.com/streamlit/streamlit/pull/10244)).
- 🧹 Bug fix: We improved error messages for `st.query_params` ([#10111](https://github.com/streamlit/streamlit/issues/10111), [#10237](https://github.com/streamlit/streamlit/pull/10237)).
- 🪱 Bug fix: Linting for `st.altair_chart` recognizes all Altair chart types ([#10202](https://github.com/streamlit/streamlit/pull/10202)).
- ↗️ Bug fix: `st.dataframe` supports raw Arrow data ([#5606](https://github.com/streamlit/streamlit/issues/5606), [#10191](https://github.com/streamlit/streamlit/pull/10191)).
- 🐍 Bug fix: `st.navigation` and `st.page_link` work when running in pure Python tests ([#10163](https://github.com/streamlit/streamlit/pull/10163)).
- ☠️ Bug fix: Retries were added to prevent a possible race condition when files are removed while Streamlit is running ([#10148](https://github.com/streamlit/streamlit/pull/10148)).
- 👽 Bug fix: When printing an app, `st.logo` will only print once ([#10165](https://github.com/streamlit/streamlit/issues/10165), [#10171](https://github.com/streamlit/streamlit/pull/10171)).
- 🌍 Bug fix: Material icons are marked to prevent translation ([#10168](https://github.com/streamlit/streamlit/issues/10168), [#10174](https://github.com/streamlit/streamlit/pull/10174)).
- 👻 Bug fix: `st.vega_lite_chart` correctly caches and updates its data ([#6689](https://github.com/streamlit/streamlit/issues/6689), [#10125](https://github.com/streamlit/streamlit/pull/10125)).
- 🦀 Bug fix: When a fragment ID is not found, Streamlit logs a warning but doesn't raise an error ([#9921](https://github.com/streamlit/streamlit/issues/9921), [#10130](https://github.com/streamlit/streamlit/pull/10130)).
- 🦋 Bug fix: The label on `st.expander` correctly fades when stale ([#10085](https://github.com/streamlit/streamlit/pull/10085)).
- 🦎 Bug fix: `st.date_input` provides better type hinting for its return value ([#9477](https://github.com/streamlit/streamlit/issues/9477), [#9620](https://github.com/streamlit/streamlit/pull/9620)). Thanks, [pranaybattu](https://github.com/pranaybattu)!
- 🐌 Bug fix: In dataframes, small float values display their first significant figure instead of displaying as 0 ([#10060](https://github.com/streamlit/streamlit/pull/10060)).
- 🕸️ Bug fix: When `rich` is installed, errors are only logged once. ([#10097](https://github.com/streamlit/streamlit/pull/10097)).
- 🦗 Bug fix: `st.text` preserves whitespace ([#10055](https://github.com/streamlit/streamlit/issues/10055), [#10062](https://github.com/streamlit/streamlit/pull/10062)).
- 🦂 Bug fix: Dataframe `width` is not ignored when `height` is changed ([#9762](https://github.com/streamlit/streamlit/issues/9762), [#10036](https://github.com/streamlit/streamlit/pull/10036)).
- 🦟 Bug fix: Multi index columns correctly handle empty labels ([#9749](https://github.com/streamlit/streamlit/issues/9749), [#10035](https://github.com/streamlit/streamlit/pull/10035)).
- 🦠 Bug fix: Pinned columns respect `column_order` in when configured in `st.dataframe` ([#9997](https://github.com/streamlit/streamlit/issues/9997), [#10034](https://github.com/streamlit/streamlit/pull/10034)).
- 🪰 Bug fix: Tooltips don't overflow to the left or right ([#9288](https://github.com/streamlit/streamlit/issues/9288), [#9452](https://github.com/streamlit/streamlit/issues/9452), [#9983](https://github.com/streamlit/streamlit/pull/9983)).
- 🪳 Bug fix: Disabled feedback widgets correctly show their value ([#10030](https://github.com/streamlit/streamlit/pull/10030)).
- 🕷️ Bug fix: Widgets correctly submit values if a user edits the value and immediately clicks a button ([#10007](https://github.com/streamlit/streamlit/issues/10007), [#10018](https://github.com/streamlit/streamlit/pull/10018)).
- 🐞 Bug fix: Some MIME types have been hardcoded to protect against browser misconfiguration ([#10004](https://github.com/streamlit/streamlit/issues/10004), [#10010](https://github.com/streamlit/streamlit/pull/10010)).
- 🐝 Bug fix: Files that unnecessarily inflated Streamlit's installation size were removed ([#10008](https://github.com/streamlit/streamlit/issues/10008), [#10011](https://github.com/streamlit/streamlit/pull/10011)).
- 🐜 Bug fix: `st.date_input` gives the correct type hint for the `value` parameter ([#10005](https://github.com/streamlit/streamlit/issues/10005), [#10006](https://github.com/streamlit/streamlit/pull/10006)).
- 🪲 Bug fix: `st.write` passes to `st.html` when `._repr_html()` is present for an object ([#9910](https://github.com/streamlit/streamlit/pull/9910)).
- 🐛 Bug fix: `st.html` preserves `target=_blank` if set in an HTML string ([#9972](https://github.com/streamlit/streamlit/issues/9972), [#9994](https://github.com/streamlit/streamlit/pull/9994)).</style>

---

# 教程

Source: https://docs.streamlit.io/develop/tutorials


我们的教程包括在 Streamlit 中构建不同类型应用的分步示例。

<TileContainer layout="list">
<RefCard href="/develop/tutorials/authentication">
<h5>添加用户身份验证</h5>

使用 Streamlit 对 OpenID Connect 的内置支持添加用户身份验证。

</RefCard>
<RefCard href="/develop/tutorials/chat-and-llm-apps">
<h5>聊天应用和大语言模型</h5>

使用大语言模型并创建聊天应用。

</RefCard>
<RefCard href="/develop/tutorials/configuration-and-theming">
<h5>配置和主题</h5>

自定义您的应用的外观。

</RefCard>
<RefCard href="/develop/tutorials/databases">
<h5>连接到数据源</h5>

连接到流行的数据源。

</RefCard>
<RefCard href="/develop/tutorials/elements">
<h5>使用 Streamlit 的核心元素</h5>

使用数据框和图表等核心元素。

</RefCard>
<RefCard href="/develop/tutorials/execution-flow">
<h5>使用核心功能来处理 Streamlit 的执行模型</h5>

构建简单应用并通过示例来了解 Streamlit 的核心功能和执行模型。

</RefCard>
<RefCard href="/develop/tutorials/multipage">
<h5>创建多页应用</h5>

创建多页应用、导航和流程。

</RefCard>
</TileContainer>

完成应用开发后，也请查看我们的 [部署教程](/deploy/tutorials)！

---

# Authenticate users and personalize your app

Source: https://docs.streamlit.io/develop/tutorials/authentication


Streamlit supports user authentication with the OpenID Connect (OIDC) protocol. You can use any OIDC provider. Whether you want to create a social login or manage your enterprise users, Streamlit makes it simple to authenticate your users.

<TileContainer layout="list">
<RefCard href="/develop/tutorials/authentication/google">
<h5>Google Auth Platform</h5>
        Google is one of the most popular identity providers for social logins. You can use the Google Auth Platform with any Google account, including personal and organization accounts.
    </RefCard>
<RefCard href="/develop/tutorials/authentication/microsoft">
<h5>Microsoft Entra</h5>
        Microsoft is popular for both social and business logins. You can include personal, school, or work accounts in your integration.
    </RefCard>
</TileContainer>

---

# Use the Google Auth Platform to authenticate users

Source: https://docs.streamlit.io/develop/tutorials/authentication/google


Google is one of the most popular identity providers for social logins. You can use the Google Auth Platform with both private and organizational Google accounts. This tutorial configures authentication for anyone with a Google account. For more information, see Google's overview of the [Google Auth Platform](https://support.google.com/cloud/topic/15540269?hl=en=3473162=576431444945556851-NC) and [OpenID Connect](https://developers.google.com/identity/openid-connect/openid-connect#discovery).

## Prerequisites

- This tutorial requires the following Python libraries:

  ```text
  streamlit&gt;=1.42.0
  Authlib&gt;=1.3.2
  ```

- You should have a clean working directory called `your-repository`.
- You must have a Google account and accept the terms of [Google Cloud](https://console.cloud.google.com/) to use their authentication service.
- You must have a project in Google Cloud within which to create your application.
  For more information about managing your projects in Google Cloud, see [Creating and managing projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects) in Google's documentation.

## Summary

In this tutorial, you'll build an app that users can log in to with their Google accounts. When they log in, they'll see a personalized greeting with their name and have the option to log out.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

`.streamlit/secrets.toml`

```toml
[auth]
redirect_uri = "http://localhost:8501/oauth2callback"
cookie_secret = "xxx"
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://accounts.google.com/.well-known/openid-configuration"
```

`app.py`

```python
import streamlit as st

def login_screen():
    st.header("This app is private.")
    st.subheader("Please log in.")
    st.button("Log in with Google", on_click=st.login)

if not st.user.is_logged_in:
    login_screen()
else:
    st.header(f"Welcome, {st.user.name}!")
    st.button("Log out", on_click=st.logout)
```

</Collapse>

## Create a web application in Google Cloud Console

In this section, you'll complete three steps to create your web application in your project in Google Cloud Console:

- Configure your consent screen.
- Configure your audience.
- Configure your client.

The consent screen is what users see from Google within the authentication flow. The audience settings manage your application's status (_Testing_ or _Published_). Creating a client for your web application generates the ID and secrets needed to configure your Streamlit app. To learn more about consent screens, audience, and clients, see Google's overview of the [Google Auth Platform](https://support.google.com/cloud/topic/15540269?hl=en=3473162=576431444945556851-NC).

### Configure your consent screen

1. Go to the [Google Auth Platform](https://console.cloud.google.com/auth/overview), and sign in to Google.

1. In the upper-left corner, select your project.

1. In the left navigation menu, select "**Branding**."

1. Fill in the required information for your application's consent screen.

   This information controls what users see within the Google authentication flow. Your "**App name**" is displayed to users within Google's prompts. Google asks users to consent to sending their account information to your application. If you are developing locally and/or deploying on Streamlit Community Cloud, in "**Authorized domain**," use `example.com`. For more information about the available fields, see [Setting up your OAuth consent screen](https://support.google.com/cloud/answer/10311615).

1. At the bottom of the branding page, select "**SAVE**."

### Configure your audience

1. In the left navigation menu, select "**Audience**."

1. Below "OAuth user cap" → "Test users," select "**ADD USERS**."

1. Enter the email address for a personal Google account, and select "**SAVE**."

   When you create a new application in the Google Auth Platform, its status is _Testing_. While the status is _Testing_, only specific users can authenticate to your application; users can't register themselves. Therefore, add any email address you want to use for testing your app in development. When you're ready to publish your app, you'll return to this section and change the status to _Published_. After an application is published, your application will accept new users.

### Configure your client

1. In the left navigation menu, select "**Clients**."

1. At the top of the client list, select "**CREATE CLIENT**."

1. For the application type, select "**Web application**."

1. Enter a unique name for your application.

   The client name is used internally and not shown to your users.

1. Skip over "Authorized JavaScript origins."

1. Under "Authorized redirect URIs," select "**ADD URI**."

1. Enter your app's URL with the pathname `oauth2callback`.

   For example, if you are developing locally, enter `http://localhost:8501/oauth2callback`. If you are using a different port, change `8501` to match your port.

1. Optional: Add additional authorized redirect URIs.

   If you will host your app from multiple URLs, or if you know a URL you will use in the future, you can add it now. Ensure that each URL includes the `oauth2callback` pathname.

1. At the bottom of the screen, select "**CREATE**."

You now have a client in Google Cloud that's ready to authenticate your users.

### Gather your application's details

1. From the clients page, select your new client.

1. To store your app information to use in later steps, open a text editor, or (even better) create a new item in a password locker.

   Always handle your app secrets securely. Remember to label the values as you paste them so you don't mix them up.

1. On the right, copy your "Client ID" and "Client secret" into your text editor.

For the Google Auth Platform, the server metadata URL is shared between all applications and isn't listed individually in your client. The server metadata URL for the Google Auth Platform is `https://accounts.google.com/.well-known/openid-configuration`. For more information about the server metadata URL, see [The discovery document](https://developers.google.com/identity/openid-connect/openid-connect#discovery) in Google's documentation.

## Build the example

To create an app with user authentication, you'll need to configure your secrets and prompt your users to log in. You'll use secrets management to store the information from your client, and then create a simple app that welcomes your user by name after they log in.

### Configure your secrets

1. In `your_repository`, create a `.streamlit/secrets.toml` file.

1. Add `secrets.toml` to your `.gitignore` file.

   <Important>
      Never commit secrets to your repository. For more information about `.gitignore`, see [Ignoring files](https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files).
   </Important>

1. Generate a strong, random secret to use as your cookie secret.

   The cookie secret is used to sign each user's identity cookie, which Streamlit stores when they log in.

1. In `.streamlit/secrets.toml`, add your connection configuration:

   ```toml
   [auth]
   redirect_uri = "http://localhost:8501/oauth2callback"
   cookie_secret = "xxx"
   client_id = "xxx"
   client_secret = "xxx"
   server_metadata_url = "https://accounts.google.com/.well-known/openid-configuration"
   ```

   Replace the values of `client_id` and `client_secret` with the values you copied into your text editor earlier. Replace the value of `cookie_secret` with the random secret you generated in the previous step.

1. Save your `secrets.toml` file.

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
   import streamlit as st
   ```

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Log the user in and out

1. Define a function that prompts the user to log in:

   ```python
   def login_screen():
       st.header("This app is private.")
       st.subheader("Please log in.")
       st.button("Log in with Google", on_click=st.login)
   ```

   This function displays a short message and a button. Streamlit's login command is assigned to the button as a callback.

   <Note>
      If you don't want to use a callback, you can replace the last line with an equivalent `if` statement:
      ```diff
      -  st.button("Log in with Google", on_click=st.login)
      +  if st.button("Log in with Google"):
      +     st.login()
      ```
   </Note>

1. Conditioned on whether the user is logged in, call your function to prompt the user, or show their information:

   ```python
   if not st.user.is_logged_in:
       login_screen()
   else:
       st.user
   ```

   Because `st.user` is a dict-like object in a line by itself, Streamlit magic displays it in your app.

1. Save your `app.py` file, and test your running app.

   In your live preview, when you log in to your app, the login button is replaced with the contents of your identity token. Observe the different values that are available from Google. You can use these values to personalize your app for your users.

1. Return to your code.

1. Replace `st.user` with a personalized greeting:

   ```diff
   else:
   -   st.user
   +   st.header(f"Welcome, {st.user.name}!")
   ```

1. Add a logout button:

   ```python
       st.button("Log out", on_click=st.logout)
   ```

1. Save your `app.py` file and test your running app.

   In your live preview, if you log out of your app, it will return to the login prompt.

## Deploy your app on Community Cloud

When you are ready to deploy your app, you must update your application on Google Cloud and your secrets. The following steps describe how to deploy your app on Community Cloud.

1. Add a `requirements.txt` file to your repository with the following lines:

   ```txt
   streamlit&gt;=1.42.0
   Authlib&gt;=1.3.2
   ```

   This ensures that the correct Python dependencies are installed for your deployed app.

1. Save your `requirements.txt` file.

1. Deploy your app, and copy your app's URL into your text editor.

   You'll use your app's URL to update your secrets and client configuration in the following steps. For more information about deploying an app on Community Cloud, see [Deploy your app](/deploy/streamlit-community-cloud/deploy-your-app).

1. In your [app settings](/deploy/streamlit-community-cloud/manage-your-app/app-settings) in Community Cloud, select "**Secrets**."

1. Copy the contents of your local `secrets.toml` file, and paste them into your app settings.

1. Change your `redirect_uri` to reflect your deployed app's URL, which you copied earlier in this tutorial.

   For example, if your app is `my_streamlit_app.streamlit.io`, your redirect URI would be `https://my_streamlit_app.streamlit.io/oauth2callback`.

1. Save and close your settings.

1. Return to the clients page in the Google Auth Platform, and select your client.

1. Under "Authorized redirect URIs," add or update a URI to match your new `redirect_uri`.

1. At the bottom of the page, select "**SAVE**."

1. Open your deployed app, and test it.

   Your Google Cloud application's status is still _Testing_. You should be able to log in and out of your app with the personal Google account you entered on the "Audience" page.

1. When you are ready for others to use your app, return to the "Audience" page in the Google Auth Platform, and set your application status to _Published_.

---

# Use Microsoft Entra to authenticate users

Source: https://docs.streamlit.io/develop/tutorials/authentication/microsoft


[Microsoft Identity Platform](https://learn.microsoft.com/en-us/entra/identity-platform/v2-overview) is a service within Microsoft Entra that lets you build applications to authenticate users. Your applications can use personal, work, and school accounts managed by Microsoft.

## Prerequisites

- This tutorial requires the following Python libraries:

  ```text
  streamlit&gt;=1.42.0
  Authlib&gt;=1.3.2
  ```

- You should have a clean working directory called `your-repository`.
- You must have a Microsoft Azure account, which includes Microsoft Entra ID.

## Summary

In this tutorial, you'll build an app that users can log in to with their personal Microsoft accounts. When they log in, they'll see a personalized greeting with their name and have the option to log out.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

`.streamlit/secrets.toml`

```toml
[auth]
redirect_uri = "http://localhost:8501/oauth2callback"
cookie_secret = "xxx"
client_id = "xxx"
client_secret = "xxx"
server_metadata_url = "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration"
```

`app.py`

```python
import streamlit as st

def login_screen():
    st.header("This app is private.")
    st.subheader("Please log in.")
    st.button("Log in with Microsoft", on_click=st.login)

if not st.user.is_logged_in:
    login_screen()
else:
    st.header(f"Welcome, {st.user.name}!")
    st.button("Log out", on_click=st.logout)
```

</Collapse>

## Create a web application in Microsoft Entra ID

Within Microsoft Entra ID in Azure, you'll need to register a new application and generate a secret needed to configure your app. In this example, your application will only accept personal Microsoft accounts, but you can optionally accept work and school accounts or restrict the application to your personal tenant. Microsoft Entra also lets you connect other, external identity providers.

### Register a new application

1. Go to [Microsoft Azure](https://portal.azure.com/#home), and sign in to Microsoft.

1. At the top of the page among the services, select "**Microsoft Entra ID**."

1. In the left navigation, select "**Manage**" → "**App registrations**."

1. At the top of the screen, select "**New registration**."

1. Fill in a name for your application.

   The application name will be visible to your users within the authentication flow presented by Microsoft.

1. Under "Supported account types," select "**Personal Microsoft accounts only**."

1. Under "Redirect URI," select a "**Web**" platform, and enter your app's URL with the pathname `oauth2callback`.

   For example, if you are developing locally, enter `http://localhost:8501/oauth2callback`. If you are using a different port, change `8501` to match your port.

1. At the bottom of the screen, select "**Register**."

   Microsoft will redirect you to your new application, a resource within Azure.

### Gather your application's details

1. To store your app information to use in later steps, open a text editor, or (even better) create a new item in a password locker.

   Always handle your app secrets securely. Remember to label the values as you paste them so you don't mix them up.

1. Under "Essentials," copy the "Application (client) ID" into your text editor.

   This is your `client_id`.

1. At the top of the page, select "**Endpoints**."

1. Copy the "OpenID Connect metadata document" into your text editor.

   This is your `server_metadata_url`.

1. In the left navigation, select "**Manage**" → "**Certificates  secrets**."

1. Near the top, select "**New client secret**."

1. Enter a description, and select an expiration time.

   The description is only used internally. You will use the generated secret to configure your Streamlit app, so choose a description that helps you remember where you use the secret.

1. At the bottom of the dialog, select "**Add**."

   It may take a few seconds for Azure to generate your secret.

1. Copy the "Value" into your text editor.

   This is your `client_secret`. Microsoft will hide the value after you leave Azure, so ensure that you securely store it somewhere now. If you lose your secret, you'll need to delete it from your configuration and generate a new one.

Your client is ready to accept users.

## Build the example

To create an app with user authentication, you'll need to configure your secrets and prompt your users to log in. You'll use secrets management to store the information from your client, and then create a simple app that welcomes your user by name after they log in.

### Configure your secrets

1. In `your_repository`, create a `.streamlit/secrets.toml` file.

1. Add `secrets.toml` to your `.gitignore` file.

   <Important>
      Never commit secrets to your repository. For more information about `.gitignore`, see [Ignoring files](https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files).
   </Important>

1. Generate a strong, random secret to use as your cookie secret.

   The cookie secret is used to sign each user's identity cookie, which Streamlit stores when they log in.

1. In `.streamlit/secrets.toml`, add your connection configuration:

   ```toml
    [auth]
    redirect_uri = "http://localhost:8501/oauth2callback"
    cookie_secret = "xxx"
    client_id = "xxx"
    client_secret = "xxx"
    server_metadata_url = "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration"
   ```

   Replace the values of `client_id`, `client_secret`, and `server_metadata_url` with the values you copied into your text editor earlier. Replace the value of `cookie_secret` with the random secret you generated in the previous step.

1. Save your `secrets.toml` file.

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
   import streamlit as st
   ```

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Log the user in and out

1. Define a function that prompts the user to log in:

   ```python
   def login_screen():
       st.header("This app is private.")
       st.subheader("Please log in.")
       st.button("Log in with Microsoft", on_click=st.login)
   ```

   This function displays a short message and a button. Streamlit's login command is assigned to the button as a callback.

   <Note>
      If you don't want to use a callback, you can replace the last line with an equivalent `if` statement:
      ```diff
      -  st.button("Log in with Microsoft", on_click=st.login)
      +  if st.button("Log in with Microsoft"):
      +     st.login()
      ```
   </Note>

1. Conditioned on whether the user is logged in, call your function to prompt the user, or show their information:

   ```python
   if not st.user.is_logged_in:
       login_screen()
   else:
       st.user
   ```

   Because `st.user` is a dict-like object in a line by itself, Streamlit magic displays it in your app.

1. Save your `app.py` file, and test your running app.

   In your live preview, when you log in to your app, the login button is replaced with the contents of your identity token. Observe the different values that are available from Microsoft. You can use these values to personalize your app for your users.

1. Return to your code.

1. Replace `st.user` with a personalized greeting:

   ```diff
   else:
   -   st.user
   +   st.header(f"Welcome, {st.user.name}!")
   ```

1. Add a logout button:

   ```python
       st.button("Log out", on_click=st.logout)
   ```

1. Save your `app.py` file and test your running app.

   In your live preview, if you log out of your app, it will return to the login prompt.

## Deploy your app on Community Cloud

When you are ready to deploy your app, you must update your application in Microsoft Azure and your secrets. The following steps describe how to deploy your app on Community Cloud.

1. Add a `requirements.txt` file to your repository with the following lines:

   ```txt
   streamlit&gt;=1.42.0
   Authlib&gt;=1.3.2
   ```

   This ensures that the correct Python dependencies are installed for your deployed app.

1. Save your `requirements.txt` file.

1. Deploy your app, and copy your app's URL into your text editor.

   You'll use your app's URL to update your secrets and application configuration in the following steps. For more information about deploying an app on Community Cloud, see [Deploy your app](/deploy/streamlit-community-cloud/deploy-your-app).

1. In your [app settings](/deploy/streamlit-community-cloud/manage-your-app/app-settings) in Community Cloud, select "**Secrets**."

1. Copy the contents of your local `secrets.toml` file, and paste them into your app settings.

1. Change your `redirect_uri` to reflect your deployed app's URL.

   For example, if your app is `my_streamlit_app.streamlit.io`, your redirect URI would be `https://my_streamlit_app.streamlit.io/oauth2callback`.

1. Save and close your settings.

1. Return to your application in Microsoft Azure.

   If you've closed Microsoft Azure and need to navigate back to your application, go to your Azure portal → Microsoft Entra ID → App registrations, and select it from the list.

1. In the left navigation, select "**Authentication**."

1. Under "Platform configurations" → "Web," add or update a URI to match your new `redirect_uri`.

1. At the bottom of the page, select "**Save**."

1. Open your deployed app, and test it.

---

# Build LLM apps

Source: https://docs.streamlit.io/develop/tutorials/chat-and-llm-apps


<TileContainer layout="list">
<RefCard href="/develop/tutorials/llms/build-conversational-apps">
<h5>Build a basic chat app</h5>

Build a simple OpenAI chat app to get started with Streamlit's chat elements.

</RefCard>
<RefCard href="/develop/tutorials/llms/llm-quickstart">
<h5>Build an LLM app using LangChain</h5>

Build a chat app using the LangChain framework with OpenAI.

</RefCard>
<RefCard href="/develop/tutorials/chat-and-llm-apps/chat-response-feedback">
<h5>Get chat response feedback</h5>

Buid a chat app and let users rate the responses.
(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;thumb_up</i>
<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;thumb_down</i>)

</RefCard>
<RefCard href="/develop/tutorials/chat-and-llm-apps/validate-and-edit-chat-responses">
<h5>Validate and edit chat responses</h5>

Build a chat app with response validation. Let users correct or edit the responses.

</RefCard>
</TileContainer>

---

# Build a basic LLM chat app

Source: https://docs.streamlit.io/develop/tutorials/chat-and-llm-apps/build-conversational-apps


## Introduction

The advent of large language models like GPT has revolutionized the ease of developing chat-based applications. Streamlit offers several [Chat elements](/develop/api-reference/chat), enabling you to build Graphical User Interfaces (GUIs) for conversational agents or chatbots. Leveraging [session state](/develop/concepts/architecture/session-state) along with these elements allows you to construct anything from a basic chatbot to a more advanced, ChatGPT-like experience using purely Python code.

In this tutorial, we'll start by walking through Streamlit's chat elements, `st.chat_message` and `st.chat_input`. Then we'll proceed to construct three distinct applications, each showcasing an increasing level of complexity and functionality:

1. First, we'll [Build a bot that mirrors your input](#build-a-bot-that-mirrors-your-input) to get a feel for the chat elements and how they work. We'll also introduce [session state](/develop/concepts/architecture/session-state) and how it can be used to store the chat history. This section will serve as a foundation for the rest of the tutorial.
2. Next, you'll learn how to [Build a simple chatbot GUI with streaming](#build-a-simple-chatbot-gui-with-streaming).
3. Finally, we'll [Build a ChatGPT-like app](#build-a-chatgpt-like-app) that leverages session state to remember conversational context, all within less than 50 lines of code.

Here's a sneak peek of the LLM-powered chatbot GUI with streaming we'll build in this tutorial:

<Cloud height="700px" name="doc-chat-llm"/>

Play around with the above demo to get a feel for what we'll build in this tutorial. A few things to note:

- There's a chat input at the bottom of the screen that's always visible. It contains some placeholder text. You can type in a message and press Enter or click the run button to send it.
- When you enter a message, it appears as a chat message in the container above. The container is scrollable, so you can scroll up to see previous messages. A default avatar is displayed to your messages' left.
- The assistant's responses are streamed to the frontend and are displayed with a different default avatar.

Before we start building, let's take a closer look at the chat elements we'll use.

## Chat elements

Streamlit offers several commands to help you build conversational apps. These chat elements are designed to be used in conjunction with each other, but you can also use them separately.

[`st.chat_message`](/develop/api-reference/chat/st.chat_message) lets you insert a chat message container into the app so you can display messages from the user or the app. Chat containers can contain other Streamlit elements, including charts, tables, text, and more. [`st.chat_input`](/develop/api-reference/chat/st.chat_input) lets you display a chat input widget so the user can type in a message.

For an overview of the API, check out this video tutorial by Chanin Nantasenamat ([@dataprofessor](https://www.youtube.com/dataprofessor)), a Senior Developer Advocate at Streamlit.

<YouTube videoId="4sPnOqeUDmk"/>

### st.chat_message

`st.chat_message` lets you insert a multi-element chat message container into your app. The returned container can contain any Streamlit element, including charts, tables, text, and more. To add elements to the returned container, you can use `with` notation.

`st.chat_message`'s first parameter is the `name` of the message author, which can be either `"user"` or `"assistant"` to enable preset styling and avatars, like in the demo above. You can also pass in a custom string to use as the author name. Currently, the name is not shown in the UI but is only set as an accessibility label. For accessibility reasons, you should not use an empty string.

Here's an minimal example of how to use `st.chat_message` to display a welcome message:

```python
import streamlit as st

with st.chat_message("user"):
    st.write("Hello 👋")
```

<Image src="/images/knowledge-base/chat-message-hello.png"/>
<br/>

Notice the message is displayed with a default avatar and styling since we passed in `"user"` as the author name. You can also pass in `"assistant"` as the author name to use a different default avatar and styling, or pass in a custom name and avatar. See the [API reference](/develop/api-reference/chat/st.chat_message) for more details.

```python
import streamlit as st
import numpy as np

with st.chat_message("assistant"):
    st.write("Hello human")
    st.bar_chart(np.random.randn(30, 3))
```

<Cloud height="450px" name="doc-chat-message-user1"/>

While we've used the preferred `with` notation in the above examples, you can also just call methods directly in the returned objects. The below example is equivalent to the one above:

```python
import streamlit as st
import numpy as np

message = st.chat_message("assistant")
message.write("Hello human")
message.bar_chart(np.random.randn(30, 3))
```

So far, we've displayed predefined messages. But what if we want to display messages based on user input?

### st.chat_input

`st.chat_input` lets you display a chat input widget so the user can type in a message. The returned value is the user's input, which is `None` if the user hasn't sent a message yet. You can also pass in a default prompt to display in the input widget. Here's an example of how to use `st.chat_input` to display a chat input widget and show the user's input:

```python
import streamlit as st

prompt = st.chat_input("Say something")
if prompt:
    st.write(f"User has sent the following prompt: {prompt}")
```

<Cloud height="350px" name="doc-chat-input"/>

Pretty straightforward, right? Now let's combine `st.chat_message` and `st.chat_input` to build a bot the mirrors or echoes your input.

## Build a bot that mirrors your input

In this section, we'll build a bot that mirrors or echoes your input. More specifically, the bot will respond to your input with the same message. We'll use `st.chat_message` to display the user's input and `st.chat_input` to accept user input. We'll also use [session state](/develop/concepts/architecture/session-state) to store the chat history so we can display it in the chat message container.

First, let's think about the different components we'll need to build our bot:

- Two chat message containers to display messages from the user and the bot, respectively.
- A chat input widget so the user can type in a message.
- A way to store the chat history so we can display it in the chat message containers. We can use a list to store the messages, and append to it every time the user or bot sends a message. Each entry in the list will be a dictionary with the following keys: `role` (the author of the message), and `content` (the message content).

```python
import streamlit as st

st.title("Echo Bot")

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages from history on app rerun
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])
```

In the above snippet, we've added a title to our app and a for loop to iterate through the chat history and display each message in the chat message container (with the author role and message content). We've also added a check to see if the `messages` key is in `st.session_state`. If it's not, we initialize it to an empty list. This is because we'll be adding messages to the list later on, and we don't want to overwrite the list every time the app reruns.

Now let's accept user input with `st.chat_input`, display the user's message in the chat message container, and add it to the chat history.

```python
# React to user input
if prompt := st.chat_input("What is up?"):
    # Display user message in chat message container
    with st.chat_message("user"):
        st.markdown(prompt)
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
```

We used the `:=` operator to assign the user's input to the `prompt` variable and checked if it's not `None` in the same line. If the user has sent a message, we display the message in the chat message container and append it to the chat history.

All that's left to do is add the chatbot's responses within the `if` block. We'll use the same logic as before to display the bot's response (which is just the user's prompt) in the chat message container and add it to the history.

```python
response = f"Echo: {prompt}"
# Display assistant response in chat message container
with st.chat_message("assistant"):
    st.markdown(response)
# Add assistant response to chat history
st.session_state.messages.append({"role": "assistant", "content": response})
```

Putting it all together, here's the full code for our simple chatbot GUI and the result:

<Collapse title="View full code">{false}&gt;

```python
import streamlit as st

st.title("Echo Bot")

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages from history on app rerun
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# React to user input
if prompt := st.chat_input("What is up?"):
    # Display user message in chat message container
    st.chat_message("user").markdown(prompt)
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})

    response = f"Echo: {prompt}"
    # Display assistant response in chat message container
    with st.chat_message("assistant"):
        st.markdown(response)
    # Add assistant response to chat history
    st.session_state.messages.append({"role": "assistant", "content": response})
```

</Collapse>
<Cloud height="700px" name="doc-chat-echo"/>

While the above example is very simple, it's a good starting point for building more complex conversational apps. Notice how the bot responds instantly to your input. In the next section, we'll add a delay to simulate the bot "thinking" before responding.

## Build a simple chatbot GUI with streaming

In this section, we'll build a simple chatbot GUI that responds to user input with a random message from a list of pre-determind responses. In the [next section](#build-a-chatgpt-like-app), we'll convert this simple toy example into a ChatGPT-like experience using OpenAI.

Just like previously, we still require the same components to build our chatbot. Two chat message containers to display messages from the user and the bot, respectively. A chat input widget so the user can type in a message. And a way to store the chat history so we can display it in the chat message containers.

Let's just copy the code from the previous section and add a few tweaks to it.

```python
import streamlit as st
import random
import time

st.title("Simple chat")

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages from history on app rerun
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Accept user input
if prompt := st.chat_input("What is up?"):
    # Display user message in chat message container
    with st.chat_message("user"):
        st.markdown(prompt)
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
```

The only difference so far is we've changed the title of our app and added imports for `random` and `time`. We'll use `random` to randomly select a response from a list of responses and `time` to add a delay to simulate the chatbot "thinking" before responding.

All that's left to do is add the chatbot's responses within the `if` block. We'll use a list of responses and randomly select one to display. We'll also add a delay to simulate the chatbot "thinking" before responding (or stream its response). Let's make a helper function for this and insert it at the top of our app.

```python
# Streamed response emulator
def response_generator():
    response = random.choice(
        [
            "Hello there! How can I assist you today?",
            "Hi, human! Is there anything I can help you with?",
            "Do you need help?",
        ]
    )
    for word in response.split():
        yield word + " "
        time.sleep(0.05)
```

Back to writing the response in our chat interface, we'll use `st.write_stream` to write out the streamed response with a typewriter effect.

```python
# Display assistant response in chat message container
with st.chat_message("assistant"):
    response = st.write_stream(response_generator())
# Add assistant response to chat history
st.session_state.messages.append({"role": "assistant", "content": response})
```

Above, we've added a placeholder to display the chatbot's response. We've also added a for loop to iterate through the response and display it one word at a time. We've added a delay of 0.05 seconds between each word to simulate the chatbot "thinking" before responding. Finally, we append the chatbot's response to the chat history. As you've probably guessed, this is a naive implementation of streaming. We'll see how to implement streaming with OpenAI in the [next section](#build-a-chatgpt-like-app).

Putting it all together, here's the full code for our simple chatbot GUI and the result:

<Collapse title="View full code">{false}&gt;

```python
import streamlit as st
import random
import time


# Streamed response emulator
def response_generator():
    response = random.choice(
        [
            "Hello there! How can I assist you today?",
            "Hi, human! Is there anything I can help you with?",
            "Do you need help?",
        ]
    )
    for word in response.split():
        yield word + " "
        time.sleep(0.05)


st.title("Simple chat")

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages from history on app rerun
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Accept user input
if prompt := st.chat_input("What is up?"):
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
    # Display user message in chat message container
    with st.chat_message("user"):
        st.markdown(prompt)

    # Display assistant response in chat message container
    with st.chat_message("assistant"):
        response = st.write_stream(response_generator())
    # Add assistant response to chat history
    st.session_state.messages.append({"role": "assistant", "content": response})
```

</Collapse>
<Cloud height="700px" name="doc-chat-simple"/>

Play around with the above demo to get a feel for what we've built. It's a very simple chatbot GUI, but it has all the components of a more sophisticated chatbot. In the next section, we'll see how to build a ChatGPT-like app using OpenAI.

## Build a ChatGPT-like app

Now that you've understood the basics of Streamlit's chat elements, let's make a few tweaks to it to build our own ChatGPT-like app. You'll need to install the [OpenAI Python library](https://pypi.org/project/openai/) and get an [API key](https://platform.openai.com/account/api-keys) to follow along.

### Install dependencies

First let's install the dependencies we'll need for this section:

```bash
pip install openai streamlit
```

### Add OpenAI API key to Streamlit secrets

Next, let's add our OpenAI API key to [Streamlit secrets](/develop/concepts/connections/secrets-management). We do this by creating `.streamlit/secrets.toml` file in our project directory and adding the following lines to it:

```toml
# .streamlit/secrets.toml
OPENAI_API_KEY = "YOUR_API_KEY"
```

### Write the app

Now let's write the app. We'll use the same code as before, but we'll replace the list of responses with a call to the OpenAI API. We'll also add a few more tweaks to make the app more ChatGPT-like.

```python
import streamlit as st
from openai import OpenAI

st.title("ChatGPT-like clone")

# Set OpenAI API key from Streamlit secrets
client = OpenAI(api_key=st.secrets["OPENAI_API_KEY"])

# Set a default model
if "openai_model" not in st.session_state:
    st.session_state["openai_model"] = "gpt-3.5-turbo"

# Initialize chat history
if "messages" not in st.session_state:
    st.session_state.messages = []

# Display chat messages from history on app rerun
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Accept user input
if prompt := st.chat_input("What is up?"):
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
    # Display user message in chat message container
    with st.chat_message("user"):
        st.markdown(prompt)
```

All that's changed is that we've added a default model to `st.session_state` and set our OpenAI API key from Streamlit secrets. Here's where it gets interesting. We can replace our emulated stream with the model's responses from OpenAI:

```python
    # Display assistant response in chat message container
    with st.chat_message("assistant"):
        stream = client.chat.completions.create(
            model=st.session_state["openai_model"],
            messages=[
                {"role": m["role"], "content": m["content"]}
                for m in st.session_state.messages
            ],
            stream=True,
        )
        response = st.write_stream(stream)
    st.session_state.messages.append({"role": "assistant", "content": response})
```

Above, we've replaced the list of responses with a call to [`OpenAI().chat.completions.create`](https://platform.openai.com/docs/guides/text-generation/chat-completions-api). We've set `stream=True` to stream the responses to the frontend. In the API call, we pass the model name we hardcoded in session state and pass the chat history as a list of messages. We also pass the `role` and `content` of each message in the chat history. Finally, OpenAI returns a stream of responses (split into chunks of tokens), which we iterate through and display each chunk.

Putting it all together, here's the full code for our ChatGPT-like app and the result:

<Collapse title="View full code">{false}&gt;

```python
from openai import OpenAI
import streamlit as st

st.title("ChatGPT-like clone")

client = OpenAI(api_key=st.secrets["OPENAI_API_KEY"])

if "openai_model" not in st.session_state:
    st.session_state["openai_model"] = "gpt-3.5-turbo"

if "messages" not in st.session_state:
    st.session_state.messages = []

for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

if prompt := st.chat_input("What is up?"):
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    with st.chat_message("assistant"):
        stream = client.chat.completions.create(
            model=st.session_state["openai_model"],
            messages=[
                {"role": m["role"], "content": m["content"]}
                for m in st.session_state.messages
            ],
            stream=True,
        )
        response = st.write_stream(stream)
    st.session_state.messages.append({"role": "assistant", "content": response})
```

<Image src="/images/knowledge-base/chatgpt-clone.gif"/>
</Collapse>
<Cloud height="700px" name="doc-chat-llm"/>

Congratulations! You've built your own ChatGPT-like app in less than 50 lines of code.

We're very excited to see what you'll build with Streamlit's chat elements. Experiment with different models and tweak the code to build your own conversational apps. If you build something cool, let us know on the [Forum](https://discuss.streamlit.io/c/streamlit-examples/9) or check out some other [Generative AI apps](https://streamlit.io/generative-ai) for inspiration. 🎈

---

# Collect user feedback about LLM responses

Source: https://docs.streamlit.io/develop/tutorials/chat-and-llm-apps/chat-response-feedback


A common task in a chat app is to collect user feedback about an LLM's responses. Streamlit includes `st.feedback` to conveniently collect user sentiment by displaying a group of selectable sentiment icons.

This tutorial uses Streamlit's chat commands and `st.feedback` to build a simple chat app that collects user feedback about each response.

## Applied concepts

- Use `st.chat_input` and `st.chat_message` to create a chat interface.
- Use `st.feedback` to collect user sentiment about chat responses.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.42.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of [Session State](/develop/concepts/architecture/session-state).

## Summary

In this example, you'll build a chat interface. To avoid API calls, the chat app will echo the user's prompt within a fixed response. Each chat response will be followed by a feedback widget where the user can vote "thumb up" or "thumb down." In the following code, a user can't change their feedback after it's given. If you want to let users change their rating, see the optional instructions at the end of this tutorial.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import time


def chat_stream(prompt):
    response = f'You said, "{prompt}" ...interesting.'
    for char in response:
        yield char
        time.sleep(0.02)


def save_feedback(index):
    st.session_state.history[index]["feedback"] = st.session_state[f"feedback_{index}"]


if "history" not in st.session_state:
    st.session_state.history = []

for i, message in enumerate(st.session_state.history):
    with st.chat_message(message["role"]):
        st.write(message["content"])
        if message["role"] == "assistant":
            feedback = message.get("feedback", None)
            st.session_state[f"feedback_{i}"] = feedback
            st.feedback(
                "thumbs",
                key=f"feedback_{i}",
                disabled=feedback is not None,
                on_change=save_feedback,
                args=[i],
            )

if prompt := st.chat_input("Say something"):
    with st.chat_message("user"):
        st.write(prompt)
    st.session_state.history.append({"role": "user", "content": prompt})
    with st.chat_message("assistant"):
        response = st.write_stream(chat_stream(prompt))
        st.feedback(
            "thumbs",
            key=f"feedback_{len(st.session_state.history)}",
            on_change=save_feedback,
            args=[len(st.session_state.history)],
        )
    st.session_state.history.append({"role": "assistant", "content": response})
```

</Collapse>
<Cloud height="600px" name="doc-tutorial-chat-response-feedback"/>

## Build the example

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
   import streamlit as st
   import time
   ```

   You'll use `time` to build a simulated chat response stream.

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Build a function to simulate a chat response stream

To begin, you'll define a function to stream a fixed chat response. You can skip this section if you just want to copy the function.

<Collapse title="Complete function to simulate a chat stream">{false}&gt;

```python
def chat_stream(prompt):
    response = f'You said, "{prompt}" ...interesting.'
    for char in response:
        yield char
        time.sleep(0.02)
```

</Collapse>

1. Define a function which accepts a prompt and formulates a response:

   ```python
   def chat_stream(prompt):
       response = f'You said, "{prompt}" ...interesting.'
   ```

1. Loop through the characters and yield each one at 0.02-second intervals:

   ```python
       for char in response:
           yield char
           time.sleep(.02)
   ```

You now have a complete generator function to simulate a chat stream object.

### Initialize and render your chat history

To make your chat app stateful, you'll save the conversation history into Session State as a list of messages. Each message is a dictionary of message attributes. The dictionary keys include the following:

- `"role"`: Indicates the source of the message (either `"user"` or `"assistant"`).
- `"content"`: The body of the message as a string.
- `"feedback"`: An integer that indicates a user's feedback. This is only included when the message role is `"assistant"` because users do not leave feedback on their own prompts.

1. Initialize the chat history in Session State:

   ```python
   if "history" not in st.session_state:
       st.session_state.history = []
   ```

1. Iterate through the messages in your chat history and render their contents in chat message containers:

   ```python
   for i, message in enumerate(st.session_state.history):
       with st.chat_message(message["role"]):
           st.write(message["content"])
   ```

   In a later step, you'll need a unique key for each assistant message. You can use the index of the message in your chat history to create a unique key. Therefore, use `enumerate()` to get an index along with each message dictionary.

1. For each assistant message, check whether feedback has been saved:

   ```python
           if message["role"] == "assistant":
               feedback = message.get("feedback", None)
   ```

   If no feedback is saved for the current message, the `.get()` method will return the specified default of `None`.

1. Save the feedback value into Session State under a unique key for that message:

   ```python
               st.session_state[f"feedback_{i}"] = feedback
   ```

   Because the message index within the ordered chat history is unique, you can use the index as the key. For readability, you can add a prefix, "feedback\_", to the index. In the next step, to make the feedback widget show this value, you'll assign the same key to the widget.

1. Add a feedback widget to the chat message container:

   ```python
               st.feedback(
                   "thumbs",
                   key=f"feedback_{i}",
                   disabled=feedback is not None,
               )
   ```

   The code you've written so far will show the chat history. If a user has already rated a message in the chat history, the feedback widget will show the rating and be disabled. The user won't be able to change their rating.

   All unrated messages include an enabled feedback widget. However, if a user interacts with one of those widgets, there is no code to save that information into the chat history yet. To solve this, use a callback as shown in the following steps.

1. At the top of your app, after the definition of `chat_stream()` and before you initialize your chat history, define a function to use as a callback:

   ```python
   def save_feedback(index):
       st.session_state.history[index]["feedback"] = st.session_state[f"feedback_{index}"]
   ```

   The `save_feedback()` function accepts an index and uses the index to get the associated widget value from Session State. Then, this value is saved into chat history.

1. Add the callback and index argument to your `st.feedback` widget:

   ```diff
               st.feedback(
                   "thumbs",
                   key=f"feedback_{i}",
                   disabled=feedback is not None,
   +               on_change=save_feedback,
   +               args=[i],
               )
   ```

   When a user interacts with the feedback widget, the callback will update the chat history before the app reruns.

### Add chat input

1. Accept the user's prompt from an `st.chat_input` widget, display it in a chat message container, and then save it to the chat history:

   ```python
   if prompt := st.chat_input("Say something"):
       with st.chat_message("user"):
           st.write(prompt)
       st.session_state.history.append({"role": "user", "content": prompt})
   ```

   The `st.chat_input` widget acts like a button. When a user enters a prompt and clicks the send icon, it triggers a rerun. During the rerun, the previous code displays the chat history. When this conditional block is executed, the user's new prompt is displayed and then added to the history. On the next rerun, this prompt will be displayed as part of the history.

   The `:=` notation is shorthand to assign a variable within an expression. The following code is equivalent to the previous code in this step:

   ```python
   prompt = st.chat_input("Say something")
   if prompt:
       with st.chat_message("user"):
           st.write(prompt)
       st.session_state.history.append({"role": "user", "content": prompt})
   ```

1. In another chat message container, process the prompt, display the response, add a feedback widget, and append the response to the chat history:

   ```python
      with st.chat_message("assistant"):
          response = st.write_stream(chat_stream(prompt))
          st.feedback(
              "thumbs",
              key=f"feedback_{len(st.session_state.history)}",
              on_change=save_feedback,
              args=[len(st.session_state.history)],
          )
      st.session_state.history.append({"role": "assistant", "content": response})
   ```

   This is the same pattern used for the user's prompt. Within the body of the conditional block, the response is displayed and then added to the history. On the next rerun, this response will be displayed as a part of the chat history.

   When Streamlit executes the `st.feedback` command, the response is not yet added to the chat history. Use an index equal to the length of the chat history because that is the index that the response will have when it's added to the chat history on the next line.

1. Save your file and go to your browser to try your new app.

### Optional: Change the feedback behavior

Your app currently allows users to rate any response once. They can submit their rating at any time, but can't change it.

If you want users to rate only the _most recent_ response, you can remove the widgets from the chat history:

```diff
  for i, message in enumerate(st.session_state.history):
      with st.chat_message(message["role"]):
          st.write(message["content"])
-         if message["role"] == "assistant":
-             feedback = message.get("feedback", None)
-             st.session_state[f"feedback_{i}"] = feedback
-             st.feedback(
-                 "thumbs",
-                 key=f"feedback_{i}",
-                 disabled=feedback is not None,
-                 on_change=save_feedback,
-                 args=[i],
-             )
```

Or, if you want to allow users to change their responses, you can just remove the `disabled` parameter:

```diff
  for i, message in enumerate(st.session_state.history):
      with st.chat_message(message["role"]):
          st.write(message["content"])
          if message["role"] == "assistant":
              feedback = message.get("feedback", None)
              st.session_state[f"feedback_{i}"] = feedback
              st.feedback(
                  "thumbs",
                  key=f"feedback_{i}",
-                 disabled=feedback is not None,
                  on_change=save_feedback,
                  args=[i],
              )
```

---

# Build an LLM app using LangChain

Source: https://docs.streamlit.io/develop/tutorials/chat-and-llm-apps/llm-quickstart


## OpenAI, LangChain, and Streamlit in 18 lines of code

In this tutorial, you will build a Streamlit LLM app that can generate text from a user-provided prompt. This Python app will use the LangChain framework and Streamlit. Optionally, you can deploy your app to [Streamlit Community Cloud](https://streamlit.io/cloud) when you're done.

_This tutorial is adapted from a blog post by Chanin Nantesanamat: [LangChain tutorial #1: Build an LLM-powered app in 18 lines of code](https://blog.streamlit.io/langchain-tutorial-1-build-an-llm-powered-app-in-18-lines-of-code/)._

<Cloud height="600px" name="doc-tutorial-llm-18-lines-of-code"/>

## Objectives

1. Get an OpenAI key from the end user.
2. Validate the user's OpenAI key.
3. Get a text prompt from the user.
4. Authenticate OpenAI with the user's key.
5. Send the user's prompt to OpenAI's API.
6. Get a response and display it.

Bonus: Deploy the app on Streamlit Community Cloud!

## Prerequisites

- Python 3.9+
- Streamlit
- LangChain
- [OpenAI API key](https://platform.openai.com/account/api-keys?ref=blog.streamlit.io)

## Setup coding environment

In your IDE (integrated coding environment), open the terminal and install the following two Python libraries:

```python
pip install streamlit langchain-openai
```

Create a `requirements.txt` file located in the root of your working directory and save these dependencies. This is necessary for deploying the app to the Streamlit Community Cloud later.

```python
streamlit
openai
langchain
```

## Building the app

The app is only 18 lines of code:

```python
import streamlit as st
from langchain_openai.chat_models import ChatOpenAI

st.title("🦜🔗 Quickstart App")

openai_api_key = st.sidebar.text_input("OpenAI API Key", type="password")


def generate_response(input_text):
    model = ChatOpenAI(temperature=0.7, api_key=openai_api_key)
    st.info(model.invoke(input_text))


with st.form("my_form"):
    text = st.text_area(
        "Enter text:",
        "What are the three key pieces of advice for learning how to code?",
    )
    submitted = st.form_submit_button("Submit")
    if not openai_api_key.startswith("sk-"):
        st.warning("Please enter your OpenAI API key!", icon="⚠")
    if submitted and openai_api_key.startswith("sk-"):
        generate_response(text)

```

To start, create a new Python file and save it as `streamlit_app.py` in the root of your working directory.

1. Import the necessary Python libraries.

   ```python
   import streamlit as st
   from langchain_openai.chat_models import ChatOpenAI
   ```

2. Create the app's title using `st.title`.

   ```python
   st.title("🦜🔗 Quickstart App")
   ```

3. Add a text input box for the user to enter their OpenAI API key.

   ```python
   openai_api_key = st.sidebar.text_input("OpenAI API Key", type="password")
   ```

4. Define a function to authenticate to OpenAI API with the user's key, send a prompt, and get an AI-generated response. This function accepts the user's prompt as an argument and displays the AI-generated response in a blue box using `st.info`.

   ```python
   def generate_response(input_text):
       model = ChatOpenAI(temperature=0.7, api_key=openai_api_key)
       st.info(model.invoke(input_text))
   ```

5. Finally, use `st.form()` to create a text box (`st.text_area()`) for user input. When the user clicks `Submit`, the `generate-response()` function is called with the user's input as an argument.

   ```python
   with st.form("my_form"):
       text = st.text_area(
           "Enter text:",
           "What are the three key pieces of advice for learning how to code?",
       )
       submitted = st.form_submit_button("Submit")
       if not openai_api_key.startswith("sk-"):
           st.warning("Please enter your OpenAI API key!", icon="⚠")
       if submitted and openai_api_key.startswith("sk-"):
           generate_response(text)
   ```

6. Remember to save your file!
7. Return to your computer's terminal to run the app.

   ```bash
   streamlit run streamlit_app.py
   ```

## Deploying the app

To deploy the app to the Streamlit Cloud, follow these steps:

1. Create a GitHub repository for the app. Your repository should contain two files:

   ```
   your-repository/
   ├── streamlit_app.py
   └── requirements.txt
   ```

1. Go to [Streamlit Community Cloud](http://share.streamlit.io), click the `New app` button from your workspace, then specify the repository, branch, and main file path. Optionally, you can customize your app's URL by choosing a custom subdomain.
1. Click the `Deploy!` button.

Your app will now be deployed to Streamlit Community Cloud and can be accessed from around the world! 🌎

## Conclusion

Congratulations on building an LLM-powered Streamlit app in 18 lines of code! 🥳 You can use this app to generate text from any prompt that you provide. The app is limited by the capabilities of the OpenAI LLM, but it can still be used to generate some creative and interesting text.

We hope you found this tutorial helpful! Check out [more examples](https://streamlit.io/generative-ai) to see the power of Streamlit and LLM. 💖

Happy Streamlit-ing! 🎈

---

# Validate and edit chat responses

Source: https://docs.streamlit.io/develop/tutorials/chat-and-llm-apps/validate-and-edit-chat-responses


As you train LLM models, you may want users to correct or improve chat responses. With Streamlit, you can build a chat app that lets users improve chat responses.

This tutorial uses Streamlit's chat commands to build a simple chat app that lets users modify chat responses to improve them.

## Applied concepts

- Use `st.chat_input` and `st.chat_message` to create a chat interface.
- Use Session State to manage stages of a process.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.24.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of [Session State](/develop/concepts/architecture/session-state).

## Summary

In this example, you'll build a chat interface. To avoid API calls, the app will include a generator function to simulate a chat stream object. When the simulated chat assistant responds, a function validates the response and highlights possible "errors" for the user to review. The user must accept, correct, or rewrite the response before proceeding.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import lorem
from random import randint
import time

if "stage" not in st.session_state:
    st.session_state.stage = "user"
    st.session_state.history = []
    st.session_state.pending = None
    st.session_state.validation = {}


def chat_stream():
    for i in range(randint(3, 9)):
        yield lorem.sentence() + " "
        time.sleep(0.2)


def validate(response):
    response_sentences = response.split(". ")
    response_sentences = [
        sentence.strip(". ") + "."
        for sentence in response_sentences
        if sentence.strip(". ") != ""
    ]
    validation_list = [
        True if sentence.count(" ") &gt; 4 else False for sentence in response_sentences
    ]
    return response_sentences, validation_list


def add_highlights(response_sentences, validation_list, bg="red", text="red"):
    return [
        f":{text}[:{bg}-background[" + sentence + "]]" if not is_valid else sentence
        for sentence, is_valid in zip(response_sentences, validation_list)
    ]


for message in st.session_state.history:
    with st.chat_message(message["role"]):
        st.write(message["content"])

if st.session_state.stage == "user":
    if user_input := st.chat_input("Enter a prompt"):
        st.session_state.history.append({"role": "user", "content": user_input})
        with st.chat_message("user"):
            st.write(user_input)
        with st.chat_message("assistant"):
            response = st.write_stream(chat_stream())
            st.session_state.pending = response
            st.session_state.stage = "validate"
            st.rerun()

elif st.session_state.stage == "validate":
    st.chat_input("Accept, correct, or rewrite the answer above.", disabled=True)
    response_sentences, validation_list = validate(st.session_state.pending)
    highlighted_sentences = add_highlights(response_sentences, validation_list)
    with st.chat_message("assistant"):
        st.markdown(" ".join(highlighted_sentences))
        st.divider()
        cols = st.columns(3)
        if cols[0].button(
            "Correct errors", type="primary", disabled=all(validation_list)
        ):
            st.session_state.validation = {
                "sentences": response_sentences,
                "valid": validation_list,
            }
            st.session_state.stage = "correct"
            st.rerun()
        if cols[1].button("Accept"):
            st.session_state.history.append(
                {"role": "assistant", "content": st.session_state.pending}
            )
            st.session_state.pending = None
            st.session_state.validation = {}
            st.session_state.stage = "user"
            st.rerun()
        if cols[2].button("Rewrite answer", type="tertiary"):
            st.session_state.stage = "rewrite"
            st.rerun()

elif st.session_state.stage == "correct":
    st.chat_input("Accept, correct, or rewrite the answer above.", disabled=True)
    response_sentences = st.session_state.validation["sentences"]
    validation_list = st.session_state.validation["valid"]
    highlighted_sentences = add_highlights(
        response_sentences, validation_list, "gray", "gray"
    )
    if not all(validation_list):
        focus = validation_list.index(False)
        highlighted_sentences[focus] = ":red[:red" + highlighted_sentences[focus][11:]
    else:
        focus = None
    with st.chat_message("assistant"):
        st.markdown(" ".join(highlighted_sentences))
        st.divider()
        if focus is not None:
            new_sentence = st.text_input(
                "Replacement text:", value=response_sentences[focus]
            )
            cols = st.columns(2)
            if cols[0].button(
                "Update", type="primary", disabled=len(new_sentence.strip()) </Collapse>

---

# Customize your theme and configure your app

Source: https://docs.streamlit.io/develop/tutorials/configuration-and-theming


<TileContainer layout="list">
<RefCard href="/develop/tutorials/configuration-and-theming/external-fonts">
<h5>Use external font files and fallbacks to customize your font</h5>

Make a new font available to your app. This tutorial uses externally hosted font files to define an alternative font and declares a built-in fallback.

</RefCard>
<RefCard href="/develop/tutorials/configuration-and-theming/static-fonts">
<h5>Use static font files to customize your font</h5>

Make a new font available to your app. This tutorial uses static font files to define an alternative font.

</RefCard>
<RefCard href="/develop/tutorials/configuration-and-theming/variable-fonts">
<h5>Use variable font files to customize your font</h5>

Make a new font available to your app. This tutorial uses variable font files to define an alternative font.

</RefCard>
</TileContainer>

---

# Use externally hosted fonts and fallbacks to customize your font

Source: https://docs.streamlit.io/develop/tutorials/configuration-and-theming/external-fonts


Streamlit comes with Source Sans as the default font, but you can configure your app to use another font. This tutorial uses variable font files and is a walkthrough of Example 3 from [Customize fonts in your Streamlit app](/develop/concepts/configuration/theming-customize-fonts#example-1-define-an-alternative-font-with-variable-font-files). For an example that uses self-hosted variable font files, see [Use variable font files to customize your font](/develop/tutorials/configuration-and-theming/variable-fonts). For an example that uses self-hosted static font files, see [Use static font files to customize your font](/develop/tutorials/configuration-and-theming/static-fonts).

This tutorial uses inline font definitions, which were introduced in Streamlit version 1.50.0. For an older workaround, see [Use externally hosted fonts and fallbacks to customize your font (`streamlit

---

# Use externally hosted fonts and fallbacks to customize your font (`streamlit

Source: https://docs.streamlit.io/develop/tutorials/configuration-and-theming/external-fonts-old

---

# Use static font files to customize your font

Source: https://docs.streamlit.io/develop/tutorials/configuration-and-theming/static-fonts


Streamlit comes with Source Sans as the default font, but you can configure your app to use another font. This tutorial uses static font files and is a walkthrough of Example 2 from [Customize fonts in your Streamlit app](/develop/concepts/configuration/theming-customize-fonts#example-2-define-an-alternative-font-with-static-font-files). For an example that uses variable font files, see [Use variable font files to customize your font](/develop/tutorials/configuration-and-theming/variable-fonts).

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.45.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of [static file serving](/develop/concepts/configuration/serving-static-files).
- You should have a basic understanding of working with font files in web development. Otherwise, start by reading [Customize fonts in your Streamlit app](/develop/concepts/configuration/theming-customize-fonts) up to Example 2.

## Summary

The following example uses [Tuffy](https://fonts.google.com/specimen/Tuffy) font. The font has four static font files which cover the four following weight-style pairs:

- normal normal
- normal bold
- italic normal
- italic bold

Here's a look at what you'll build:

<Collapse title="Complete config.toml file">{false}&gt;

Directory structure:

```none
your_repository/
├── .streamlit/
│   └── config.toml
├── static/
│   ├── Tuffy-Bold.ttf
│   ├── Tuffy-BoldItalic.ttf
│   ├── Tuffy-Italic.ttf
│   └── Tuffy-Regular.ttf
└── streamlit_app.py
```

`.streamlit/config.toml`:

```toml
[server]
enableStaticServing = true

[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Regular.ttf"
style="normal"
weight=400
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Bold.ttf"
style="normal"
weight=700
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-Italic.ttf"
style="italic"
weight=400
[[theme.fontFaces]]
family="tuffy"
url="app/static/Tuffy-BoldItalic.ttf"
style="italic"
weight=700

[theme]
font="tuffy"
```

`streamlit_app.py`:

```
import streamlit as st

st.write("Normal ABCabc123")
st.write("*Italic ABCabc123*")
st.write("**Bold ABCabc123**")
st.write("***Bold-italic ABCabc123***")
st.write("`Code ABCabc123`")
```

</Collapse>

## Download and save your font files

1. Go to [Google fonts](https://fonts.google.com/).

1. Search for or follow the link to [Tuffy](https://fonts.google.com/specimen/Tuffy), and select "**Get font**."

1. To download your font files, in the upper-right corner, select the shopping bag (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;shopping_bag</i>), and then select "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;download</i> **Download all**."

1. In your downloads directory, unzip the downloaded file.

1. From the unzipped files, copy and save the TTF font files into a `static/` directory in `your_repository/`.

   Copy the following files:

   ```none
   Tuffy/
   ├── Tuffy-Bold.ttf
   ├── Tuffy-BoldItalic.ttf
   ├── Tuffy-Italic.ttf
   └── Tuffy-Regular.ttf
   ```

   Save those files in your repository:

   ```none
   your_repository/
   └── static/
       ├── Tuffy-Bold.ttf
       ├── Tuffy-BoldItalic.ttf
       ├── Tuffy-Italic.ttf
       └── Tuffy-Regular.ttf
   ```

## Create your app configuration

1. In `your_repository/`, create a `.streamlit/config.toml` file:

   ```none
   your_repository/
   ├── .streamlit/
   │   └── config.toml
   └── static/
       ├── Tuffy-Bold.ttf
       ├── Tuffy-BoldItalic.ttf
       ├── Tuffy-Italic.ttf
       └── Tuffy-Regular.ttf
   ```

1. To enable static file serving, in `.streamlit/config.toml`, add the following text:

   ```toml
   [server]
   enableStaticServing = true
   ```

   This makes the files in your `static/` directory publicly available through your app's URL at the relative path `app/static/{filename}`.

1. To define your alternative fonts, in `.streamlit/config.toml`, add the following text:

   ```toml
    [[theme.fontFaces]]
    family="tuffy"
    url="app/static/Tuffy-Regular.ttf"
    style="normal"
    weight=400
    [[theme.fontFaces]]
    family="tuffy"
    url="app/static/Tuffy-Bold.ttf"
    style="normal"
    weight=700
    [[theme.fontFaces]]
    family="tuffy"
    url="app/static/Tuffy-Italic.ttf"
    style="italic"
    weight=400
    [[theme.fontFaces]]
    family="tuffy"
    url="app/static/Tuffy-BoldItalic.ttf"
    style="italic"
    weight=700
   ```

   The `[[theme.fontFaces]]` table can be repeated to use multiple files to define a single font or to define multiple fonts. In this example, the definitions make `"tuffy"` available to other font configuration options.

   <Tip>

   For convenience, avoid spaces in your font family names. When you declare the default font, you can also declare fallback fonts. If you avoid spaces in your font family names, you don't need inner quotes.

   </Tip>

1. To set your alternative fonts as the default font for your app, in `.streamlit/config.toml`, add the following text:

   ```toml
   [theme]
   font="tuffy"
   ```

   This sets Tuffy as the default for all text in your app except inline code and code blocks.

## Build the example

To verify that your font is loaded correctly, create a simple app.

### Initialize your app

1. In your_repository, create a file named `streamlit_app.py`.

1. In a terminal, change directories to your_repository, and start your app:

   ```bash
   streamlit run streamlit_app.py
   ```

   Your app will be blank because you still need to add code.

1. In `streamlit_app.py`, write the following:

   ```
   import streamlit as st
   ```

1. Save your `streamlit_app.py` file, and view your running app.

1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `streamlit_app.py`.

1. Return to your code.

### Display some text in your app

1. Create a `streamlit_app.py` file in your working directory.

1. In `streamlit_app.py`, add the following text:

   ```
   import streamlit as st

   st.write("Normal ABCabc123")
   st.write("*Italic ABCabc123*")
   st.write("**Bold ABCabc123**")
   st.write("***Bold-italic ABCabc123***")
   st.write("`Code ABCabc123`")
   ```

1. Save your `streamlit_app.py` file, and view your running app.

---

# Use variable font files to customize your font

Source: https://docs.streamlit.io/develop/tutorials/configuration-and-theming/variable-fonts


Streamlit comes with Source Sans as the default font, but you can configure your app to use another font. This tutorial uses variable font files and is a walkthrough of Example 1 from [Customize fonts in your Streamlit app](/develop/concepts/configuration/theming-customize-fonts#example-1-define-an-alternative-font-with-variable-font-files). For an example that uses static font files, see [Use static font files to customize your font](/develop/tutorials/configuration-and-theming/static-fonts).

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.45.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of [static file serving](/develop/concepts/configuration/serving-static-files).
- You should have a basic understanding of working with font files in web development. Otherwise, start by reading [Customize fonts in your Streamlit app](/develop/concepts/configuration/theming-customize-fonts) up to Example 1.

## Summary

The following example uses static file serving to host Google's [Noto Sans](https://fonts.google.com/noto/specimen/Noto+Sans) and [Noto Sans Mono](https://fonts.google.com/noto/specimen/Noto+Sans+Mono) fonts and configures the app to use them. Both of these fonts are defined with variable font files that include a parameterized weight. However, because font style is not parameterized, Noto Sans requires two files to define the normal and italic styles separately. Noto Sans Mono does not include a separate file for its italic style. Per [CSS rules](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style#italic), because no italic style is explicitly provided, it will be simulated by skewing the normal-style font.

Here's a look at what you'll build:

<Collapse title="Complete config.toml file">{false}&gt;

Directory structure:

```none
your_repository/
├── .streamlit/
│   └── config.toml
├── static/
│   ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
│   ├── NotoSans-VariableFont_wdth,wght.ttf
│   └── NotoSansMono-VariableFont_wdth,wght.ttf
└── streamlit_app.py
```

`.streamlit/config.toml`:

```toml
[server]
enableStaticServing = true

[[theme.fontFaces]]
family="noto-sans"
url="app/static/NotoSans-Italic-VariableFont_wdth,wght.ttf"
style="italic"
[[theme.fontFaces]]
family="noto-sans"
url="app/static/NotoSans-VariableFont_wdth,wght.ttf"
style="normal"
[[theme.fontFaces]]
family="noto-mono"
url="app/static/NotoSansMono-VariableFont_wdth,wght.ttf"

[theme]
font="noto-sans"
codeFont="noto-mono"
```

`streamlit_app.py`:

```
import streamlit as st

st.write("Normal efg")
st.write("*Italic efg*")
st.write("**Bold efg**")
st.write("***Bold-italic efg***")
st.write("`Code normal efg`")
st.write("*`Code italic efg`*")
st.write("**`Code bold efg`**")
st.write("***`Code bold-italic efg`***")
```

</Collapse>

## Download and save your font files

1. Go to [Google fonts](https://fonts.google.com/).

1. Search for or follow the link to [Noto Sans](https://fonts.google.com/noto/specimen/Noto+Sans), and select "**Get font**."

1. Search for or follow the link to [Noto Sans Mono](https://fonts.google.com/noto/specimen/Noto+Sans+Mono), and select "**Get font**."

1. To download your font files, in the upper-right corner, select the shopping bag (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;shopping_bag</i>), and then select "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;download</i> **Download all**."

1. In your downloads directory, unzip the downloaded file.

1. From the unzipped files, copy and save the TTF font files into a `static/` directory in `your_repository/`.

   Copy the following files:

   ```none
   Noto_Sans,Noto_Sans_Mono/
   ├── Noto_Sans_Mono/
   │   └── NotoSansMono-VariableFont_wdth,wght.ttf
   └── Noto_Sans/
      ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
      └── NotoSans-VariableFont_wdth,wght.ttf
   ```

   Save those files in your repository:

   ```none
   your_repository/
   └── static/
       ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
       ├── NotoSans-VariableFont_wdth,wght.ttf
       └── NotoSansMono-VariableFont_wdth,wght.ttf
   ```

   In this example, the font files are `NotoSans-Italic-VariableFont_wdth,wght.ttf` and `NotoSansMono-VariableFont_wdth,wght.ttf` for Noto Sans italic and normal font, respectively. `NotoSansMono-VariableFont_wdth,wght.ttf` is the file for Noto Sans Mono.

## Create your app configuration

1. In `your_repository/`, create a `.streamlit/config.toml` file:

   ```none
   your_repository/
   ├── .streamlit/
   │   └── config.toml
   └── static/
       ├── NotoSans-Italic-VariableFont_wdth,wght.ttf
       ├── NotoSans-VariableFont_wdth,wght.ttf
       └── NotoSansMono-VariableFont_wdth,wght.ttf
   ```

1. To enable static file serving, in `.streamlit/config.toml`, add the following text:

   ```toml
   [server]
   enableStaticServing = true
   ```

   This makes the files in your `static/` directory publicly available through your app's URL at the relative path `app/static/{filename}`.

1. To define your alternative fonts, in `.streamlit/config.toml`, add the following text:

   ```toml
   [[theme.fontFaces]]
   family="noto-sans"
   url="app/static/NotoSans-Italic-VariableFont_wdth,wght.ttf"
   style="italic"
   [[theme.fontFaces]]
   family="noto-sans"
   url="app/static/NotoSans-VariableFont_wdth,wght.ttf"
   style="normal"
   [[theme.fontFaces]]
   family="noto-mono"
   url="app/static/NotoSansMono-VariableFont_wdth,wght.ttf"
   ```

   The `[[theme.fontFaces]]` table can be repeated to use multiple files to define a single font or to define multiple fonts. In this example, the definitions make `"noto-sans"` and `"noto-mono"` available to other font configuration options.

   <Tip>

   For convenience, avoid spaces in your font family names. When you declare the default font, you can also declare fallback fonts. If you avoid spaces in your font family names, you don't need inner quotes.

   </Tip>

1. To set your alternative fonts as the default font for your app, in `.streamlit/config.toml`, add the following text:

   ```toml
   [theme]
   font="noto-sans"
   codeFont="noto-mono"
   ```

   This sets Noto Sans as the default for all text in your app except inline code and code blocks, which will be Noto Sans Mono instead.

## Build the example

To verify that your font is loaded correctly, create a simple app.

### Initialize your app

1. In your_repository, create a file named `streamlit_app.py`.

1. In a terminal, change directories to your_repository, and start your app:

   ```bash
   streamlit run streamlit_app.py
   ```

   Your app will be blank because you still need to add code.

1. In `streamlit_app.py`, write the following:

   ```
   import streamlit as st
   ```

1. Save your `streamlit_app.py` file, and view your running app.

1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `streamlit_app.py`.

1. Return to your code.

### Display some text in your app

1. Create a `streamlit_app.py` file in your working directory.

1. In `streamlit_app.py`, add the following text:

   ```
   import streamlit as st

   st.write("Normal efg")
   st.write("*Italic efg*")
   st.write("**Bold efg**")
   st.write("***Bold-italic efg***")
   st.write("`Code normal efg`")
   st.write("*`Code italic efg`*")
   st.write("**`Code bold efg`**")
   st.write("***`Code bold-italic efg`***")
   ```

   The example includes "efg" in each line to better show the typographical differences when you run your app. The italic "f" descends below baseline, but the normal "f" doesn't. The italic "e" has a rounded front, but the normal "e" has a sharp corner.

1. Save your `streamlit_app.py` file, and view your running app.

---

# Connect Streamlit to data sources

Source: https://docs.streamlit.io/develop/tutorials/databases


These step-by-step guides demonstrate how to connect Streamlit apps to various databases  APIs.
They use Streamlit's [Secrets management](/develop/concepts/connections/secrets-management) and
[caching](/develop/concepts/architecture/caching) to provide secure and fast data access.

<DataSourcesContainer>
<DataSourcesCard href="/develop/tutorials/databases/aws-s3">
<Image>alt="screenshot" src="/images/databases/s3.png" /&gt;

<h5>AWS S3</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/bigquery">
<Image>alt="screenshot" src="/images/databases/bigquery.png" /&gt;

<h5>BigQuery</h5>
</Image>
<DataSourcesCard href="https://blog.streamlit.io/streamlit-firestore/">
<Image>alt="screenshot" src="/images/databases/firestore.png" /&gt;

<h5>Firestore (blog)</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/gcs">
<Image>alt="screenshot" src="/images/databases/gcs.png" /&gt;

<h5>Google Cloud Storage</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/mssql">
<Image>alt="screenshot" src="/images/databases/mssql.png" /&gt;

<h5>Microsoft SQL Server</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/mongodb">
<Image>alt="screenshot" src="/images/databases/mongodb.png" /&gt;

<h5>MongoDB</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/mysql">
<Image>alt="screenshot" src="/images/databases/mysql.png" /&gt;

<h5>MySQL</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/neon">
<Image>alt="screenshot" src="/images/databases/neon-logo.png" /&gt;

<h5>Neon</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/postgresql">
<Image>alt="screenshot" src="/images/databases/postgresql.png" /&gt;

<h5>PostgreSQL</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/private-gsheet">
<Image>alt="screenshot" src="/images/databases/gsheet.png" /&gt;

<h5>Private Google Sheet</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/public-gsheet">
<Image>alt="screenshot" src="/images/databases/gsheet.png" /&gt;

<h5>Public Google Sheet</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/snowflake">
<Image>alt="screenshot" src="/images/databases/snowflake.png" /&gt;

<h5>Snowflake</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/supabase">
<Image>alt="screenshot" src="/images/databases/supabase.png" /&gt;

<h5>Supabase</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/tableau">
<Image>alt="screenshot" src="/images/databases/tableau.png" /&gt;

<h5>Tableau</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/tidb">
<Image>alt="screenshot" src="/images/databases/tidb.png" /&gt;

<h5>TiDB</h5>
</Image>
<DataSourcesCard href="/develop/tutorials/databases/tigergraph">
<Image>alt="screenshot" src="/images/databases/tigergraph.png" /&gt;

<h5>TigerGraph</h5>
</Image>
</DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesCard></DataSourcesContainer>

---

# Connect Streamlit to AWS S3

Source: https://docs.streamlit.io/develop/tutorials/databases/aws-s3


## Introduction

This guide explains how to securely access files on AWS S3 from Streamlit Community Cloud. It uses [Streamlit FilesConnection](https://github.com/streamlit/files-connection), the [s3fs](https://github.com/dask/s3fs) library and optionally Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

## Create an S3 bucket and add a file

<Note>

If you already have a bucket that you want to use, feel free
to [skip to the next step](#create-access-keys).

</Note>

First, [sign up for AWS](https://aws.amazon.com/) or log in. Go to the [S3 console](https://s3.console.aws.amazon.com/s3/home) and create a new bucket:

<Flex>
<Image alt="AWS screenshot 1" src="/images/databases/aws-1.png"/>
<Image alt="AWS screenshot 2" src="/images/databases/aws-2.png"/>
</Flex>

Navigate to the upload section of your new bucket:

<Flex>
<Image alt="AWS screenshot 3" src="/images/databases/aws-3.png"/>
<Image alt="AWS screenshot 4" src="/images/databases/aws-4.png"/>
</Flex>

And note down the "AWS Region" for later. In this example, it's `us-east-1`, but it may differ for you.

Next, upload the following CSV file, which contains some example data:

<Download href="/images/databases/myfile.csv">myfile.csv</Download>

## Create access keys

Go to the [AWS console](https://console.aws.amazon.com/), create access keys as shown below and copy the "Access Key ID" and "Secret Access Key":

<Flex>
<Image alt="AWS screenshot 5" src="/images/databases/aws-5.png"/>
<Image alt="AWS screenshot 6" src="/images/databases/aws-6.png"/>
</Flex>
<Tip>

Access keys created as a root user have wide-ranging permissions. In order to make your AWS account
more secure, you should consider creating an IAM account with restricted permissions and using its
access keys. More information [here](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html).

</Tip>

## Set up your AWS credentials locally

Streamlit FilesConnection and s3fs will read and use your existing [AWS credentials and configuration](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html) if available - such as from an `~/.aws/credentials` file or environment variables.

If you don't already have this set up, or plan to host the app on Streamlit Community Cloud, you should specify the credentials from a file `.streamlit/secrets.toml` in your app's root directory or your home directory. Create this file if it doesn't exist yet and add to it the access key ID, access key secret, and the AWS default region you noted down earlier, as shown below:

```toml
# .streamlit/secrets.toml
AWS_ACCESS_KEY_ID = "xxx"
AWS_SECRET_ACCESS_KEY = "xxx"
AWS_DEFAULT_REGION = "xxx"
```

<Important>

Be sure to replace `xxx` above with the values you noted down earlier, and add this file to `.gitignore` so you don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

To host your app on Streamlit Community Cloud, you will need to pass your credentials to your deployed app via secrets. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` above into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add FilesConnection and s3fs to your requirements file

Add the [FilesConnection](https://github.com/streamlit/files-connection) and [s3fs](https://github.com/dask/s3fs) packages to your `requirements.txt` file, preferably pinning the versions (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
s3fs==x.x.x
st-files-connection
```

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Make sure to adapt the name of your bucket and file. Note that Streamlit automatically turns the access keys from your secrets file into environment variables, where `s3fs` searches for them by default.

```python
# streamlit_app.py

import streamlit as st
from st_files_connection import FilesConnection

# Create connection object and retrieve file contents.
# Specify input format is a csv and to cache the result for 600 seconds.
conn = st.connection('s3', type=FilesConnection)
df = conn.read("testbucket-jrieke/myfile.csv", input_format="csv", ttl=600)

# Print results.
for row in df.itertuples():
    st.write(f"{row.Owner} has a :{row.Pet}:")
```

See `st.connection` above? This handles secrets retrieval, setup, result caching and retries. By default, `read()` results are cached without expiring. In this case, we set `ttl=600` to ensure the file contents is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example file given above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)

---

# 连接 Streamlit 到 Google BigQuery

Source: https://docs.streamlit.io/develop/tutorials/databases/bigquery


## 简介

本指南解释了如何从 Streamlit Community Cloud 安全地访问 BigQuery 数据库。它使用
[google-cloud-bigquery](https://googleapis.dev/python/bigquery/latest/index.html) 库和
Streamlit 的 [密钥管理](/develop/concepts/connections/secrets-management)。

## 创建 BigQuery 数据库

<Note>

如果您已经有一个想要使用的数据库，请随时
[跳到下一步](#启用-bigquery-api)。

</Note>

对于此示例，我们将使用来自 BigQuery 的 [示例数据集之一](https://cloud.google.com/bigquery/public-data#sample_tables)（即 `shakespeare` 表）。如果您想创建新数据集，请按照 [Google 的快速入门指南](https://cloud.google.com/bigquery/docs/quickstarts/quickstart-web-ui) 操作。

## 启用 BigQuery API

对 BigQuery 的程序化访问通过 [Google Cloud Platform](https://cloud.google.com) 控制。创建账户或登录并前往 [APIs  Services 仪表板](https://console.cloud.google.com/apis/dashboard)（如果询问请选择或创建项目）。如下所示，搜索 BigQuery API 并启用它：

<Flex>
<Image alt="Bigquery 截图 1" src="/images/databases/big-query-1.png"/>
<Image alt="Bigquery 截图 2" src="/images/databases/big-query-2.png"/>
<Image alt="Bigquery 截图 3" src="/images/databases/big-query-3.png"/>
</Flex>

## 创建服务账户和密钥文件

要从 Streamlit Community Cloud 使用 BigQuery API，您需要一个 Google Cloud Platform 服务账户（一种用于程序化数据访问的特殊账户类型）。转到 [服务账户](https://console.cloud.google.com/iam-admin/serviceaccounts) 页面并创建一个具有 **Viewer** 权限的账户（这将允许该账户访问数据但不能更改数据）：

<Flex>
<Image alt="Bigquery 截图 4" src="/images/databases/big-query-4.png"/>
<Image alt="Bigquery 截图 5" src="/images/databases/big-query-5.png"/>
<Image alt="Bigquery 截图 6" src="/images/databases/big-query-6.png"/>
</Flex>
<Note>

如果按钮 **CREATE SERVICE ACCOUNT** 是灰色的，说明您没有正确的权限。请联系您的 Google Cloud 项目的管理员寻求帮助。

</Note>

点击 **DONE** 后，您应该返回到服务账户概览页面。为新账户创建一个 JSON 密钥文件并下载它：

<Flex>
<Image alt="Bigquery 截图 7" src="/images/databases/big-query-7.png"/>
<Image alt="Bigquery 截图 8" src="/images/databases/big-query-8.png"/>
<Image alt="Bigquery 截图 9" src="/images/databases/big-query-9.png"/>
</Flex>

## 将密钥文件添加到本地应用密钥

您的本地 Streamlit 应用将从应用根目录下的 `.streamlit/secrets.toml` 文件读取密钥。如果该文件尚不存在，请创建它，并按照下面所示将您刚刚下载的密钥文件内容添加到其中：

```toml
# .streamlit/secrets.toml

[gcp_service_account]
type = "service_account"
project_id = "xxx"
private_key_id = "xxx"
private_key = "xxx"
client_email = "xxx"
client_id = "xxx"
auth_uri = "https://accounts.google.com/o/oauth2/auth"
token_uri = "https://oauth2.googleapis.com/token"
auth_provider_x509_cert_url = "https://www.googleapis.com/oauth2/v1/certs"
client_x509_cert_url = "xxx"
```

<Important>

将此文件添加到 `.gitignore` 并且不要将其提交到 GitHub 仓库中！

</Important>

## 将应用密钥复制到云端

由于上面的 `secrets.toml` 文件未提交到 GitHub，因此需要将其内容单独传递给部署的应用（在 Streamlit Community Cloud 上）。转到 [应用仪表板](https://share.streamlit.io/)，在应用的下拉菜单中，点击 **Edit Secrets**。将 `secrets.toml` 的内容复制到文本区域。更多信息请参阅 [密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

![密钥管理器截图](/images/databases/edit-secrets.png)

## 将 google-cloud-bigquery 添加到需求文件

将 [google-cloud-bigquery](https://googleapis.dev/python/bigquery/latest/index.html) 包添加到 `requirements.txt` 文件中，最好固定其版本（将 `x.x.x` 替换为您希望安装的版本）：

```bash
# requirements.txt
google-cloud-bigquery==x.x.x
```

## 编写您的 Streamlit 应用

将以下代码复制到您的 Streamlit 应用并运行。如果您不使用示例表，请确保调整查询。

```python
# streamlit_app.py

import streamlit as st
from google.oauth2 import service_account
from google.cloud import bigquery

# 创建 API 客户端。
credentials = service_account.Credentials.from_service_account_info(
    st.secrets["gcp_service_account"]
)
client = bigquery.Client(credentials=credentials)

# 执行查询。
# 使用 st.cache_data 只在查询更改或10分钟后重新运行。
@st.cache_data(ttl=600)
def run_query(query):
    query_job = client.query(query)
    rows_raw = query_job.result()
    # 转换为字典列表。st.cache_data 需要哈希返回值。
    rows = [dict(row) for row in rows_raw]
    return rows

rows = run_query("SELECT word FROM `bigquery-public-data.samples.shakespeare` LIMIT 10")

# 打印结果。
st.write("莎士比亚的一些智慧之言:")
for row in rows:
    st.write("✍️ " + row['word'])
```

看到了上面的 `st.cache_data` 吗？如果没有它，Streamlit 会在应用每次重新运行时（例如在小部件交互时）执行查询。有了 `st.cache_data`，它只在查询更改或10分钟后运行（这就是 `ttl` 的作用）。请注意：如果您的数据库更新更频繁，您应该调整 `ttl` 或移除缓存，以便查看者始终看到最新数据。了解更多请参阅 [缓存](/develop/concepts/architecture/caching)。

另外，您可以使用 pandas 从 BigQuery 直接读取到数据框中！按照上述所有步骤，安装 [pandas-gbq](https://pandas-gbq.readthedocs.io/en/latest/index.html) 库（别忘了将其添加到 `requirements.txt` 中！），并调用 `pandas.read_gbq(query, credentials=credentials)`。更多信息请参阅 [pandas 文档](https://pandas.pydata.org/docs/reference/api/pandas.read_gbq.html)。

如果一切顺利（并且您使用了示例表），您的应用应该如下所示：

![最终应用截图](/images/databases/big-query-10.png)

---

# Connect Streamlit to Google Cloud Storage

Source: https://docs.streamlit.io/develop/tutorials/databases/gcs


## Introduction

This guide explains how to securely access files on Google Cloud Storage from Streamlit Community Cloud. It uses [Streamlit FilesConnection](https://github.com/streamlit/files-connection), the [gcsfs](https://github.com/fsspec/gcsfs) library and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

## Create a Google Cloud Storage bucket and add a file

<Note>

If you already have a bucket that you want to use, feel free
to [skip to the next step](#enable-the-google-cloud-storage-api).

</Note>

First, [sign up for Google Cloud Platform](https://console.cloud.google.com/) or log in. Go to the [Google Cloud Storage console](https://console.cloud.google.com/storage/) and create a new bucket.

<Flex>
<Image alt="GCS screenshot 1" src="/images/databases/gcs-1.png"/>
<Image alt="GCS screenshot 2" src="/images/databases/gcs-2.png"/>
</Flex>

Navigate to the upload section of your new bucket:

<Flex>
<Image alt="GCS screenshot 3" src="/images/databases/gcs-3.png"/>
<Image alt="GCS screenshot 4" src="/images/databases/gcs-4.png"/>
</Flex>

And upload the following CSV file, which contains some example data:

<Download href="/images/databases/myfile.csv">myfile.csv</Download>

## Enable the Google Cloud Storage API

The Google Cloud Storage API is [enabled by default](https://cloud.google.com/service-usage/docs/enabled-service#default) when you create a project through the Google Cloud Console or CLI. Feel free to [skip to the next step](#create-a-service-account-and-key-file).

If you do need to enable the API for programmatic access in your project, head over to the [APIs  Services dashboard](https://console.cloud.google.com/apis/dashboard) (select or create a project if asked). Search for the Cloud Storage API and enable it. The screenshot below has a blue "Manage" button and indicates the "API is enabled" which means no further action needs to be taken. This is very likely what you have since the API is enabled by default. However, if that is not what you see and you have an "Enable" button, you'll need to enable the API:

<Flex>
<Image alt="GCS screenshot 5" src="/images/databases/gcs-5.png"/>
<Image alt="GCS screenshot 6" src="/images/databases/gcs-6.png"/>
<Image alt="GCS screenshot 7" src="/images/databases/gcs-7.png"/>
</Flex>

## Create a service account and key file

To use the Google Cloud Storage API from Streamlit, you need a Google Cloud Platform service account (a special type for programmatic data access). Go to the Service Accounts page and create an account with <b>Viewer</b> permission.

<Flex>
<Image alt="GCS screenshot 8" src="/images/databases/gcs-8.png"/>
<Image alt="GCS screenshot 9" src="/images/databases/gcs-9.png"/>
<Image alt="GCS screenshot 10" src="/images/databases/gcs-10.png"/>
</Flex>
<Note>

If the button **CREATE SERVICE ACCOUNT** is gray, you don't have the correct permissions. Ask the
admin of your Google Cloud project for help.

</Note>

After clicking **DONE**, you should be back on the service accounts overview. Create a JSON key file for the new account and download it:

<Flex>
<Image alt="GCS screenshot 11" src="/images/databases/gcs-11.png"/>
<Image alt="GCS screenshot 12" src="/images/databases/gcs-12.png"/>
<Image alt="GCS screenshot 13" src="/images/databases/gcs-13.png"/>
</Flex>

## Add the key to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the access key to it as shown below:

```toml
# .streamlit/secrets.toml

[connections.gcs]
type = "service_account"
project_id = "xxx"
private_key_id = "xxx"
private_key = "xxx"
client_email = "xxx"
client_id = "xxx"
auth_uri = "https://accounts.google.com/o/oauth2/auth"
token_uri = "https://oauth2.googleapis.com/token"
auth_provider_x509_cert_url = "https://www.googleapis.com/oauth2/v1/certs"
client_x509_cert_url = "xxx"
```

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add FilesConnection and gcsfs to your requirements file

Add the [FilesConnection](https://github.com/streamlit/files-connection) and [gcsfs](https://github.com/fsspec/gcsfs) packages to your `requirements.txt` file, preferably pinning the versions (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
gcsfs==x.x.x
st-files-connection
```

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Make sure to adapt the name of your bucket and file. Note that Streamlit automatically turns the access keys from your secrets file into environment variables.

```python
# streamlit_app.py

import streamlit as st
from st_files_connection import FilesConnection

# Create connection object and retrieve file contents.
# Specify input format is a csv and to cache the result for 600 seconds.
conn = st.connection('gcs', type=FilesConnection)
df = conn.read("streamlit-bucket/myfile.csv", input_format="csv", ttl=600)

# Print results.
for row in df.itertuples():
    st.write(f"{row.Owner} has a :{row.Pet}:")
```

See `st.connection` above? This handles secrets retrieval, setup, result caching and retries. By default, `read()` results are cached without expiring. In this case, we set `ttl=600` to ensure the file contents is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example file given above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)

---

# 连接 Streamlit 到 MongoDB

Source: https://docs.streamlit.io/develop/tutorials/databases/mongodb


## 简介

本指南解释了如何从 Streamlit Community Cloud 安全地访问 **_远程_** MongoDB 数据库。它使用 [PyMongo](https://github.com/mongodb/mongo-python-driver) 库和 Streamlit 的 [密钥管理](/develop/concepts/connections/secrets-management)。

## 创建 MongoDB 数据库

<Note>

如果您已经有一个想要使用的数据库，请随时
[跳到下一步](#将用户名和密码添加到本地应用密钥)。

</Note>

首先，按照官方教程 [安装 MongoDB](https://docs.mongodb.com/guides/server/install/)，[设置身份验证](https://docs.mongodb.com/guides/server/auth/)（记下用户名和密码！），以及 [连接到 MongoDB 实例](https://docs.mongodb.com/guides/server/drivers/)。连接后，打开 `mongo` shell 并输入以下两个命令来创建一个包含一些示例值的集合：

```sql
use mydb
db.mycollection.insertMany([{"name" : "Mary", "pet": "dog"}, {"name" : "John", "pet": "cat"}, {"name" : "Robert", "pet": "bird"}])
```

## 将用户名和密码添加到本地应用密钥

您的本地 Streamlit 应用将从应用根目录下的 `.streamlit/secrets.toml` 文件读取密钥。如果该文件尚不存在，请创建它，并按照下面所示添加数据库信息：

```toml
# .streamlit/secrets.toml

[mongo]
host = "localhost"
port = 27017
username = "xxx"
password = "xxx"
```

<Important>

当复制应用密钥到 Streamlit Community Cloud 时，请务必用远程 MongoDB 数据库的 **host**、**port**、**username** 和 **password** 替换这些值！

将此文件添加到 `.gitignore` 并且不要将其提交到 GitHub 仓库中！

</Important>

## 将应用密钥复制到云端

由于上面的 `secrets.toml` 文件未提交到 GitHub，因此需要将其内容单独传递给部署的应用（在 Streamlit Community Cloud 上）。转到 [应用仪表板](https://share.streamlit.io/)，在应用的下拉菜单中，点击 **Edit Secrets**。将 `secrets.toml` 的内容复制到文本区域。更多信息请参阅 [密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

![密钥管理器截图](/images/databases/edit-secrets.png)

## 将 PyMongo 添加到需求文件

将 [PyMongo](https://github.com/mongodb/mongo-python-driver) 包添加到 `requirements.txt` 文件中，最好固定其版本（将 `x.x.x` 替换为您希望安装的版本）：

```bash
# requirements.txt
pymongo==x.x.x
```

## 编写您的 Streamlit 应用

将以下代码复制到您的 Streamlit 应用并运行。确保适配您的数据库和集合名称。

```python
# streamlit_app.py

import streamlit as st
import pymongo

# 初始化连接。
# 使用 st.cache_resource 只运行一次。
@st.cache_resource
def init_connection():
    return pymongo.MongoClient(**st.secrets["mongo"])

client = init_connection()

# 从集合中提取数据。
# 使用 st.cache_data 只在查询更改或10分钟后重新运行。
@st.cache_data(ttl=600)
def get_data():
    db = client.mydb
    items = db.mycollection.find()
    items = list(items)  # 使 st.cache_data 可哈希
    return items

items = get_data()

# 打印结果。
for item in items:
    st.write(f"{item['name']} 有一只 :{item['pet']}:")
```

看到了上面的 `st.cache_data` 吗？如果没有它，Streamlit 会在应用每次重新运行时（例如在小部件交互时）执行查询。有了 `st.cache_data`，它只在查询更改或10分钟后运行（这就是 `ttl` 的作用）。请注意：如果您的数据库更新更频繁，您应该调整 `ttl` 或移除缓存，以便查看者始终看到最新数据。了解更多请参阅 [缓存](/develop/concepts/architecture/caching)。

如果一切顺利（并且您使用了上面我们创建的示例数据），您的应用应该如下所示：

![完成的应用截图](/images/databases/streamlit-app.png)

---

# Connect Streamlit to Microsoft SQL Server

Source: https://docs.streamlit.io/develop/tutorials/databases/mssql


## Introduction

This guide explains how to securely access a **_remote_** Microsoft SQL Server database from Streamlit Community Cloud. It uses the [pyodbc](https://github.com/mkleehammer/pyodbc/wiki) library and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

## Create an SQL Server database

<Note>

If you already have a remote database that you want to use, feel free
to [skip to the next step](#add-username-and-password-to-your-local-app-secrets).

</Note>

First, follow the Microsoft documentation to install [SQL Server](https://docs.microsoft.com/en-gb/sql/sql-server/?view=sql-server-ver15) and the `sqlcmd` [Utility](https://docs.microsoft.com/en-gb/sql/tools/sqlcmd-utility?view=sql-server-ver15). They have detailed installation guides on how to:

- [Install SQL Server on Windows](https://docs.microsoft.com/en-gb/sql/database-engine/install-windows/install-sql-server?view=sql-server-ver15)
- [Install on Red Hat Enterprise Linux](https://docs.microsoft.com/en-gb/sql/linux/quickstart-install-connect-red-hat?view=sql-server-ver15)
- [Install on SUSE Linux Enterprise Server](https://docs.microsoft.com/en-gb/sql/linux/quickstart-install-connect-suse?view=sql-server-ver15)
- [Install on Ubuntu](https://docs.microsoft.com/en-gb/sql/linux/quickstart-install-connect-ubuntu?view=sql-server-ver15)
- [Run on Docker](https://docs.microsoft.com/en-gb/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15)
- [Provision a SQL VM in Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sql/provision-sql-server-linux-virtual-machine?toc=/sql/toc/toc.json)

Once you have SQL Server installed, note down your SQL Server name, username, and password during setup.

## Connect locally

If you are connecting locally, use `sqlcmd` to connect to your new local SQL Server instance.

1. In your terminal, run the following command:

   ```bash
   sqlcmd -S localhost -U SA -P '<YourPassword>'
   ```

   As you are connecting locally, the SQL Server name is `localhost`, the username is `SA`, and the password is the one you provided during the SA account setup.

2. You should see a **sqlcmd** command prompt `1&gt;`, if successful.

3. If you run into a connection failure, review Microsoft's connection troubleshooting recommendations for your OS ([Linux](https://docs.microsoft.com/en-gb/sql/linux/sql-server-linux-troubleshooting-guide?view=sql-server-ver15#connection)  [Windows](https://docs.microsoft.com/en-gb/sql/linux/sql-server-linux-troubleshooting-guide?view=sql-server-ver15#connection)).

<Tip>

When connecting remotely, the SQL Server name is the machine name or IP address. You might also need to open the SQL Server TCP port (default 1433) on your firewall.

</Tip>

### Create a SQL Server database

By now, you have SQL Server running and have connected to it with `sqlcmd`! 🥳 Let's put it to use by creating a database containing a table with some example values.

1. From the `sqlcmd` command prompt, run the following Transact-SQL command to create a test database `mydb`:

   ```sql
   CREATE DATABASE mydb
   ```

2. To execute the above command, type `GO` on a new line:

   ```sql
   GO
   ```

### Insert some data

Next create a new table, `mytable`, in the `mydb` database with three columns and two rows.

1. Switch to the new `mydb` database:

   ```sql
   USE mydb
   ```

2. Create a new table with the following schema:

   ```sql
   CREATE TABLE mytable (name varchar(80), pet varchar(80))
   ```

3. Insert some data into the table:

   ```sql
   INSERT INTO mytable VALUES ('Mary', 'dog'), ('John', 'cat'), ('Robert', 'bird')
   ```

4. Type `GO` to execute the above commands:

   ```sql
   GO
   ```

To end your **sqlcmd** session, type `QUIT` on a new line.

### Add username and password to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the SQL Server name, database name, username, and password as shown below:

```toml
# .streamlit/secrets.toml

server = "localhost"
database = "mydb"
username = "SA"
password = "xxx"
```

<Important>

When copying your app secrets to Streamlit Community Cloud, be sure to replace the values of **server**, **database**, **username**, and **password** with those of your _remote_ SQL Server!

And add this file to `.gitignore` and don't commit it to your GitHub repo.

</Important>

## Copy your app secrets to Streamlit Community Cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add pyodbc to your requirements file

To connect to SQL Server _locally_ with Streamlit, you need to `pip install pyodbc`, in addition to the Microsoft ODBC driver you installed during the SQL Server installation.

On _Streamlit Cloud_, we have built-in support for SQL Server. On popular demand, we directly added SQL Server tools including the ODBC drivers and the executables `sqlcmd` and `bcp` to the container image for Cloud apps, so you don't need to install them.

All you need to do is add the [`pyodbc`](https://github.com/mkleehammer/pyodbc) Python package to your `requirements.txt` file, and you're ready to go! 🎈

```bash
# requirements.txt
pyodbc==x.x.x
```

Replace `x.x.x` ☝️ with the version of pyodbc you want installed on Cloud.

<Note>

At this time, Streamlit Community Cloud does not support Azure Active Directory authentication. We will update this tutorial when we add support for Azure Active Directory.

</Note>

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Make sure to adapt `query` to use the name of your table.

```python
import streamlit as st
import pyodbc

# Initialize connection.
# Uses st.cache_resource to only run once.
@st.cache_resource
def init_connection():
    return pyodbc.connect(
        "DRIVER={ODBC Driver 17 for SQL Server};SERVER="
        + st.secrets["server"]
        + ";DATABASE="
        + st.secrets["database"]
        + ";UID="
        + st.secrets["username"]
        + ";PWD="
        + st.secrets["password"]
    )

conn = init_connection()

# Perform query.
# Uses st.cache_data to only rerun when the query changes or after 10 min.
@st.cache_data(ttl=600)
def run_query(query):
    with conn.cursor() as cur:
        cur.execute(query)
        return cur.fetchall()

rows = run_query("SELECT * from mytable;")

# Print results.
for row in rows:
    st.write(f"{row[0]} has a :{row[1]}:")

```

See `st.cache_data` above? Without it, Streamlit would run the query every time the app reruns (e.g. on a widget interaction). With `st.cache_data`, it only runs when the query changes or after 10 minutes (that's what `ttl` is for). Watch out: If your database updates more frequently, you should adapt `ttl` or remove caching so viewers always see the latest data. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example table we created above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)</YourPassword>

---

# 连接 Streamlit 到 MySQL

Source: https://docs.streamlit.io/develop/tutorials/databases/mysql


## 简介

本指南解释了如何从 Streamlit Community Cloud 安全地访问 **_远程_** MySQL 数据库。它使用 [st.connection](/develop/api-reference/connections/st.connection) 和 Streamlit 的 [密钥管理](/develop/concepts/connections/secrets-management)。下面的示例代码将 **仅适用于 Streamlit 版本 &gt;= 1.28**，因为 `st.connection` 是在该版本中添加的。

## 创建 MySQL 数据库

<Note>

如果您已经有一个想要使用的数据库，请随时
[跳到下一步](#将用户名和密码添加到本地应用密钥)。

</Note>

首先，按照 [此教程](https://dev.mysql.com/doc/mysql-getting-started/en/) 安装 MySQL 并启动 MySQL 服务器（记下用户名和密码！）。一旦您的 MySQL 服务器启动并运行，使用 `mysql` 客户端连接到它并输入以下命令来创建数据库和具有某些示例值的表：

```sql
CREATE DATABASE pets;

USE pets;

CREATE TABLE mytable (
    name varchar(80),
    pet varchar(80)
);

INSERT INTO mytable VALUES ('Mary', 'dog'), ('John', 'cat'), ('Robert', 'bird');
```

## 将用户名和密码添加到本地应用密钥

您的本地 Streamlit 应用将从应用根目录下的 `.streamlit/secrets.toml` 文件读取密钥。了解更多关于 [Streamlit 密钥管理的信息](/develop/concepts/connections/secrets-management)。如果该文件尚不存在，请创建它，并按照下面所示添加 MySQL 服务器的数据库名称、用户和密码：

```toml
# .streamlit/secrets.toml

[connections.mysql]
dialect = "mysql"
host = "localhost"
port = 3306
database = "xxx"
username = "xxx"
password = "xxx"
query = { charset = "xxx" }
```

如果在定义连接时使用 `query`，则必须使用 `streamlit&gt;=1.35.0`。

<Important>

当复制应用密钥到 Streamlit Community Cloud 时，请务必用远程 MySQL 数据库的 **host**、**port**、**database**、**username** 和 **password** 替换这些值！

将此文件添加到 `.gitignore` 并且不要将其提交到 GitHub 仓库中！

</Important>

## 将应用密钥复制到云端

由于上面的 `secrets.toml` 文件未提交到 GitHub，因此需要将其内容单独传递给部署的应用（在 Streamlit Community Cloud 上）。转到 [应用仪表板](https://share.streamlit.io/)，在应用的下拉菜单中，点击 **Edit Secrets**。将 `secrets.toml` 的内容复制到文本区域。更多信息请参阅 [密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

![密钥管理器截图](/images/databases/edit-secrets.png)

## 将依赖项添加到需求文件

将 [mysqlclient](https://github.com/PyMySQL/mysqlclient) 和 [SQLAlchemy](https://github.com/sqlalchemy/sqlalchemy) 包添加到 `requirements.txt` 文件中，最好固定其版本（将 `x.x.x` 替换为您希望安装的版本）：

```bash
# requirements.txt
mysqlclient==x.x.x
SQLAlchemy==x.x.x
```

## 编写您的 Streamlit 应用

将以下代码复制到您的 Streamlit 应用并运行。确保适配 `query` 以使用您的表名。

```python
# streamlit_app.py

import streamlit as st

# 初始化连接。
conn = st.connection('mysql', type='sql')

# 执行查询。
df = conn.query('SELECT * from mytable;', ttl=600)

# 打印结果。
for row in df.itertuples():
    st.write(f"{row.name} 有一只 :{row.pet}:")
```

看到了上面的 `st.connection` 吗？这会处理密钥检索、设置、查询缓存和重试。默认情况下，`query()` 结果会被缓存而不会过期。在这种情况下，我们设置了 `ttl=600` 以确保查询结果的缓存时间不超过10分钟。您也可以设置 `ttl=0` 来禁用缓存。了解更多请参阅 [缓存](/develop/concepts/architecture/caching)。

如果一切顺利（并且您使用了上面我们创建的示例表），您的应用应该如下所示：

![完成的应用截图](/images/databases/streamlit-app.png)

---

# Connect Streamlit to Neon

Source: https://docs.streamlit.io/develop/tutorials/databases/neon


## Introduction

This guide explains how to securely access a [Neon database](https://neon.tech/) from Streamlit. Neon is a fully managed serverless PostgreSQL database that separates storage and compute to offer features such as instant branching and automatic scaling.

### Prerequisites

- The following packages must be installed in your Python environment:

  ```txt
  streamlit&gt;=1.28
  psycopg2-binary&gt;=2.9.6
  sqlalchemy&gt;=2.0.0
  ```

    <Note>
        You may use `psycopg2` instead of `psycopg2-binary`. However, building Psycopg requires a few prerequisites (like a C compiler). To use `psycopg2` on Community Cloud, you must include `libpq-dev` in a [`packages.txt`](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#apt-get-dependencies) file in the root of your repository. `psycopg2-binary` is a stand-alone package that is practical for testing and development.
    </Note>

- You must have a Neon account.
- You should have a basic understanding of [`st.connection`](/develop/api-reference/connections/st.connection) and [Secrets management](/develop/concepts/connections/secrets-management).

## Create a Neon project

If you already have a Neon project that you want to use, you can [skip to the next step](#add-neon-connection-string-to-your-local-app-secrets).

1. Log in to the Neon console and navigate to the [Projects](https://console.neon.tech/app/projects) section.
1. If you see a prompt to enter your project name, skip to the next step. Otherwise, click the "**New Project**" button to create a new project.
1. Enter "Streamlit-Neon" for your project name, accept the othe default settings, and click "**Create Project**."

   After Neon creates your project with a ready-to-use `neondb` database, you will be redirected to your project's Quickstart.

1. Click on "**SQL Editor**" from the left sidebar.
1. Replace the text in the input area with the following code and click "**Run**" to add sample data to your project.

   ```sql
   CREATE TABLE home (
       id SERIAL PRIMARY KEY,
       name VARCHAR(100),
       pet VARCHAR(100)
   );

   INSERT INTO home (name, pet)
   VALUES
       ('Mary', 'dog'),
       ('John', 'cat'),
       ('Robert', 'bird');
   ```

## Add the Neon connection string to your local app secrets

1. Within your Neon project, click "**Dashboard**" in the left sidebar.
1. Within the "Connection Details" tile, locate your database connection string. It should look similar to this:

   ```bash
   postgresql://neondb_owner:xxxxxxxxxxxx@ep-adjective-noun-xxxxxxxx.us-east-2.aws.neon.tech/neondb?sslmode=require
   ```

1. If you do not already have a `.streamlit/secrets.toml` file in your app's root directory, create an empty secrets file.
1. Copy your connection string and add it to your app's `.streamlit/secrets.toml` file as follows:

   ```toml
   # .streamlit/secrets.toml

   [connections.neon]
   url="postgresql://neondb_owner:xxxxxxxxxxxx@ep-adjective-noun-xxxxxxxx.us-east-2.aws.neon.tech/neondb?sslmode=require"
   ```

   <Important>
       Add this file to `.gitignore` and don't commit it to your GitHub repo!
   </Important>

## Write your Streamlit app

1. Copy the code below to your Streamlit app and save it.

   ```python
   # streamlit_app.py

   import streamlit as st

   # Initialize connection.
   conn = st.connection("neon", type="sql")

   # Perform query.
   df = conn.query('SELECT * FROM home;', ttl="10m")

   # Print results.
   for row in df.itertuples():
       st.write(f"{row.name} has a :{row.pet}:")
   ```

   The `st.connection` object above handles secrets retrieval, setup, query caching and retries.

   By default, `query()` results are cached without expiring. Setting the `ttl` parameter to `"10m"` ensures the query result is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching).

1. Run your Streamlit app.

   ```bash
   streamlit run streamlit_app.py
   ```

   If everything worked out (and you used the example table we created above), your app should look like this:

   ![Finished app screenshot](/images/databases/streamlit-app.png)

## Connecting to a Neon database from Community Cloud

This tutorial assumes a local Streamlit app, but you can also connect to a Neon database from apps hosted on Community Cloud. The additional steps are:

- Add a [`requirements.txt`](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies) file to your repo. Include all the packages listed in [Prequisites](#prerequisites) and any other dependencies.
- [Add your secrets](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management#deploy-an-app-and-set-up-secrets) to your app in Community Cloud.

---

# 连接 Streamlit 到 PostgreSQL

Source: https://docs.streamlit.io/develop/tutorials/databases/postgresql


## 简介

本指南解释了如何从 Streamlit Community Cloud 安全地访问 **_远程_** PostgreSQL 数据库。它使用 [st.connection](/develop/api-reference/connections/st.connection) 和 Streamlit 的 [密钥管理](/develop/concepts/connections/secrets-management)。下面的示例代码将 **仅适用于 Streamlit 版本 &gt;= 1.28**，因为 `st.connection` 是在该版本中添加的。

## 创建 PostgreSQL 数据库

<Note>

如果你已经有想要使用的数据库，请随时
[跳到下一步](#将用户名和密码添加到本地应用密钥)。

</Note>

首先，按照 [此教程](https://www.tutorialspoint.com/postgresql/postgresql_environment.htm) 安装 PostgreSQL 并创建数据库（记下数据库名称、用户名和密码！）。打开 SQL Shell (`psql`) 并输入以下两个命令来创建一个包含一些示例值的表：

```sql
CREATE TABLE mytable (
    name            varchar(80),
    pet             varchar(80)
);

INSERT INTO mytable VALUES ('Mary', 'dog'), ('John', 'cat'), ('Robert', 'bird');
```

## 将用户名和密码添加到本地应用密钥

您的本地 Streamlit 应用将从应用根目录下的 `.streamlit/secrets.toml` 文件读取密钥。如果该文件尚不存在，请创建它，并按照下面所示添加数据库的名称、用户和密码：

```toml
# .streamlit/secrets.toml

[connections.postgresql]
dialect = "postgresql"
host = "localhost"
port = "5432"
database = "xxx"
username = "xxx"
password = "xxx"
```

<Important>

当复制应用密钥到 Streamlit Community Cloud 时，请务必用远程 PostgreSQL 数据库的 **host**、**port**、**database**、**username** 和 **password** 替换这些值！

将此文件添加到 `.gitignore` 并且不要将其提交到 GitHub 仓库中！

</Important>

## 将应用密钥复制到云端

由于上面的 `secrets.toml` 文件未提交到 GitHub，因此需要将其内容单独传递给部署的应用（在 Streamlit Community Cloud 上）。转到 [应用仪表板](https://share.streamlit.io/)，在应用的下拉菜单中，点击 **Edit Secrets**。将 `secrets.toml` 的内容复制到文本区域。更多信息请参阅 [密钥管理](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management)。

![密钥管理器截图](/images/databases/edit-secrets.png)

## 将依赖项添加到需求文件

将 [psycopg2-binary](https://www.psycopg.org/) 和 [SQLAlchemy](https://github.com/sqlalchemy/sqlalchemy) 包添加到 `requirements.txt` 文件中，最好固定其版本（将 `x.x.x` 替换为您希望安装的版本）：

```bash
# requirements.txt
psycopg2-binary==x.x.x
sqlalchemy==x.x.x
```

## 编写您的 Streamlit 应用

将以下代码复制到您的 Streamlit 应用并运行。确保适配 `query` 以使用您的表名。

```python
# streamlit_app.py

import streamlit as st

# 初始化连接。
conn = st.connection("postgresql", type="sql")

# 执行查询。
df = conn.query('SELECT * FROM mytable;', ttl="10m")

# 打印结果。
for row in df.itertuples():
    st.write(f"{row.name} 有一只 :{row.pet}:")
```

看到了上面的 `st.connection` 吗？这会处理密钥检索、设置、查询缓存和重试。默认情况下，`query()` 结果会被缓存而不会过期。在这种情况下，我们设置了 `ttl="10m"` 以确保查询结果的缓存时间不超过10分钟。您也可以设置 `ttl=0` 来禁用缓存。了解更多请参阅 [缓存](/develop/concepts/architecture/caching)。

如果一切顺利（并且您使用了上面我们创建的示例表），您的应用应该如下所示：

![完成的应用截图](/images/databases/streamlit-app.png)

---

# Connect Streamlit to a private Google Sheet

Source: https://docs.streamlit.io/develop/tutorials/databases/private-gsheet


## Introduction

This guide explains how to securely access a private Google Sheet from Streamlit Community Cloud. It uses [st.connection](/develop/api-reference/connections/st.connection), [Streamlit GSheetsConnection](https://github.com/streamlit/gsheets-connection), and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

If you are fine with enabling link sharing for your Google Sheet (i.e. everyone with the link can view it), the guide [Connect Streamlit to a public Google Sheet](/develop/tutorials/databases/public-gsheet) shows a simpler method of doing this. If your Sheet contains sensitive information and you cannot enable link sharing, keep on reading.

### Prerequisites

This tutorial requires `streamlit&gt;=1.28` and `st-gsheets-connection` in your Python environment.

## Create a Google Sheet

If you already have a Sheet that you want to use, you can [skip to the next step](#enable-the-sheets-api).

Create a spreadsheet with this example data.

<div>{{ maxWidth: '200px', margin: 'auto' }}&gt;

| name   | pet  |
| :----- | :--- |
| Mary   | dog  |
| John   | cat  |
| Robert | bird |

</div>

![Google sheet screenshot](/images/databases/private-gsheet-1.png)

## Enable the Sheets API

Programmatic access to Google Sheets is controlled through [Google Cloud Platform](https://cloud.google.com/). Create an account or sign in and head over to the [**APIs  Services** dashboard](https://console.cloud.google.com/apis/dashboard) (select or create a project if asked). As shown below, search for the Sheets API and enable it:

<Flex>
<Image alt="GCP screenshot 1" src="/images/databases/private-gsheet-2.png"/>
<Image alt="GCP screenshot 2" src="/images/databases/private-gsheet-3.png"/>
<Image alt="GCP screenshot 3" src="/images/databases/private-gsheet-4.png"/>
</Flex>

## Create a service account  key file

To use the Sheets API from Streamlit Community Cloud, you need a Google Cloud Platform service account (a special account type for programmatic data access). Go to the [**Service Accounts** page](https://console.cloud.google.com/iam-admin/serviceaccounts) and create an account with the **Viewer** permission (this will let the account access data but not change it):

<Flex>
<Image alt="GCP screenshot 5" src="/images/databases/private-gsheet-5.png"/>
<Image alt="GCP screenshot 6" src="/images/databases/private-gsheet-6.png"/>
<Image alt="GCP screenshot 7" src="/images/databases/private-gsheet-7.png"/>
</Flex>
<Note>

The button "**CREATE SERVICE ACCOUNT**" is gray, you don't have the correct permissions. Ask the admin of your Google Cloud project for help.

</Note>

After clicking "**DONE**", you should be back on the service accounts overview. First, note down the email address of the account you just created (**important for next step!**). Then, create a JSON key file for the new account and download it:

<Flex>
<Image alt="GCP screenshot 8" src="/images/databases/private-gsheet-8.png"/>
<Image alt="GCP screenshot 9" src="/images/databases/private-gsheet-9.png"/>
<Image alt="GCP screenshot 10" src="/images/databases/private-gsheet-10.png"/>
</Flex>

## Share the Google Sheet with the service account

By default, the service account you just created cannot access your Google Sheet. To give it access, click on the "**Share**" button in the Google Sheet, add the email of the service account (noted down in step 2), and choose the correct permission (if you just want to read the data, "**Viewer**" is enough):

<Flex>
<Image alt="GCP screenshot 11" src="/images/databases/private-gsheet-11.png"/>
<Image alt="GCP screenshot 12" src="/images/databases/private-gsheet-12.png"/>
</Flex>

## Add the key file to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the URL of your Google Sheet plus the content of the key file you downloaded to it as shown below:

```toml
# .streamlit/secrets.toml

[connections.gsheets]
spreadsheet = "https://docs.google.com/spreadsheets/d/xxxxxxx/edit#gid=0"

# From your JSON key file
type = "service_account"
project_id = "xxx"
private_key_id = "xxx"
private_key = "xxx"
client_email = "xxx"
client_id = "xxx"
auth_uri = "https://accounts.google.com/o/oauth2/auth"
token_uri = "https://oauth2.googleapis.com/token"
auth_provider_x509_cert_url = "https://www.googleapis.com/oauth2/v1/certs"
client_x509_cert_url = "xxx"
```

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Write your Streamlit app

Copy the code below to your Streamlit app and run it.

```python
# streamlit_app.py

import streamlit as st
from streamlit_gsheets import GSheetsConnection

# Create a connection object.
conn = st.connection("gsheets", type=GSheetsConnection)

df = conn.read()

# Print results.
for row in df.itertuples():
    st.write(f"{row.name} has a :{row.pet}:")
```

See `st.connection` above? This handles secrets retrieval, setup, query caching and retries. By default, `.read()` results are cached without expiring. You can pass optional parameters to `.read()` to customize your connection. For example, you can specify the name of a worksheet, cache expiration time, or pass-through parameters for [`pandas.read_csv`](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html) like this:

```python
df = conn.read(
    worksheet="Sheet1",
    ttl="10m",
    usecols=[0, 1],
    nrows=3,
)
```

In this case, we set `ttl="10m"` to ensure the query result is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching). We've declared optional parameters `usecols=[0,1]` and `nrows=3` for `pandas` to use under the hood.

If everything worked out (and you used the example table we created above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)

## Connecting to a Google Sheet from Community Cloud

This tutorial assumes a local Streamlit app, however you can also connect to Google Sheets from apps hosted in Community Cloud. The main additional steps are:

- [Include information about dependencies](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies) using a `requirements.txt` file with `st-gsheets-connection` and any other dependencies.
- [Add your secrets](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management) to your Community Cloud app.

---

# Connect Streamlit to a public Google Sheet

Source: https://docs.streamlit.io/develop/tutorials/databases/public-gsheet


## Introduction

This guide explains how to securely access a public Google Sheet from Streamlit. It uses [st.connection](/develop/api-reference/connections/st.connection), [Streamlit GSheetsConnection](https://github.com/streamlit/gsheets-connection), and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

This method requires you to enable link sharing for your Google Sheet. While the sharing link will not appear in your code (and actually acts as sort of a password!), someone with the link can get all the data in the Sheet. If you don't want this, follow the (more complicated) guide to [Connect Streamlit to a private Google Sheet](private-gsheet).

### Prerequisites

This tutorial requires `streamlit&gt;=1.28` and `st-gsheets-connection` in your Python environment.

## Create a Google Sheet and turn on link sharing

If you already have a Sheet that you want to access, you can [skip to the next step](#add-the-sheets-url-to-your-local-app-secrets). See Google's documentation on how to [share spreadsheets](https://support.google.com/docs/answer/9331169?hl=en#6.1) for more information.

Create a spreadsheet with this example data and create a share link. The link should have "Anyone with the link" set as a "Viewer."

<div>{{ maxWidth: '200px', margin: 'auto' }}&gt;

| name   | pet  |
| :----- | :--- |
| Mary   | dog  |
| John   | cat  |
| Robert | bird |

</div>
<Flex>
<Image alt="screenshot 1" src="/images/databases/public-gsheet-1.png"/>
<Image alt="screenshot 1" src="/images/databases/public-gsheet-2.png"/>
</Flex>

## Add the Sheets URL to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the share link of your Google Sheet to it as shown below:

```toml
# .streamlit/secrets.toml
[connections.gsheets]
spreadsheet = "https://docs.google.com/spreadsheets/d/xxxxxxx/edit#gid=0"
```

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Write your Streamlit app

Copy the code below to your Streamlit app and run it.

```python
# streamlit_app.py

import streamlit as st
from streamlit_gsheets import GSheetsConnection

# Create a connection object.
conn = st.connection("gsheets", type=GSheetsConnection)

df = conn.read()

# Print results.
for row in df.itertuples():
    st.write(f"{row.name} has a :{row.pet}:")
```

See `st.connection` above? This handles secrets retrieval, setup, query caching and retries. By default, `.read()` results are cached without expiring. You can pass optional parameters to `.read()` to customize your connection. For example, you can specify the name of a worksheet, cache expiration time, or pass-through parameters for [`pandas.read_csv`](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html) like this:

```python
df = conn.read(
    worksheet="Sheet1",
    ttl="10m",
    usecols=[0, 1],
    nrows=3,
)
```

In this case, we set `ttl="10m"` to ensure the query result is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching). We've declared optional parameters `usecols=[0,1]` and `nrows=3` for `pandas` to use under the hood.

If everything worked out (and you used the example table we created above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)

## Connecting to a Google Sheet from Community Cloud

This tutorial assumes a local Streamlit app, however you can also connect to Google Sheets from apps hosted in Community Cloud. The main additional steps are:

- [Include information about dependencies](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies) using a `requirements.txt` file with `st-gsheets-connection` and any other dependencies.
- [Add your secrets](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management) to your Community Cloud app.

---

# Connect Streamlit to Snowflake

Source: https://docs.streamlit.io/develop/tutorials/databases/snowflake


## Introduction

This guide explains how to securely access a Snowflake database from Streamlit. It uses [st.connection](/develop/api-reference/connections/st.connection), the [Snowpark library](https://docs.snowflake.com/en/developer-guide/snowpark/python/index), and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

### Prerequisites

- The following packages must be installed in your Python environment:

  ```txt
  streamlit&gt;=1.28
  snowflake-snowpark-python&gt;=0.9.0
  snowflake-connector-python&gt;=2.8.0
  ```

    <Note>
        Use the correct version of Python required by `snowflake-snowpark-python`. For example, if you use `snowflake-snowpark-python==1.23.0`, you must use Python version \&gt;=3.8, \</Note>

---

# Connect Streamlit to Supabase

Source: https://docs.streamlit.io/develop/tutorials/databases/supabase


## Introduction

This guide explains how to securely access a Supabase instance from Streamlit Community Cloud. It uses [st.connection](/develop/api-reference/connections/st.connection), [Streamlit Supabase Connector](https://github.com/SiddhantSadangi/st_supabase_connection/tree/main) (a community-built connection developed by [@SiddhantSadangi](https://github.com/SiddhantSadangi)) and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management). Supabase is the open source Firebase alternative and is based on PostgreSQL.

<Note>

Community-built connections, such as the [Streamlit Supabase Connector](https://github.com/SiddhantSadangi/st_supabase_connection/tree/main), extend and build on the `st.connection` interface and make it easier than ever to build Streamlit apps with a wide variety of data sources. These type of connections work exactly the same as [the ones built into Streamlit](/develop/api-reference/connections) and have access to all the same capabilities.

</Note>

## Sign in to Supabase and create a project

First, head over to [Supabase](https://app.supabase.io/) and sign up for a free account using your GitHub.

<Flex>
<Image caption="Sign in with GitHub" src="/images/databases/supabase-1.png"/>
<Image caption="Authorize Supabase" src="/images/databases/supabase-2.png"/>
</Flex>

Once you're signed in, you can create a project.

<Flex>
<Image caption="Your Supabase account" src="/images/databases/supabase-3.png"/>
<Image caption="Create a new project" src="/images/databases/supabase-4.png"/>
</Flex>

Your screen should look like this once your project has been created:

<Image src="/images/databases/supabase-5.png"/>
<Important>

Make sure to note down your Project API Key and Project URL highlighted in the above screenshot. ☝️

You will need these to connect to your Supabase instance from Streamlit.

</Important>

## Create a Supabase database

Now that you have a project, you can create a database and populate it with some sample data. To do so, click on the **SQL editor** button on the same project page, followed by the **New query** button in the SQL editor.

<Flex>
<Image caption="Open the SQL editor" src="/images/databases/supabase-6.png"/>
<Image caption="Create a new query" src="/images/databases/supabase-7.png"/>
</Flex>

In the SQL editor, enter the following queries to create a database and a table with some example values:

```sql
CREATE TABLE mytable (
    name            varchar(80),
    pet             varchar(80)
);

INSERT INTO mytable VALUES ('Mary', 'dog'), ('John', 'cat'), ('Robert', 'bird');
```

Click **Run** to execute the queries. To verify that the queries were executed successfully, click on the **Table Editor** button on the left menu, followed by your newly created table `mytable`.

<Flex>
<Image caption="Write and run your queries" src="/images/databases/supabase-8.png"/>
<Image caption="View your table in the Table Editor" src="/images/databases/supabase-9.png"/>
</Flex>

With your Supabase database created, you can now connect to it from Streamlit!

### Add Supabase Project URL and API key to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the `SUPABASE_URL` and `SUPABASE_KEY` here:

```toml
# .streamlit/secrets.toml

[connections.supabase]
SUPABASE_URL = "xxxx"
SUPABASE_KEY = "xxxx"
```

Replace `xxxx` above with your Project URL and API key from [Step 1](/develop/tutorials/databases/supabase#sign-in-to-supabase-and-create-a-project).

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add st-supabase-connection to your requirements file

Add the [`st-supabase-connection`](https://pypi.org/project/st-supabase-connection/) community-built connection library to your `requirements.txt` file, preferably pinning its version (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
st-supabase-connection==x.x.x
```

<Tip>

We've used the `st-supabase-connection` library here in combination with `st.connection` to benefit from the ease of setting up the data connection, managing your credentials, and Streamlit's caching capabilities that native and community-built connections provide.

You can however still directly use the [Supabase Python Client Library](https://pypi.org/project/supabase/) library if you prefer, but you'll need to write more code to set up the connection and cache the results. See [Using the Supabase Python Client Library](/develop/tutorials/databases/supabase#using-the-supabase-python-client-library) below for an example.

</Tip>

## Write your Streamlit app

Copy the code below to your Streamlit app and run it.

```python
# streamlit_app.py

import streamlit as st
from st_supabase_connection import SupabaseConnection

# Initialize connection.
conn = st.connection("supabase",type=SupabaseConnection)

# Perform query.
rows = conn.query("*", table="mytable", ttl="10m").execute()

# Print results.
for row in rows.data:
    st.write(f"{row['name']} has a :{row['pet']}:")

```

See `st.connection` above? This handles secrets retrieval, setup, query caching and retries. By default, `query()` results are cached without expiring. In this case, we set `ttl="10m"` to ensure the query result is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example table we created above), your app should look like this:

![Finished app screenshot](/images/databases/supabase-10.png)

As Supabase uses PostgresSQL under the hood, you can also connect to Supabase by using the connection string Supabase provides under Settings &gt; Databases. From there, you can refer to the [PostgresSQL tutorial](/develop/tutorials/databases/postgresql) to connect to your database.

## Using the Supabase Python Client Library

If you prefer to use the [Supabase Python Client Library](https://pypi.org/project/supabase/) directly, you can do so by following the steps below.

1. Add your Supabase Project URL and API key to your local app secrets:

   Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add the SUPABASE_URL and SUPABASE_KEY here:

   ```toml
   # .streamlit/secrets.toml

   SUPABASE_URL = "xxxx"
   SUPABASE_KEY = "xxxx"
   ```

2. Add `supabase` to your requirements file:

   Add the [`supabase`](https://github.com/supabase-community/supabase-py) Python Client Library to your `requirements.txt` file, preferably pinning its version (replace `x.x.x` with the version you want installed):

   ```bash
   # requirements.txt
   supabase==x.x.x
   ```

3. Write your Streamlit app:

   Copy the code below to your Streamlit app and run it.

   ```python
   # streamlit_app.py

   import streamlit as st
   from supabase import create_client, Client

   # Initialize connection.
   # Uses st.cache_resource to only run once.
   @st.cache_resource
   def init_connection():
       url = st.secrets["SUPABASE_URL"]
       key = st.secrets["SUPABASE_KEY"]
       return create_client(url, key)

   supabase = init_connection()

   # Perform query.
   # Uses st.cache_data to only rerun when the query changes or after 10 min.
   @st.cache_data(ttl=600)
   def run_query():
       return supabase.table("mytable").select("*").execute()

   rows = run_query()

   # Print results.
   for row in rows.data:
       st.write(f"{row['name']} has a :{row['pet']}:")
   ```

   See `st.cache_data` above? Without it, Streamlit would run the query every time the app reruns (e.g. on a widget interaction). With `st.cache_data`, it only runs when the query changes or after 10 minutes (that's what `ttl` is for). Watch out: If your database updates more frequently, you should adapt `ttl` or remove caching so viewers always see the latest data. Learn more in [Caching](/develop/concepts/architecture/caching).

---

# Connect Streamlit to Tableau

Source: https://docs.streamlit.io/develop/tutorials/databases/tableau


## Introduction

This guide explains how to securely access data on Tableau from Streamlit Community Cloud. It uses the [tableauserverclient](https://tableau.github.io/server-client-python/#) library and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

## Create a Tableau site

<Note>

If you already have a database that you want to use, feel free
to [skip to the next step](#create-personal-access-tokens).

</Note>

For simplicity, we are using the cloud version of Tableau here but this guide works equally well for self-hosted deployments. First, sign up for [Tableau Online](https://www.tableau.com/products/cloud-bi) or log in. Create a workbook or run one of the example workbooks under "Dashboard Starters".

![Tableau screenshot 1](/images/databases/tableau-1.png)

## Create personal access tokens

While the Tableau API allows authentication via username and password, you should use [personal access tokens](https://help.tableau.com/current/server/en-us/security_personal_access_tokens.htm) for a production app.

Go to your [Tableau Online homepage](https://online.tableau.com/), create an access token and note down the token name and secret.

<Flex>
<Image alt="Tableau screenshot 2" src="/images/databases/tableau-2.png"/>
<Image alt="Tableau screenshot 3" src="/images/databases/tableau-3.png"/>
</Flex>
<Note>

Personal access tokens will expire if not used after 15 consecutive days.

</Note>

## Add token to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Create this file if it doesn't exist yet and add your token, the site name you created during setup, and the URL of your Tableau server like below:

```toml
# .streamlit/secrets.toml

[tableau]
token_name = "xxx"
token_secret = "xxx"
server_url = "https://abc01.online.tableau.com/"
site_id = "streamlitexample"  # in your site's URL behind the server_url
```

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add tableauserverclient to your requirements file

Add the [tableauserverclient](https://tableau.github.io/server-client-python/#) package to your `requirements.txt` file, preferably pinning its version (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
tableauserverclient==x.x.x
```

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Note that this code just shows a few options of data you can get – explore the [tableauserverclient](https://tableau.github.io/server-client-python/#) library to find more!

```python
# streamlit_app.py

import streamlit as st
import tableauserverclient as TSC


# Set up connection.
tableau_auth = TSC.PersonalAccessTokenAuth(
    st.secrets["tableau"]["token_name"],
    st.secrets["tableau"]["personal_access_token"],
    st.secrets["tableau"]["site_id"],
)
server = TSC.Server(st.secrets["tableau"]["server_url"], use_server_version=True)


# Get various data.
# Explore the tableauserverclient library for more options.
# Uses st.cache_data to only rerun when the query changes or after 10 min.
@st.cache_data(ttl=600)
def run_query():
    with server.auth.sign_in(tableau_auth):

        # Get all workbooks.
        workbooks, pagination_item = server.workbooks.get()
        workbooks_names = [w.name for w in workbooks]

        # Get views for first workbook.
        server.workbooks.populate_views(workbooks[0])
        views_names = [v.name for v in workbooks[0].views]

        # Get image  CSV for first view of first workbook.
        view_item = workbooks[0].views[0]
        server.views.populate_image(view_item)
        server.views.populate_csv(view_item)
        view_name = view_item.name
        view_image = view_item.image
        # `view_item.csv` is a list of binary objects, convert to str.
        view_csv = b"".join(view_item.csv).decode("utf-8")

        return workbooks_names, views_names, view_name, view_image, view_csv

workbooks_names, views_names, view_name, view_image, view_csv = run_query()


# Print results.
st.subheader("📓 Workbooks")
st.write("Found the following workbooks:", ", ".join(workbooks_names))

st.subheader("👁️ Views")
st.write(
    f"Workbook *{workbooks_names[0]}* has the following views:",
    ", ".join(views_names),
)

st.subheader("🖼️ Image")
st.write(f"Here's what view *{view_name}* looks like:")
st.image(view_image, width=300)

st.subheader("📊 Data")
st.write(f"And here's the data for view *{view_name}*:")
st.write(pd.read_csv(StringIO(view_csv)))
```

See `st.cache_data` above? Without it, Streamlit would run the query every time the app reruns (e.g. on a widget interaction). With `st.cache_data`, it only runs when the query changes or after 10 minutes (that's what `ttl` is for). Watch out: If your database updates more frequently, you should adapt `ttl` or remove caching so viewers always see the latest data. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out, your app should look like this (can differ based on your workbooks):

![Tableau screenshot 4](/images/databases/tableau-4.png)

---

# Connect Streamlit to TiDB

Source: https://docs.streamlit.io/develop/tutorials/databases/tidb


## Introduction

This guide explains how to securely access a **_remote_** TiDB database from Streamlit Community Cloud. It uses [st.connection](/develop/api-reference/connections/st.connection) and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management). The below example code will **only work on Streamlit version &gt;= 1.28**, when `st.connection` was added.

[TiDB](https://www.pingcap.com/tidb/) is an open-source, MySQL-compatible database that supports Hybrid Transactional and Analytical Processing (HTAP) workloads. TiDB introducs a [built-in vector search](https://www.pingcap.com/ai/) to the SQL database family, enabling support for your AI applications without requiring a new database or additional technical stacks. [TiDB Cloud](https://tidb.cloud/) is a fully managed cloud database service that simplifies the deployment and management of TiDB databases for developers.

## Sign in to TiDB Cloud and create a cluster

First, head over to [TiDB Cloud](https://tidbcloud.com/free-trial) and sign up for a free account, using either Google, GitHub, Microsoft or E-mail:

![Sign up TiDB Cloud](/images/databases/tidb-1.png)

Once you've signed in, you will already have a TiDB cluster:

![List clusters](/images/databases/tidb-2.png)

You can create more clusters if you want to. Click the cluster name to enter cluster overview page:

![Cluster overview](/images/databases/tidb-3.png)

Then click **Connect** to easily get the connection arguments to access the cluster. On the popup, click **Generate Password** to set the password.

![Get connection arguments](/images/databases/tidb-4.png)

<Important>

Make sure to note down the password. It won't be available on TiDB Cloud after this step.

</Important>

## Create a TiDB database

<Note>

If you already have a database that you want to use, feel free
to [skip to the next step](#add-username-and-password-to-your-local-app-secrets).

</Note>

Once your TiDB cluster is up and running, connect to it with the `mysql` client(or with **SQL Editor** tab on the console) and enter the following commands to create a database and a table with some example values:

```sql
CREATE DATABASE pets;

USE pets;

CREATE TABLE mytable (
    name            varchar(80),
    pet             varchar(80)
);

INSERT INTO mytable VALUES ('Mary', 'dog'), ('John', 'cat'), ('Robert', 'bird');
```

## Add username and password to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app's root directory. Learn more about [Streamlit secrets management here](/develop/concepts/connections/secrets-management). Create this file if it doesn't exist yet and add host, username and password of your TiDB cluster as shown below:

```toml
# .streamlit/secrets.toml

[connections.tidb]
dialect = "mysql"
host = "<TiDB_cluster_host>"
port = 4000
database = "pets"
username = "<TiDB_cluster_user>"
password = "<TiDB_cluster_password>"
```

<Important>

When copying your app secrets to Streamlit Community Cloud, be sure to replace the values of **host**, **username** and **password** with those of your _remote_ TiDB cluster!

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on **Edit Secrets**. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add dependencies to your requirements file

Add the [mysqlclient](https://github.com/PyMySQL/mysqlclient) and [SQLAlchemy](https://github.com/sqlalchemy/sqlalchemy) packages to your `requirements.txt` file, preferably pinning its version (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
mysqlclient==x.x.x
SQLAlchemy==x.x.x
```

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Make sure to adapt `query` to use the name of your table.

```python
# streamlit_app.py

import streamlit as st

# Initialize connection.
conn = st.connection('tidb', type='sql')

# Perform query.
df = conn.query('SELECT * from mytable;', ttl=600)

# Print results.
for row in df.itertuples():
    st.write(f"{row.name} has a :{row.pet}:")
```

See `st.connection` above? This handles secrets retrieval, setup, query caching and retries. By default, `query()` results are cached without expiring. In this case, we set `ttl=600` to ensure the query result is cached for no longer than 10 minutes. You can also set `ttl=0` to disable caching. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example table we created above), your app should look like this:

![Finished app screenshot](/images/databases/streamlit-app.png)

## Connect with PyMySQL

Other than [mysqlclient](https://github.com/PyMySQL/mysqlclient), [PyMySQL](https://github.com/PyMySQL/PyMySQL) is another popular MySQL Python client. To use PyMySQL, first you need to adapt your requirements file:

```bash
# requirements.txt
PyMySQL==x.x.x
SQLAlchemy==x.x.x
```

Then adapt your secrets file:

```toml
# .streamlit/secrets.toml

[connections.tidb]
dialect = "mysql"
driver = "pymysql"
host = "<TiDB_cluster_host>"
port = 4000
database = "pets"
username = "<TiDB_cluster_user>"
password = "<TiDB_cluster_password>"
create_engine_kwargs = { connect_args = { ssl = { ca = "<path_to_CA_store>" }}}
```</path_to_CA_store></TiDB_cluster_password></TiDB_cluster_user></TiDB_cluster_host></TiDB_cluster_password></TiDB_cluster_user></TiDB_cluster_host>

---

# Connect Streamlit to TigerGraph

Source: https://docs.streamlit.io/develop/tutorials/databases/tigergraph


## Introduction

This guide explains how to securely access a TigerGraph database from Streamlit Community Cloud. It uses the [pyTigerGraph](https://pytigergraph.github.io/pyTigerGraph/GettingStarted/) library and Streamlit's [Secrets management](/develop/concepts/connections/secrets-management).

## Create a TigerGraph Cloud Database

First, follow the official tutorials to create a TigerGraph instance in TigerGraph Cloud, either as a [blog](https://www.tigergraph.com/blog/getting-started-with-tigergraph-3-0/) or a [video](https://www.youtube.com/watch?v=NtNW2e8MfCQ). Note your username, password, and subdomain.

For this tutorial, we will be using the COVID-19 starter kit. When setting up your solution, select the “COVID-19 Analysis" option.

![TG_Cloud_COVID19](/images/databases/tigergraph-1.png)

Once it is started, ensure your data is downloaded and queries are installed.

![TG_Cloud_Schema](/images/databases/tigergraph-2.png)

## Add username and password to your local app secrets

Your local Streamlit app will read secrets from a file `.streamlit/secrets.toml` in your app’s root directory. Create this file if it doesn’t exist yet and add your TigerGraph Cloud instance username, password, graph name, and subdomain as shown below:

```toml
# .streamlit/secrets.toml

[tigergraph]
host = "https://xxx.i.tgcloud.io/"
username = "xxx"
password = "xxx"
graphname = "xxx"
```

<Important>

Add this file to `.gitignore` and don't commit it to your GitHub repo!

</Important>

## Copy your app secrets to the cloud

As the `secrets.toml` file above is not committed to GitHub, you need to pass its content to your deployed app (on Streamlit Community Cloud) separately. Go to the [app dashboard](https://share.streamlit.io/) and in the app's dropdown menu, click on Edit Secrets. Copy the content of `secrets.toml` into the text area. More information is available at [Secrets management](/deploy/streamlit-community-cloud/deploy-your-app/secrets-management).

![Secrets manager screenshot](/images/databases/edit-secrets.png)

## Add PyTigerGraph to your requirements file

Add the pyTigerGraph package to your `requirements.txt` file, preferably pinning its version (replace `x.x.x` with the version you want installed):

```bash
# requirements.txt
pyTigerGraph==x.x.x
```

## Write your Streamlit app

Copy the code below to your Streamlit app and run it. Make sure to adapt the name of your graph and query.

```python
# streamlit_app.py

import streamlit as st
import pyTigerGraph as tg

# Initialize connection.
conn = tg.TigerGraphConnection(**st.secrets["tigergraph"])
conn.apiToken = conn.getToken(conn.createSecret())

# Pull data from the graph by running the "mostDirectInfections" query.
# Uses st.cache_data to only rerun when the query changes or after 10 min.
@st.cache_data(ttl=600)
def get_data():
    most_infections = conn.runInstalledQuery("mostDirectInfections")[0]["Answer"][0]
    return most_infections["v_id"], most_infections["attributes"]

items = get_data()

# Print results.
st.title(f"Patient {items[0]} has the most direct infections")
for key, val in items[1].items():
    st.write(f"Patient {items[0]}'s {key} is {val}.")
```

See `st.cache_data` above? Without it, Streamlit would run the query every time the app reruns (e.g. on a widget interaction). With `st.cache_data`, it only runs when the query changes or after 10 minutes (that's what `ttl` is for). Watch out: If your database updates more frequently, you should adapt `ttl` or remove caching so viewers always see the latest data. Learn more in [Caching](/develop/concepts/architecture/caching).

If everything worked out (and you used the example data we created above), your app should look like this:

![Final_App](/images/databases/tigergraph-3.png)

---

# Work with Streamlit elements

Source: https://docs.streamlit.io/develop/tutorials/elements


<TileContainer layout="list">
<RefCard href="/develop/tutorials/elements/annotate-an-altair-chart">
<h5>Annotate an Altair chart</h5>

Add annotations to an Altair chart.

</RefCard>
<RefCard href="/develop/tutorials/elements/dataframe-row-selections">
<h5>Get row selections from dataframes</h5>

Work with user row-selections in dataframes.

</RefCard>
</TileContainer>

---

# Annotate an Altair chart

Source: https://docs.streamlit.io/develop/tutorials/elements/annotate-an-altair-chart


Altair allows you to annotate your charts with text, images, and emojis. You can do this by overlaying two charts to create a [layered chart](https://altair-viz.github.io/user_guide/compound_charts.html#layered-charts).

## Applied concepts

- Use layered charts in Altair to create annotations.

## Prerequisites

- This tutorial requires the following Python libraries:

  ```txt
  streamlit
  altair&gt;=4.0.0
  vega_datasets
  ```

- This tutorial assumes you have a clean working directory called `your-repository`.
- You should have a basic understanding of the Vega-Altair charting library.

## Summary

In this example, you will create a time-series chart to track the evolution of stock prices. The chart will have two layers: a data layer and an
annotation layer. Each layer is an `altair.Chart` object. You will combine the two charts with the `+` opterator to create a layered chart.

Within the data layer, you'll add a multi-line tooltip to show information about datapoints. To learn more about multi-line tooltips, see this [example](https://altair-viz.github.io/gallery/multiline_tooltip.html) in Vega-Altair's documentation. You'll add another tooltip to the annotation layer.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import altair as alt
import pandas as pd
from vega_datasets import data


@st.cache_data
def get_data():
    source = data.stocks()
    source = source[source.date.gt("2004-01-01")]
    return source


stock_data = get_data()

hover = alt.selection_single(
    fields=["date"],
    nearest=True,
    on="mouseover",
    empty="none",
)

lines = (
    alt.Chart(stock_data, title="Evolution of stock prices")
    .mark_line()
    .encode(
        x="date",
        y="price",
        color="symbol",
    )
)

points = lines.transform_filter(hover).mark_circle(size=65)

tooltips = (
    alt.Chart(stock_data)
    .mark_rule()
    .encode(
        x="yearmonthdate(date)",
        y="price",
        opacity=alt.condition(hover, alt.value(0.3), alt.value(0)),
        tooltip=[
            alt.Tooltip("date", title="Date"),
            alt.Tooltip("price", title="Price (USD)"),
        ],
    )
    .add_selection(hover)
)

data_layer = lines + points + tooltips

ANNOTATIONS = [
    ("Sep 01, 2007", 450, "🙂", "Something's going well for GOOG  AAPL."),
    ("Nov 01, 2008", 220, "🙂", "The market is recovering."),
    ("Dec 01, 2007", 750, "😱", "Something's going wrong for GOOG  AAPL."),
    ("Dec 01, 2009", 680, "😱", "A hiccup for GOOG."),
]
annotations_df = pd.DataFrame(
    ANNOTATIONS, columns=["date", "price", "marker", "description"]
)
annotations_df.date = pd.to_datetime(annotations_df.date)

annotation_layer = (
    alt.Chart(annotations_df)
    .mark_text(size=20, dx=-10, dy=0, align="left")
    .encode(x="date:T", y=alt.Y("price:Q"), text="marker", tooltip="description")
)

combined_chart = data_layer + annotation_layer
st.altair_chart(combined_chart, use_container_width=True)
```

</Collapse>
<Cloud height="450px" name="doc-annotate-altair"/>

## Build the example

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
    import streamlit as st
    import altair as alt
    import pandas as pd
    from vega_datasets import data
   ```

   You'll be using these libraries as follows:
   - You'll download a dataset using [`vega_datasets`](https://pypi.org/project/vega-datasets/).
   - You'll maniputate the data using `pandas`.
   - You'll define a chart using `altair`.

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Build the data layer

You'll build an interactive time-series chart of the stock prices with a multi-line tooltip. The x-axis represents the date, and the y-axis represents the stock price.

1. Import data from `vega_datasets`.

   ```python
   @st.cache_data
   def get_data():
       source = data.stocks()
       source = source[source.date.gt("2004-01-01")]
       return source

   stock_data = get_data()
   ```

   The `@st.cache_data` decorator turns `get_data()` into a cahced function. Streamlit will only download the data once since the data will be saved in a cache. For more information about caching, see [Caching overview](/develop/concepts/architecture/caching).

1. Define a mouseover selection event in Altair.

   ```python
   hover = alt.selection_single(
       fields=["date"],
       nearest=True,
       on="mouseover",
       empty="none",
   )
   ```

   This defines a mouseover selection for points. `fields=["date"]` allows Altair to identify other points with the same date. You will use this to create a vertical line highlight when a user hovers over a point.

1. Define a basic line chart to graph the five series in your data set.

   ```python
   lines = (
       alt.Chart(stock_data, title="Evolution of stock prices")
       .mark_line()
       .encode(
           x="date",
           y="price",
           color="symbol",
       )
   )
   ```

1. Draw points on the lines and highlight them based on the mouseover selection.

   ```python
   points = lines.transform_filter(hover).mark_circle(size=65)
   ```

   Since the mouseover selection includes `fields=["date"]`, Altair will draw circles on each series at the same date.

1. Draw a vertical rule at the location of the mouseover selection.

   ```python
   tooltips = (
       alt.Chart(stock_data)
       .mark_rule()
       .encode(
           x="yearmonthdate(date)",
           y="price",
           opacity=alt.condition(hover, alt.value(0.3), alt.value(0)),
           tooltip=[
               alt.Tooltip("date", title="Date"),
               alt.Tooltip("price", title="Price (USD)"),
           ],
       )
       .add_selection(hover)
   )
   ```

   The `opacity` parameter ensures each vertical line is only visible when it's part of a mouseover selection. Each `alt.Tooltip` adds a line to your multi-line tooltip.

1. Combine the lines, points, and tooltips into a single chart.

   ```python
   data_layer = lines + points + tooltips
   ```

1. Optional: Test out your code by rendering your data layer.

   ```python
   st.altair_chart(data_layer, use_container_width=True)
   ```

   Save your file and examine the chart in your app. Use your mouse to hover over points. Observe the circle marks, vertical line, and tooltip as you hover over a point. Delete the line or keep it at the end of your app to be updated as you continue.

### Build the annotation layer

Now that you have the first chart that shows the data, you can annotate it with text and an emoji. In this section, you'll add some emojis and tooltips to mark specifc points of interest.

1. Create a list of annotations.

   ```python
   ANNOTATIONS = [
       ("Sep 01, 2007", 450, "🙂", "Something's going well for GOOG  AAPL."),
       ("Nov 01, 2008", 220, "🙂", "The market is recovering."),
       ("Dec 01, 2007", 750, "😱", "Something's going wrong for GOOG  AAPL."),
       ("Dec 01, 2009", 680, "😱", "A hiccup for GOOG."),
   ]
   annotations_df = pd.DataFrame(
       ANNOTATIONS, columns=["date", "price", "marker", "description"]
   )
   annotations_df.date = pd.to_datetime(annotations_df.date)
   ```

   The first two columns ("date" and "price") determine where Altair will place the marker. The third column ("marker") determines what icon Altair will place. The last column ("description") will fill in the associated tooltip.

1. Create a scatter plot with the x-axis representing the date and the y-axis representing the height ("price") of each annotation.

   ```python
   annotation_layer = (
       alt.Chart(annotations_df)
       .mark_text(size=20, dx=-10, dy=0, align="left")
       .encode(x="date:T", y=alt.Y("price:Q"), text="marker", tooltip="description")
   )
   ```

   The `dx=-10, dy=0` inside of `.mark_text()` offsets the icons so they are centered at the coordinate in your annotations dataframe. The four columns are passed to the chart through the `.encode()` method. If you want to use the same marker for all points, you can remove `text="marker"` from the `.encode()` method and add the marker to `.mark_text()`. For example, `.mark_text(text="🥳")` would make all the icons be "🥳". For more information about `.mark_text()`, see Altair's [documentation](https://altair-viz.github.io/user_guide/marks.html).

### Combine the chart layers

1. Define the combined chart.

   ```python
   combined_chart = data_layer + annotation_layer
   ```

1. Display the chart in Streamlit.

   ```python
   st.altair_chart(combined_chart, use_container_width=True)
   ```

## Next steps

Play around with your new app.

- If you want to use custom images instead of text or emojis to annotation your chart, you can replace the line containing `.mark_text()` with `.mark_image()`. For some URL string stored in a variable `IMAGE_URL`, you could do something like this:

  ```python
  .mark_image(
      width=12,
      height=12,
      url=IMAGE_URL,
  )
  ```

- If you want to enable panning and zooming for your chart, add `.interactive()` when you define your combined chart:

  ```python
  combined_chart = (data_layer + annotation_layer).interactive()
  ```

---

# Get dataframe row-selections from users

Source: https://docs.streamlit.io/develop/tutorials/elements/dataframe-row-selections


Streamlit offers two commands for rendering beautiful, interactive dataframes in your app. If you need users to edit data, add rows, or delete rows, use `st.data_editor`. If you don't want users to change the data in your dataframe, use `st.dataframe`. Users can sort and search through data rendered with `st.dataframe`. Additionally, you can activate selections to work with users' row and column selections.

This tutorial uses row selections, which were introduced in Streamlit version 1.35.0. For an older workaround using `st.data_editor`, see [Get dataframe row-selections (`streamlit

---

# Get dataframe row-selections from users (`streamlit

Source: https://docs.streamlit.io/develop/tutorials/elements/dataframe-row-selections-old

---

# Use core features to work with Streamlit's execution model

Source: https://docs.streamlit.io/develop/tutorials/execution-flow


## Fragments

<TileContainer layout="list">
<RefCard href="/develop/tutorials/execution-flow/trigger-a-full-script-rerun-from-a-fragment">
<h5>Trigger a full-script rerun from inside a fragment</h5>

Call `st.rerun` from inside a fragment to trigger a full-script rerun when a condition is met.

</RefCard>
<RefCard href="/develop/tutorials/execution-flow/create-a-multiple-container-fragment">
<h5>Create a fragment across multiple containers</h5>

Use a fragment to write to multiple containers across your app.

</RefCard>
<RefCard href="/develop/tutorials/execution-flow/start-and-stop-fragment-auto-reruns">
<h5>Start and stop a streaming fragment</h5>

Use a fragment to live-stream data. Use a button to start and stop the live-streaming.

</RefCard>
</TileContainer>

---

# Create a fragment across multiple containers

Source: https://docs.streamlit.io/develop/tutorials/execution-flow/create-a-multiple-container-fragment


Streamlit lets you turn functions into [fragments](/develop/concepts/architecture/fragments), which can rerun independently from the full script. If your fragment doesn't write to outside containers, Streamlit will clear and redraw all the fragment elements with each fragment rerun. However, if your fragment _does_ write elements to outside containers, Streamlit will not clear those elements during a fragment rerun. Instead, those elements accumulate with each fragment rerun until the next full-script rerun. If you want a fragment to update multiple containers in your app, use [`st.empty()`](/develop/api-reference/layout/st.empty) containers to prevent accumulating elements.

## Applied concepts

- Use fragments to run two independent processes separately.
- Distribute a fragment across multiple containers.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.37.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of fragments and `st.empty()`.

## Summary

In this toy example, you'll build an app with six containers. Three containers will have orange cats. The other three containers will have black cats. You'll have three buttons in the sidebar: "**Herd the black cats**," "**Herd the orange cats**," and "**Herd all the cats**." Since herding cats is slow, you'll use fragments to help Streamlit run the associated processes efficiently. You'll create two fragments, one for the black cats and one for the orange cats. Since the buttons will be in the sidebar and the fragments will update containers in the main body, you'll use a trick with `st.empty()` to ensure you don't end up with too many cats in your app (if it's even possible to have too many cats). 😻

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import time

st.title("Cats!")

row1 = st.columns(3)
row2 = st.columns(3)

grid = [col.container(height=200) for col in row1 + row2]
safe_grid = [card.empty() for card in grid]


def black_cats():
    time.sleep(1)
    st.title("🐈‍⬛ 🐈‍⬛")
    st.markdown("🐾 🐾 🐾 🐾")


def orange_cats():
    time.sleep(1)
    st.title("🐈 🐈")
    st.markdown("🐾 🐾 🐾 🐾")


@st.fragment
def herd_black_cats(card_a, card_b, card_c):
    st.button("Herd the black cats")
    container_a = card_a.container()
    container_b = card_b.container()
    container_c = card_c.container()
    with container_a:
        black_cats()
    with container_b:
        black_cats()
    with container_c:
        black_cats()


@st.fragment
def herd_orange_cats(card_a, card_b, card_c):
    st.button("Herd the orange cats")
    container_a = card_a.container()
    container_b = card_b.container()
    container_c = card_c.container()
    with container_a:
        orange_cats()
    with container_b:
        orange_cats()
    with container_c:
        orange_cats()


with st.sidebar:
    herd_black_cats(grid[0].empty(), grid[2].empty(), grid[4].empty())
    herd_orange_cats(grid[1].empty(), grid[3].empty(), grid[5].empty())
    st.button("Herd all the cats")
```

</Collapse>
<Cloud height="650px" name="doc-tutorial-fragment-multiple-container"/>

## Build the example

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
   import streamlit as st
   import time
   ```

   You'll use `time.sleep()` to slow things down and see the fragments working.

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Frame out your app's containers

1. Add a title to your app and two rows of three containers.

   ```python
   st.title("Cats!")

   row1 = st.columns(3)
   row2 = st.columns(3)

   grid = [col.container(height=200) for col in row1 + row2]
   ```

   Save your file to see your updated preview.

1. Define a helper function to draw two black cats.

   ```python
   def black_cats():
       time.sleep(1)
       st.title("🐈‍⬛ 🐈‍⬛")
       st.markdown("🐾 🐾 🐾 🐾")
   ```

   This function represents "herding two cats" and uses `time.sleep()` to simulate a slower process. You will use this to draw two cats in one of your grid cards later on.

1. Define another helper function to draw two orange cats.

   ```python
   def orange_cats():
       time.sleep(1)
       st.title("🐈 🐈")
       st.markdown("🐾 🐾 🐾 🐾")
   ```

1. Optional: Test out your functions by calling each one within a grid card.

   ```python
   with grid[0]:
       black_cats()
   with grid[1]:
       orange_cats()
   ```

   Save your `app.py` file to see the preview. Delete these four lines when finished.

### Define your fragments

Since each fragment will span across the sidebar and three additional containers, you'll use the sidebar to hold the main body of the fragment and pass the three containers as function arguments.

1. Use an [`@st.fragment`](/develop/api-reference/execution-flow/st.fragment) decorator and start your black-cat fragment definition.

   ```python
   @st.fragment
   def herd_black_cats(card_a, card_b, card_c):
   ```

1. Add a button for rerunning this fragment.

   ```python
       st.button("Herd the black cats")
   ```

1. Write to each container using your helper function.

   ```python
       with card_a:
           black_cats()
       with card_b:
           black_cats()
       with card_c:
           black_cats()
   ```

   **This code above will not behave as desired, but you'll explore and correct this in the following steps.**

1. Test out your code. Call your fragment function in the sidebar.

   ```python
   with st.sidebar:
       herd_black_cats(grid[0], grid[2], grid[4])
   ```

   Save your file and try using the button in the sidebar. More and more cats are appear in the cards with each fragment rerun! This is the expected behavior when fragments write to outside containers. To fix this, you will pass `st.empty()` containers to your fragment function.

   ![Example Streamlit app showing accumulating elements when a fragment writes to outside containers](/images/tutorials/fragment-multiple-containers-tutorial-app-duplicates.jpg)

1. Delete the lines of code from the previous two steps.

1. To prepare for using `st.empty()` containers, correct your cat-herding function as follows. After the button, define containers to place in the `st.empty()` cards you'll pass to your fragment.

   ```python
       container_a = card_a.container()
       container_b = card_b.container()
       container_c = card_c.container()
       with container_a:
           black_cats()
       with container_b:
           black_cats()
       with container_c:
           black_cats()
   ```

   In this new version, `card_a`, `card_b`, and `card_c` will be `st.empty()` containers. You create `container_a`, `container_b`, and `container_c` to allow Streamlit to draw multiple elements on each grid card.

1. Similarly define your orange-cat fragment function.

   ```python
   @st.fragment
   def herd_orange_cats(card_a, card_b, card_c):
       st.button("Herd the orange cats")
       container_a = card_a.container()
       container_b = card_b.container()
       container_c = card_c.container()
       with container_a:
           orange_cats()
       with container_b:
           orange_cats()
       with container_c:
           orange_cats()
   ```

### Put the functions together together to create an app

1. Call both of your fragments in the sidebar.

   ```python
   with st.sidebar:
       herd_black_cats(grid[0].empty(), grid[2].empty(), grid[4].empty())
       herd_orange_cats(grid[1].empty(), grid[3].empty(), grid[5].empty())
   ```

   By creating `st.empty()` containers in each card and passing them to your fragments, you prevent elements from accumulating in the cards with each fragment rerun. If you create the `st.empty()` containers earlier in your app, full-script reruns will clear the orange-cat cards while (first) rendering the black-cat cards.

1. Include a button outside of your fragments. When clicked, the button will trigger a full-script rerun since you're calling its widget function outside of any fragment.

   ```python
       st.button("Herd all the cats")
   ```

1. Save your file and try out the app! When you click "**Herd the black cats**" or "**Herd the orange cats**," Streamlit will only redraw the three related cards. When you click "**Herd all the cats**," Streamlit redraws all six cards.

---

# Start and stop a streaming fragment

Source: https://docs.streamlit.io/develop/tutorials/execution-flow/start-and-stop-fragment-auto-reruns


Streamlit lets you turn functions into [fragments](/develop/concepts/architecture/fragments), which can rerun independently from the full script. Additionally, you can tell Streamlit to rerun a fragment at a set time interval. This is great for streaming data or monitoring processes. You may want the user to start and stop this live streaming. To do this, programmatically set the `run_every` parameter for your fragment.

## Applied concepts

- Use a fragment to stream live data.
- Start and stop a fragment from automatically rerunning.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.37.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of fragments.

## Summary

In this example, you'll build an app that streams two data series in a line chart. Your app will gather recent data on the first load of a session and statically display the line chart. Two buttons in the sidebar will allow users to start and stop data streaming to update the chart in real time. You'll use a fragment to manage the frequency and scope of the live updates.

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta


def get_recent_data(last_timestamp):
    """Generate and return data from last timestamp to now, at most 60 seconds."""
    now = datetime.now()
    if now - last_timestamp &gt; timedelta(seconds=60):
        last_timestamp = now - timedelta(seconds=60)
    sample_time = timedelta(seconds=0.5)  # time between data points
    next_timestamp = last_timestamp + sample_time
    timestamps = np.arange(next_timestamp, now, sample_time)
    sample_values = np.random.randn(len(timestamps), 2)

    data = pd.DataFrame(sample_values, index=timestamps, columns=["A", "B"])
    return data


if "data" not in st.session_state:
    st.session_state.data = get_recent_data(datetime.now() - timedelta(seconds=60))

if "stream" not in st.session_state:
    st.session_state.stream = False


def toggle_streaming():
    st.session_state.stream = not st.session_state.stream


st.title("Data feed")
st.sidebar.slider(
    "Check for updates every: (seconds)", 0.5, 5.0, value=1.0, key="run_every"
)
st.sidebar.button(
    "Start streaming", disabled=st.session_state.stream, on_click=toggle_streaming
)
st.sidebar.button(
    "Stop streaming", disabled=not st.session_state.stream, on_click=toggle_streaming
)

if st.session_state.stream is True:
    run_every = st.session_state.run_every
else:
    run_every = None


@st.fragment(run_every=run_every)
def show_latest_data():
    last_timestamp = st.session_state.data.index[-1]
    st.session_state.data = pd.concat(
        [st.session_state.data, get_recent_data(last_timestamp)]
    )
    st.session_state.data = st.session_state.data[-100:]
    st.line_chart(st.session_state.data)


show_latest_data()
```

</Collapse>
<Cloud height="550px" name="doc-tutorial-fragment-streaming"/>

## Build the example

### Initialize your app

1. In `your_repository`, create a file named `app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run app.py
   ```

   Your app will be blank because you still need to add code.

1. In `app.py`, write the following:

   ```python
    import streamlit as st
    import pandas as pd
    import numpy as np
    from datetime import datetime, timedelta
   ```

   You'll be using these libraries as follows:
   - You'll work with two data series in a `pandas.DataFrame`.
   - You'll generate random data with `numpy`.
   - The data will have `datetime.datetime` index values.

1. Save your `app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `app.py`.

1. Return to your code.

### Build a function to generate random, recent data

To begin with, you'll define a function to randomly generate some data for two time series, which you'll call "A" and "B." It's okay to skip this section if you just want to copy the function.

<Collapse title="Complete function to randomly generate sales data">{false}&gt;

```python
def get_recent_data(last_timestamp):
    """Generate and return data from last timestamp to now, at most 60 seconds."""
    now = datetime.now()
    if now - last_timestamp &gt; timedelta(seconds=60):
        last_timestamp = now - timedelta(seconds=60)
    sample_time = timedelta(seconds=0.5)  # time between data points
    next_timestamp = last_timestamp + sample_time
    timestamps = np.arange(next_timestamp, now, sample_time)
    sample_values = np.random.randn(len(timestamps), 2)

    data = pd.DataFrame(sample_values, index=timestamps, columns=["A", "B"])
    return data
```

</Collapse>

1. Start your function definition.

   ```python
   def get_recent_data(last_timestamp):
       """Generate and return data from last timestamp to now, at most 60 seconds."""
   ```

   You'll pass the timestamp of your most recent datapoint to your data-generating function. Your function will use this to only return new data.

1. Get the current time and adjust the last timestamp if it is over 60 seconds ago.

   ```python
       now = datetime.now()
       if now - last_timestamp &gt; timedelta(seconds=60):
           last_timestamp = now - timedelta(seconds=60)
   ```

   By updating the last timestamp, you'll ensure the function never returns more than 60 seconds of data.

1. Declare a new variable, `sample_time`, to define the time between datapoints. Calculate the timestamp of the first, new datapoint.

   ```python
       sample_time = timedelta(seconds=0.5)  # time between data points
       next_timestamp = last_timestamp + sample_time
   ```

1. Create a `datetime.datetime` index and generate two data series of the same length.

   ```python
       timestamps = np.arange(next_timestamp, now, sample_time)
       sample_values = np.random.randn(len(timestamps), 2)
   ```

1. Combine the data series with the index into a `pandas.DataFrame` and return the data.

   ```python
       data = pd.DataFrame(sample_values, index=timestamps, columns=["A", "B"])
       return data
   ```

1. Optional: Test out your function by calling it and displaying the data.

   ```python
   data = get_recent_data(datetime.now() - timedelta(seconds=60))
   data
   ```

   Save your `app.py` file to see the preview. Delete these two lines when finished.

### Initialize Session State values for your app

Since you will dynamically change the `run_every` parameter of `@st.fragment()`, you'll need to initialize the associated variables and Session State values before defining your fragment function. Your fragment function will also read and update values in Session State, so you can define those now to make the fragment function easier to understand.

1. Initialize your data for the first app load in a session.

   ```python
   if "data" not in st.session_state:
       st.session_state.data = get_recent_data(datetime.now() - timedelta(seconds=60))
   ```

   Your app will display this initial data in a static line chart before a user starts streaming data.

1. Initialize `"stream"` in Session State to turn streaming on and off. Set the default to off (`False`).

   ```python
   if "stream" not in st.session_state:
       st.session_state.stream = False
   ```

1. Create a callback function to toggle `"stream"` between `True` and `False`.

   ```python
   def toggle_streaming():
       st.session_state.stream = not st.session_state.stream
   ```

1. Add a title to your app.

   ```python
   st.title("Data feed")
   ```

1. Add a slider to the sidebar to set how frequently to check for data while streaming.

   ```python
   st.sidebar.slider(
       "Check for updates every: (seconds)", 0.5, 5.0, value=1.0, key="run_every"
   )
   ```

1. Add buttons to the sidebar to turn streaming on and off.

   ```python
   st.sidebar.button(
       "Start streaming", disabled=st.session_state.stream, on_click=toggle_streaming
   )
   st.sidebar.button(
       "Stop streaming", disabled=not st.session_state.stream, on_click=toggle_streaming
   )
   ```

   Both functions use the same callback to toggle `"stream"` in Session State. Use the current value `"stream"` to disable one of the buttons. This ensures the buttons are always consistent with the current state; "**Start streaming**" is only clickable when streaming is off, and "**Stop streaming**" is only clickable when streaming is on. The buttons also provide status to the user by highlighting which action is available to them.

1. Create and set a new variable, `run_every`, that will determine whether or not the fragment function will rerun automatically (and how fast).

   ```python
   if st.session_state.stream is True:
       run_every = st.session_state.run_every
   else:
       run_every = None
   ```

### Build a fragment function to stream data

To allow the user to turn data streaming on and off, you must set the `run_every` parameter in the `@st.fragment()` decorator.

<Collapse title="Complete function to show and stream data">{false}&gt;

```python
@st.fragment(run_every=run_every)
def show_latest_data():
    last_timestamp = st.session_state.data.index[-1]
    st.session_state.data = pd.concat(
        [st.session_state.data, get_recent_data(last_timestamp)]
    )
    st.session_state.data = st.session_state.data[-100:]
    st.line_chart(st.session_state.data)
```

</Collapse>

1. Use an [`@st.fragment`](/develop/api-reference/execution-flow/st.fragment) decorator and start your function definition.

   ```python
    @st.fragment(run_every=run_every)
    def show_latest_data():
   ```

   Use the `run_every` variable declared above to set the parameter of the same name.

1. Retrieve the timestamp of the last datapoint in Session State.

   ```python
       last_timestamp = st.session_state.data.index[-1]
   ```

1. Update the data in Session State and trim to keep only the last 100 timestamps.

   ```python
       st.session_state.data = pd.concat(
           [st.session_state.data, get_recent_data(last_timestamp)]
       )
       st.session_state.data = st.session_state.data[-100:]
   ```

1. Show the data in a line chart.

   ```python
       st.line_chart(st.session_state.data)
   ```

   Your fragment-function definition is complete.

### Call and test out your fragment function

1. Call your function at the bottom of your code.

   ```python
   show_latest_data()
   ```

1. Test out your app by clicking "**Start streaming**." Try adjusting the frequency of updates.

## Next steps

Try adjusting the frequency of data generation or how much data is kept in Session State. Within `get_recent_data` try setting `sample_time` with a widget.

Try using [st.plotly_chart](/develop/api-reference/charts/st.plotly_chart) or [st.altair_chart](/develop/api-reference/charts/st.altair_chart) to add labels to your chart.

---

# Trigger a full-script rerun from inside a fragment

Source: https://docs.streamlit.io/develop/tutorials/execution-flow/trigger-a-full-script-rerun-from-a-fragment


Streamlit lets you turn functions into [fragments](/develop/concepts/architecture/fragments), which can rerun independently from the full script. When a user interacts with a widget inside a fragment, only the fragment reruns. Sometimes, you may want to trigger a full-script rerun from inside a fragment. To do this, call [`st.rerun`](/develop/api-reference/execution-flow/st.rerun) inside the fragment.

## Applied concepts

- Use a fragment to rerun part or all of your app, depending on user input.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```text
  streamlit&gt;=1.37.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of fragments and `st.rerun`.

## Summary

In this example, you'll build an app to display sales data. The app has two sets of elements that depend on a date selection. One set of elements displays information for the selected day. The other set of elements displays information for the associated month. If the user changes days within a month, Streamlit only needs to update the first set of elements. If the user selects a day in a different month, Streamlit needs to update all the elements.

You'll collect the day-specific elements into a fragment to avoid rerunning the full app when a user changes days within the same month. If you want to jump ahead to the fragment function definition, see [Build a function to show daily sales data](#build-a-function-to-show-daily-sales-data).

<div>{{ maxWidth: '60%', margin: 'auto' }}&gt;
<Image alt="Execution flow of example Streamlit app showing daily sales on the left and monthly sales on the right" src="/images/tutorials/fragment-rerun-tutorial-execution-flow.png"/>
</div>

Here's a look at what you'll build:

<Collapse title="Complete code">{false}&gt;

```python
import streamlit as st
import pandas as pd
import numpy as np
from datetime import date, timedelta
import string
import time


@st.cache_data
def get_data():
    """Generate random sales data for Widget A through Widget Z"""

    product_names = ["Widget " + letter for letter in string.ascii_uppercase]
    average_daily_sales = np.random.normal(1_000, 300, len(product_names))
    products = dict(zip(product_names, average_daily_sales))

    data = pd.DataFrame({})
    sales_dates = np.arange(date(2023, 1, 1), date(2024, 1, 1), timedelta(days=1))
    for product, sales in products.items():
        data[product] = np.random.normal(sales, 300, len(sales_dates)).round(2)
    data.index = sales_dates
    data.index = data.index.date
    return data


@st.fragment
def show_daily_sales(data):
    time.sleep(1)
    with st.container(height=100):
        selected_date = st.date_input(
            "Pick a day ",
            value=date(2023, 1, 1),
            min_value=date(2023, 1, 1),
            max_value=date(2023, 12, 31),
            key="selected_date",
        )

    if "previous_date" not in st.session_state:
        st.session_state.previous_date = selected_date
    previous_date = st.session_state.previous_date
    st.session_state.previous_date = selected_date
    is_new_month = selected_date.replace(day=1) != previous_date.replace(day=1)
    if is_new_month:
        st.rerun()

    with st.container(height=510):
        st.header(f"Best sellers, {selected_date:%m/%d/%y}")
        top_ten = data.loc[selected_date].sort_values(ascending=False)[0:10]
        cols = st.columns([1, 4])
        cols[0].dataframe(top_ten)
        cols[1].bar_chart(top_ten)

    with st.container(height=510):
        st.header(f"Worst sellers, {selected_date:%m/%d/%y}")
        bottom_ten = data.loc[selected_date].sort_values()[0:10]
        cols = st.columns([1, 4])
        cols[0].dataframe(bottom_ten)
        cols[1].bar_chart(bottom_ten)


def show_monthly_sales(data):
    time.sleep(1)
    selected_date = st.session_state.selected_date
    this_month = selected_date.replace(day=1)
    next_month = (selected_date.replace(day=28) + timedelta(days=4)).replace(day=1)

    st.container(height=100, border=False)
    with st.container(height=510):
        st.header(f"Daily sales for all products, {this_month:%B %Y}")
        monthly_sales = data[(data.index </Collapse>

---

# Build multipage apps

Source: https://docs.streamlit.io/develop/tutorials/multipage


<TileContainer layout="list">
<RefCard href="/develop/tutorials/multipage/dynamic-navigation">
<h5>Create a dynamic navigation menu</h5>

Create a dynamic, user-dependant navigation menu with `st.navigation`.

</RefCard>
</TileContainer>

---

# Create a dynamic navigation menu

Source: https://docs.streamlit.io/develop/tutorials/multipage/dynamic-navigation


`st.navigation` makes it easy to build dynamic navigation menus. You can change the set of pages passed to `st.navigation` with each rerun, which changes the navigation menu to match. This is a convenient feature for creating custom, role-based navigation menus.

This tutorial uses `st.navigation` and `st.Page`, which were introduced in Streamlit version 1.36.0. For an older workaround using the `pages/` directory and `st.page_link`, see [Build a custom navigation menu with `st.page_link`](/develop/tutorials/multipage/st.page_link-nav).

## Applied concepts

- Use `st.navigation` and `st.Page` to define a multipage app.
- Create a dynamic, role-based navigation menu.

## Prerequisites

- This tutorial requires the following version of Streamlit:

  ```
  streamlit&gt;=1.36.0
  ```

- You should have a clean working directory called `your-repository`.
- You should have a basic understanding of `st.navigation` and `st.Page`.

## Summary

In this example, we'll build a dynamic navigation menu for a multipage app that depends on the current user's role. You'll abstract away the use of username and credentials to simplify the example. Instead, you'll use a selectbox to let users choose a role and log in.

The entrypoint file, `streamlit_app.py` will handle user authentication. The other pages will be stubs representing account management (`settings.py`) and specific pages associated to three roles: Requester, Responder, and Admin. Requesters can access the account and request pages. Responders can access the account and respond pages. Admins can access all pages.

Here's a look at what we'll build:

<Collapse title="Complete code">{false}&gt;

**Directory structure:**

```
your-repository/
├── admin
│   ├── admin_1.py
│   └── admin_2.py
├── images
│   ├── horizontal_blue.png
│   └── icon_blue.png
├── request
│   ├── request_1.py
│   └── request_2.py
├── respond
│   ├── respond_1.py
│   └── respond_2.py
├── settings.py
└── streamlit_app.py
```

**`streamlit_app.py`:**

```python
import streamlit as st

if "role" not in st.session_state:
    st.session_state.role = None

ROLES = [None, "Requester", "Responder", "Admin"]


def login():

    st.header("Log in")
    role = st.selectbox("Choose your role", ROLES)

    if st.button("Log in"):
        st.session_state.role = role
        st.rerun()


def logout():
    st.session_state.role = None
    st.rerun()


role = st.session_state.role

logout_page = st.Page(logout, title="Log out", icon=":material/logout:")
settings = st.Page("settings.py", title="Settings", icon=":material/settings:")
request_1 = st.Page(
    "request/request_1.py",
    title="Request 1",
    icon=":material/help:",
    default=(role == "Requester"),
)
request_2 = st.Page(
    "request/request_2.py", title="Request 2", icon=":material/bug_report:"
)
respond_1 = st.Page(
    "respond/respond_1.py",
    title="Respond 1",
    icon=":material/healing:",
    default=(role == "Responder"),
)
respond_2 = st.Page(
    "respond/respond_2.py", title="Respond 2", icon=":material/handyman:"
)
admin_1 = st.Page(
    "admin/admin_1.py",
    title="Admin 1",
    icon=":material/person_add:",
    default=(role == "Admin"),
)
admin_2 = st.Page("admin/admin_2.py", title="Admin 2", icon=":material/security:")

account_pages = [logout_page, settings]
request_pages = [request_1, request_2]
respond_pages = [respond_1, respond_2]
admin_pages = [admin_1, admin_2]

st.title("Request manager")
st.logo("images/horizontal_blue.png", icon_image="images/icon_blue.png")

page_dict = {}
if st.session_state.role in ["Requester", "Admin"]:
    page_dict["Request"] = request_pages
if st.session_state.role in ["Responder", "Admin"]:
    page_dict["Respond"] = respond_pages
if st.session_state.role == "Admin":
    page_dict["Admin"] = admin_pages

if len(page_dict) &gt; 0:
    pg = st.navigation({"Account": account_pages} | page_dict)
else:
    pg = st.navigation([st.Page(login)])

pg.run()
```

</Collapse>
<Cloud height="600px" name="doc-dynamic-navigation"/>

## Build the example

### Initialize your app

1. In `your_repository`, create a file named `streamlit_app.py`.
1. In a terminal, change directories to `your_repository`, and start your app:

   ```bash
   streamlit run streamlit_app.py
   ```

   Your app will be blank because you still need to add code.

1. In `streamlit_app.py`, write the following:

   ```python
   import streamlit as st
   ```

1. Save your `streamlit_app.py` file, and view your running app.
1. In your app, select "**Always rerun**", or press the "**A**" key.

   Your preview will be blank but will automatically update as you save changes to `streamlit_app.py`.

1. Return to your code.

### Add your page and image files

1. In `your_repositoy`, create a file named `settings.py`.

1. In `settings.py` add the following stub.

   ```python
   import streamlit as st

   st.header("Settings")
   st.write(f"You are logged in as {st.session_state.role}.")
   ```

   In later steps, you'll create an authentication method that saves the current user's role to `st.session_state.role`. Since you'll be blocking access to this page until a user is logged in, you don't need to initialize the `"role"` key in Session State for this page.

1. Create similar stubs by changing the value of `st.header` for the following six pages:

   ```
   your-repository/
   ├── admin
   │   ├── admin_1.py
   │   └── admin_2.py
   ├── request
   │   ├── request_1.py
   │   └── request_2.py
   └── respond
       ├── respond_1.py
       └── respond_2.py
   ```

   For example, `admin/admin_1.py` should be the following:

   ```python
   import streamlit as st

   st.header("Admin 1")
   st.write(f"You are logged in as {st.session_state.role}.")
   ```

1. Create an `images` subdirectory in `your-repository` and add the following two files:
   - [horizontal_blue.png](/images/horizontal_blue.png)
   - [icon_blue.png](/images/icon_blue.png)

   You now have all the files needed to build your app.

### Initialize global values

1. Return to `streamlit_app.py` and initialize `"role"` in Session State.

   ```python
   if "role" not in st.session_state:
       st.session_state.role = None
   ```

   You will use this value to gatekeep access to your app. This represents the role of the current, authenticated user.

1. Define the available roles.

   ```python
   ROLES = [None, "Requester", "Responder", "Admin"]
   ```

   `None` is included as a role since that is the value corresponding to an unauthenticated user.

### Define your user authentication pages

`st.navigation` lets you define pages from Python functions. Here, you'll define the login and logout pages from Python functions.

1. Begin your login page (function definition).

   ```python
   def login():
   ```

1. Add a header for the page.

   ```python
       st.header("Log in")
   ```

1. Create a selectbox for the user to choose a role.

   ```python
       role = st.selectbox("Choose your role", ROLES)
   ```

1. Add a button to commit the user role to Session State.

   ```python
       if st.button("Log in"):
           st.session_state.role = role
           st.rerun()
   ```

   This is an abstraction of an authentication workflow. When a user clicks the button, Streamlit saves the role to Session State and reruns the app. In later steps, you'll add logic to direct users to a role's default page when the value changes in `st.session_state.role`. This completes your login page function.

1. Begin your logout page (function definition).

   ```python
   def logout():
   ```

1. Immediately set the role to `None` and rerun the app.

   ```python
       st.session_state.role = None
       st.rerun()
   ```

   Since the lougout page function immediately updates Session State and reruns, a user will never view this page. The page will execute in a fraction of a second and, upon rerunning, the app will send the user to the login page. Therefore, no additional elements are rendered on the page. If desired, you can change this page to also include a button, similar to the login page. A button would allow users to confirm they really intend to log out.

### Define all your pages

1. As a convenience, save `st.session_state.role` to a variable.

   ```python
   role = st.session_state.role
   ```

1. Define your account pages.

   ```python
   logout_page = st.Page(logout, title="Log out", icon=":material/logout:")
   settings = st.Page("settings.py", title="Settings", icon=":material/settings:")
   ```

   This gives each page a nice title and icon to make your navigation menu look neat and clean.

1. Define your request pages.

   ```python
   request_1 = st.Page(
       "request/request_1.py",
       title="Request 1",
       icon=":material/help:",
       default=(role == "Requester"),
   )
   request_2 = st.Page(
       "request/request_2.py", title="Request 2", icon=":material/bug_report:"
   )
   ```

   If you don't manually declare a default page in `st.navigation`, then the first page will automatically be the default. The first page in the menu will be "Log out" within an "Account" section of the menu. Therefore, you'll need to tell Streamlit what page each user should be directed to by default.

   This code dynamically sets `default=True` when the role is "Requester" and sets it to `False`, otherwise.

1. Define your remaining pages.

   ```python
   respond_1 = st.Page(
       "respond/respond_1.py",
       title="Respond 1",
       icon=":material/healing:",
       default=(role == "Responder"),
   )
   respond_2 = st.Page(
       "respond/respond_2.py", title="Respond 2", icon=":material/handyman:"
   )
   admin_1 = st.Page(
       "admin/admin_1.py",
       title="Admin 1",
       icon=":material/person_add:",
       default=(role == "Admin"),
   )
   admin_2 = st.Page("admin/admin_2.py", title="Admin 2", icon=":material/security:")
   ```

   Similar to the request pages, the `default` parameter is set for the other roles' default pages.

1. Group your pages into convenient lists.

   ```python
   account_pages = [logout_page, settings]
   request_pages = [request_1, request_2]
   respond_pages = [respond_1, respond_2]
   admin_pages = [admin_1, admin_2]
   ```

   These are all the pages available to logged-in users.

### Define your common elements and navigation

1. Add a title to show on all pages.

   ```python
   st.title("Request manager")
   ```

   Since you're calling the title command in your entrypoint file, this title will be visible on all pages. Elements created in your entrypoint file create a frame of common elements around all your pages.

1. Add a logo to your app.

   ```python
   st.logo("images/horizontal_blue.png", icon_image="images/icon_blue.png")
   ```

   Once again, since you're calling this command in your entrypoint file, you won't need to also call it within each page.

1. Initialize a dictionary of page lists.

   ```python
   page_dict = {}
   ```

   In the next step, you'll check the user's role and add pages to the dictionary that the user is allowed to access. When `st.navigation` receives a dictionary of page lists, it creates a navigation menu with groups of pages and section headers.

1. Build the dictionary of allowed pages by checking the user's role.

   ```python
   if st.session_state.role in ["Requester", "Admin"]:
       page_dict["Request"] = request_pages
   if st.session_state.role in ["Responder", "Admin"]:
       page_dict["Respond"] = respond_pages
   if st.session_state.role == "Admin":
       page_dict["Admin"] = admin_pages
   ```

1. Check if the user is allowed to access any pages and add the account pages if they are.

   ```python
   if len(page_dict) &gt; 0:
       pg = st.navigation({"Account": account_pages} | page_dict)
   ```

   If `page_dict` is not empty, then the user is logged in. The `|` operator merges the two dictionaries, adding the account pages to the beginning.

1. Fallback to the login page if the user isn't logged in.

   ```python
   else:
       pg = st.navigation([st.Page(login)])
   ```

1. Execute the page returned by `st.navigation`.

   ```python
   pg.run()
   ```

1. Save your `streamlit_app.py` file and view your app!

   Try logging in, switching pages, and logging out. Try again with a different role.

---

# 使用 `st.page_link` 构建自定义导航菜单

Source: https://docs.streamlit.io/develop/tutorials/multipage/st.page_link-nav


Streamlit 让您可以使用 `st.page_link` 构建自定义导航菜单和元素。在 Streamlit 1.31.0 版本中引入的 `st.page_link` 可以链接到多页面应用中的其他页面或外部网站。当链接到应用中的另一个页面时，`st.page_link` 会显示高亮效果以指示当前页面。结合 [`client.showSidebarNavigation`](/develop/concepts/configuration#client) 配置选项，您可以在应用中构建简洁、动态的导航。

## 前提条件

在开发环境中创建一个新的工作目录。我们将此目录称为 `your-repository`。

## 摘要

在这个示例中，我们将为一个多页面应用构建一个动态导航菜单，该菜单根据当前用户的职责而变化。我们抽象了用户名和凭据的使用，以简化示例。相反，我们将在应用的主页上使用一个选择框来切换角色。会话状态将在页面之间传递此选择。应用将有一个主页（`app.py`），它充当抽象的登录页面。还有三个额外的页面，根据当前角色，这些页面将被隐藏或可访问。文件结构如下：

```
your-repository/
├── .streamlit/
│   └── config.toml
├── pages/
│   ├── admin.py
│   ├── super-admin.py
│   └── user.py
├── menu.py
└── app.py
```

这是我们即将构建的效果：

<Cloud height="400px" name="doc-custom-navigation"/>

## 构建示例

### 隐藏默认侧边栏导航

创建自定义导航菜单时，您需要使用 `client.showSidebarNavigation` 隐藏默认的侧边栏导航。在工作目录中添加以下 `.streamlit/config.toml` 文件：

```toml
[client]
showSidebarNavigation = false
```

### 创建菜单函数

您可以为不同页面编写不同的菜单逻辑，也可以创建一个可在多个页面上调用的单一菜单函数。在此示例中，我们将在所有页面上使用相同的菜单逻辑，包括在用户未登录时重定向到主页。我们将构建一些辅助函数来完成此操作。

- `menu_with_redirect()` 检查用户是否已登录，然后重定向到主页或渲染菜单。
- `menu()` 将根据用户是否已登录调用正确的辅助函数来渲染菜单。
- `authenticated_menu()` 将根据已验证用户的角色显示菜单。
- `unauthenticated_menu()` 将为未验证用户提供菜单。

我们将在主页上调用 `menu()`，并在其他页面上调用 `menu_with_redirect()`。`st.session_state.role` 将存储当前选定的角色。如果此值不存在或设置为 `None`，则用户未登录。否则，它将以字符串形式保存用户的角色："user"、"admin" 或 "super-admin"。

将以下 `menu.py` 文件添加到您的工作目录。(我们将在下面更详细地描述这些函数。)

```python
import streamlit as st


def authenticated_menu():
    # 为已验证用户显示导航菜单
    st.sidebar.page_link("app.py", label="切换账户")
    st.sidebar.page_link("pages/user.py", label="您的资料")
    if st.session_state.role in ["admin", "super-admin"]:
        st.sidebar.page_link("pages/admin.py", label="管理用户")
        st.sidebar.page_link(
            "pages/super-admin.py",
            label="管理管理员权限",
            disabled=st.session_state.role != "super-admin",
        )


def unauthenticated_menu():
    # 为未验证用户显示导航菜单
    st.sidebar.page_link("app.py", label="登录")


def menu():
    # 确定用户是否已登录，然后显示正确的导航菜单
    if "role" not in st.session_state or st.session_state.role is None:
        unauthenticated_menu()
        return
    authenticated_menu()


def menu_with_redirect():
    # 如果用户未登录，将其重定向到主页，否则继续渲染导航菜单
    if "role" not in st.session_state or st.session_state.role is None:
        st.switch_page("app.py")
    menu()
```

让我们更仔细地看看 `authenticated_menu()`。当调用此函数时，`st.session_state.role` 存在且具有非 `None` 的值。

```python
def authenticated_menu():
    # 为已验证用户显示导航菜单
```

导航菜单中的前两个页面对所有用户都可用。由于我们知道调用此函数时用户已登录，因此我们将为主页使用标签"切换账户"。(如果您不使用 `label` 参数，页面名称将从文件名派生，就像使用默认侧边栏导航一样。)

```python
    st.sidebar.page_link("app.py", label="切换账户")
    st.sidebar.page_link("pages/user.py", label="您的资料")
```

我们只想向管理员显示接下来的两个页面。此外，我们选择禁用(但不隐藏)超级管理员页面，当管理员不是超级管理员时。我们使用 `disabled` 参数来实现这一点。(当角色不是"super-admin"时，`disabled=True`。)

```
    if st.session_state.role in ["admin", "super-admin"]:
        st.sidebar.page_link("pages/admin.py", label="管理用户")
        st.sidebar.page_link(
            "pages/super-admin.py",
            label="管理管理员权限",
            disabled=st.session_state.role != "super-admin",
        )
```

就是这样！`unauthenticated_menu()` 只显示一个链接到应用主页的链接，标签为"登录"。`menu()` 简单检查 `st.session_state.role` 以在两个菜单渲染函数之间切换。最后，`menu_with_redirect()` 扩展 `menu()` 以在用户未登录时将其重定向到 `app.py`。

<Tip>

如果要在页面标签中包含表情符号，可以使用 `icon` 参数。无需在文件名或 `label` 参数中包含表情符号。

</Tip>

### 创建应用的主文件

主 `app.py` 文件将充当伪登录页面。用户可以从 `st.selectbox` 小部件中选择一个角色。一些逻辑将把该角色保存到会话状态中，以便在页面间导航时保留它——即使返回到 `app.py`。

将以下 `app.py` 文件添加到您的工作目录：

```python
import streamlit as st
from menu import menu

# 将 st.session_state.role 初始化为 None
if "role" not in st.session_state:
    st.session_state.role = None

# 从会话状态检索角色以初始化小部件
st.session_state._role = st.session_state.role

def set_role():
    # 回调函数，将角色选择保存到会话状态
    st.session_state.role = st.session_state._role


# 选择框以选择角色
st.selectbox(
    "选择您的角色:",
    [None, "user", "admin", "super-admin"],
    key="_role",
    on_change=set_role,
)
menu() # 渲染动态菜单！
```

### 向应用添加其他页面

添加以下 `pages/user.py` 文件：

```python
import streamlit as st
from menu import menu_with_redirect

# 如果未登录则重定向到 app.py，否则显示导航菜单
menu_with_redirect()

st.title("此页面对所有用户可用")
st.markdown(f"您当前以 {st.session_state.role} 角色登录。")
```

如果用户手动通过URL导航到页面，会话状态会重置。因此，如果用户尝试在此示例中访问管理员页面，会话状态将被清除，他们将被重定向到主页作为未验证用户。然而，仍建议在每个受限页面顶部包含角色检查。如果角色不在白名单中，您可以使用 `st.stop` 停止应用。

`pages/admin.py`:

```python
import streamlit as st
from menu import menu_with_redirect

# 如果未登录则重定向到 app.py，否则显示导航菜单
menu_with_redirect()

# 验证用户角色
if st.session_state.role not in ["admin", "super-admin"]:
    st.warning("您没有权限查看此页面。")
    st.stop()

st.title("此页面对所有管理员可用")
st.markdown(f"您当前以 {st.session_state.role} 角色登录。")
```

`pages/super-admin.py`:

```python
import streamlit as st
from menu import menu_with_redirect

# 如果未登录则重定向到 app.py，否则显示导航菜单
menu_with_redirect()

# 验证用户角色
if st.session_state.role not in ["super-admin"]:
    st.warning("您没有权限查看此页面。")
    st.stop()

st.title("此页面对超级管理员可用")
st.markdown(f"您当前以 {st.session_state.role} 角色登录。")
```

如上所述，`menu_with_redirect()` 中的重定向将阻止用户看到管理员页面上的警告消息。如果您想看到警告，请在 `app.py` 底部添加另一个 `st.page_link("pages/admin.py")` 按钮，这样您可以在选择"用户"角色后导航到管理员页面。😉

---

# Streamlit 快速开始指南

Source: https://docs.streamlit.io/get-started


本快速开始指南介绍如何使用 Streamlit、如何在首选操作系统上安装 Streamlit，以及如何创建你的第一个 Streamlit 应用！

<InlineCalloutContainer>
<InlineCallout bold="安装" color="orange-70" href="/get-started/installation" icon="downloading">帮助你设置开发环境。走过在 Windows、macOS 或 Linux 上安装 Streamlit 的过程。或者，在浏览器中使用 GitHub Codespaces 或 Streamlit in Snowflake 进行编码。</InlineCallout>
<InlineCallout bold="基础知识" color="orange-70" href="/get-started/fundamentals" icon="description">介绍 Streamlit 的数据模型和开发流程。你将学习什么使 Streamlit 成为构建数据应用的最强大方式，包括显示和样式化数据、绘制图表和地图、添加交互式控件、自定义应用布局、缓存计算和定义主题的能力。</InlineCallout>
<InlineCallout bold="首步教程" color="orange-70" href="/get-started/tutorials" icon="auto_awesome">引导你使用核心功能创建应用，包括获取和缓存数据、绘制图表、在地图上绘制信息，以及使用交互式控件过滤结果。</InlineCallout>
<InlineCallout bold="使用 GitHub Codespaces" color="orange-70" href="/get-started/installation/community-cloud" icon="rocket_launch">如果你想跳过本地安装并直接在浏览器中编码。本指南使用 Streamlit Community Cloud 帮助你自动配置代码空间。</InlineCallout>
</InlineCalloutContainer>
<NoteSplit background="gray-20" copy="30 Days of Streamlit 🎈 是一个免费、自主节奏的 30 天挑战，教你如何使用 Streamlit 构建和部署数据应用。完成每日挑战，在 Twitter 和 LinkedIn 上与我们分享你的解决方案，并访问论坛提出任何问题！" title="30 Days of Streamlit 🎈">{{
        text: "开始挑战",
        link: "https://30days.streamlit.app/",
        target: "_blank",
      }}
image="/30days.png"
/&gt;</NoteSplit>

---

# 基本概念

Source: https://docs.streamlit.io/get-started/fundamentals


您是 Streamlit 的新手，想要进行全面的了解吗？如果是这样，您来对地方了！

<InlineCalloutContainer>
<InlineCallout bold="基本概念。" color="orange-70" href="/get-started/fundamentals/main-concepts" icon="description">了解 Streamlit 的基本概念。Streamlit 应用是如何构造的？它如何运行？它是如何神奇地在网页上获取您的数据的？</InlineCallout>
<InlineCallout bold="高级概念。" color="orange-70" href="/get-started/fundamentals/advanced-concepts" icon="description">了解了 Streamlit 的重新运行逻辑后，学习如何使用缓存和会话状态创建高效和动态的应用。了解如何处理数据库连接。</InlineCallout>
<InlineCallout bold="附加功能。" color="orange-70" href="/get-started/fundamentals/additional-features" icon="description">了解 Streamlit 的附加功能。您不需要为您的第一个应用了解这些概念，但请检查一下以了解有什么可用的。</InlineCallout>
</InlineCalloutContainer>

---

# Additional Streamlit features

Source: https://docs.streamlit.io/get-started/fundamentals/additional-features


So you've read all about Streamlit's [Basic concepts](/get-started/fundamentals/main-concepts) and gotten a taste of caching and Session State in [Advanced concepts](/get-started/fundamentals/advanced-concepts). But what about the bells and whistles? Here's a quick look at some extra features to take your app to the next level.

## Theming

Streamlit supports Light and Dark themes out of the box. Streamlit will first
check if the user viewing an app has a Light or Dark mode preference set by
their operating system and browser. If so, then that preference will be used.
Otherwise, the Light theme is applied by default.

You can also change the active theme from "⋮" → "Settings".

![Changing Themes](/images/change_theme.gif)

Want to add your own theme to an app? The "Settings" menu has a theme editor
accessible by clicking on "Edit active theme". You can use this editor to try
out different colors and see your app update live.

![Editing Themes](/images/edit_theme.gif)

When you're happy with your work, themes can be saved by
[setting config options](/develop/concepts/configuration)
in the `[theme]` config section. After you've defined a theme for your app, it
will appear as "Custom Theme" in the theme selector and will be applied by
default instead of the included Light and Dark themes.

More information about the options available when defining a theme can be found
in the [theme option documentation](/develop/concepts/configuration/theming).

<Note>

The theme editor menu is available only in local development. If you've deployed your app using
Streamlit Community Cloud, the "Edit active theme" button will no longer be displayed in the "Settings"
menu.

</Note>
<Tip>

Another way to experiment with different theme colors is to turn on the "Run on save" option, edit
your config.toml file, and watch as your app reruns with the new theme colors applied.

</Tip>

## Pages

As apps grow large, it becomes useful to organize them into multiple pages. This makes the app easier to manage as a developer and easier to navigate as a user. Streamlit provides a powerful way to create multipage apps using [`st.Page`](/develop/api-reference/navigation/st.page) and [`st.navigation`](/develop/api-reference/navigation/st.navigation). Just create your pages and connect them with navigation as follows:

1. Create an entry point script that defines and connects your pages
2. Create separate Python files for each page's content
3. Use [`st.Page`](/develop/api-reference/navigation/st.page) to define your pages and [`st.navigation`](/develop/api-reference/navigation/st.navigation) to connect them

Here's an example of a three-page app:

<details>
<summary><code>streamlit_app.py</code></summary>

```python
import streamlit as st

# Define the pages
main_page = st.Page("main_page.py", title="Main Page", icon="🎈")
page_2 = st.Page("page_2.py", title="Page 2", icon="❄️")
page_3 = st.Page("page_3.py", title="Page 3", icon="🎉")

# Set up navigation
pg = st.navigation([main_page, page_2, page_3])

# Run the selected page
pg.run()
```

</details>
<details>
<summary><code>main_page.py</code></summary>

```python
import streamlit as st

# Main page content
st.markdown("# Main page 🎈")
st.sidebar.markdown("# Main page 🎈")
```

</details>
<details>
<summary><code>page_2.py</code></summary>

```python
import streamlit as st

st.markdown("# Page 2 ❄️")
st.sidebar.markdown("# Page 2 ❄️")
```

</details>
<details>
<summary><code>page_3.py</code></summary>

```python
import streamlit as st

st.markdown("# Page 3 🎉")
st.sidebar.markdown("# Page 3 🎉")
```

</details>
<br/>

Now run `streamlit run streamlit_app.py` and view your shiny new multipage app! The navigation menu will automatically appear, allowing users to switch between pages.

<Image src="/images/mpa-v2-main-concepts.gif"/>

Our documentation on [Multipage apps](/develop/concepts/multipage-apps) teaches you how to add pages to your app, including how to define pages, structure and run multipage apps, and navigate between pages. Once you understand the basics, [create your first multipage app](/get-started/tutorials/create-a-multipage-app)!

## Custom components

If you can't find the right component within the Streamlit library, try out custom components to extend Streamlit's built-in functionality. Explore and browse through popular, community-created components in the [Components gallery](https://streamlit.io/components). If you dabble in frontend development, you can build your own custom component with Streamlit's [components API](/develop/concepts/custom-components/intro).

## Static file serving

As you learned in Streamlit fundamentals, Streamlit runs a server that clients connect to. That means viewers of your app don't have direct access to the files which are local to your app. Most of the time, this doesn't matter because Streamlt commands handle that for you. When you use `st.image(<path-to-image>)` your Streamlit server will access the file and handle the necessary hosting so your app viewers can see it. However, if you want a direct URL to an image or file you'll need to host it. This requires setting the correct configuration and placing your hosted files in a directory named `static`. For example, your project could look like:

```bash
your-project/
├── static/
│   └── my_hosted-image.png
└── streamlit_app.py
```

To learn more, read our guide on [Static file serving](/develop/concepts/configuration/serving-static-files).

## App testing

Good development hygiene includes testing your code. Automated testing allows you to write higher quality code, faster! Streamlit has a built-in testing framework that let's you build tests easily. Use your favorite testing framework to run your tests. We like [`pytest`](https://pypi.org/project/pytest/). When you test a Streamlit app, you simulate running the app, declare user input, and inspect the results. You can use GitHub workflows to automate your tests and get instant alerts about breaking changes. Learn more in our guide to [App testing](/develop/concepts/app-testing).</path-to-image>

---

# Advanced concepts of Streamlit

Source: https://docs.streamlit.io/get-started/fundamentals/advanced-concepts


Now that you know how a Streamlit app runs and handles data, let's talk about being efficient. Caching allows you to save the output of a function so you can skip over it on rerun. Session State lets you save information for each user that is preserved between reruns. This not only allows you to avoid unecessary recalculation, but also allows you to create dynamic pages and handle progressive processes.

## Caching

Caching allows your app to stay performant even when loading data from the web, manipulating large datasets, or performing expensive computations.

The basic idea behind caching is to store the results of expensive function calls and return the cached result when the same inputs occur again. This avoids repeated execution of a function with the same input values.

To cache a function in Streamlit, you need to apply a caching decorator to it. You have two choices:

- `st.cache_data` is the recommended way to cache computations that return data. Use `st.cache_data` when you use a function that returns a serializable data object (e.g. str, int, float, DataFrame, dict, list). **It creates a new copy of the data at each function call**, making it safe against [mutations and race conditions](/develop/concepts/architecture/caching#mutation-and-concurrency-issues). The behavior of `st.cache_data` is what you want in most cases – so if you're unsure, start with `st.cache_data` and see if it works!
- `st.cache_resource` is the recommended way to cache global resources like ML models or database connections. Use `st.cache_resource` when your function returns unserializable objects that you don’t want to load multiple times. **It returns the cached object itself**, which is shared across all reruns and sessions without copying or duplication. If you mutate an object that is cached using `st.cache_resource`, that mutation will exist across all reruns and sessions.

Example:

```python
@st.cache_data
def long_running_function(param1, param2):
    return …
```

In the above example, `long_running_function` is decorated with `@st.cache_data`. As a result, Streamlit notes the following:

- The name of the function (`"long_running_function"`).
- The value of the inputs (`param1`, `param2`).
- The code within the function.

Before running the code within `long_running_function`, Streamlit checks its cache for a previously saved result. If it finds a cached result for the given function and input values, it will return that cached result and not rerun function's code. Otherwise, Streamlit executes the function, saves the result in its cache, and proceeds with the script run. During development, the cache updates automatically as the function code changes, ensuring that the latest changes are reflected in the cache.

<Image alt="Streamlit's two caching decorators and their use cases. Use st.cache_data for anything you'd store in a database. Use st.cache_resource for anything you can't store in a database, like a connection to a database or a machine learning model." caption="Streamlit's two caching decorators and their use cases." src="/images/caching-high-level-diagram.png"/>

For more information about the Streamlit caching decorators, their configuration parameters, and their limitations, see [Caching](/develop/concepts/architecture/caching).

## Session State

Session State provides a dictionary-like interface where you can save information that is preserved between script reruns. Use `st.session_state` with key or attribute notation to store and recall values. For example, `st.session_state["my_key"]` or `st.session_state.my_key`. Remember that widgets handle their statefulness all by themselves, so you won't always need to use Session State!

### What is a session?

A session is a single instance of viewing an app. If you view an app from two different tabs in your browser, each tab will have its own session. So each viewer of an app will have a Session State tied to their specific view. Streamlit maintains this session as the user interacts with the app. If the user refreshes their browser page or reloads the URL to the app, their Session State resets and they begin again with a new session.

### Examples of using Session State

Here's a simple app that counts the number of times the page has been run. Every time you click the button, the script will rerun.

```python
import streamlit as st

if "counter" not in st.session_state:
    st.session_state.counter = 0

st.session_state.counter += 1

st.header(f"This page has run {st.session_state.counter} times.")
st.button("Run it again")
```

- **First run:** The first time the app runs for each user, Session State is empty. Therefore, a key-value pair is created (`"counter":0`). As the script continues, the counter is immediately incremented (`"counter":1`) and the result is displayed: "This page has run 1 times." When the page has fully rendered, the script has finished and the Streamlit server waits for the user to do something. When that user clicks the button, a rerun begins.

- **Second run:** Since "counter" is already a key in Session State, it is not reinitialized. As the script continues, the counter is incremented (`"counter":2`) and the result is displayed: "This page has run 2 times."

There are a few common scenarios where Session State is helpful. As demonstrated above, Session State is used when you have a progressive process that you want to build upon from one rerun to the next. Session State can also be used to prevent recalculation, similar to caching. However, the differences are important:

- Caching associates stored values to specific functions and inputs. Cached values are accessible to all users across all sessions.
- Session State associates stored values to keys (strings). Values in session state are only available in the single session where it was saved.

If you have random number generation in your app, you'd likely use Session State. Here's an example where data is generated randomly at the beginning of each session. By saving this random information in Session State, each user gets different random data when they open the app but it won't keep changing on them as they interact with it. If you select different colors with the picker you'll see that the data does not get re-randomized with each rerun. (If you open the app in a new tab to start a new session, you'll see different data!)

```python
import streamlit as st
import pandas as pd
import numpy as np

if "df" not in st.session_state:
    st.session_state.df = pd.DataFrame(np.random.randn(20, 2), columns=["x", "y"])

st.header("Choose a datapoint color")
color = st.color_picker("Color", "#FF0000")
st.divider()
st.scatter_chart(st.session_state.df, x="x", y="y", color=color)
```

If you are pulling the same data for all users, you'd likely cache a function that retrieves that data. On the other hand, if you pull data specific to a user, such as querying their personal information, you may want to save that in Session State. That way, the queried data is only available in that one session.

As mentioned in [Basic concepts](/get-started/fundamentals/main-concepts#widgets), Session State is also related to widgets. Widgets are magical and handle statefulness quietly on their own. As an advanced feature however, you can manipulate the value of widgets within your code by assigning keys to them. Any key assigned to a widget becomes a key in Session State tied to the value of the widget. This can be used to manipulate the widget. After you finish understanding the basics of Streamlit, check out our guide on [Widget behavior](/develop/concepts/architecture/widget-behavior) to dig in the details if you're interested.

## Connections

As hinted above, you can use `@st.cache_resource` to cache connections. This is the most general solution which allows you to use almost any connection from any Python library. However, Streamlit also offers a convenient way to handle some of the most popular connections, like SQL! `st.connection` takes care of the caching for you so you can enjoy fewer lines of code. Getting data from your database can be as easy as:

```python
import streamlit as st

conn = st.connection("my_database")
df = conn.query("select * from my_table")
st.dataframe(df)
```

Of course, you may be wondering where your username and password go. Streamlit has a convenient mechanism for [Secrets management](/develop/concepts/connections/secrets-management). For now, let's just see how `st.connection` works very nicely with secrets. In your local project directory, you can save a `.streamlit/secrets.toml` file. You save your secrets in the toml file and `st.connection` just uses them! For example, if you have an app file `streamlit_app.py` your project directory may look like this:

```none hideHeader
your-LOCAL-repository/
├── .streamlit/
│   └── secrets.toml # Make sure to gitignore this!
└── streamlit_app.py
```

For the above SQL example, your `secrets.toml` file might look like the following:

```toml
[connections.my_database]
    type="sql"
    dialect="mysql"
    username="xxx"
    password="xxx"
    host="example.com" # IP or URL
    port=3306 # Port number
    database="mydb" # Database name
```

Since you don't want to commit your `secrets.toml` file to your repository, you'll need to learn how your host handles secrets when you're ready to publish your app. Each host platform may have a different way for you to pass your secrets. If you use Streamlit Community Cloud for example, each deployed app has a settings menu where you can load your secrets. After you've written an app and are ready to deploy, you can read all about how to [Deploy your app](/deploy/streamlit-community-cloud/deploy-your-app) on Community Cloud.

---

# Streamlit 基本概念

Source: https://docs.streamlit.io/get-started/fundamentals/main-concepts


使用 Streamlit 很简单。首先在普通 Python 脚本中加入一些 Streamlit 命令，然后使用 `streamlit run` 运行它：

```bash
streamlit run your_script.py [-- script args]
```

一旦你按上述方式运行脚本，一个本地 Streamlit 服务器将启动，并且你的应用程序将在默认网络浏览器的新标签页中打开。应用程序是你的画布，你可以在其中绘制图表、文本、小部件、表格等。

绘制到应用程序中的内容取决于你。例如，[`st.text`](/develop/api-reference/text/st.text) 将原始文本写入你的应用程序，而 [`st.line_chart`](/develop/api-reference/charts/st.line_chart) 绘制——你猜对了——线形图。请参阅我们的 [API 文档](/develop/api-reference) 以查看所有可用的命令。

<Note>

当给脚本传递一些自定义参数时，它们必须在两个破折号后传递。否则参数将被解释为 Streamlit 本身的参数。

</Note>

运行 Streamlit 的另一种方法是将其作为 Python 模块运行。这在配置像 PyCharm 这样的 IDE 与 Streamlit 配合使用时很有用：

```bash
# 运行
python -m streamlit run your_script.py

# 等同于:
streamlit run your_script.py
```

<Tip>

你也可以传递一个 URL 给 `streamlit run`！这与 GitHub Gists 结合使用效果很好。例如：

```bash
streamlit run https://raw.githubusercontent.com/streamlit/demo-uber-nyc-pickups/master/streamlit_app.py
```

</Tip>

## 开发流程

每次你想要更新应用程序时，保存源文件。当您这样做时，Streamlit 会检测是否有更改，并询问您是否要重新运行应用程序。在屏幕右上角选择"始终重新运行"，以便每次更改源代码时自动更新应用程序。

这使您能够在一个快速的交互循环中工作：您输入一些代码，保存它，实时尝试，然后输入更多代码，保存它，尝试它，等等，直到对结果满意为止。这种编码和实时查看结果之间的紧密循环是 Streamlit 让您的生活更轻松的方式之一。

<Tip>

在开发 Streamlit 应用程序时，建议将编辑器和浏览器窗口并排布局，这样可以同时看到代码和应用程序。试试看！

</Tip>

从 Streamlit 版本 1.10.0 及更高版本开始，Streamlit 应用程序不能从 Linux 发行版的根目录运行。如果您尝试从根目录运行 Streamlit 应用程序，Streamlit 将抛出一个 `FileNotFoundError: [Errno 2] No such file or directory` 错误。有关更多信息，请参见 GitHub 问题 [#5239](https://github.com/streamlit/streamlit/issues/5239)。

如果您使用的是 Streamlit 版本 1.10.0 或更高版本，则主脚本应该位于非根目录中。使用 Docker 时，可以使用 `WORKDIR` 命令指定主脚本所在的目录。有关如何执行此操作的示例，请阅读 [创建 Dockerfile](/deploy/tutorials/docker#create-a-dockerfile)。

## 数据流

Streamlit 的架构允许您以编写普通 Python 脚本的方式编写应用程序。为了实现这一点，Streamlit 应用程序具有独特的数据流：每当屏幕上必须更新某些内容时，Streamlit 会从头到尾重新运行整个 Python 脚本。

这可能在两种情况下发生：

- 每当您修改应用程序的源代码时。

- 每当用户与应用程序中的小部件交互时。例如，拖动滑块、在输入框中输入文本或单击按钮。

每当通过 `on_change`（或 `on_click`）参数向小部件传递回调时，回调将在脚本其余部分之前运行。有关回调 API 的详细信息，请参阅我们的 [会话状态 API 参考指南](/develop/api-reference/caching-and-state/st.session_state#use-callbacks-to-update-session-state)。

为了使这一切快速且无缝，Streamlit 在后台为您做了大量工作。其中一个重要角色是 [`@st.cache_data`](#caching) 装饰器，它允许开发人员在应用程序重新运行时跳过某些耗时的计算。我们将在本页后面介绍缓存。

## 显示和样式化数据

在 Streamlit 应用程序中显示数据（表格、数组、数据框）有几种方法。[下面](#use-magic)，您将了解 _魔法_ 和 [`st.write()`](/develop/api-reference/write-magic/st.write)，它们可以用来写入从文本到表格的任何内容。之后，让我们看看专门用于可视化数据的方法。

### 使用魔法

您还可以在不调用任何 Streamlit 方法的情况下写入应用程序。Streamlit 支持 "[魔法命令](/develop/api-reference/write-magic/magic)"，这意味着你根本不必使用 [`st.write()`](/develop/api-reference/write-magic/st.write)！要查看实际效果，请尝试这个代码片段：

```
"""
# 我的第一个应用程序
这是我们第一次尝试使用数据创建表格：
"""

import streamlit as st
import pandas as pd
df = pd.DataFrame({
  '第一列': [1, 2, 3, 4],
  '第二列': [10, 20, 30, 40]
})

df
```

每当 Streamlit 在自己的行上看到变量或字面值时，它会自动使用 [`st.write()`](/develop/api-reference/write-magic/st.write) 将其写入应用程序。有关详细信息，请参阅 [魔法命令](/develop/api-reference/write-magic/magic) 的文档。

### 写入数据框

除了 [魔法命令](/develop/api-reference/write-magic/magic) 之外，[`st.write()`](/develop/api-reference/write-magic/st.write) 是 Streamlit 的"瑞士军刀"。你可以将几乎所有内容传递给 [`st.write()`](/develop/api-reference/write-magic/st.write)：文本、数据、Matplotlib 图形、Altair 图表等等。不用担心，Streamlit 会弄清楚并以正确的方式呈现内容。

```python
import streamlit as st
import pandas as pd

st.write("这是我们第一次尝试使用数据创建表格：")
st.write(pd.DataFrame({
    '第一列': [1, 2, 3, 4],
    '第二列': [10, 20, 30, 40]
}))
```

还有其他特定数据函数，如 [`st.dataframe()`](/develop/api-reference/data/st.dataframe) 和 [`st.table()`](/develop/api-reference/data/st.table)，你也可以用来显示数据。让我们了解何时使用这些功能以及如何为数据框添加颜色和样式。

你可能在问自己，"为什么我不能总是使用 `st.write()`？"有几个原因：

1. _魔法_ 和 [`st.write()`](/develop/api-reference/write-magic/st.write) 检查您传入的数据类型，然后决定如何在应用程序中最好地呈现它。有时您想用另一种方式绘制。例如，不是将数据框绘制为交互式表格，您可能想使用 `st.table(df)` 将其绘制为静态表格。
2. 第二个原因是其他方法返回一个可以使用和修改的对象，可以通过向其添加数据或替换它来实现。
3. 最后，如果您使用更具体的 Streamlit 方法，您可以传递附加参数来自定义其行为。

例如，让我们创建一个数据框并使用 Pandas `Styler` 对象更改其格式。在此示例中，您将使用 Numpy 生成一个随机样本，并使用 [`st.dataframe()`](/develop/api-reference/data/st.dataframe) 方法绘制交互式表格。

<Note>

此示例使用 Numpy 生成随机样本，但您可以使用 Pandas DataFrames、Numpy 数组或纯 Python 数组。

</Note>

```python
import streamlit as st
import numpy as np

dataframe = np.random.randn(10, 20)
st.dataframe(dataframe)
```

让我们扩展第一个示例，使用 Pandas `Styler` 对象来突出显示交互式表格中的某些元素。

```python
import streamlit as st
import numpy as np
import pandas as pd

dataframe = pd.DataFrame(
    np.random.randn(10, 20),
    columns=('col %d' % i for i in range(20)))

st.dataframe(dataframe.style.highlight_max(axis=0))
```

Streamlit 还有一个用于静态表格生成的方法：[`st.table()`](/develop/api-reference/data/st.table)。

```python
import streamlit as st
import numpy as np
import pandas as pd

dataframe = pd.DataFrame(
    np.random.randn(10, 20),
    columns=('col %d' % i for i in range(20)))
st.table(dataframe)
```

### 绘制图表和地图

Streamlit 支持几个流行的数据图表库，如 [Matplotlib、Altair、deck.gl 等](/develop/api-reference#chart-elements)。在本节中，您将向应用程序添加条形图、折线图和地图。

### 绘制折线图

您可以使用 [`st.line_chart()`](/develop/api-reference/charts/st.line_chart) 轻松地将折线图添加到应用程序中。我们将使用 Numpy 生成一个随机样本，然后将其绘制成图表。

```python
import streamlit as st
import numpy as np
import pandas as pd

chart_data = pd.DataFrame(
     np.random.randn(20, 3),
     columns=['a', 'b', 'c'])

st.line_chart(chart_data)
```

### 绘制地图

使用 [`st.map()`](/develop/api-reference/charts/st.map) 您可以在地图上显示数据点。让我们使用 Numpy 生成一些样本数据，并将其绘制在旧金山地图上。

```python
import streamlit as st
import numpy as np
import pandas as pd

map_data = pd.DataFrame(
    np.random.randn(1000, 2) / [50, 50] + [37.76, -122.4],
    columns=['lat', 'lon'])

st.map(map_data)
```

## 小部件

当你将数据或模型置于想要探索的状态时，你可以添加小部件，如 [`st.slider()`](/develop/api-reference/widgets/st.slider)、[`st.button()`](/develop/api-reference/widgets/st.button) 或 [`st.selectbox()`](/develop/api-reference/widgets/st.selectbox)。这非常简单——将小部件视为变量：

```python
import streamlit as st
x = st.slider('x')  # 👈 这是一个小部件
st.write(x, '的平方是', x * x)
```

在第一次运行时，上面的应用程序应该输出文本"0 的平方是 0"。然后每次用户与小部件交互时，Streamlit 只是从头到尾重新运行您的脚本，在此过程中将小部件的当前状态分配给您的变量。

例如，如果用户将滑块移动到位置 `10`，Streamlit 将重新运行上面的代码并将 `x` 设置为 `10`。所以现在您应该看到文本"10 的平方是 100"。

如果选择指定一个字符串作为小部件的唯一键，小部件也可以通过键访问：

```python
import streamlit as st
st.text_input("您的姓名", key="name")

# 您可以在任何时间点访问该值：
st.session_state.name
```

每个带键的小部件都会自动添加到会话状态中。有关会话状态的更多信息、它与小部件状态的关联及其限制，请参阅 [会话状态 API 参考指南](/develop/api-reference/caching-and-state/st.session_state)。

### 使用复选框显示/隐藏数据

复选框的一个用例是在应用程序中隐藏或显示特定图表或部分。[`st.checkbox()`](/develop/api-reference/widgets/st.checkbox) 接受一个参数，即小部件标签。在此示例中，复选框用于切换条件语句。

```python
import streamlit as st
import numpy as np
import pandas as pd

if st.checkbox('显示数据框'):
    chart_data = pd.DataFrame(
       np.random.randn(20, 3),
       columns=['a', 'b', 'c'])

    chart_data
```

### 使用选择框进行选项选择

使用 [`st.selectbox`](/develop/api-reference/widgets/st.selectbox) 从一系列选项中选择。您可以输入想要的选项，或传递数组或数据框列。

让我们使用前面创建的 `df` 数据框。

```python
import streamlit as st
import pandas as pd

df = pd.DataFrame({
    '第一列': [1, 2, 3, 4],
    '第二列': [10, 20, 30, 40]
    })

option = st.selectbox(
    '您最喜欢哪个数字?',
     df['第一列'])

'您选择了: ', option
```

## 布局

Streamlit 通过 [`st.sidebar`](/develop/api-reference/layout/st.sidebar) 使您能够轻松地将小部件组织到左侧边栏中。传递给 [`st.sidebar`](/develop/api-reference/layout/st.sidebar) 的每个元素都会固定到左侧，允许用户专注于应用程序中的内容，同时仍然可以访问 UI 控件。

例如，如果您想向侧边栏添加选择框和滑块，请使用 `st.sidebar.slider` 和 `st.sidebar.selectbox` 而不是 `st.slider` 和 `st.selectbox`：

```python
import streamlit as st

# 向侧边栏添加一个选择框:
add_selectbox = st.sidebar.selectbox(
    '您希望如何被联系?',
    ('电子邮件', '家庭电话', '手机')
)

# 向侧边栏添加一个滑块:
add_slider = st.sidebar.slider(
    '选择一个值的范围',
    0.0, 100.0, (25.0, 75.0)
)
```

除了侧边栏，Streamlit 还提供了其他几种控制应用程序布局的方法。[`st.columns`](/develop/api-reference/layout/st.columns) 让您可以将小部件并排放置，而 [`st.expander`](/develop/api-reference/layout/st.expander) 让您通过隐藏大内容来节省空间。

```python
import streamlit as st

left_column, right_column = st.columns(2)
# 您可以像使用 st.sidebar 一样使用列:
left_column.button('点我!')

# 或者更好的是，在 "with" 块内调用 Streamlit 函数:
with right_column:
    chosen = st.radio(
        '分院帽',
        ("格兰芬多", "拉文克劳", "赫奇帕奇", "斯莱特林"))
    st.write(f"你在 {chosen} 学院!")
```

<Note>

目前不支持在侧边栏或布局选项中使用 `st.echo` 和 `st.spinner`。不过请放心，我们目前正在努力添加对这些的支持！

</Note>

### 显示进度

在向应用程序添加长时间运行的计算时，您可以使用 [`st.progress()`](/develop/api-reference/status/st.progress) 实时显示状态。

首先，让我们导入 time。我们将使用 `time.sleep()` 方法来模拟长时间运行的计算：

```python
import time
```

现在，让我们创建一个进度条：

```python
import streamlit as st
import time

'开始长时间计算...'

# 添加一个占位符
latest_iteration = st.empty()
bar = st.progress(0)

for i in range(100):
  # 每次迭代更新进度条。
  latest_iteration.text(f'迭代 {i+1}')
  bar.progress(i + 1)
  time.sleep(0.1)

'...现在完成了!'
```

---

# 应用模型摘要

Source: https://docs.streamlit.io/get-started/fundamentals/summary


现在您对所有各个部分了解得更多了，让我们总结一下它是如何一起工作的：

1. Streamlit 应用是从上到下运行的 Python 脚本。
1. 每次用户打开指向您的应用的浏览器选项卡时，脚本都会执行并启动一个新会话。
1. 当脚本执行时，Streamlit 会在浏览器中实时绘制其输出。
1. 每次用户与小部件交互时，您的脚本都会重新执行，并且 Streamlit 会在浏览器中重新绘制其输出。
   - 该小部件的输出值在重新运行期间与新值相匹配。
1. 脚本使用 Streamlit 缓存来避免重新计算昂贵的函数，因此更新发生得非常快。
1. 会话状态让您保存在重新运行之间持续存在的信息，当您需要超过简单小部件时。
1. Streamlit 应用可以包含多个页面，这些页面在 `pages` 文件夹中的单独 `.py` 文件中定义。

![The Streamlit app model](/images/app_model.png)

---

# 安装 Streamlit

Source: https://docs.streamlit.io/get-started/installation


有多种方式来设置您的开发环境并安装 Streamlit。
在您自己的计算机上安装 Python 后进行本地开发是最
常见的场景。

<Tip>

试试在您的浏览器中运行的 Streamlit Playground  无需安装。
（请注意，这不是 Streamlit 的预期使用方式，因为它有许多缺点。这就是为什么它是
一个_游乐场_！）

<IconLink cssModuleClassName="Indigo" cssModuleIconClassName="IconRight" href="/get-started/installation/streamlit-playground" icon="arrow_forward" label="游乐场说明"/>
</Tip>

## 经验丰富的 Python 开发者摘要

1. 要设置您的 Python 环境并测试您的安装，请执行以下终端命令：

   ```bash
   pip install streamlit
   streamlit hello
   ```

1. 跳转到我们的 [基本概念](/get-started/fundamentals/main-concepts)。

## 在您的机器上安装 Streamlit

### 选项 1：我喜欢命令行

使用 `venv` 和 `pip` 等工具在您自己的机器上安装 Streamlit。

<IconLink cssModuleClassName="Orange" cssModuleIconClassName="IconRight" href="/get-started/installation/command-line" icon="arrow_forward" label="命令行说明"/>

### 选项 2：我更喜欢图形界面

使用 Anaconda Distribution 图形用户界面安装 Streamlit。如果您使用 Windows 或没有设置 Python，这也是最好的
方法。

<IconLink cssModuleClassName="Orange" cssModuleIconClassName="IconRight" href="/get-started/installation/anaconda-distribution" icon="arrow_forward" label="Anaconda Distribution 说明"/>

## 在云中创建应用

### 选项 1：我想要一个免费的云环境

使用 Streamlit Community Cloud 和 GitHub Codespaces，这样您就不必费力
安装 Python 和设置环境。

<IconLink cssModuleClassName="Orange" cssModuleIconClassName="IconRight" href="/get-started/installation/community-cloud" icon="arrow_forward" label="GitHub Codespaces 说明"/>

### 选项 2：我需要安全、受控且在云中的东西

使用 Snowflake 中的 Streamlit 在云中编码您的应用，同时使用基于角色的访问控制与您的
数据在一起。

<IconLink cssModuleClassName="Orange" cssModuleIconClassName="IconRight" href="/get-started/installation/streamlit-in-snowflake" icon="arrow_forward" label="Snowflake 说明"/>

---

# Install Streamlit using Anaconda Distribution

Source: https://docs.streamlit.io/get-started/installation/anaconda-distribution


This page walks you through installing Streamlit locally using Anaconda Distribution. At the end, you'll build a simple "Hello world" app and run it. You can read more about [Getting started with Anaconda Distribution](https://docs.anaconda.com/free/anaconda/getting-started/) in Anaconda's docs. If you prefer to manage your Python environments via command line, check out how to [Install Streamlit using command line](/get-started/installation/command-line).

## Prerequisites

1. **A code editor**

   Anaconda Distribution includes Python and basically everything you need to get started.
   The only thing left for you to choose is a code editor.

   Our favorite editor is [VS Code](https://code.visualstudio.com/download), which is also what we
   use in all our tutorials.

1. **Knowledge about environment managers**

   Environment managers create virtual environments to isolate Python package installations between
   projects. For a detailed introduction to Python environments, check out
   [Python Virtual Environments: A Primer](https://realpython.com/python-virtual-environments-a-primer/).

   But don't worry! In this guide we'll teach you how to install and use an environment manager
   (Anaconda).

## Install Anaconda Distribution

1. Go to [anaconda.com/download](https://www.anaconda.com/download).

2. Install Anaconda Distribution for your OS.

## Create an environment using Anaconda Navigator

3. Open Anaconda Navigator (the graphical interface included with Anaconda Distribution).

4. You can decline signing in to Anaconda if prompted.

5. In the left menu, click "**Environments**."
   ![Open your environments list in Anaconda Navigator](/images/get-started/Anaconda-Navigator-environment-1.png)

6. At the bottom of your environments list, click "**Create**."
   ![Click "Create" to open the Create new environment dialog](/images/get-started/Anaconda-Navigator-environment-2-create.png)

7. Enter "streamlitenv" for the name of your environment.

8. Click "**Create**."
<div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
    <Image alt="Finalize your new conda environment" src="/images/get-started/Anaconda-Navigator-environment-3-name.png"/>
</div>

## Activate your environment

9. Click the green play icon (<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;play_circle</i>) next to your environment.

10. Click "**Open Terminal**."
    ![Open a new terminal with your environment activated](/images/get-started/Anaconda-Navigator-environment-6-activate.png)

11. A terminal will open with your environment activated. Your environment's name will appear in parentheses at the beginning of your terminal's prompt to show that it's activated.

## Install Streamlit in your environment

12. In your terminal, type:

    ```bash
    pip install streamlit
    ```

13. To validate your installation, enter:

    ```bash
    streamlit hello
    ```

    If this doesn't work, use the long-form command:

    ```bash
    python -m streamlit hello
    ```

14. The Streamlit Hello example app will automatically open in your browser. If it doesn't, open your browser and go to the localhost address indicated in your terminal, typically `http://localhost:8501`. Play around with the app!

15. Close your terminal.

## Create a `Hello World` app and run it

17. Open VS Code with a new project.

18. Create a Python file named `app.py` in your project folder.
    ![Create a new file called app.py](/images/get-started/hello-world-1-new-file.png)

19. Copy the following code into `app.py` and save it.

    ```python
    import streamlit as st

    st.write("Hello World")
    ```

20. Click your Python interpreter in the lower-right corner, then choose your `streamlitenv` environment from the drop-down.
    ![Set your Python interpreter to your `streamlitenv` environment](/images/get-started/hello-world-3-change-interpreter.png)

21. Right-click `app.py` in your file navigation and click "**Open in integrated terminal**."
    ![Open your terminal in your project folder](/images/get-started/hello-world-4-open-terminal.png)

22. A terminal will open with your environment activated. Confirm this by looking for "(streamlitenv)" at the beginning of your next prompt.
    If it is not there, manually activate your environment with the command:

    ```bash
    conda activate streamlitenv
    ```

23. In your terminal, type:

    ```bash
    streamlit run app.py
    ```

    If this doesn't work, use the long-form command:

    ```bash
    python -m streamlit run app.py
    ```

    ![Start your Streamlit app with `streamlit run app.py`](/images/get-started/hello-world-5-streamlit-run.png)

24. Your app will automatically open in your browser. If it doesn't for any reason, open your browser and go to the localhost address indicated in your terminal, typically `http://localhost:8501`.

25. Change `st.write` to `st.title` and save your file:

    ```python
    import streamlit as st

    st.title("Hello World")
    ```

26. In your browser, click "**Always rerun**" to instantly rerun your app whenever you save a change to your file.
    ![Automatically rerun your app when your source file changes](/images/get-started/hello-world-6-always-rerun.png)

27. Your app will update! Keep making changes and you will see your changes as soon as you save your file.
    ![Your app updates when you resave your source file](/images/get-started/hello-world-7-updated-app.png)

28. When you're done, you can stop your app with `Ctrl+C` in your terminal or just by closing your terminal.

## What's next?

Read about our [Basic concepts](/get-started/fundamentals/main-concepts) and try out more commands in your app.

---

# 使用命令行安装 Streamlit

Source: https://docs.streamlit.io/get-started/installation/command-line


本页面将引导您使用 `venv` 创建环境并使用 `pip` 安装 Streamlit。这些是我们推荐的工具，但如果您熟悉其他工具，也可以使用您喜欢的工具。最后，您将构建一个简单的"Hello world"应用并运行它。如果您更喜欢使用图形界面来管理您的 Python 环境，请查看如何 [使用 Anaconda 发行版安装 Streamlit](/get-started/installation/anaconda-distribution)。

## 先决条件

与任何编程工具一样，为了安装 Streamlit，您首先需要确保您的计算机已正确设置。更具体地说，您需要：

1. **Python**

   我们支持 [版本 3.9 到 3.13](https://www.python.org/downloads/)。

1. **Python 环境管理器** (推荐)

   环境管理器在项目之间创建虚拟环境，以隔离 Python 包的安装。

   我们推荐使用虚拟环境，因为安装或升级 Python 包可能会对另一个包产生意外影响。有关 Python 环境的详细介绍，请查看
   [Python 虚拟环境：入门指南](https://realpython.com/python-virtual-environments-a-primer/)。

   对于本指南，我们将使用 `venv`，它随 Python 一起提供。

1. **Python 包管理器**

   包管理器处理安装每个 Python 包，包括 Streamlit。

   对于本指南，我们将使用 `pip`，它随 Python 一起提供。

1. **仅在 macOS 上：Xcode 命令行工具**

   使用 [这些说明](https://mac.install.guide/commandlinetools/4.html) 下载 Xcode 命令行工具，以便包管理器安装 Streamlit 的一些依赖项。

1. **代码编辑器**

   我们最喜欢的编辑器是 [VS Code](https://code.visualstudio.com/download)，我们在所有教程中都使用它。

## 使用 `venv` 创建环境

1. 打开终端并导航到您的项目文件夹。

   ```bash
   cd myproject
   ```

2. 在终端中，输入：

   ```bash
   python -m venv .venv
   ```

3. 您的项目中将出现一个名为".venv"的文件夹。此目录是您的虚拟环境及其依赖项安装的位置。

## 激活您的环境

4. 在终端中，根据您的操作系统，使用以下命令之一激活您的环境。

   ```bash
   # Windows 命令提示符
   .venv\Scripts\activate.bat

   # Windows PowerShell
   .venv\Scripts\Activate.ps1

   # macOS 和 Linux
   source .venv/bin/activate
   ```

5. 激活后，您将在提示符前的括号中看到您的环境名称。"(.venv)"

## 在您的环境中安装 Streamlit

6. 在激活环境的终端中，输入：

   ```bash
   pip install streamlit
   ```

7. 通过启动 Streamlit Hello 示例应用程序来测试安装是否成功：

   ```bash
   streamlit hello
   ```

   如果这不起作用，请使用完整命令：

   ```bash
   python -m streamlit hello
   ```

8. Streamlit 的 Hello 应用程序应该在您的网页浏览器的新标签页中出现！
   <Cloud height="700px" name="doc-mpa-hello"/>
9. 完成后关闭您的终端。

## 创建"Hello World"应用程序并运行它

10. 在您的项目文件夹中创建一个名为 `app.py` 的文件。

```python
import streamlit as st

st.write("Hello world")
```

11. 每当您想使用您的新环境时，首先需要转到您的项目文件夹（其中包含 `.venv` 目录）并运行激活它的命令：

```bash
# Windows 命令提示符
.venv\Scripts\activate.bat

# Windows PowerShell
.venv\Scripts\Activate.ps1

# macOS 和 Linux
source .venv/bin/activate
```

12. 激活后，您将在终端提示符开头的括号中看到您的环境名称。"(.venv)"

13. 运行您的 Streamlit 应用程序。

```bash
streamlit run app.py
```

如果这不起作用，请使用完整命令：

```bash
python -m streamlit run app.py
```

14. 要停止 Streamlit 服务器，请在终端中按 `Ctrl+C`。

15. 当您完成使用此环境时，通过输入以下内容返回到正常 shell：

```bash
deactivate
```

## 下一步是什么？

阅读我们的 [基本概念](/get-started/fundamentals/main-concepts) 来了解 Streamlit 的数据流模型。

---

# 使用社区云和 GitHub Codespaces 进行开发

Source: https://docs.streamlit.io/get-started/installation/community-cloud


要使用 GitHub Codespaces 进行 Streamlit 开发，您需要一个正确配置的 `devcontainer.json` 文件来设置环境。幸运的是，Streamlit 社区云可以帮助您！虽然社区云主要用于向全世界部署和共享应用程序，但我们内置了一些便捷功能，使 GitHub Codespaces 的使用变得更加容易。本指南将解释如何创建社区云账户并使用自动化工作流程进入 GitHub codespace 并实时编辑 Streamlit 应用程序。所有这些操作都在浏览器中完成，无需安装。

如果您已经创建了社区云账户并连接了 GitHub，请跳转至[从模板创建新应用](/get-started/installation/community-cloud#create-a-new-app-from-a-template)。

## 前提条件

- 您必须拥有 GitHub 账户。

## 注册 Streamlit 社区云

1. 访问 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a>。
1. 点击"**继续登录**。"
1. 点击"**继续使用 GitHub**。"
1. 输入您的 GitHub 凭据并按照 GitHub 的身份验证提示操作。
1. 填写您的账户信息，然后点击底部的"**我接受**"。

## 添加对公共仓库的访问权限

1. 在左上角，点击"**工作区 <i>{{ verticalAlign: "-.25em", color: "#ff8700" }} className={{ class: "material-icons-sharp" }}&gt;warning</i>**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="将您的 GitHub 账户连接到新的社区云账户" src="/images/streamlit-community-cloud/workspace-unconnected-setup.png"/>
</div>

1. 从下拉菜单中，点击"**连接 GitHub 账户**。"
1. 输入您的 GitHub 凭据并按照 GitHub 的身份验证提示操作。
1. 点击"**授权 streamlit**。"

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="授权社区云连接到您的 GitHub 账户" src="/images/streamlit-community-cloud/GitHub-auth1-none.png"/>
</div>

## 可选：添加对私有仓库的访问权限

1. 在左上角，点击您的 GitHub 用户名。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="访问您的工作区设置" src="/images/streamlit-community-cloud/workspace-empty-menu.png"/>
</div>

1. 从下拉菜单中，点击"**设置**。"
1. 在对话框左侧，选择"**已连接的账户**。"
1. 在"源代码管理"下，点击"**在此连接 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_forward</i>**。"
1. 点击"**授权 streamlit**。"

<div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
<Image alt="授权社区云连接到您的私有 GitHub 仓库" src="/images/streamlit-community-cloud/GitHub-auth2-none.png"/>
</div>

## 从模板创建新应用

1. 在右上角，点击"**创建应用**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="在 Streamlit 社区云中从工作区创建新应用" src="/images/streamlit-community-cloud/deploy-empty-new-app.png"/>
</div>

1. 当询问"您是否已有应用？"时，点击"**没有，从模板创建一个**。"
1. 从左侧的模板列表中，选择"**空白应用**。"
1. 在底部，选择"**打开 GitHub Codespaces...**"选项
1. 在底部，点击"**部署**。"

## 在 GitHub Codespaces 中编辑您的应用

1. 等待 GitHub 设置您的 codespace。

   完全初始化您的 codespace 可能需要几分钟时间。在您看到 codespace 中的 Visual Studio Code 编辑器后，可能还需要几分钟来安装 Python 并启动 Streamlit 服务器。完成后，您将看到一个分屏视图，左侧为代码编辑器，右侧为正在运行的应用程序。代码编辑器默认打开两个标签：仓库的 readme 文件和应用程序入口文件。

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="您的新 GitHub Codespace" src="/images/streamlit-community-cloud/deploy-template-blank-codespace.png"/>
</div>

1. 在左侧面板中转到应用程序入口文件(`streamlit_app.py`)，并在第3行中在 `st.title` 内添加"Streamlit"。

   ```diff
   -st.title("🎈 My new app")
   +st.title("🎈 My new Streamlit app")
   ```

   在 codespace 中，每次编辑都会自动保存文件。

1. 输入更改后片刻，您右侧的应用程序将显示重新运行提示。点击"**始终重新运行**。"

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="编辑示例 Streamlit 应用的标题" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit.png"/>
</div>

   如果在您点击之前重新运行提示消失，您可以悬停在溢出菜单图标(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_vert</i>)上将其恢复。

1. 可选：继续进行编辑并观察几秒钟内的更改。

## 发布您的更改

1. 在左侧导航栏中，点击源代码管理图标。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="查看已部署的 Streamlit 应用" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-source-control.png"/>
</div>

1. 在左侧的源代码管理侧边栏中，为您的提交输入一个名称。
1. 点击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;check</i> 提交**。"

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="查看已部署的 Streamlit 应用" src="/images/streamlit-community-cloud/deploy-template-blank-codespace-edit-commit.png"/>
</div>

1. 在确认对话框中，点击"**是**"以暂存并提交所有更改。您的更改已在 codespace 中本地提交。
1. 在左侧的源代码管理侧边栏中，点击"**<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;cached</i> 1 <i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;arrow_upward</i>**"以将您的提交推送到 GitHub。
1. 在确认对话框中，点击"**确定**"以将提交推送到"origin/main"。

   您的更改现在已保存到 GitHub 仓库中。社区云将立即在您部署的应用程序中反映这些更改。

1. 可选：要查看更新后的已发布应用，请返回到 <a href="https://share.streamlit.io" target="_blank">share.streamlit.io</a> 工作区中的"**我的应用**"部分，然后点击您的应用。

## 学习 Streamlit 基础知识

如果您还没有学习 Streamlit 的基本概念，现在是转到[基础知识](/get-started/fundamentals)的好时机。使用您的 codespace 浏览并尝试基本的 Streamlit 命令。完成后，回到这里了解如何清理您的 codespace。

## 停止或删除您的 codespace

当您停止与 codespace 交互时，GitHub 通常会为您停止 codespace。但是，避免容量意外使用的最可靠方法是在完成后停止或删除 codespace。

1. 访问 <a href="https://github.com/codespaces" target="_blank">github.com/codespaces</a>。在页面底部，列出所有您的 codespaces。点击您 codespace 的溢出菜单图标(<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;more_horiz</i>)。

<div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
<Image alt="停止或删除您的 GitHub Codespace" src="/images/streamlit-community-cloud/deploy-hello-codespace-manage.png"/>
</div>

2. 如果您想稍后返回工作，请点击"**停止 codespace**。否则，请点击"**删除**。"

   <div>{{ maxWidth: '40%', margin: 'auto' }}&gt;
   <Image alt="停止您的 GitHub codespace" src="/images/streamlit-community-cloud/codespace-menu.png"/>
</div>

3. 恭喜！您刚刚将应用部署到了 Streamlit 社区云。🎉 返回 <a href="https://share.streamlit.io/" target="_blank">share.streamlit.io/</a> 工作区并[部署另一个 Streamlit 应用](/deploy/streamlit-community-cloud/deploy-your-app)。

   <div>{{ maxWidth: '90%', margin: 'auto' }}&gt;
   <Image alt="查看您已部署的 Streamlit 应用" src="/images/streamlit-community-cloud/deploy-template-blank-edited.png"/>
</div>

---

# Use Streamlit in Snowflake to code in a secure environment

Source: https://docs.streamlit.io/get-started/installation/streamlit-in-snowflake


Snowflake is a single, global platform that powers the Data Cloud. If you want to use a secure platform with role-based access control, this is the option for you! This page walks you through creating a trial Snowflake account and building a "Hello world" app. Your trial account comes with an account credit so you can try out the service without entering any payment information.

<Note>

For more information, see [Limitations and unsupported features](https://docs.snowflake.com/en/developer-guide/streamlit/limitations) in the Snowflake documentation.

</Note>

## Prerequisites

All you need is an email address! Everything else happens in your 30-day trial account.

## Create an account

1. Go to <SnowflakeTrial/>. (This link will open in a new tab.)

1. Fill in your information, and click "**CONTINUE**."

1. Select "**Standard**" for your Snowflake edition and "**Amazon Web Services**" for your cloud provider.

1. Choose the region nearest you, accept the terms, and click "**GET STARTED**."

<div>{{ maxWidth: '50%', margin: 'auto' }}&gt;
    <Image alt="Choose your Snowflake edition, provider, and region" src="/images/get-started/SiS-region.png"/>
</div>

1. Answer a few questions to let us know more about yourself, or skip them.

1. A message will display: "You're now signed up!" Go to your email, and click on the activation link. (Within your link, note the subdomain. This is your Snowflake account identifier. `https://<account_identifier>.snowflakecomputing.com`)

1. Set your username and password. This will be an admin user account within your Snowflake account. Your Snowflake account can have multiple users within it.

1. If you are not signed in after setting your password, follow the instructions to enter your Snowflake account identifier, and then enter your username and password. If you've accidentally closed your browser, you can sign in at [app.snowflake.com](https://app.snowflake.com/).

Congratulations! You have a trial Snowflake account.

The displayed interface is called Snowsight. Snowsight provides a web-based, graphical user interface for your Snowflake account. The default page is "**Home**," which provides popular quick actions to get started. You can access your "**Projects**" in the left navigation or at the bottom of your "**Home**" page. "**Projects**" include worksheets, notebooks, Streamlit apps, and dashboards. Check out the Snowflake docs for a [quick tour](https://docs.snowflake.com/en/user-guide/ui-snowsight-quick-tour).)

![Sample databases in your new trial Snowflake account](/images/get-started/SiS-1-landing-page.png)

## Optional: Create a warehouse

Warehouses provide compute resources for tasks and apps in your Snowflake account. Your trial account already has an XS warehouse which you can use. This is named "COMPUTE_WH." However, if you want to use more compute resources, you can create another warehouse.

1. In the lower-left corner under your name, confirm that your current role is "ACCOUNTADMIN." If it isn't, click your name, hover over "**Switch Role**," and select "**ACCOUNTADMIN**."

1. In the left navigation, select "**Admin**" → "**Warehouses**."

1. In the upper-right corner, click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;add</i> **Warehouse**" button.

1. Enter "STREAMLIT_WH" for the name and select a type and size. The default type and size are "Standard" and "X-Small," respectively. Click "**Create Warehouse**."

## Create a database

Databases provide storage for data and apps in your Snowflake account. Your trial account comes with a shared database of sample data, but you must create a new database in your account to store your app files.

1. In the left navigation, select "**Data**" → "**Databases**."

1. In the upper-right corner, click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;add</i> **Database**" button.

1. Enter "STREAMLIT_DB" for the name, and click "**Create**."

Yay! You now have a new database to hold all your Streamlit apps.

![New database in your new trial Snowflake account](/images/get-started/SiS-2-databases.png)

The databases in the above screenshot are as follows:

- "SNOWFLAKE:" A built-in database that stores meta data for your account.
- "SNOWFLAKE_SAMPLE_DATA:" A shared database with sample data.
- "STREAMLIT_DB:" Your new database where you'll put your Streamlit files.

## Create a "Hello World" Streamlit app

1. In the left navigation, select "**Projects**" → "**Streamlit**."

1. In the upper-right corner, click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;add</i> **Streamlit App**" button.

1. Enter your app details as follows:
   - App title: "Hello World"
   - App location: "STREAMLIT_DB" and "PUBLIC"
   - App warehouse: "COMPUTE_WH" (default) or "STREAMLIT_WH" (if you created a new warehouse)

   If you can't select your database, refresh the page to ensure that the interface is displaying current information.

1. Click "**Create**." (Note that the app will run with the rights of "ACCOUNTADMIN" for simplicity. You can curate your roles and permissions to choose who can create and access apps.)

   ![Create your first Streamlit in Snowflake app](/images/get-started/SiS-3-create-app.png)

   Your new app is prefilled with example code and opens in editing mode. The left panel shows your code. The right panel shows the resulting app.

1. Optional: Explore the example app.

1. In the left code editor, delete everything, and replace it with the following:

   ```python
   import streamlit as st

   st.write("Hello World")
   ```

   If you want to return to the sample code later, you can always make another app to edit the same example again.

1. In the upper-right corner, click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;play_arrow</i> **Run**" button to make the running app reflect your changes.

   Hooray! You just wrote a Streamlit app.

   ![Hello World in Streamlit in Snowflake app](/images/get-started/SiS-4-hello-world.png)

   <Tip>

   In the lower-left corner of the editing interface, you can click the splitscreen icons to toggle the visibility of your file navigation, code editor, and app preview.

   </Tip>

1. Change `st.write` to `st.title`:

   ```python
   import streamlit as st

   st.title("Hello World")
   ```

1. In the upper-right corner, click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;play_arrow</i> **Run**" button to make the running app reflect your changes.

   Your app now displays the larger title text.

1. Optional: Make more edits to your app. You must interact with your app or click the blue "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;play_arrow</i> **Run**" button to display the changes. This is different from a local environment where you can save your changes to trigger a rerun.

1. To return to Snowsight, in the upper-left corner, click "<i>{{ verticalAlign: "-.25em" }} className={{ class: "material-icons-sharp" }}&gt;chevron_left</i> **Streamlit Apps**."

## Return to your app

When you want to view or edit your app again, you can return to it through Snowsight. If you are returning to the site, you can sign in at [app.snowflake.com](https://app.snowflake.com/).

1. In the left navigation, select "**Projects**" → "**Streamlit**."

1. In your list of apps, click "**Hello World**."

   If you don't see your app, check that your role is set to "ACCOUNTADMIN" as described in [Optional: Create a warehouse](/get-started/installation/streamlit-in-snowflake#optional-create-a-warehouse).

1. Your app will open in viewing mode. To edit your app, in the upper-right corner, click "**Edit**."

   ![Change to editing mode in Streamlit in Snowflake](/images/get-started/SiS-5-hello-world-edit.png)

## What's next?

Read about our [Basic concepts](/get-started/fundamentals/main-concepts) and try out more commands in your app. Or, create more apps in Snowflake! You can reuse your warehouse and database, so you don't need to repeat those steps.

For more information about creating and managing Streamlit in Snowflake apps, check out the [Snowflake docs](https://docs.snowflake.com/en/developer-guide/streamlit/about-streamlit).</account_identifier>

---

# Use Streamlit Playground in your browser

Source: https://docs.streamlit.io/get-started/installation/streamlit-playground


The fastest way to try out Streamlit is to try out our Playground! Streamlit Playground runs in your browser. Just visit the Playground, and a _limited_ version of Streamlit loads as browser scripts.

Enjoy the following conveniences:

- Start playing with code right away, completely in your browser.
- No configuration.
- No command line.
- No application installations in your OS.

<Important>

Although the Playground has everything you need to get started, it doesn't contain the full version of Streamlit. To access the full awesomeness of Streamlit, see [Install Streamlit using command line](/get-started/installation/command-line) or [Install Streamlit using Anaconda Distribution](/get-started/installation/anaconda-distribution).

</Important>

## Prerequisites

Because the Playground runs Streamlit _locally_ in your browser, you should visit the Playground from a personal computer, not a mobile device.

## Go to the Playground

1. Go to [streamlit.io/playground](https://streamlit.io/playground).

1. Wait for the playground to load.

   Behind the scenes, the site installs a browser-based version of Python and Streamlit. This can take as little as a few seconds. The setup time can vary depending on your machine and internet connection. When Streamlit is done loading, an example app is displayed in the right panel.

   ![Streamlit Playground is fully loaded and ready to accept code edits](/images/get-started/Playground-1-loaded.png)

1. Optional: To view different examples, above the editor, select them from the examples list.

## Create a `Hello World` app

1. From the "EXAMPLES" list, select "**Blank**."

1. On the left, update the contents of the code editor to contain the following code:

   ```python
   import streamlit as st

   st.write("Hello World")
   ```

   A second or two after typing or pasting the code into the editor, the right panel will display the updated app. The code editor saves your edits whenever you pause from typing. Therefore, if you pause between keystrokes as you type a new line of code, you may see an error on the right because Streamlit executed an incomplete line. If this happens, just keep typing to complete the line(s) you are writing. When you pause again at the end of the line, Streamlit reruns the app.

1. On the left, change `st.write` to `st.title` so the code editor has the following code:

   ```python
   import streamlit as st

   st.title("Hello World")
   ```

   A second after you stop typing, Streamlit reruns the app and updates the display on the right.

1. Keep making changes! Watch as your edits are automatically saved and the new result is displayed on the right.

## What's next?

- Option 1: If you're already intrigued and ready to install Streamlit on your computer, see one of the options to [Install Streamlit on your machine](/get-started/installation#install-on-your-machine).

- Option 2: Otherwise, you can keep using the playground while you read about our [Basic concepts](/get-started/fundamentals/main-concepts) and try out more commands in your app.

  When you use the Streamlit Playground to work through the basic concepts, you can skip over any instructions to save your file or to select "**Rerun on save**." Streamlit Playground automatically saves your code when you pause from editing, as described above. Also, it is already configured to rerun on save.

---

# 构建 Streamlit 应用的第一步

Source: https://docs.streamlit.io/get-started/tutorials


如果您刚刚阅读了我们的 [基本概念](/get-started/fundamentals/main-concepts) 并想开始学习 Streamlit。查看这些教程。确保您已 [安装 Streamlit](/get-started/installation) 以便您可以自己执行代码。

<InlineCalloutContainer>
<InlineCallout bold="创建应用" color="orange-70" href="/get-started/tutorials/create-an-app" icon="description">使用基础知识中学到的概念以及缓存来指导您创建第一个应用。</InlineCallout>
<InlineCallout bold="创建多页应用" color="orange-70" href="/get-started/tutorials/create-a-multipage-app" icon="auto_stories">完成向您的应用添加页面的简单步骤。</InlineCallout>
</InlineCalloutContainer>

---

# Create a multipage app

Source: https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app


In [Additional features](/get-started/fundamentals/additional-features), we introduced multipage apps, including how to define pages, structure and run multipage apps, and navigate between pages in the user interface. You can read more details in our guide to [Multipage apps](/develop/concepts/multipage-apps)

In this guide, let’s put our understanding of multipage apps to use by converting the previous version of our `streamlit hello` app to a multipage app!

## Motivation

Before Streamlit 1.10.0, the streamlit hello command was a large single-page app. As there was no support for multiple pages, we resorted to splitting the app's content using `st.selectbox` in the sidebar to choose what content to run. The content is comprised of three demos for plotting, mapping, and dataframes.

Here's what the code and single-page app looked like:

<details>
<summary><b><code>hello.py</code></b>  (👈 Toggle to expand)</summary>
<br/>

```python
import streamlit as st

def intro():
    import streamlit as st

    st.write("# Welcome to Streamlit! 👋")
    st.sidebar.success("Select a demo above.")

    st.markdown(
        """
        Streamlit is an open-source app framework built specifically for
        Machine Learning and Data Science projects.

        **👈 Select a demo from the dropdown on the left** to see some examples
        of what Streamlit can do!

        ### Want to learn more?

        - Check out [streamlit.io](https://streamlit.io)
        - Jump into our [documentation](https://docs.streamlit.io)
        - Ask a question in our [community
          forums](https://discuss.streamlit.io)

        ### See more complex demos

        - Use a neural net to [analyze the Udacity Self-driving Car Image
          Dataset](https://github.com/streamlit/demo-self-driving)
        - Explore a [New York City rideshare dataset](https://github.com/streamlit/demo-uber-nyc-pickups)
    """
    )

def mapping_demo():
    import streamlit as st
    import pandas as pd
    import pydeck as pdk

    from urllib.error import URLError

    st.markdown(f"# {list(page_names_to_funcs.keys())[2]}")
    st.write(
        """
        This demo shows how to use
[`st.pydeck_chart`](https://docs.streamlit.io/develop/api-reference/charts/st.pydeck_chart)
to display geospatial data.
"""
    )

    @st.cache_data
    def from_data_file(filename):
        url = (
            "http://raw.githubusercontent.com/streamlit/"
            "example-data/master/hello/v1/%s" % filename
        )
        return pd.read_json(url)

    try:
        ALL_LAYERS = {
            "Bike Rentals": pdk.Layer(
                "HexagonLayer",
                data=from_data_file("bike_rental_stats.json"),
                get_position=["lon", "lat"],
                radius=200,
                elevation_scale=4,
                elevation_range=[0, 1000],
                extruded=True,
            ),
            "Bart Stop Exits": pdk.Layer(
                "ScatterplotLayer",
                data=from_data_file("bart_stop_stats.json"),
                get_position=["lon", "lat"],
                get_color=[200, 30, 0, 160],
                get_radius="[exits]",
                radius_scale=0.05,
            ),
            "Bart Stop Names": pdk.Layer(
                "TextLayer",
                data=from_data_file("bart_stop_stats.json"),
                get_position=["lon", "lat"],
                get_text="name",
                get_color=[0, 0, 0, 200],
                get_size=15,
                get_alignment_baseline="'bottom'",
            ),
            "Outbound Flow": pdk.Layer(
                "ArcLayer",
                data=from_data_file("bart_path_stats.json"),
                get_source_position=["lon", "lat"],
                get_target_position=["lon2", "lat2"],
                get_source_color=[200, 30, 0, 160],
                get_target_color=[200, 30, 0, 160],
                auto_highlight=True,
                width_scale=0.0001,
                get_width="outbound",
                width_min_pixels=3,
                width_max_pixels=30,
            ),
        }
        st.sidebar.markdown("### Map Layers")
        selected_layers = [
            layer
            for layer_name, layer in ALL_LAYERS.items()
            if st.sidebar.checkbox(layer_name, True)
        ]
        if selected_layers:
            st.pydeck_chart(
                pdk.Deck(
                    map_style="mapbox://styles/mapbox/light-v9",
                    initial_view_state={
                        "latitude": 37.76,
                        "longitude": -122.4,
                        "zoom": 11,
                        "pitch": 50,
                    },
                    layers=selected_layers,
                )
            )
        else:
            st.error("Please choose at least one layer above.")
    except URLError as e:
        st.error(
            """
            **This demo requires internet access.**

            Connection error: %s
        """
            % e.reason
        )

def plotting_demo():
    import streamlit as st
    import time
    import numpy as np

    st.markdown(f'# {list(page_names_to_funcs.keys())[1]}')
    st.write(
        """
        This demo illustrates a combination of plotting and animation with
Streamlit. We're generating a bunch of random numbers in a loop for around
5 seconds. Enjoy!
"""
    )

    progress_bar = st.sidebar.progress(0)
    status_text = st.sidebar.empty()
    last_rows = np.random.randn(1, 1)
    chart = st.line_chart(last_rows)

    for i in range(1, 101):
        new_rows = last_rows[-1, :] + np.random.randn(5, 1).cumsum(axis=0)
        status_text.text("%i%% Complete" % i)
        chart.add_rows(new_rows)
        progress_bar.progress(i)
        last_rows = new_rows
        time.sleep(0.05)

    progress_bar.empty()

    # Streamlit widgets automatically run the script from top to bottom. Since
    # this button is not connected to any other logic, it just causes a plain
    # rerun.
    st.button("Re-run")


def data_frame_demo():
    import streamlit as st
    import pandas as pd
    import altair as alt

    from urllib.error import URLError

    st.markdown(f"# {list(page_names_to_funcs.keys())[3]}")
    st.write(
        """
        This demo shows how to use `st.write` to visualize Pandas DataFrames.

(Data courtesy of the [UN Data Explorer](http://data.un.org/Explorer.aspx).)
"""
    )

    @st.cache_data
    def get_UN_data():
        AWS_BUCKET_URL = "http://streamlit-demo-data.s3-us-west-2.amazonaws.com"
        df = pd.read_csv(AWS_BUCKET_URL + "/agri.csv.gz")
        return df.set_index("Region")

    try:
        df = get_UN_data()
        countries = st.multiselect(
            "Choose countries", list(df.index), ["China", "United States of America"]
        )
        if not countries:
            st.error("Please select at least one country.")
        else:
            data = df.loc[countries]
            data /= 1000000.0
            st.write("### Gross Agricultural Production ($B)", data.sort_index())

            data = data.T.reset_index()
            data = pd.melt(data, id_vars=["index"]).rename(
                columns={"index": "year", "value": "Gross Agricultural Product ($B)"}
            )
            chart = (
                alt.Chart(data)
                .mark_area(opacity=0.3)
                .encode(
                    x="year:T",
                    y=alt.Y("Gross Agricultural Product ($B):Q", stack=None),
                    color="Region:N",
                )
            )
            st.altair_chart(chart, use_container_width=True)
    except URLError as e:
        st.error(
            """
            **This demo requires internet access.**

            Connection error: %s
        """
            % e.reason
        )

page_names_to_funcs = {
    "—": intro,
    "Plotting Demo": plotting_demo,
    "Mapping Demo": mapping_demo,
    "DataFrame Demo": data_frame_demo
}

demo_name = st.sidebar.selectbox("Choose a demo", page_names_to_funcs.keys())
page_names_to_funcs[demo_name]()
```

</details>
<Cloud height="700px" name="doc-hello"/>

Notice how large the file is! Each app “page" is written as a function, and the selectbox is used to pick which page to display. As our app grows, maintaining the code requires a lot of additional overhead. Moreover, we’re limited by the `st.selectbox` UI to choose which “page" to run, we cannot customize individual page titles with `st.set_page_config`, and we’re unable to navigate between pages using URLs.

## Convert an existing app into a multipage app

Now that we've identified the limitations of a single-page app, what can we do about it? Armed with our knowledge from the previous section, we can convert the existing app to be a multipage app, of course! At a high level, we need to perform the following steps:

1. Create a new `pages` folder in the same folder where the “entrypoint file" (`hello.py`) lives
2. Rename our entrypoint file to `Hello.py` , so that the title in the sidebar is capitalized
3. Create three new files inside of `pages`:
   - `pages/1_📈_Plotting_Demo.py`
   - `pages/2_🌍_Mapping_Demo.py`
   - `pages/3_📊_DataFrame_Demo.py`
4. Move the contents of the `plotting_demo`, `mapping_demo`, and `data_frame_demo` functions into their corresponding new files from Step 3
5. Run `streamlit run Hello.py` to view your newly converted multipage app!

Now, let’s walk through each step of the process and view the corresponding changes in code.

## Create the entrypoint file

<details>
<summary><code>Hello.py</code></summary>

```python
import streamlit as st

st.set_page_config(
    page_title="Hello",
    page_icon="👋",
)

st.write("# Welcome to Streamlit! 👋")

st.sidebar.success("Select a demo above.")

st.markdown(
    """
    Streamlit is an open-source app framework built specifically for
    Machine Learning and Data Science projects.
    **👈 Select a demo from the sidebar** to see some examples
    of what Streamlit can do!
    ### Want to learn more?
    - Check out [streamlit.io](https://streamlit.io)
    - Jump into our [documentation](https://docs.streamlit.io)
    - Ask a question in our [community
        forums](https://discuss.streamlit.io)
    ### See more complex demos
    - Use a neural net to [analyze the Udacity Self-driving Car Image
        Dataset](https://github.com/streamlit/demo-self-driving)
    - Explore a [New York City rideshare dataset](https://github.com/streamlit/demo-uber-nyc-pickups)
"""
)
```

</details>
<br/>

We rename our entrypoint file to `Hello.py` , so that the title in the sidebar is capitalized and only the code for the intro page is included. Additionally, we’re able to customize the page title and favicon — as it appears in the browser tab with `st.set_page_config`. We can do so for each of our pages too!

<Image src="/images/mpa-hello.png"/>

Notice how the sidebar does not contain page labels as we haven’t created any pages yet.

## Create multiple pages

A few things to remember here:

1. We can change the ordering of pages in our MPA by adding numbers to the beginning of each Python file. If we add a 1 to the front of our file name, Streamlit will put that file first in the list.
2. The name of each Streamlit app is determined by the file name, so to change the app name you need to change the file name!
3. We can add some fun to our app by adding emojis to our file names that will render in our Streamlit app.
4. Each page will have its own URL, defined by the name of the file.

Check out how we do all this below! For each new page, we create a new file inside the pages folder, and add the appropriate demo code into it.

<br/>
<details>
<summary><code>pages/1_📈_Plotting_Demo.py</code></summary>

```python
import streamlit as st
import time
import numpy as np

st.set_page_config(page_title="Plotting Demo", page_icon="📈")

st.markdown("# Plotting Demo")
st.sidebar.header("Plotting Demo")
st.write(
    """This demo illustrates a combination of plotting and animation with
Streamlit. We're generating a bunch of random numbers in a loop for around
5 seconds. Enjoy!"""
)

progress_bar = st.sidebar.progress(0)
status_text = st.sidebar.empty()
last_rows = np.random.randn(1, 1)
chart = st.line_chart(last_rows)

for i in range(1, 101):
    new_rows = last_rows[-1, :] + np.random.randn(5, 1).cumsum(axis=0)
    status_text.text("%i%% Complete" % i)
    chart.add_rows(new_rows)
    progress_bar.progress(i)
    last_rows = new_rows
    time.sleep(0.05)

progress_bar.empty()

# Streamlit widgets automatically run the script from top to bottom. Since
# this button is not connected to any other logic, it just causes a plain
# rerun.
st.button("Re-run")
```

</details>
<Image src="/images/mpa-plotting-demo.png"/>
<details>
<summary><code>pages/2_🌍_Mapping_Demo.py</code></summary>

```python
import streamlit as st
import pandas as pd
import pydeck as pdk
from urllib.error import URLError

st.set_page_config(page_title="Mapping Demo", page_icon="🌍")

st.markdown("# Mapping Demo")
st.sidebar.header("Mapping Demo")
st.write(
    """This demo shows how to use
[`st.pydeck_chart`](https://docs.streamlit.io/develop/api-reference/charts/st.pydeck_chart)
to display geospatial data."""
)


@st.cache_data
def from_data_file(filename):
    url = (
        "http://raw.githubusercontent.com/streamlit/"
        "example-data/master/hello/v1/%s" % filename
    )
    return pd.read_json(url)


try:
    ALL_LAYERS = {
        "Bike Rentals": pdk.Layer(
            "HexagonLayer",
            data=from_data_file("bike_rental_stats.json"),
            get_position=["lon", "lat"],
            radius=200,
            elevation_scale=4,
            elevation_range=[0, 1000],
            extruded=True,
        ),
        "Bart Stop Exits": pdk.Layer(
            "ScatterplotLayer",
            data=from_data_file("bart_stop_stats.json"),
            get_position=["lon", "lat"],
            get_color=[200, 30, 0, 160],
            get_radius="[exits]",
            radius_scale=0.05,
        ),
        "Bart Stop Names": pdk.Layer(
            "TextLayer",
            data=from_data_file("bart_stop_stats.json"),
            get_position=["lon", "lat"],
            get_text="name",
            get_color=[0, 0, 0, 200],
            get_size=15,
            get_alignment_baseline="'bottom'",
        ),
        "Outbound Flow": pdk.Layer(
            "ArcLayer",
            data=from_data_file("bart_path_stats.json"),
            get_source_position=["lon", "lat"],
            get_target_position=["lon2", "lat2"],
            get_source_color=[200, 30, 0, 160],
            get_target_color=[200, 30, 0, 160],
            auto_highlight=True,
            width_scale=0.0001,
            get_width="outbound",
            width_min_pixels=3,
            width_max_pixels=30,
        ),
    }
    st.sidebar.markdown("### Map Layers")
    selected_layers = [
        layer
        for layer_name, layer in ALL_LAYERS.items()
        if st.sidebar.checkbox(layer_name, True)
    ]
    if selected_layers:
        st.pydeck_chart(
            pdk.Deck(
                map_style="mapbox://styles/mapbox/light-v9",
                initial_view_state={
                    "latitude": 37.76,
                    "longitude": -122.4,
                    "zoom": 11,
                    "pitch": 50,
                },
                layers=selected_layers,
            )
        )
    else:
        st.error("Please choose at least one layer above.")
except URLError as e:
    st.error(
        """
        **This demo requires internet access.**
        Connection error: %s
    """
        % e.reason
    )
```

</details>
<Image src="/images/mpa-mapping-demo.png"/>
<details>
<summary><code>pages/3_📊_DataFrame_Demo.py</code></summary>

```python
import streamlit as st
import pandas as pd
import altair as alt
from urllib.error import URLError

st.set_page_config(page_title="DataFrame Demo", page_icon="📊")

st.markdown("# DataFrame Demo")
st.sidebar.header("DataFrame Demo")
st.write(
    """This demo shows how to use `st.write` to visualize Pandas DataFrames.
(Data courtesy of the [UN Data Explorer](http://data.un.org/Explorer.aspx).)"""
)


@st.cache_data
def get_UN_data():
    AWS_BUCKET_URL = "http://streamlit-demo-data.s3-us-west-2.amazonaws.com"
    df = pd.read_csv(AWS_BUCKET_URL + "/agri.csv.gz")
    return df.set_index("Region")


try:
    df = get_UN_data()
    countries = st.multiselect(
        "Choose countries", list(df.index), ["China", "United States of America"]
    )
    if not countries:
        st.error("Please select at least one country.")
    else:
        data = df.loc[countries]
        data /= 1000000.0
        st.write("### Gross Agricultural Production ($B)", data.sort_index())

        data = data.T.reset_index()
        data = pd.melt(data, id_vars=["index"]).rename(
            columns={"index": "year", "value": "Gross Agricultural Product ($B)"}
        )
        chart = (
            alt.Chart(data)
            .mark_area(opacity=0.3)
            .encode(
                x="year:T",
                y=alt.Y("Gross Agricultural Product ($B):Q", stack=None),
                color="Region:N",
            )
        )
        st.altair_chart(chart, use_container_width=True)
except URLError as e:
    st.error(
        """
        **This demo requires internet access.**
        Connection error: %s
    """
        % e.reason
    )
```

</details>
<Image src="/images/mpa-dataframe-demo.png"/>

With our additional pages created, we can now put it all together in the final step below.

## Run the multipage app

To run your newly converted multipage app, run:

```bash
streamlit run Hello.py
```

That’s it! The `Hello.py` script now corresponds to the main page of your app, and other scripts that Streamlit finds in the pages folder will also be present in the new page selector that appears in the sidebar.

<Cloud height="700px" name="doc-mpa-hello"/>

## Next steps

Congratulations! 🎉 If you've read this far, chances are you've learned to create both single-page and multipage apps. Where you go from here is entirely up to your creativity! We’re excited to see what you’ll build now that adding additional pages to your apps is easier than ever. Try adding more pages to the app we've just built as an exercise. Also, stop by the forum to show off your multipage apps with the Streamlit community! 🎈

Here are a few resources to help you get started:

- Deploy your app for free on Streamlit's [Community Cloud](/deploy/streamlit-community-cloud).
- Post a question or share your multipage app on our [community forum](https://discuss.streamlit.io/c/streamlit-examples/9).
- Check out our documentation on [Multipage apps](/develop/concepts/multipage-apps).
- Read through [Concepts](/develop/concepts) for things like caching, theming, and adding statefulness to apps.
- Browse our [API reference](/develop/api-reference/) for examples of every Streamlit command.

---

# Create an app

Source: https://docs.streamlit.io/get-started/tutorials/create-an-app


If you've made it this far, chances are you've [installed Streamlit](/get-started/installation) and run through the basics in [Basic concepts](/get-started/fundamentals/main-concepts) and [Advanced concepts](/get-started/fundamentals/advanced-concepts). If not, now is a good time to take a look.

The easiest way to learn how to use Streamlit is to try things out yourself. As you read through this guide, test each method. As long as your app is running, every time you add a new element to your script and save, Streamlit's UI will ask if you'd like to rerun the app and view the changes. This allows you to work in a fast interactive loop: you write some code, save it, review the output, write some more, and so on, until you're happy with the results. The goal is to use Streamlit to create an interactive app for your data or model and along the way to use Streamlit to review, debug, perfect, and share your code.

In this guide, you're going to use Streamlit's core features to
create an interactive app; exploring a public Uber dataset for pickups and
drop-offs in New York City. When you're finished, you'll know how to fetch
and cache data, draw charts, plot information on a map, and use interactive
widgets, like a slider, to filter results.

<Tip>

If you'd like to skip ahead and see everything at once, the [complete script
is available below](#lets-put-it-all-together).

</Tip>

## Create your first app

Streamlit is more than just a way to make data apps, it’s also a community of creators that share their apps and ideas and help each other make their work better. Please come join us on the community forum. We love to hear your questions, ideas, and help you work through your bugs — stop by today!

1. The first step is to create a new Python script. Let's call it
   `uber_pickups.py`.

2. Open `uber_pickups.py` in your favorite IDE or text editor, then add these
   lines:

   ```python
   import streamlit as st
   import pandas as pd
   import numpy as np
   ```

3. Every good app has a title, so let's add one:

   ```python
   st.title('Uber pickups in NYC')
   ```

4. Now it's time to run Streamlit from the command line:

   ```bash
   streamlit run uber_pickups.py
   ```

   Running a Streamlit app is no different than any other Python script. Whenever you need to view the app, you can use this command.

   <Tip>

   Did you know you can also pass a URL to `streamlit run`? This is great when combined with GitHub Gists. For example:

   ```bash
   streamlit run https://raw.githubusercontent.com/streamlit/demo-uber-nyc-pickups/master/streamlit_app.py
   ```

   </Tip>

5. As usual, the app should automatically open in a new tab in your
   browser.

## Fetch some data

Now that you have an app, the next thing you'll need to do is fetch the Uber
dataset for pickups and drop-offs in New York City.

1. Let's start by writing a function to load the data. Add this code to your
   script:

   ```python
   DATE_COLUMN = 'date/time'
   DATA_URL = ('https://s3-us-west-2.amazonaws.com/'
            'streamlit-demo-data/uber-raw-data-sep14.csv.gz')

   def load_data(nrows):
       data = pd.read_csv(DATA_URL, nrows=nrows)
       lowercase = lambda x: str(x).lower()
       data.rename(lowercase, axis='columns', inplace=True)
       data[DATE_COLUMN] = pd.to_datetime(data[DATE_COLUMN])
       return data
   ```

   You'll notice that `load_data` is a plain old function that downloads some
   data, puts it in a Pandas dataframe, and converts the date column from text
   to datetime. The function accepts a single parameter (`nrows`), which
   specifies the number of rows that you want to load into the dataframe.

2. Now let's test the function and review the output. Below your function, add
   these lines:

   ```python
   # Create a text element and let the reader know the data is loading.
   data_load_state = st.text('Loading data...')
   # Load 10,000 rows of data into the dataframe.
   data = load_data(10000)
   # Notify the reader that the data was successfully loaded.
   data_load_state.text('Loading data...done!')
   ```

   You'll see a few buttons in the upper-right corner of your app asking if
   you'd like to rerun the app. Choose **Always rerun**, and you'll see your
   changes automatically each time you save.

Ok, that's underwhelming...

It turns out that it takes a long time to download data, and load 10,000 lines
into a dataframe. Converting the date column into datetime isn’t a quick job
either. You don’t want to reload the data each time the app is updated –
luckily Streamlit allows you to cache the data.

## Effortless caching

1. Try adding `@st.cache_data` before the `load_data` declaration:

   ```python
   @st.cache_data
   def load_data(nrows):
   ```

2. Then save the script, and Streamlit will automatically rerun your app. Since
   this is the first time you’re running the script with `@st.cache_data`, you won't
   see anything change. Let’s tweak your file a little bit more so that you can
   see the power of caching.

3. Replace the line `data_load_state.text('Loading data...done!')` with this:

   ```python
   data_load_state.text("Done! (using st.cache_data)")
   ```

4. Now save. See how the line you added appeared immediately? If you take a
   step back for a second, this is actually quite amazing. Something magical is
   happening behind the scenes, and it only takes one line of code to activate
   it.

### How's it work?

Let's take a few minutes to discuss how `@st.cache_data` actually works.

When you mark a function with Streamlit’s cache annotation, it tells Streamlit
that whenever the function is called that it should check two things:

1. The input parameters you used for the function call.
2. The code inside the function.

If this is the first time Streamlit has seen both these items, with these exact
values, and in this exact combination, it runs the function and stores the
result in a local cache. The next time the function is called, if the two
values haven't changed, then Streamlit knows it can skip executing the function
altogether. Instead, it reads the output from the local cache and passes it on
to the caller -- like magic.

"But, wait a second," you’re saying to yourself, "this sounds too good to be
true. What are the limitations of all this awesomesauce?"

Well, there are a few:

1. Streamlit will only check for changes within the current working directory.
   If you upgrade a Python library, Streamlit's cache will only notice this if
   that library is installed inside your working directory.
2. If your function is not deterministic (that is, its output depends on random
   numbers), or if it pulls data from an external time-varying source (for
   example, a live stock market ticker service) the cached value will be
   none-the-wiser.
3. Lastly, you should avoid mutating the output of a function cached with `st.cache_data` since cached
   values are stored by reference.

While these limitations are important to keep in mind, they tend not to be an
issue a surprising amount of the time. Those times, this cache is really
transformational.

<Tip>

Whenever you have a long-running computation in your code, consider
refactoring it so you can use `@st.cache_data`, if possible. Please read [Caching](/develop/concepts/architecture/caching) for more details.

</Tip>

Now that you know how caching with Streamlit works, let’s get back to the Uber
pickup data.

## Inspect the raw data

It's always a good idea to take a look at the raw data you're working with
before you start working with it. Let's add a subheader and a printout of the
raw data to the app:

```python
st.subheader('Raw data')
st.write(data)
```

In the [Basic concepts](/get-started/fundamentals/main-concepts) guide you learned that
[`st.write`](/develop/api-reference/write-magic/st.write) will render almost anything you pass
to it. In this case, you're passing in a dataframe and it's rendering as an
interactive table.

[`st.write`](/develop/api-reference/write-magic/st.write) tries to do the right thing based on
the data type of the input. If it isn't doing what you expect you can use a
specialized command like [`st.dataframe`](/develop/api-reference/data/st.dataframe)
instead. For a full list, see [API reference](/develop/api-reference).

## Draw a histogram

Now that you've had a chance to take a look at the dataset and observe what's
available, let's take things a step further and draw a histogram to see what
Uber's busiest hours are in New York City.

1. To start, let's add a subheader just below the raw data section:

   ```python
   st.subheader('Number of pickups by hour')
   ```

2. Use NumPy to generate a histogram that breaks down pickup times binned by
   hour:

   ```python
   hist_values = np.histogram(
       data[DATE_COLUMN].dt.hour, bins=24, range=(0,24))[0]
   ```

3. Now, let's use Streamlit's
   [`st.bar_chart()`](/develop/api-reference/charts/st.bar_chart) method to draw this
   histogram.

   ```python
   st.bar_chart(hist_values)
   ```

4. Save your script. This histogram should show up in your app right away.
   After a quick review, it looks like the busiest time is 17:00 (5 P.M.).

To draw this diagram we used Streamlit's native `bar_chart()` method, but it's
important to know that Streamlit supports more complex charting libraries like
Altair, Bokeh, Plotly, Matplotlib and more. For a full list, see
[supported charting libraries](/develop/api-reference/charts).

## Plot data on a map

Using a histogram with Uber's dataset helped us determine what the busiest
times are for pickups, but what if we wanted to figure out where pickups were
concentrated throughout the city. While you could use a bar chart to show this
data, it wouldn't be easy to interpret unless you were intimately familiar with
latitudinal and longitudinal coordinates in the city. To show pickup
concentration, let's use Streamlit [`st.map()`](/develop/api-reference/charts/st.map)
function to overlay the data on a map of New York City.

1. Add a subheader for the section:

   ```python
   st.subheader('Map of all pickups')
   ```

2. Use the `st.map()` function to plot the data:

   ```python
   st.map(data)
   ```

3. Save your script. The map is fully interactive. Give it a try by panning or
   zooming in a bit.

After drawing your histogram, you determined that the busiest hour for Uber
pickups was 17:00. Let's redraw the map to show the concentration of pickups
at 17:00.

1. Locate the following code snippet:

   ```python
   st.subheader('Map of all pickups')
   st.map(data)
   ```

2. Replace it with:

   ```python
   hour_to_filter = 17
   filtered_data = data[data[DATE_COLUMN].dt.hour == hour_to_filter]
   st.subheader(f'Map of all pickups at {hour_to_filter}:00')
   st.map(filtered_data)
   ```

3. You should see the data update instantly.

To draw this map we used the [`st.map`](/develop/api-reference/charts/st.map) function that's built into Streamlit, but
if you'd like to visualize complex map data, we encourage you to take a look at
the [`st.pydeck_chart`](/develop/api-reference/charts/st.pydeck_chart).

## Filter results with a slider

In the last section, when you drew the map, the time used to filter results was
hardcoded into the script, but what if we wanted to let a reader dynamically
filter the data in real time? Using Streamlit's widgets you can. Let's add a
slider to the app with the `st.slider()` method.

1. Locate `hour_to_filter` and replace it with this code snippet:

   ```python
   hour_to_filter = st.slider('hour', 0, 23, 17)  # min: 0h, max: 23h, default: 17h
   ```

2. Use the slider and watch the map update in real time.

## Use a button to toggle data

Sliders are just one way to dynamically change the composition of your app.
Let's use the [`st.checkbox`](/develop/api-reference/widgets/st.checkbox) function to add a
checkbox to your app. We'll use this checkbox to show/hide the raw data
table at the top of your app.

1. Locate these lines:

   ```python
   st.subheader('Raw data')
   st.write(data)
   ```

2. Replace these lines with the following code:

   ```python
   if st.checkbox('Show raw data'):
       st.subheader('Raw data')
       st.write(data)
   ```

We're sure you've got your own ideas. When you're done with this tutorial, check out all the widgets that Streamlit exposes in our [API Reference](/develop/api-reference).

## Let's put it all together

That's it, you've made it to the end. Here's the complete script for our interactive app.

<Tip>

If you've skipped ahead, after you've created your script, the command to run
Streamlit is `streamlit run [app name]`.

</Tip>

```python
import streamlit as st
import pandas as pd
import numpy as np

st.title('Uber pickups in NYC')

DATE_COLUMN = 'date/time'
DATA_URL = ('https://s3-us-west-2.amazonaws.com/'
            'streamlit-demo-data/uber-raw-data-sep14.csv.gz')

@st.cache_data
def load_data(nrows):
    data = pd.read_csv(DATA_URL, nrows=nrows)
    lowercase = lambda x: str(x).lower()
    data.rename(lowercase, axis='columns', inplace=True)
    data[DATE_COLUMN] = pd.to_datetime(data[DATE_COLUMN])
    return data

data_load_state = st.text('Loading data...')
data = load_data(10000)
data_load_state.text("Done! (using st.cache_data)")

if st.checkbox('Show raw data'):
    st.subheader('Raw data')
    st.write(data)

st.subheader('Number of pickups by hour')
hist_values = np.histogram(data[DATE_COLUMN].dt.hour, bins=24, range=(0,24))[0]
st.bar_chart(hist_values)

# Some number in the range 0-23
hour_to_filter = st.slider('hour', 0, 23, 17)
filtered_data = data[data[DATE_COLUMN].dt.hour == hour_to_filter]

st.subheader('Map of all pickups at %s:00' % hour_to_filter)
st.map(filtered_data)
```

## Share your app

After you’ve built a Streamlit app, it's time to share it! To show it off to the world you can use **Streamlit Community Cloud** to deploy, manage, and share your app for free.

It works in 3 simple steps:

1. Put your app in a public GitHub repo (and make sure it has a requirements.txt!)
2. Sign into [share.streamlit.io](https://share.streamlit.io)
3. Click 'Deploy an app' and then paste in your GitHub URL

That's it! 🎈 You now have a publicly deployed app that you can share with the world. Click to learn more about [how to use Streamlit Community Cloud](/deploy/streamlit-community-cloud).

## Get help

That's it for getting started, now you can go and build your own apps! If you
run into difficulties here are a few things you can do.

- Check out our [community forum](https://discuss.streamlit.io/) and post a question
- Quick help from command line with `streamlit help`
- Go through our [Knowledge Base](/knowledge-base) for tips, step-by-step tutorials, and articles that answer your questions about creating and deploying Streamlit apps.
- Read more documentation! Check out:
  - [Concepts](/develop/concepts) for things like caching, theming, and adding statefulness to apps.
  - [API reference](/develop/api-reference/) for examples of every Streamlit command.

---

# 知识库

Source: https://docs.streamlit.io/knowledge-base


知识库是一个自助式的技巧、分步教程和文章库，可以回答您关于创建和部署 Streamlit 应用的问题。

<InlineCalloutContainer>
<InlineCallout bold="常见问题" color="darkBlue-70" href="/knowledge-base/using-streamlit" icon="quiz">以下是关于使用 Streamlit 的一些常见问题。</InlineCallout>
<InlineCallout bold="安装依赖项" color="darkBlue-70" href="/knowledge-base/dependencies" icon="downloading">如果您在为 Streamlit 应用安装依赖项时遇到问题，我们可以帮助您。</InlineCallout>
<InlineCallout bold="部署问题" color="darkBlue-70" href="/knowledge-base/deploy" icon="report">对将 Streamlit 应用部署到云有疑问？本部分涵盖部署相关的问题。</InlineCallout>
</InlineCalloutContainer>

---

# 安装依赖项

Source: https://docs.streamlit.io/knowledge-base/dependencies


- [ModuleNotFoundError: No module named](/knowledge-base/dependencies/module-not-found-error)
- [ImportError: libGL.so.1: cannot open shared object file: No such file or directory](/knowledge-base/dependencies/libgl)
- [ERROR: No matching distribution found for](/knowledge-base/dependencies/no-matching-distribution)
- [如何安装不在PyPI/Conda上但可在GitHub上获得的包](/knowledge-base/dependencies/install-package-not-pypi-conda-available-github)

---

# 如何安装不在 PyPI/Conda 上但可在 GitHub 上获得的包

Source: https://docs.streamlit.io/knowledge-base/dependencies/install-package-not-pypi-conda-available-github


## 概述

您是否尝试将应用部署到[Streamlit Community Cloud](/deploy/streamlit-community-cloud)，但不知道如何在 requirements 文件中指定[Python 依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)，而该依赖项在公共 GitHub 仓库上可用，但不在 PyPI 或 Conda 等任何包索引上？如果是这样，请继续阅读以了解如何操作！

假设您想从 GitHub 安装 `SomePackage` 及其 Python 依赖项，GitHub 是流行的版本控制系统 (VCS) Git 的托管服务。假设 `SomePackage` 可在以下 URL 获取：`https://github.com/SomePackage.git`。

pip（通过 `requirements.txt`）[支持](https://pip.pypa.io/en/stable/topics/vcs-support/)从 GitHub 安装。此支持需要一个可用的工作可执行文件（对于 Git）。它通过 URL 前缀使用：`git+`。

## 指定 GitHub 网址

要安装 `SomePackage`，请在 `requirements.txt` 文件中包含以下内容：

```bash
git+https://github.com/SomePackage#egg=SomePackage
```

您甚至可以指定 "git ref"，例如分支名称、提交哈希或标签名称，如下面的示例所示。

## 指定 Git 分支名称

通过在 `requirements.txt` 中指定分支名称（如 `main`、`master`、`develop` 等）来安装 `SomePackage`：

```bash
git+https://github.com/SomePackage.git@main#egg=SomePackage
```

## 指定提交哈希

通过在 `requirements.txt` 中指定提交哈希来安装 `SomePackage`：

```bash
git+https://github.com/SomePackage.git@eb40b4ff6f7c5c1e4366cgfg0671291bge918#egg=SomePackage
```

## 指定标签

通过在 `requirements.txt` 中指定标签来安装 `SomePackage`：

```bash
git+https://github.com/SomePackage.git@v1.1.0#egg=SomePackage
```

## 限制

目前**不可能**使用 URI 形式从私有 GitHub 仓库安装私有包：

```bash
git+https://{token}@github.com/user/project.git@{version}
```

其中 `version` 是标签、分支或提交。`token` 是具有只读权限的个人访问令牌。Streamlit Community Cloud 仅支持从公共 GitHub 仓库安装公共包。

---

# ImportError: libGL.so.1: 无法打开共享对象文件: 没有那个文件或目录

Source: https://docs.streamlit.io/knowledge-base/dependencies/libgl


## 问题

在[Streamlit Community Cloud](https://streamlit.io/cloud)上部署的应用中使用 OpenCV 时，你会收到错误 `ImportError: libGL.so.1: cannot open shared object file: No such file or directory`。

## 解决方案

如果你在应用中使用 OpenCV，在 Streamlit Community Cloud 的 requirements 文件中用 `opencv-python-headless` 代替 `opencv_contrib_python` 和 `opencv-python`。

如果 `opencv-python` 是你的应用或应用使用的库的依赖项的*必需*（非可选）依赖项，上述解决方案不适用。相反，你可以使用以下解决方案：

在你的仓库中创建一个 `packages.txt` 文件，包含以下行以安装[apt-get 依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#apt-get-dependencies) `libgl`：

```
libgl1
```

---

# ModuleNotFoundError: No module named

Source: https://docs.streamlit.io/knowledge-base/dependencies/module-not-found-error


## 问题

在[Streamlit Community Cloud](https://streamlit.io/cloud)上部署应用时，你会收到错误 `ModuleNotFoundError: No module named`。

## 解决方案

当你在 Streamlit Community Cloud 上导入一个未包含在 requirements 文件中的模块时，会发生此错误。任何不与[标准 Python 安装](https://docs.python.org/3/py-modindex.html)一起分发的外部[Python 依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)都应包含在 requirements 文件中。

例如，如果你不在 requirements 文件中包含 `scikit-learn` 并在你的应用中 `import sklearn`，你会看到 `ModuleNotFoundError: No module named 'sklearn'`。

相关主论坛帖子：

- https://discuss.streamlit.io/t/getting-error-modulenotfounderror-no-module-named-beautifulsoup/9126
- https://discuss.streamlit.io/t/modulenotfounderror-no-module-named-vega-datasets/16354

---

# ERROR: No matching distribution found for

Source: https://docs.streamlit.io/knowledge-base/dependencies/no-matching-distribution


## 问题

在[Streamlit Community Cloud](https://streamlit.io/cloud)上部署应用时，你会收到错误 `ERROR: No matching distribution found for`。

## 解决方案

当你在 Streamlit Community Cloud 上部署应用且你的 requirements 文件中的[Python 依赖项](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)存在以下一个或多个错误时，会发生此错误：

1. 该包是[Python 标准库](https://docs.python.org/3/py-modindex.html)的一部分。例如，如果你在 requirements 文件中包含 [`base64`](https://docs.python.org/3/library/base64.html)，你会看到 **`ERROR: No matching distribution found for base64`**，因为它是 Python 标准库的一部分。解决方案是不在 requirements 文件中包含该包。仅包含无法与标准 Python 安装一起发行的包。
2. 你的 requirements 文件中的包名拼错了。在包含包到 requirements 文件之前，仅需检查包名。
3. 该包不支持你的 Streamlit 应用运行所在的操作系统。例如，部署到 Streamlit Community Cloud 时，你看到 **`ERROR: No matching distribution found for pywin32`**。`pywin32` 模块提供了与 Python 中许多 Windows API 的访问权限。部署到 Streamlit Community Cloud 的应用在 Linux 环境中执行。因此，`pywin32` 在非 Windows 系统上（包括在 Streamlit Community Cloud 上）无法安装。解决方案是从你的 requirements 文件中排除 `pywin32`，或将你的应用部署到提供 Windows 机器的云服务上。

相关主论坛帖子：

- https://discuss.streamlit.io/t/error-no-matching-distribution-found-for-base64/15758
- https://discuss.streamlit.io/t/error-could-not-find-a-version-that-satisfies-the-requirement-pywin32-301-from-versions-none/15343/2

---

# 部署相关问题和错误

Source: https://docs.streamlit.io/knowledge-base/deploy


- [如何在域上部署 Streamlit 应用以使其显示为在常规端口（即端口 80）上运行？](/knowledge-base/deploy/deploy-streamlit-domain-port-80)
- [如何在不同子域上部署多个 Streamlit 应用？](/knowledge-base/deploy/deploy-multiple-streamlit-apps-different-subdomains)
- [在部署的 Streamlit 应用中调用 Python 子进程](/knowledge-base/deploy/invoking-python-subprocess-deployed-streamlit-app)
- [Streamlit 支持 WSGI 协议吗？（又名我可以用 gunicorn 部署 Streamlit 吗？）](/knowledge-base/deploy/does-streamlit-support-wsgi-protocol)
- [呃。此应用已超过其资源限制。](/knowledge-base/deploy/resource-limits)
- [远程运行时应用未加载](/knowledge-base/deploy/remote-start)
- [无 SSO 身份验证](/knowledge-base/deploy/authentication-without-sso)
- [如何增加 Streamlit Community Cloud 上 st.file_uploader 的上传限制？](/knowledge-base/deploy/increase-file-uploader-limit-streamlit-cloud)
- [登录时出现"呃。这不应该发生"消息](/knowledge-base/deploy/huh-this-isnt-supposed-to-happen-message-after-trying-to-log-in)
- [登录 Streamlit Community Cloud 失败，错误 403](/knowledge-base/deploy/login-attempt-to-streamlit-community-cloud-fails-with-error-403)
- [如何为 Streamlit Community Cloud 提交支持案例](/knowledge-base/deploy/how-to-submit-a-support-case-for-streamlit-community-cloud)

---

# 如何在不同子域上部署多个 Streamlit 应用？

Source: https://docs.streamlit.io/knowledge-base/deploy/deploy-multiple-streamlit-apps-different-subdomains


## 问题

你想在不同子域上部署多个 Streamlit 应用。

## 解决方案

与在端口 80 等更常见的端口上运行 Streamlit 应用一样，子域由 Apache 或 Nginx 等 web 服务器处理：

- 在具有公共 IP 地址的计算机上设置 web 服务器，然后使用 DNS 服务器将所有所需子域指向你的 web 服务器的 IP 地址

- 配置你的 web 服务器，以将每个子域名的请求路由到你的 Streamlit 应用运行所在的不同端口

例如，假设你有两个 Streamlit 应用，分别称为 `Calvin` 和 `Hobbes`。应用 `Calvin` 运行在端口 **8501** 上。你将应用 `Hobbes` 设置为运行在端口 **8502** 上。然后你的 web 服务器会设置为监听子域 `calvin.somedomain.com` 和 `hobbes.subdomain.com` 上的请求，并分别将请求路由到端口 **8501** 和 **8502**。

查看这两个关于 Apache2 和 Nginx 的教程，它们涉及设置 web 服务器以将子域重定向到不同端口：

- [Apache2 subdomains](https://stackoverflow.com/questions/8541182/apache-redirect-to-another-port)
- [NGinx subdomains](https://gist.github.com/soheilhy/8b94347ff8336d971ad0)

---

# 如何在域上部署Streamlit以使其显示在常规端口(即端口 80)上运行？

Source: https://docs.streamlit.io/knowledge-base/deploy/deploy-streamlit-domain-port-80


## 问题

你想在一个域上部署Streamlit应用程序，使其显示在端口 80 上运行。

## 解决方案

- 你应该使用**反向代理**来从[Apache](https://httpd.apache.org/)或[Nginx](https://www.nginx.com/)等web服务器转发请求到你的Streamlit应用程序运行所在的端口。你可以以许多不同的方案完成此作。最简单的方案是[转发所有发送到你的域的请求](https://discuss.streamlit.io/t/permission-denied-in-ec2-port-80/798/3)，以便Streamlit应用程序车止作为你的应用程序内容。

- 另一个方法是配置你的web服务器以转发请求到指定的子文件夹(例如 _http://awesomestuff.net/streamlitapp_)到同一域上的不同Streamlit应用程序，如此[Nginx配置示例](https://discuss.streamlit.io/t/how-to-use-streamlit-with-nginx/378/7)于Streamlit穆族会员提交。

Related forum posts:

- https://discuss.streamlit.io/t/permission-denied-in-ec2-port-80/798/3
- https://discuss.streamlit.io/t/how-to-use-streamlit-with-nginx/378/7

---

# Streamlit支持WSGI协议吗?(也就是說我能用gunicorn部署Streamlit吗?)

Source: https://docs.streamlit.io/knowledge-base/deploy/does-streamlit-support-wsgi-protocol


## 问题

你不确定nuStreamlit应用是否可以用gunicorn部署。

## 解决方案

Streamlit目前不支持WSGI协议，因此目前无法使用(e.g.) gunicorn部署Streamlit。查看此[]关于以gunicorn方式部署Streamlit的论坛线程](https://discuss.streamlit.io/t/how-do-i-set-the-server-to-0-0-0-0-for-deployment-using-docker/216)以了解其他用户是如何实现的。

---

# 如何为Streamlit Community Cloud提交支持案例

Source: https://docs.streamlit.io/knowledge-base/deploy/how-to-submit-a-support-case-for-streamlit-community-cloud


本文讲述了向Snowflake提交Streamlit Community Cloud支持请求的步骤。

<Note>

对于Snowflake客户，可以通过[Snowsight上的支持门户](https://community.snowflake.com/s/article/How-To-Submit-a-Support-Case-in-Snowflake-Lodge#Option1)提交支持案例。

</Note>

1. 在浏览器中导航到[https://community.snowflake.com/s/](https://community.snowflake.com/s/)。
1. 如果你已经Snowflake Community账户，请登录。否则，单击“**CREATE ACCOUNT**”，然后按照提示操作。
1. 在页面上方，单击“**SUPPORT**”。
1. 从下拉菜单中，选择“**Submit A Case**”。
1. 选择“**I am a Streamlit Community Cloud user**”选项。
1. 单击“**Next**”以打开案例描述页面。
1. 填写你的请求并提交支持案例。

你应该收到包含案例编号的确认电子邮件。Snowflake支持工程师将直接跟进，了解解决你的案例的后续步骤。所有沟通都将通过电子邮件进行。

---

# 登录时出现"呃。这不应该发生"消息

Source: https://docs.streamlit.io/knowledge-base/deploy/huh-this-isnt-supposed-to-happen-message-after-trying-to-log-in


本文帮助解决由GitHub和Streamlit Community Cloud之间电子邮件不匹配引起的登录问题。

## 问题

登录到你的Streamlit Community Cloud账户后，你会看到以下消息：

![Huh. This is isn't supposed to happen message](/images/knowledge-base/huh-this-isnt-supposed-to-happen.png)

此消息通常表示我们的系统已将你的GitHub用户名与你当前登录的电子邮件地址以外的电子邮件地址关联。

## 解决方案

别担心–你只需要：

1. 完全退出Streamlit Community Cloud(通过你的电子邮件和GitHub账户)。
2. 首先使用你的电子邮件账户登录(你可以通过["Continue with Google"](/deploy/streamlit-community-cloud/manage-your-account/sign-in-sign-out#sign-in-with-google)或["Continue with email"](/knowledge-base/deploy/sign-in-without-sso)进行)。
3. 使用你的[GitHub账户](/deploy/streamlit-community-cloud/manage-your-account/sign-in-sign-out#sign-in-with-email)登录。

---

# 如何增加Streamlit Community Cloud上st.file_uploader的上传限制？

Source: https://docs.streamlit.io/knowledge-base/deploy/increase-file-uploader-limit-streamlit-cloud


## 概述

默认情况下，使用[`st.file_uploader()`](/develop/api-reference/widgets/st.file_uploader)上传的文件限制为200MB。你可以使用`server.maxUploadSize`配置选项配置此项。

Streamlit提供[四种不同的方法来设置配置选项](/develop/concepts/configuration)：

1. 在**全局配置文件**中，位macOS/Linux的`~/.streamlit/config.toml`或Windows的`%userprofile%/.streamlit/config.toml`：
   ```toml
   [server]
   maxUploadSize = 200
   ```
2. 在**每个项目配置文件**中，位于`$CWD/.streamlit/config.toml`，其中`$CWD`是你从中运行Streamlit的文件夹。
3. 通过`STREAMLIT_*`**一气辏式匉8渔字段**，例如：
   ```bash
   export STREAMLIT_SERVER_MAX_UPLOAD_SIZE=200
   ```
4. 运行`streamlit run`时作为**命令行标志**：
   ```bash
   streamlit run your_script.py --server.maxUploadSize 200
   ```

对于部署到[Streamlit Community Cloud](/deploy/streamlit-community-cloud)的应用，你应该选择四种方案中的哪一个？🤔

## 解决方案

将应用部署到Streamlit Community Cloud时，你应该**使用方案 1**。即，在上传到应用GitHub仓库的全局配置文件(`.streamlit/config.toml`)中设置`maxUploadSize`配置选项。🎈

例如，要将上传限制增加到400MB，请将包含以下行的`.streamlit/config.toml`文件上传到应用的GitHub仓库：

```toml
[server]
maxUploadSize = 400
```

## 相关资源

- [Streamlit拖放限制为200MB，需要解决方案](https://discuss.streamlit.io/t/streamlit-drag-and-drop-capping-at-200mb-need-workaround/19803/2)
- [文件上传器小部件API](/develop/api-reference/widgets/st.file_uploader)
- [如何设置Streamlit配置选项](/develop/concepts/configuration)

---

# 在部署的Streamlit应用中调用Python子进程

Source: https://docs.streamlit.io/knowledge-base/deploy/invoking-python-subprocess-deployed-streamlit-app


## 问题

假设你想在部署的Streamlit应用`streamlit_app.py`中调用子进程来运行Python脚本`script.py`。例如，机器学习库[Ludwig](https://ludwig-ai.github.io/ludwig-docs/)使用命令行界面运行，或者你可能想从Python运行bash脚本或类似类型的进程。

你尝试了以下方法，但即使你在requirements文件中指定了Python依赖，仍然遇到`script.py`的依赖问题：

```python
# streamlit_app.py
import streamlit as st
import subprocess

subprocess.run(["python", "script.py"])
```

## 解决方案

当你运行上述代码块时，你将获得系统路径上的Python版本-不一定是Streamlit代码运行的虚拟环境中安装的Python可执行文件。

解决方案是使用[`sys.executable`](https://docs.python.org/3/library/sys.html#sys.executable)直接检测Python可执行文件：

```python
# streamlit_app.py
import streamlit as st
import subprocess
import sys

subprocess.run([f"{sys.executable}", "script.py"])
```

这确保了`script.py`在与Streamlit代码相同的Python可执行文件下运行-其中安装了你的[Python依赖](/deploy/streamlit-community-cloud/deploy-your-app/app-dependencies#add-python-dependencies)。

### 相关链接

- https://stackoverflow.com/questions/69947867/run-portion-of-python-code-in-parallel-from-a-streamlit-app/69948545#69948545
- https://discuss.streamlit.io/t/modulenotfounderror-no-module-named-cv2-streamlit/18319/3?u=snehankekre
- https://docs.python.org/3/library/sys.html#sys.executable

---

# 登录Streamlit Community Cloud失败，错误403

Source: https://docs.streamlit.io/knowledge-base/deploy/login-attempt-to-streamlit-community-cloud-fails-with-error-403


## 问题

Streamlit Community Cloud具有监控作业来检测使用该平台进行加密挖矿的恶意用户。这些作业有时会导致误报，正常用户开始针对登录尝试获得错误403。

## 解决方案

请通过提供你的**GitHub用户名**[联系支持](mailto:support@streamlit.io)，以获取参考此文章的帮助。

---

# 远程运行时应用未加载

Source: https://docs.streamlit.io/knowledge-base/deploy/remote-start


以下是用户自行设置解决方案来远程托管Streamlit应用时发生的一些常见错误。

要了解一个欺骗性简单的方式来托管Streamlit应用，避免下面的所有问题，请查看[Streamlit Community Cloud](https://streamlit.io/cloud)。

### 症状#1：应用从不加载

当你在浏览器中输入应用URL时，只看到**空白页面、"Page not found"错误、"Connection refused"错误**或类似的东西，首先检查Streamlit是否确实在远程服务器上运行。在Linux服务器上，你可以通过SSH连接到它，然后运行：

```bash
ps -Al | grep streamlit
```

如果你看到Streamlit正在运行，最可能的原因是Streamlit端口未暴露。修复取决于你的确切设置。以下是三个示例修复：

- **尝试端口80：**某些主机默认暴露端口80。要将Streamlit设置为使用该端口，请使用`--server.port`选项启动Streamlit：

  ```bash
  streamlit run my_app.py --server.port=80
  ```

- **AWS EC2服务器**：首先，在[AWS控制台](https://us-west-2.console.aws.amazon.com/ec2/v2/home)中单击你的实例。然后向下滚动并单击_Security Groups_ → _Inbound_ → _Edit_。接下来，添加允许_Port Range_`8501`且_Source_为`0.0.0.0/0`的_Custom TCP_规则。

- **其他类型的服务器**：检查防火墙设置。

如果这仍然无法解决问题，请尝试运行一个简单的HTTP服务器而不是Streamlit，并查看_是否_能正常工作。如果确实有效，那么你就知道问题出在你的Streamlit应用或配置的某个地方(在这种情况下，你应该在我们的[论坛](https://discuss.streamlit.io)中寻求帮助！)如果没有，那么它肯定与Streamlit无关。

如何启动简单的HTTP服务器：

```bash
python -m http.server [port]
```

### 症状#2：应用显示"Please wait..."或永远显示骨架元素

从1.29.0版本开始，此症状显示不同。对于Streamlit的早期版本，加载应用在页面中央显示带有"Please wait..."消息的蓝色框。从1.29.0版本开始，加载应用显示骨架元素。如果此加载屏幕不消失，潜在原因可能是以下之一：

- 使用为内部开发保留的端口3000。
- 配置错误的[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)保护。
- 服务器从Websocket连接中剥离标头，从而破坏压缩。

要诊断此问题，首先确保你没有使用端口3000。如有疑问，请尝试如上所述的端口80。

接下来，尝试通过使用`--server.enableCORS`标志设置为`false`运行Streamlit来暂时禁用CORS保护：

```bash
streamlit run my_app.py --server.enableCORS=false
```

如果这解决了你的问题，**你应该重新启用CORS保护**，然后将`browser.serverAddress`设置为你的Streamlit应用的URL。

如果问题仍然存在，尝试通过使用`--server.enableWebsocketCompression`标志设置为`false`运行Streamlit来禁用websocket压缩

```bash
streamlit run my_app.py --server.enableWebsocketCompression=false
```

如果这解决了你的问题，你的服务器设置可能会剥离用于协商Websocket压缩的`Sec-WebSocket-Extensions` HTTP标头。

压缩对于Streamlit工作不是必需的，但强烈建议，因为它改进性能。如果你想重新打开它，你需要找出基础设施的哪一部分在剥离`Sec-WebSocket-Extensions` HTTP标头，并更改该行为。

### 症状#3：在多个副本中运行时无法上传文件

If the file uploader widget returns an error with status code 403, this is probably
due to a misconfiguration in your app's
[XSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) protection logic.

To diagnose the issue, try temporarily disabling XSRF protection by running Streamlit
with the `--server.enableXsrfProtection` flag set to `false`:

```bash
streamlit run my_app.py --server.enableXsrfProtection=false
```

If this fixes your issue, **you should re-enable XSRF protection** and try one
or both of the following:

- Set `browser.serverAddress` and `browser.serverPort` to the URL and port of
  your Streamlit app.
- Configure your app to use the same secret across every replica by setting the
  `server.cookieSecret` config option to the same hard-to-guess string everywhere.

---

# 呃。此应用已超过其资源限制

Source: https://docs.streamlit.io/knowledge-base/deploy/resource-limits


遗憾！这意味着你已达到[Streamlit Community Cloud](https://streamlit.io/cloud)账户的[资源限制](/deploy/streamlit-community-cloud/manage-your-app#app-resources-and-limits)。

你可以在应用中进行一些更改以使其占用更少资源：

- 重启应用(临时修复)
- 使用`st.cache_data`或`st.cache_resource`仅加载模型或数据一次
- 使用`ttl`或`max_entries`限制缓存大小
- 将大型数据集移到数据库
- 分析应用的内存使用情况

查看我们关于["常见应用问题：资源限制"](https://blog.streamlit.io/common-app-problems-resource-limits/)的[博客文章](https://blog.streamlit.io/common-app-problems-resource-limits/)，了解更多深入的提示以防止你的应用达到Streamlit Community Cloud的[资源限制](/deploy/streamlit-community-cloud/manage-your-app#app-resources-and-limits)。

相关论坛帖子：

- [https://discuss.streamlit.io/t/common-app-problems-resource-limits/16969](https://discuss.streamlit.io/t/common-app-problems-resource-limits/16969)
- [https://blog.streamlit.io/common-app-problems-resource-limits/](https://blog.streamlit.io/common-app-problems-resource-limits/)

我们仅在逐案例基础上向非营利组织或教育组织提供免费资源增加。如果你是非营利组织或教育组织，请填写[此表单](https://info.snowflake.com/streamlit-resource-increase-request.html)，我们将尽快审查你的提交。

增加完成后，你将收到来自Streamlit市场营销团队的电子邮件，确认增加已应用。

---

# 常见问题解答

Source: https://docs.streamlit.io/knowledge-base/using-streamlit


以下是关于使用 Streamlit 的常见问题。如果您认为遗漏了重要内容，请 [提出问题](https://github.com/streamlit/docs/issues) 或 [提交拉取请求](https://github.com/streamlit/docs/pulls)，我们会很乐意审查！

- [健全性检查](/knowledge-base/using-streamlit/sanity-checks)
- [如何让 Streamlit 监视我在应用中导入的其他模块中的更改？](/knowledge-base/using-streamlit/streamlit-watch-changes-other-modules-importing-app)
- [Streamlit 支持哪些浏览器？](/knowledge-base/using-streamlit/supported-browsers)
- [st.file_uploader 在哪里存储上传的文件，何时删除它们？](/knowledge-base/using-streamlit/where-file-uploader-store-when-deleted)
- [如何检索使用 st.file_uploader 上传的文件的文件名？](/knowledge-base/using-streamlit/retrieve-filename-uploaded)
- [如何从应用标题中删除"· Streamlit"？](/knowledge-base/using-streamlit/remove-streamlit-app-title)
- [如何在 Streamlit 中下载文件？](/knowledge-base/using-streamlit/how-download-file-streamlit)
- [如何将 Pandas DataFrame 下载为 CSV？](/knowledge-base/using-streamlit/how-download-pandas-dataframe-csv)
- [如何使 st.pydeck_chart 使用自定义 Mapbox 样式？](/knowledge-base/using-streamlit/pydeck-chart-custom-mapbox-styles)
- [如何按不同的顺序插入元素？](/knowledge-base/using-streamlit/insert-elements-out-of-order)
- [如何升级到最新版本的 Streamlit？](/knowledge-base/using-streamlit/how-upgrade-latest-version-streamlit)
- [使用会话状态时窗口小部件每秒输入更新一次](/knowledge-base/using-streamlit/widget-updating-session-state)
- [如何创建锚链接？](/knowledge-base/using-streamlit/create-anchor-link)
- [如何启用摄像头访问？](/knowledge-base/using-streamlit/enable-camera)
- [为什么 Streamlit 限制嵌套 st.columns？](/knowledge-base/using-streamlit/why-streamlit-restrict-nested-columns)
- [什么是可序列化的会话状态？](/knowledge-base/using-streamlit/serializable-session-state)

---

# 如何创建锚链接？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/create-anchor-link


## 概述

您想过创建锚点，以便您的应用用户可以通过在 URL 中指定 `#anchor` 来直接导航到特定部分吗？如果是这样，让我们了解一下如何做。

## 解决方案

锚点会自动添加到标题文本中。

例如，如果您通过以下 [st.header()](/develop/api-reference/text/st.header) 命令定义标题文本：

```python
st.header("Section 1")
```

然后您可以使用以下命令创建指向此标题的链接：

```python
st.markdown("[Section 1](#section-1)")
```

## 示例

- 演示应用：[https://dataprofessor-streamlit-anchor-app-80kk8w.streamlit.app/](https://dataprofessor-streamlit-anchor-app-80kk8w.streamlit.app/)
- GitHub 仓库：[https://github.com/dataprofessor/streamlit/blob/main/anchor_app.py](https://github.com/dataprofessor/streamlit/blob/main/anchor_app.py)

---

# 在您的浏览器中启用摄像头或麦克风访问

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/enable-camera


Streamlit 应用可能包含从您的摄像头上传图像或用麦克风录制声音的小部件。为了保护用户的隐私和安全，浏览器要求用户在使用这些设备之前明确允许对其摄像头或麦克风的访问。

要了解如何启用摄像头访问，请查看您的浏览器的文档：

- [Chrome](https://support.google.com/chrome/answer/2693767)
- [Safari](https://support.apple.com/guide/safari/websites-ibrwe2159f50/mac)
- [Firefox](https://support.mozilla.org/en-US/kb/how-manage-your-camera-and-microphone-permissions)

---

# 如何在 Streamlit 中下载文件？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/how-download-file-streamlit


使用 Streamlit 中原生内置的 [`st.download_button`](/develop/api-reference/widgets/st.download_button) 小部件。查看一个 [示例应用](https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/)，演示如何使用 `st.download_button` 下载常见的文件格式。

## 使用示例

```python
import streamlit as st

# Text files

text_contents = '''
Foo, Bar
123, 456
789, 000
'''

# Different ways to use the API

st.download_button('Download CSV', text_contents, 'text/csv')
st.download_button('Download CSV', text_contents)  # Defaults to 'text/plain'

with open('myfile.csv') as f:
   st.download_button('Download CSV', f)  # Defaults to 'text/plain'

# ---
# Binary files

binary_contents = b'whatever'

# Different ways to use the API

st.download_button('Download file', binary_contents)  # Defaults to 'application/octet-stream'

with open('myfile.zip', 'rb') as f:
   st.download_button('Download Zip', f, file_name='archive.zip')  # Defaults to 'application/octet-stream'

# You can also grab the return value of the button,
# just like with any other button.

if st.download_button(...):
   st.write('Thanks for downloading!')
```

其他资源：

- [https://blog.streamlit.io/0-88-0-release-notes/](https://blog.streamlit.io/0-88-0-release-notes/)
- [https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/](https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/)
- [https://docs.streamlit.io/develop/api-reference/widgets/st.download_button](/develop/api-reference/widgets/st.download_button)

---

# 如何将 Pandas DataFrame 下载为 CSV？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/how-download-pandas-dataframe-csv


使用 Streamlit 中原生内置的 [`st.download_button`](/develop/api-reference/widgets/st.download_button) 小部件。查看一个 [示例应用](https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/)，演示如何使用 `st.download_button` 下载常见的文件格式。

## 使用示例

```python
import streamlit as st
import pandas as pd

df = pd.read_csv("dir/file.csv")

@st.cache_data
def convert_df(df):
   return df.to_csv(index=False).encode('utf-8')


csv = convert_df(df)

st.download_button(
   "Press to Download",
   csv,
   "file.csv",
   "text/csv",
   key='download-csv'
)
```

其他资源：

- [https://blog.streamlit.io/0-88-0-release-notes/](https://blog.streamlit.io/0-88-0-release-notes/)
- [https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/](https://streamlit-release-demos-0-88streamlit-app-0-88-v8ram3.streamlit.app/)
- https://docs.streamlit.io/develop/api-reference/widgets/st.download_button

---

# 如何升级到最新版本的 Streamlit？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/how-upgrade-latest-version-streamlit


我们建议升级到最新的官方 Streamlit 版本，以便您可以访问最新的尖端功能。如果您还没有安装 Streamlit，请阅读我们的[安装指南](/get-started/installation)。它可以帮助您设置虚拟环境，并指导您在 Windows、macOS 和 Linux 上安装 Streamlit。无论您使用哪个包管理工具和操作系统，我们建议在虚拟环境中运行本页上的命令。

如果您之前已安装 Streamlit 并想升级到最新版本，以下是根据您的依赖管理器如何操作的方法。

## Pipenv

Streamlit 官方支持的 macOS 和 Linux 环境管理器是 [Pipenv](https://pypi.org/project/pipenv/)。

1. 导航到包含您的 Pipenv 环境的项目文件夹：

```bash
cd myproject
```

2. 激活该环境，升级 Streamlit，并验证您拥有最新版本：

```bash
pipenv shell
pip install --upgrade streamlit
streamlit version
```

或者，如果您想使用易于复现的环境，每次安装或更新软件包时将 `pip` 替换为 `pipenv`：

```bash
pipenv update streamlit
pipenv run streamlit version
```

## Conda

1. 激活安装了 Streamlit 的 conda 环境：

```bash
conda activate $ENVIRONMENT_NAME
```

请确保将 `$ENVIRONMENT_NAME` ☝️ 替换为您的 conda 环境的名称！

2. 在活跃的 conda 环境中更新 Streamlit 并验证您拥有最新版本：

```bash
conda update -c conda-forge streamlit -y
streamlit version
```

## Poetry

为了使用 [Poetry](https://python-poetry.org/) 获取最新版本的 Streamlit 并验证您拥有最新版本，请运行：

```bash
poetry update streamlit
streamlit version
```

---

# 如何按不同的顺序插入元素？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/insert-elements-out-of-order


您可以使用 [`st.empty`](/develop/api-reference/layout/st.empty) 方法作为占位符，以"保留"应用中的一个槽，您可以稍后使用。

```python
st.text('This will appear first')
# Appends some text to the app.

my_slot1 = st.empty()
# Appends an empty slot to the app. We'll use this later.

my_slot2 = st.empty()
# Appends another empty slot.

st.text('This will appear last')
# Appends some more text to the app.

my_slot1.text('This will appear second')
# Replaces the first empty slot with a text string.

my_slot2.line_chart(np.random.randn(20, 2))
# Replaces the second empty slot with a chart.
```

---

# 如何使 st.pydeck_chart 使用自定义 Mapbox 样式？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/pydeck-chart-custom-mapbox-styles


如果您提供了 Mapbox 令牌，但生成的 `pydeck_chart` 没有显示您的自定义 Mapbox 样式，请检查您是否将 Mapbox 令牌添加到 Streamlit `config.toml` 配置文件中。Streamlit 不从 PyDeck 规范内部（即从 Streamlit 应用内部）读取 Mapbox 令牌。有关更多信息，请参阅此 [论坛讨论](https://discuss.streamlit.io/t/deprecation-warning-deckgl-pydeck-maps-to-require-mapbox-token-for-production-usage/2982/10)。

---

# 如何从应用标题中删除"· Streamlit"？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/remove-streamlit-app-title


使用 [`st.set_page_config`](/develop/api-reference/configuration/st.set_page_config) 分配页面标题不会在该标题后附加"· Streamlit"。例如：

```python
import streamlit as st

st.set_page_config(
   page_title="Ex-stream-ly Cool App",
   page_icon="🧊",
   layout="wide",
   initial_sidebar_state="expanded",
)
```

---

# 如何使用st.file_uploader检索上传的文件的文件名？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/retrieve-filename-uploaded


对于上传单个文件时`accept_multiple_files=False`，你可以通过返回的UploadedFile对象使用`.name`属性来获取文件名。

```python
import streamlit as st

uploaded_file = st.file_uploader("Upload a file")

if uploaded_file:
   st.write("Filename: ", uploaded_file.name)
```

对于上传多个文件时`accept_multiple_files=True`，你可以通过返回的列表中的每个UploadedFile对象使用`.name`属性来获取每个上传的文件名。

```python
import streamlit as st

uploaded_files = st.file_uploader("Upload multiple files", accept_multiple_files=True)

if uploaded_files:
   for uploaded_file in uploaded_files:
       st.write("Filename: ", uploaded_file.name)
```

相关论坛帖子：

- https://discuss.streamlit.io/t/is-it-possible-to-get-uploaded-file-file-name/7586

---

# 健全性检查

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/sanity-checks


如果您在运行 Streamlit 应用时遇到问题，这里有一些需要尝试的事情。

## 检查 #0：您使用的是 Streamlit 支持的 Python 版本吗？

Streamlit 将在实际可行的情况下保持与较早 Python 版本的向后兼容性，
保证与 _至少_ Python 3 的最后三个次要版本兼容。

随着新的 Python 版本的发布，我们会尽快尝试与新版本兼容，尽管通常我们受到其他 Python 包支持这些新版本的能力的限制。

Streamlit 目前支持 Python 的 3.9、3.10、3.11、3.12 和 3.13 版本。

## 检查 #1：Streamlit 正在运行吗？

在 Mac 或 Linux 机器上，在终端上输入以下内容：

```bash
ps -Al | grep streamlit
```

如果您在输出中看不到 `streamlit run`（或 `streamlit hello`，如果这是您运行的命令），则 Streamlit 服务器未运行。所以请重新运行您的命令，看看错误是否消失。

## 检查 #2：这是已修复的 Streamlit 错误吗？

我们会尽快修复错误，因此当您升级 Streamlit 时，很多问题都会消失。因此，在遇到问题时首先尝试的是升级到最新版本的 Streamlit：

```bash
pip install --upgrade streamlit
streamlit version
```

...然后验证打印的版本号是否与 [PyPI](https://pypi.org/project/streamlit/) 上显示的版本号相对应。

**现在尝试重现问题。** 如果未修复，请继续阅读。

## 检查 #3：您运行的是正确的 Streamlit 二进制文件吗？

让我们检查一下您的 Python 环境是否设置正确。编辑 Streamlit 脚本，其中您遇到问题，**注释掉所有内容，并改为添加以下行：**

```python
import streamlit as st
st.write(st.__version__)
```

...然后对您的脚本调用 `streamlit run`，确保它显示与上述相同的版本。如果版本不同，请查看 [这些说明](/get-started/installation) 以了解一些可靠的方法来设置您的环境。

## 检查 #4：您的浏览器是否过度缓存您的应用？

有两种简单的方法来检查这一点：

1. 在浏览器中加载您的应用，然后按 `Ctrl-Shift-R` 或 `⌘-Shift-R` 进行硬刷新（Chrome/Firefox）。

2. 作为测试，在另一个端口上运行 Streamlit。这样浏览器就会使用全新的缓存启动页面。为此，将 `--server.port` 参数传递给命令行上的 Streamlit：

   ```bash
   streamlit run my_app.py --server.port=9876
   ```

## 检查 #5：这是 Streamlit 回归吗？

如果您已升级到最新版本的 Streamlit，但事情不起作用，您可以随时使用以下命令进行降级：

```bash
pip install --upgrade streamlit==1.0.0
```

...其中 `1.0.0` 是您想要降级到的版本。有关 Streamlit 版本的完整列表，请参阅 [发行说明](/develop/quick-reference/release-notes)。

## 检查 #6 [Windows]：Python 是否添加到您的 PATH？

当通过从 [python.org](https://www.python.org/downloads/) 下载安装 Python 时，Python 不会自动添加到 [Windows 系统 PATH](https://www.howtogeek.com/118594/how-to-edit-your-system-path-for-easy-command-line-access)。因此，您可能会收到如下错误消息：

命令提示符：

```bash
C:\Users\streamlit&gt; streamlit hello
'streamlit' is not recognized as an internal or external command,
operable program or batch file.
```

PowerShell：

```bash
PS C:\Users\streamlit&gt; streamlit hello
streamlit : The term 'streamlit' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that
the path is correct and try again.
At line:1 char:1
+ streamlit hello
+ ~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (streamlit:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException
```

要解决此问题，请 [将 Python 添加到 Windows 系统 PATH](https://datatofish.com/add-python-to-windows-path/)。

将 Python 添加到您的 Windows PATH 后，您应该能够按照我们的 [入门](/get-started) 部分中的说明进行操作。

## 检查 #7 [Windows]：您需要安装 Visual Studio 的生成工具吗？

Streamlit 包含 [pyarrow](https://arrow.apache.org/docs/python/) 作为安装依赖项。有时，当尝试从 PyPI 安装 Streamlit 时，您可能会看到如下错误：

```bash
Using cached pyarrow-1.0.1.tar.gz (1.3 MB)
  Installing build dependencies ... error
  ERROR: Command errored out with exit status 1:
   command: 'c:\users\streamlit\appdata\local\programs\python\python38-32\python.exe' 'c:\users\streamlit\appdata\local\programs\python\python38-32\lib\site-packages\pip' install --ignore-installed --no-user --prefix 'C:\Users\streamlit\AppData\Local\Temp\pip-build-env-s7owjrle\overlay' --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- 'cython &gt;= 0.29' 'numpy==1.14.5; python_version

---

# 什么是可序列化的会话状态？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/serializable-session-state


## 可序列化会话状态

序列化是指将对象或数据结构转换为可以保存和共享的格式，并允许您恢复数据的原始结构的过程。Python的内置[pickle](https://docs.python.org/3/library/pickle.html)模块将Python对象序列化为字节流("pickling")并反序列化流为对象("unpickling")。

默认情况下，Streamlit的[会话状态](/develop/concepts/architecture/session-state)允许您在会话期间保留任何Python对象，无论对象是否可pickle序列化。此属性让您可以存储Python基础类型，如整数、浮点数、复数和布尔值、数据框，甚至函数返回的[lambdas](https://docs.python.org/3/reference/expressions.html#lambda)。但是，某些执行环境可能需要序列化会话状态中的所有数据，因此在开发过程中检测不兼容性可能会很有用，或者在执行环境将来停止支持它时。

为此，Streamlit提供了`runner.enforceSerializableSessionState`[配置选项](/develop/concepts/configuration)，设置为`true`时，仅允许会话状态中的pickle可序列化对象。要启用该选项，请创建具有以下内容的全局或项目配置文件，或将其用作命令行标志：

```toml
# .streamlit/config.toml
[runner]
enforceSerializableSessionState = true
```

通过"_pickle可序列化_"，我们的意思是调用`pickle.dumps(obj)`不应抛出[`PicklingError`](https://docs.python.org/3/library/pickle.html#pickle.PicklingError)异常。启用配置选项后，将不可序列化的数据添加到会话状态应会导致异常。例如，

```python
import streamlit as st

def unserializable_data():
		return lambda x: x

#👇 当enforceSerializableSessionState打开时导致异常
st.session_state.unserializable = unserializable_data()
```

<Image alt="UnserializableSessionStateError" src="/images/unserializable-session-state-error.png"/>

---

# 如何让 Streamlit 监视我在应用中导入的其他模块中的更改？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/streamlit-watch-changes-other-modules-importing-app


默认情况下，Streamlit 仅监视包含在主应用模块当前目录中的模块。您可以通过将每个模块的父目录添加到 `PYTHONPATH` 来跟踪其他模块。

```bash
export PYTHONPATH=$PYTHONPATH:/path/to/module
streamlit run your_script.py
```

---

# Streamlit 支持哪些浏览器？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/supported-browsers


Streamlit 的最新版本与以下浏览器的两个最新版本兼容：

- [Google Chrome](https://www.google.com/chrome/browser)
- [Firefox](https://www.mozilla.org/en-US/firefox/new/)
- [Microsoft Edge](https://www.microsoft.com/windows/microsoft-edge)
- [Safari](https://www.apple.com/safari/)

<Note>

您可能无法使用不受支持的浏览器或上述浏览器的较旧版本的 Streamlit 的所有最新功能。Streamlit 不会为不受支持的浏览器提供错误修复。

</Note>

---

# st.file_uploader 在哪里存储上传的文件，何时删除它们？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/where-file-uploader-store-when-deleted


使用[`st.file_uploader`](/develop/api-reference/widgets/st.file_uploader)上传文件时，数据经浏览器复制到Streamlit后端，并包含在Python内存(RAM而不是磁盘)中的BytesIO缓冲区。数据会永久存储在RAM中，直到Streamlit应用不继续自上耋下重新运行，仅在每个小部件交互中重新运行。如果您需要保存上传的数据，可以[缓存](/develop/concepts/architecture/caching)它，以便Streamlit在改之间保持它。

由于文件存储在内存中，一旦不需要它们，它们需要需要它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们它们

这意味着Streamlit有以下情况时下删除文件：

- 用户上传另一个文件，替换原来的文件
- 用户清除文件上传器
- 用户关闭upload了文件的浏览器页面

Related forum posts:

- https://discuss.streamlit.io/t/streamlit-sharing-fileupload-where-does-it-go/9267
- https://discuss.streamlit.io/t/how-to-update-the-uploaded-file-using-file-uploader/13512/

---

# 为什么 Streamlit 限制嵌套 `st.columns`？

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/why-streamlit-restrict-nested-columns


从版本 1.46.0 开始，Streamlit 移除了对嵌套列、扩展器、弹出窗口和聊天消息容器的显式限制。为了遵循最佳设计实践并在所有屏幕尺寸上保持良好的外观，不要过度使用嵌套布局。

从版本 1.18.0 到 1.45.0，Streamlit 允许在其他 `st.columns` 内嵌套 [`st.columns`](/develop/api-reference/layout/st.columns)，但有以下限制：

- 在应用的主要区域中，列可以嵌套最多一个级别。
- 在侧边栏中，列不能被嵌套。

这些限制是为了使 Streamlit 应用在所有设备尺寸上看起来很好。嵌套列多次通常会导致糟糕的用户界面。您可能能够在一个屏幕尺寸上使其看起来不错，但一旦不同屏幕上的用户查看该应用，他们就会有糟糕的体验。某些列会很小，其他列会太长，复杂的布局看起来会很不合适。Streamlit 尽力自动调整元素的大小，以在各种设备上看起来不错，无需开发人员的任何帮助。但对于具有多个级别嵌套的复杂布局，这是不可能的。

---

# 使用会话状态时窗口小部件每秒输入更新一次

Source: https://docs.streamlit.io/knowledge-base/using-streamlit/widget-updating-session-state


## 概述

您正在使用[会话状态](/develop/api-reference/caching-and-state/st.session_state)在您的应用中存储页面交互。当用户与应用中的小部件交互时（例如点击按钮），您期望您的应用更新其小部件状态并反映新值。但是，您会注意到它没有。相反，用户必须与小部件交互两次（例如，点击按钮两次）才能使应用显示正确的值。您现在做什么？🤔 让我们在下面的部分中走过解决方案。

## 解决方案

使用会话状态更新脚本中的小部件或值时，您需要使用分配给小部件的唯一键，**而不是**您分配小部件的变量。在下面的示例代码块中，分配给滑块小部件的唯一*键*是 `slider`，而小部件分配到的*变量*是 `slide_val`。

让我们在一个示例中看到这个。假设您希望用户点击一个重置滑块的按钮。

要使滑块的值在按钮点击时更新，您需要使用[回调函数](/develop/api-reference/caching-and-state/st.session_state#use-callbacks-to-update-session-state)与 [`st.button`](/develop/api-reference/widgets/st.button) 的 `on_click` 参数：

```python
# 按钮的回调函数将 1 添加到
# 滑块值最多 10
def plus_one():
    if st.session_state["slider"] 

---

